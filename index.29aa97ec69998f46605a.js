(function(){var __webpack_modules__={862:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Nn:function(){return AV},Xv:function(){return Ad},dW:function(){return Ax}});function C(Z,I){return I.forEach(function(V){V&&typeof V!="string"&&!Array.isArray(V)&&Object.keys(V).forEach(function(re){if(re!=="default"&&!(re in Z)){var ae=Object.getOwnPropertyDescriptor(V,re);Object.defineProperty(Z,re,ae.get?ae:{enumerable:!0,get:function(){return V[re]}})}})}),Object.freeze(Z)}const N=1e-7,J=1e-4;class f{constructor(I,V){this.backend=I,this.dataMover=V,this.data=new WeakMap,this.dataIdsCount=0}get(I){return this.data.has(I)||this.dataMover.moveData(this.backend,I),this.data.get(I)}set(I,V){this.dataIdsCount++,this.data.set(I,V)}has(I){return this.data.has(I)}delete(I){return this.dataIdsCount--,this.data.delete(I)}numDataIds(){return this.dataIdsCount}}class i{refCount(I){return O("refCount")}incRef(I){return O("incRef")}timerAvailable(){return!0}time(I){return O("time")}read(I){return O("read")}readSync(I){return O("readSync")}readToGPU(I,V){return O("readToGPU")}numDataIds(){return O("numDataIds")}disposeData(I,V){return O("disposeData")}write(I,V,re){return O("write")}move(I,V,re,ae,le){return O("move")}createTensorFromGPUData(I,V,re){return O("createTensorFromGPUData")}memory(){return O("memory")}floatPrecision(){return O("floatPrecision")}epsilon(){return this.floatPrecision()===32?N:J}dispose(){return O("dispose")}}function O(Z){throw new Error("'"+Z+"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen")}function t(Z,I,V){return Math.max(Z,Math.min(I,V))}function B(Z){return Z%2===0?Z:Z+1}function P(Z,I,V){const re=Z[I];Z[I]=Z[V],Z[V]=re}function o(Z){let I=0;for(let V=0;V<Z.length;V++)I+=Z[V];return I}function e(Z,I){if(!Z)throw new Error(typeof I=="string"?I:I())}function Q(Z,I,V=""){e(X(Z,I),()=>V+(" Shapes "+Z+" and "+I+" must match"))}function s(Z){e(Z!=null,()=>"The input to the tensor constructor must be a non-null value.")}function F(Z){if(Z.length===0)return 1;let I=Z[0];for(let V=1;V<Z.length;V++)I*=Z[V];return I}function X(Z,I){if(Z===I)return!0;if(Z==null||I==null||Z.length!==I.length)return!1;for(let V=0;V<Z.length;V++)if(Z[V]!==I[V])return!1;return!0}function R(Z){return Z%1===0}function K(Z){const I=Math.ceil(Math.sqrt(Z));return[I,Math.ceil(Z/I)]}function T(Z,I){return I<=Z.length?Z:Z+" ".repeat(I-Z.length)}function q(Z,I=ae=>0,V,re){return new Promise((ae,le)=>{let he=0;const ue=()=>{if(Z()){ae();return}he++;const pe=I(he);if(V!=null&&he>=V){le();return}re!=null?re(ue,pe):setTimeout(ue,pe)};ue()})}function l(Z,I){let V=1,re=-1;for(let le=0;le<Z.length;++le)if(Z[le]>=0)V*=Z[le];else if(Z[le]===-1){if(re!==-1)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+re+" and dim "+le);re=le}else if(Z[le]<0)throw Error("Shapes can not be < 0. Found "+Z[le]+" at dim "+le);if(re===-1){if(I>0&&I!==V)throw Error("Size("+I+") must match the product of shape "+Z);return Z}if(V===0)throw Error("Cannot infer the missing size in ["+Z+"] when there are 0 elements");if(I%V!==0)throw Error("The implicit shape can't be a fractional number. Got "+I+" / "+V);const ae=Z.slice();return ae[re]=I/V,ae}function n(Z,I){const V=I.length;return Z=Z==null?I.map((re,ae)=>ae):[].concat(Z),e(Z.every(re=>re>=-V&&re<V),()=>"All values in axis param must be in range [-"+V+", "+V+") but got axis "+Z),e(Z.every(re=>R(re)),()=>"All values in axis param must be integers but got axis "+Z),Z.map(re=>re<0?V+re:re)}function L(Z,I){const V=[],re=[],ae=I!=null&&Array.isArray(I)&&I.length===0,le=I==null||ae?null:n(I,Z).sort();let he=0;for(let ue=0;ue<Z.length;++ue){if(le!=null){if(le[he]===ue&&Z[ue]!==1)throw new Error("Can't squeeze axis "+ue+" since its dim '"+Z[ue]+"' is not 1");(le[he]==null||le[he]>ue)&&Z[ue]===1&&(V.push(Z[ue]),re.push(ue)),le[he]<=ue&&he++}Z[ue]!==1&&(V.push(Z[ue]),re.push(ue))}return{newShape:V,keptDims:re}}function H(Z,I){return x(Z,I)}function x(Z,I){let V=null;if(Z==null||Z==="float32")V=new Float32Array(I);else if(Z==="int32")V=new Int32Array(I);else if(Z==="bool")V=new Uint8Array(I);else if(Z==="string")V=new Array(I);else throw new Error("Unknown data type "+Z);return V}function U(Z,I){for(let V=0;V<Z.length;V++){const re=Z[V];if(isNaN(re)||!isFinite(re))throw Error("A tensor of type "+I+" being uploaded contains "+re+".")}}function G(Z){return Z==="bool"||Z==="complex64"||Z==="float32"||Z==="int32"||Z==="string"}function Y(Z,I){return!(I==="complex64"||I==="float32"&&Z!=="complex64"||I==="int32"&&Z!=="float32"&&Z!=="complex64"||I==="bool"&&Z==="bool")}function M(Z){if(Z==="float32"||Z==="int32")return 4;if(Z==="complex64")return 8;if(Z==="bool")return 1;throw new Error("Unknown dtype "+Z)}function h(Z){if(Z==null)return 0;let I=0;return Z.forEach(V=>I+=V.length),I}function j(Z){return typeof Z=="string"||Z instanceof String}function C0(Z){return typeof Z=="boolean"}function C1(Z){return typeof Z=="number"}function C2(Z){return Array.isArray(Z)?C2(Z[0]):Z instanceof Float32Array?"float32":Z instanceof Int32Array||Z instanceof Uint8Array||Z instanceof Uint8ClampedArray?"int32":C1(Z)?"float32":j(Z)?"string":C0(Z)?"bool":"float32"}function C3(Z){return!!(Z&&Z.constructor&&Z.call&&Z.apply)}function C4(Z,I){for(let V=I;V<Z;++V)if(Z%V===0)return V;return Z}function C5(Z){const I=Z.length;if(I<2)return[];const V=new Array(I-1);V[I-2]=Z[I-1];for(let re=I-3;re>=0;--re)V[re]=V[re+1]*Z[re+1];return V}function C6(Z,I,V,re=!1){const ae=new Array;if(I.length===1){const le=I[0]*(re?2:1);for(let he=0;he<le;he++)ae[he]=V[Z+he]}else{const le=I[0],he=I.slice(1),ue=he.reduce((pe,ve)=>pe*ve)*(re?2:1);for(let pe=0;pe<le;pe++)ae[pe]=C6(Z+pe*ue,he,V,re)}return ae}function C7(Z,I,V=!1){if(Z.length===0)return I[0];const re=Z.reduce((ae,le)=>ae*le)*(V?2:1);if(re===0)return[];if(re!==I.length)throw new Error("["+Z+"] does not match the input size "+I.length+(V?" for a complex tensor":"")+".");return C6(0,Z,I,V)}function C8(Z,I){if(Array.isArray(Z))return Z;if(I==="float32")return Z instanceof Float32Array?Z:new Float32Array(Z);if(I==="int32")return Z instanceof Int32Array?Z:new Int32Array(Z);if(I==="bool"||I==="string")return Uint8Array.from(new Int32Array(Z));throw new Error("Unknown dtype "+I)}function C9(Z,I){const V=CC(Z,I);for(let re=0;re<V.length;re++)V[re]=1;return V}function CC(Z,I){if(I==null||I==="float32"||I==="complex64")return new Float32Array(Z);if(I==="int32")return new Int32Array(Z);if(I==="bool")return new Uint8Array(Z);throw new Error("Unknown data type "+I)}function Cm(Z){Z.forEach(I=>{e(Number.isInteger(I)&&I>=0,()=>"Tensor must have a shape comprised of positive integers but got shape ["+Z+"].")})}function CN(Z,I,V){if(I===0)return 0;if(I===1)return Z[0];let re=Z[Z.length-1];for(let ae=0;ae<Z.length-1;++ae)re+=V[ae]*Z[ae];return re}function CJ(Z,I,V){if(I===0)return[];if(I===1)return[Z];const re=new Array(I);for(let ae=0;ae<re.length-1;++ae)re[ae]=Math.floor(Z/V[ae]),Z-=re[ae]*V[ae];return re[re.length-1]=Z,re}function Cf(Z){return Z&&Z.then&&typeof Z.then=="function"}const Ci="tfjsflags";class CO{constructor(I){this.global=I,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ct,this.populateURLFlags()}setPlatform(I,V){this.platform!=null&&(Cd().getBool("IS_TEST")||Cd().getBool("PROD")||console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+I+".")),this.platformName=I,this.platform=V}registerFlag(I,V,re){if(this.flagRegistry[I]={evaluationFn:V,setHook:re},this.urlFlags[I]!=null){const ae=this.urlFlags[I];Cd().getBool("IS_TEST")||Cd().getBool("PROD")||console.warn("Setting feature override from URL "+I+": "+ae+"."),this.set(I,ae)}}async getAsync(I){return I in this.flags?this.flags[I]:(this.flags[I]=await this.evaluateFlag(I),this.flags[I])}get(I){if(I in this.flags)return this.flags[I];const V=this.evaluateFlag(I);if(Cf(V))throw new Error("Flag "+I+" cannot be synchronously evaluated. Please use getAsync() instead.");return this.flags[I]=V,this.flags[I]}getNumber(I){return this.get(I)}getBool(I){return this.get(I)}getString(I){return this.get(I)}getFlags(){return this.flags}get features(){return this.flags}set(I,V){if(this.flagRegistry[I]==null)throw new Error("Cannot set flag "+I+" as it has not been registered.");this.flags[I]=V,this.flagRegistry[I].setHook!=null&&this.flagRegistry[I].setHook(V)}evaluateFlag(I){if(this.flagRegistry[I]==null)throw new Error("Cannot evaluate flag '"+I+"': no evaluation function found.");return this.flagRegistry[I].evaluationFn()}setFlags(I){this.flags=Object.assign({},I)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const I=this.getQueryParams(this.global.location.search);Ci in I&&I[Ci].split(",").forEach(V=>{const[re,ae]=V.split(":");this.urlFlags[re]=CS(re,ae)})}}function Ct(Z){const I={};return Z.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(V,...re)=>(CB(I,re[0],re[1]),re.join("="))),I}function CB(Z,I,V){Z[decodeURIComponent(I)]=decodeURIComponent(V||"")}function CS(Z,I){const V=I.toLowerCase();return V==="true"||V==="false"?V==="true":""+ +V===V?+V:I}function Cd(){return CV}let CV=null;function Cb(Z){CV=Z}let CP;function CE(){if(CP==null){let Z;if(typeof window<"u")Z=window;else if(typeof __webpack_require__.g<"u")Z=__webpack_require__.g;else if(typeof process<"u")Z=process;else if(typeof self<"u")Z=self;else throw new Error("Could not find a global object");CP=Z}return CP}function CD(){const Z=CE();return Z._tfGlobals==null&&(Z._tfGlobals=new Map),Z._tfGlobals}function Cg(Z,I){const V=CD();if(V.has(Z))return V.get(Z);{const re=I();return V.set(Z,re),V.get(Z)}}const CZ="Abs",Co="Add",Ce="AddN",CQ="Atan2",Cs="AvgPool",CF="BatchMatMul",CI="BatchToSpaceND",Cy="Bincount",CA="Cast",Cp="ClipByValue",Cw="Complex",CX="ComplexAbs",Cc="Concat",CW="Conv2D",CR="Conv2DBackpropFilter",CK="Conv2DBackpropInput",CT="Cos",Cv="CropAndResize",Cq="DepthToSpace",Cl="DepthwiseConv2dNative",Ca="DepthwiseConv2dNativeBackpropFilter",Cn="DepthwiseConv2dNativeBackpropInput",CL="RealDiv",CH="Einsum",Ck="Elu",Cz="ExpandDims",Cx="Fill",CU="FlipLeftRight",CG="Floor",Cu="FloorDiv",CY="GatherV2",CM="Greater",Ch="GreaterEqual",Cj="Identity",Cr="Imag",m0="LeakyRelu",m1="Less",m2="LessEqual",m3="LogicalAnd",m4="LogicalOr",m5="Max",m6="Maximum",m7="MaxPool",m8="Mean",m9="Min",mC="Minimum",mm="Multiply",mN="Neg",mJ="NonMaxSuppressionV3",mf="NonMaxSuppressionV4",mi="NonMaxSuppressionV5",mO="Pack",mt="PadV2",mB="Pow",mS="Prelu",md="Range",mV="Real",mb="Relu",mP="Reshape",mE="ResizeNearestNeighbor",mD="ResizeBilinear",mg="Relu6",mZ="Round",mo="TensorScatterUpdate",me="Select",mQ="Slice",ms="Sin",mF="Sigmoid",mI="Sqrt",my="Sum",mA="SpaceToBatchND",mp="SplitV",mw="Square",mX="StridedSlice",mc="Sub",mW="Tile",mR="Transform",mK="Transpose",mT="Unpack",mv="ZerosLike",mq="Step",ml="FromPixels",ma="RotateWithOffset",mn="_FusedMatMul",mL="FusedConv2D",mH="FusedDepthwiseConv2D";function mk(...Z){Cd().getBool("IS_TEST")||Cd().getBool("PROD")||console.warn(...Z)}function mz(...Z){Cd().getBool("IS_TEST")||Cd().getBool("PROD")||console.log(...Z)}const mx=Cg("kernelRegistry",()=>new Map),mU=Cg("gradRegistry",()=>new Map);function mG(Z,I){const V=mh(Z,I);return mx.get(V)}function mu(Z){return mU.get(Z)}function mY(Z){const I=mx.entries(),V=[];for(;;){const{done:re,value:ae}=I.next();if(re)break;const[le,he]=ae,[ue]=le.split("_");ue===Z&&V.push(he)}return V}function mM(Z){const{kernelName:I,backendName:V}=Z,re=mh(I,V);mx.has(re)&&mk("The kernel '"+I+"' for backend '"+V+"' is already registered"),mx.set(re,Z)}function mh(Z,I){return I+"_"+Z}function mj(Z){return Z instanceof Float32Array||Z instanceof Int32Array||Z instanceof Uint8Array||Z instanceof Uint8ClampedArray}var mr=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof __webpack_require__.g<"u"?__webpack_require__.g:typeof self<"u"?self:{};function N0(Z){return Z&&Z.__esModule&&Object.prototype.hasOwnProperty.call(Z,"default")?Z.default:Z}var N1=N3,N2=null;try{N2=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(Z){}function N3(Z,I,V){this.low=Z|0,this.high=I|0,this.unsigned=!!V}N3.prototype.__isLong__,Object.defineProperty(N3.prototype,"__isLong__",{value:!0});function N4(Z){return(Z&&Z.__isLong__)===!0}N3.isLong=N4;var N5={},N6={};function N7(Z,I){var V,re,ae;return I?(Z>>>=0,(ae=0<=Z&&Z<256)&&(re=N6[Z],re)?re:(V=N9(Z,(Z|0)<0?-1:0,!0),ae&&(N6[Z]=V),V)):(Z|=0,(ae=-128<=Z&&Z<128)&&(re=N5[Z],re)?re:(V=N9(Z,Z<0?-1:0,!1),ae&&(N5[Z]=V),V))}N3.fromInt=N7;function N8(Z,I){if(isNaN(Z))return I?NV:Nd;if(I){if(Z<0)return NV;if(Z>=NO)return Ng}else{if(Z<=-NB)return NZ;if(Z+1>=NB)return ND}return Z<0?N8(-Z,I).neg():N9(Z%Ni|0,Z/Ni|0,I)}N3.fromNumber=N8;function N9(Z,I,V){return new N3(Z,I,V)}N3.fromBits=N9;var NC=Math.pow;function Nm(Z,I,V){if(Z.length===0)throw Error("empty string");if(Z==="NaN"||Z==="Infinity"||Z==="+Infinity"||Z==="-Infinity")return Nd;if(typeof I=="number"?(V=I,I=!1):I=!!I,V=V||10,V<2||36<V)throw RangeError("radix");var re;if((re=Z.indexOf("-"))>0)throw Error("interior hyphen");if(re===0)return Nm(Z.substring(1),I,V).neg();for(var ae=N8(NC(V,8)),le=Nd,he=0;he<Z.length;he+=8){var ue=Math.min(8,Z.length-he),pe=parseInt(Z.substring(he,he+ue),V);if(ue<8){var ve=N8(NC(V,ue));le=le.mul(ve).add(N8(pe))}else le=le.mul(ae),le=le.add(N8(pe))}return le.unsigned=I,le}N3.fromString=Nm;function NN(Z,I){return typeof Z=="number"?N8(Z,I):typeof Z=="string"?Nm(Z,I):N9(Z.low,Z.high,typeof I=="boolean"?I:Z.unsigned)}N3.fromValue=NN;var NJ=65536,Nf=1<<24,Ni=NJ*NJ,NO=Ni*Ni,NB=NO/2,NS=N7(Nf),Nd=N7(0);N3.ZERO=Nd;var NV=N7(0,!0);N3.UZERO=NV;var Nb=N7(1);N3.ONE=Nb;var NP=N7(1,!0);N3.UONE=NP;var NE=N7(-1);N3.NEG_ONE=NE;var ND=N9(-1,2147483647,!1);N3.MAX_VALUE=ND;var Ng=N9(-1,-1,!0);N3.MAX_UNSIGNED_VALUE=Ng;var NZ=N9(0,-2147483648,!1);N3.MIN_VALUE=NZ;var No=N3.prototype;No.toInt=function(){return this.unsigned?this.low>>>0:this.low},No.toNumber=function(){return this.unsigned?(this.high>>>0)*Ni+(this.low>>>0):this.high*Ni+(this.low>>>0)},No.toString=function(Z){if(Z=Z||10,Z<2||36<Z)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(NZ)){var I=N8(Z),V=this.div(I),re=V.mul(I).sub(this);return V.toString(Z)+re.toInt().toString(Z)}else return"-"+this.neg().toString(Z);for(var ae=N8(NC(Z,6),this.unsigned),le=this,he="";;){var ue=le.div(ae),pe=le.sub(ue.mul(ae)).toInt()>>>0,ve=pe.toString(Z);if(le=ue,le.isZero())return ve+he;for(;ve.length<6;)ve="0"+ve;he=""+ve+he}},No.getHighBits=function(){return this.high},No.getHighBitsUnsigned=function(){return this.high>>>0},No.getLowBits=function(){return this.low},No.getLowBitsUnsigned=function(){return this.low>>>0},No.getNumBitsAbs=function(){if(this.isNegative())return this.eq(NZ)?64:this.neg().getNumBitsAbs();for(var Z=this.high!=0?this.high:this.low,I=31;I>0&&!(Z&1<<I);I--);return this.high!=0?I+33:I+1},No.isZero=function(){return this.high===0&&this.low===0},No.eqz=No.isZero,No.isNegative=function(){return!this.unsigned&&this.high<0},No.isPositive=function(){return this.unsigned||this.high>=0},No.isOdd=function(){return(this.low&1)===1},No.isEven=function(){return(this.low&1)===0},No.equals=function(Z){return N4(Z)||(Z=NN(Z)),this.unsigned!==Z.unsigned&&this.high>>>31===1&&Z.high>>>31===1?!1:this.high===Z.high&&this.low===Z.low},No.eq=No.equals,No.notEquals=function(Z){return!this.eq(Z)},No.neq=No.notEquals,No.ne=No.notEquals,No.lessThan=function(Z){return this.comp(Z)<0},No.lt=No.lessThan,No.lessThanOrEqual=function(Z){return this.comp(Z)<=0},No.lte=No.lessThanOrEqual,No.le=No.lessThanOrEqual,No.greaterThan=function(Z){return this.comp(Z)>0},No.gt=No.greaterThan,No.greaterThanOrEqual=function(Z){return this.comp(Z)>=0},No.gte=No.greaterThanOrEqual,No.ge=No.greaterThanOrEqual,No.compare=function(Z){if(N4(Z)||(Z=NN(Z)),this.eq(Z))return 0;var I=this.isNegative(),V=Z.isNegative();return I&&!V?-1:!I&&V?1:this.unsigned?Z.high>>>0>this.high>>>0||Z.high===this.high&&Z.low>>>0>this.low>>>0?-1:1:this.sub(Z).isNegative()?-1:1},No.comp=No.compare,No.negate=function(){return!this.unsigned&&this.eq(NZ)?NZ:this.not().add(Nb)},No.neg=No.negate,No.add=function(Z){N4(Z)||(Z=NN(Z));var I=this.high>>>16,V=this.high&65535,re=this.low>>>16,ae=this.low&65535,le=Z.high>>>16,he=Z.high&65535,ue=Z.low>>>16,pe=Z.low&65535,ve=0,we=0,Me=0,Le=0;return Le+=ae+pe,Me+=Le>>>16,Le&=65535,Me+=re+ue,we+=Me>>>16,Me&=65535,we+=V+he,ve+=we>>>16,we&=65535,ve+=I+le,ve&=65535,N9(Me<<16|Le,ve<<16|we,this.unsigned)},No.subtract=function(Z){return N4(Z)||(Z=NN(Z)),this.add(Z.neg())},No.sub=No.subtract,No.multiply=function(Z){if(this.isZero())return Nd;if(N4(Z)||(Z=NN(Z)),N2){var I=N2.mul(this.low,this.high,Z.low,Z.high);return N9(I,N2.get_high(),this.unsigned)}if(Z.isZero())return Nd;if(this.eq(NZ))return Z.isOdd()?NZ:Nd;if(Z.eq(NZ))return this.isOdd()?NZ:Nd;if(this.isNegative())return Z.isNegative()?this.neg().mul(Z.neg()):this.neg().mul(Z).neg();if(Z.isNegative())return this.mul(Z.neg()).neg();if(this.lt(NS)&&Z.lt(NS))return N8(this.toNumber()*Z.toNumber(),this.unsigned);var V=this.high>>>16,re=this.high&65535,ae=this.low>>>16,le=this.low&65535,he=Z.high>>>16,ue=Z.high&65535,pe=Z.low>>>16,ve=Z.low&65535,we=0,Me=0,Le=0,Ue=0;return Ue+=le*ve,Le+=Ue>>>16,Ue&=65535,Le+=ae*ve,Me+=Le>>>16,Le&=65535,Le+=le*pe,Me+=Le>>>16,Le&=65535,Me+=re*ve,we+=Me>>>16,Me&=65535,Me+=ae*pe,we+=Me>>>16,Me&=65535,Me+=le*ue,we+=Me>>>16,Me&=65535,we+=V*ve+re*pe+ae*ue+le*he,we&=65535,N9(Le<<16|Ue,we<<16|Me,this.unsigned)},No.mul=No.multiply,No.divide=function(Z){if(N4(Z)||(Z=NN(Z)),Z.isZero())throw Error("division by zero");if(N2){if(!this.unsigned&&this.high===-2147483648&&Z.low===-1&&Z.high===-1)return this;var I=(this.unsigned?N2.div_u:N2.div_s)(this.low,this.high,Z.low,Z.high);return N9(I,N2.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?NV:Nd;var V,re,ae;if(this.unsigned){if(Z.unsigned||(Z=Z.toUnsigned()),Z.gt(this))return NV;if(Z.gt(this.shru(1)))return NP;ae=NV}else{if(this.eq(NZ)){if(Z.eq(Nb)||Z.eq(NE))return NZ;if(Z.eq(NZ))return Nb;var le=this.shr(1);return V=le.div(Z).shl(1),V.eq(Nd)?Z.isNegative()?Nb:NE:(re=this.sub(Z.mul(V)),ae=V.add(re.div(Z)),ae)}else if(Z.eq(NZ))return this.unsigned?NV:Nd;if(this.isNegative())return Z.isNegative()?this.neg().div(Z.neg()):this.neg().div(Z).neg();if(Z.isNegative())return this.div(Z.neg()).neg();ae=Nd}for(re=this;re.gte(Z);){V=Math.max(1,Math.floor(re.toNumber()/Z.toNumber()));for(var he=Math.ceil(Math.log(V)/Math.LN2),ue=he<=48?1:NC(2,he-48),pe=N8(V),ve=pe.mul(Z);ve.isNegative()||ve.gt(re);)V-=ue,pe=N8(V,this.unsigned),ve=pe.mul(Z);pe.isZero()&&(pe=Nb),ae=ae.add(pe),re=re.sub(ve)}return ae},No.div=No.divide,No.modulo=function(Z){if(N4(Z)||(Z=NN(Z)),N2){var I=(this.unsigned?N2.rem_u:N2.rem_s)(this.low,this.high,Z.low,Z.high);return N9(I,N2.get_high(),this.unsigned)}return this.sub(this.div(Z).mul(Z))},No.mod=No.modulo,No.rem=No.modulo,No.not=function(){return N9(~this.low,~this.high,this.unsigned)},No.and=function(Z){return N4(Z)||(Z=NN(Z)),N9(this.low&Z.low,this.high&Z.high,this.unsigned)},No.or=function(Z){return N4(Z)||(Z=NN(Z)),N9(this.low|Z.low,this.high|Z.high,this.unsigned)},No.xor=function(Z){return N4(Z)||(Z=NN(Z)),N9(this.low^Z.low,this.high^Z.high,this.unsigned)},No.shiftLeft=function(Z){return N4(Z)&&(Z=Z.toInt()),(Z&=63)===0?this:Z<32?N9(this.low<<Z,this.high<<Z|this.low>>>32-Z,this.unsigned):N9(0,this.low<<Z-32,this.unsigned)},No.shl=No.shiftLeft,No.shiftRight=function(Z){return N4(Z)&&(Z=Z.toInt()),(Z&=63)===0?this:Z<32?N9(this.low>>>Z|this.high<<32-Z,this.high>>Z,this.unsigned):N9(this.high>>Z-32,this.high>=0?0:-1,this.unsigned)},No.shr=No.shiftRight,No.shiftRightUnsigned=function(Z){if(N4(Z)&&(Z=Z.toInt()),Z&=63,Z===0)return this;var I=this.high;if(Z<32){var V=this.low;return N9(V>>>Z|I<<32-Z,I>>>Z,this.unsigned)}else return Z===32?N9(I,0,this.unsigned):N9(I>>>Z-32,0,this.unsigned)},No.shru=No.shiftRightUnsigned,No.shr_u=No.shiftRightUnsigned,No.toSigned=function(){return this.unsigned?N9(this.low,this.high,!1):this},No.toUnsigned=function(){return this.unsigned?this:N9(this.low,this.high,!0)},No.toBytes=function(Z){return Z?this.toBytesLE():this.toBytesBE()},No.toBytesLE=function(){var Z=this.high,I=this.low;return[I&255,I>>>8&255,I>>>16&255,I>>>24,Z&255,Z>>>8&255,Z>>>16&255,Z>>>24]},No.toBytesBE=function(){var Z=this.high,I=this.low;return[Z>>>24,Z>>>16&255,Z>>>8&255,Z&255,I>>>24,I>>>16&255,I>>>8&255,I&255]},N3.fromBytes=function(Z,I,V){return V?N3.fromBytesLE(Z,I):N3.fromBytesBE(Z,I)},N3.fromBytesLE=function(Z,I){return new N3(Z[0]|Z[1]<<8|Z[2]<<16|Z[3]<<24,Z[4]|Z[5]<<8|Z[6]<<16|Z[7]<<24,I)},N3.fromBytesBE=function(Z,I){return new N3(Z[4]<<24|Z[5]<<16|Z[6]<<8|Z[7],Z[0]<<24|Z[1]<<16|Z[2]<<8|Z[3],I)};var Ne=N0(N1),NQ=C({__proto__:null,default:Ne},[N1]);const Ns=Ne||NQ;function NF(Z){return Ns.fromString(Z,!0,16)}const NI=NF("c3a5c85c97cb3127"),Ny=NF("b492b66fbe98f273"),NA=NF("9ae16a3b2f90404f");function Np(Z){return Z.xor(Z.shru(47))}function Nw(Z,I,V){const re=Z.slice(I,I+V);return Ns.fromBytes(Array.from(re),!0,!0)}function NX(Z,I){return Nw(Z,I,8)}function Nc(Z,I){return Nw(Z,I,4)}function NW(Z,I){return I===0?Z:Z.shru(I).or(Z.shl(64-I))}function NR(Z,I,V=NF("9ddfea08eb382d69")){let re=Z.xor(I).mul(V);re=re.xor(re.shru(47));let ae=I.xor(re).mul(V);return ae=ae.xor(ae.shru(47)),ae=ae.mul(V),ae}function NK(Z,I,V,re,ae,le){ae=ae.add(Z),le=NW(le.add(ae).add(re),21);const he=ae;return ae=ae.add(I),ae=ae.add(V),le=le.add(NW(ae,44)),[ae.add(re),le.add(he)]}function NT(Z,I,V,re){return NK(NX(Z,I),NX(Z,I+8),NX(Z,I+16),NX(Z,I+24),V,re)}function Nv(Z,I=Z.length){if(I>=8){const V=NA.add(I*2),re=NX(Z,0).add(NA),ae=NX(Z,I-8),le=NW(ae,37).mul(V).add(re),he=NW(re,25).add(ae).mul(V);return NR(le,he,V)}if(I>=4){const V=NA.add(I*2),re=Nc(Z,0);return NR(re.shl(3).add(I),Nc(Z,I-4),V)}if(I>0){const V=Z[0],re=Z[I>>1],ae=Z[I-1],le=V+(re<<8),he=I+(ae<<2);return Np(NA.mul(le).xor(NI.mul(he))).mul(NA)}return NA}function Nq(Z,I=Z.length){const V=NA.add(I*2),re=NX(Z,0).mul(Ny),ae=NX(Z,8),le=NX(Z,I-8).mul(V),he=NX(Z,I-16).mul(NA);return NR(NW(re.add(ae),43).add(NW(le,30)).add(he),re.add(NW(ae.add(NA),18)).add(le),V)}function Nl(Z,I=Z.length){const V=NA.add(I*2),re=NX(Z,0).mul(NA),ae=NX(Z,8),le=NX(Z,I-8).mul(V),he=NX(Z,I-16).mul(NA),ue=NW(re.add(ae),43).add(NW(le,30)).add(he),pe=NR(ue,re.add(NW(ae.add(NA),18)).add(le),V),ve=NX(Z,16).mul(V),we=NX(Z,24),Me=ue.add(NX(Z,I-32)).mul(V),Le=pe.add(NX(Z,I-24)).mul(V);return NR(NW(ve.add(we),43).add(NW(Me,30)).add(Le),ve.add(NW(we.add(re),18)).add(Me),V)}function Na(Z,I=Z.length){const V=Ns.fromNumber(81,!0);if(I<=32)return I<=16?Nv(Z,I):Nq(Z,I);if(I<=64)return Nl(Z,I);let re=V,ae=V.mul(Ny).add(113),le=Np(ae.mul(NA).add(113)).mul(NA),he=[Ns.UZERO,Ns.UZERO],ue=[Ns.UZERO,Ns.UZERO];re=re.mul(NA).add(NX(Z,0));let pe=0;const ve=(I-1>>6)*64,we=ve+(I-1&63)-63;do re=NW(re.add(ae).add(he[0]).add(NX(Z,pe+8)),37).mul(Ny),ae=NW(ae.add(he[1]).add(NX(Z,pe+48)),42).mul(Ny),re=re.xor(ue[1]),ae=ae.add(he[0]).add(NX(Z,pe+40)),le=NW(le.add(ue[0]),33).mul(Ny),he=NT(Z,pe,he[1].mul(Ny),re.add(ue[0])),ue=NT(Z,pe+32,le.add(ue[1]),ae.add(NX(Z,pe+16))),[le,re]=[re,le],pe+=64;while(pe!==ve);const Me=Ny.add(le.and(255).shl(1));return pe=we,ue[0]=ue[0].add(I-1&63),he[0]=he[0].add(ue[0]),ue[0]=ue[0].add(he[0]),re=NW(re.add(ae).add(he[0]).add(NX(Z,pe+8)),37).mul(Me),ae=NW(ae.add(he[1]).add(NX(Z,pe+48)),42).mul(Me),re=re.xor(ue[1].mul(9)),ae=ae.add(he[0].mul(9).add(NX(Z,pe+40))),le=NW(le.add(ue[0]),33).mul(Me),he=NT(Z,pe,he[1].mul(Me),re.add(ue[0])),ue=NT(Z,pe+32,le.add(ue[1]),ae.add(NX(Z,pe+16))),[le,re]=[re,le],NR(NR(he[0],ue[0],Me).add(Np(ae).mul(NI)).add(le),NR(he[1],ue[1],Me).add(re),Me)}function Nn(Z,I){return I==="string"?Nz(Z):NH([Z],I)}function NL(Z,I){return Z instanceof Float32Array&&I==="float32"||Z instanceof Int32Array&&I==="int32"||Z instanceof Uint8Array&&I==="bool"}function NH(Z,I){if(I==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(Z)&&(Z=NG(Z)),Cd().getBool("DEBUG")&&U(Z,I),NL(Z,I))return Z;if(I==null||I==="float32"||I==="complex64")return new Float32Array(Z);if(I==="int32")return new Int32Array(Z);if(I==="bool"){const V=new Uint8Array(Z.length);for(let re=0;re<V.length;++re)Math.round(Z[re])!==0&&(V[re]=1);return V}else throw new Error("Unknown data type "+I)}function Nk(){return Cd().platform.now()}function Nz(Z,I="utf-8"){return I=I||"utf-8",Cd().platform.encode(Z,I)}function Nx(Z,I="utf-8"){return I=I||"utf-8",Cd().platform.decode(Z,I)}function NU(Z){return Cd().platform.isTypedArray!=null?Cd().platform.isTypedArray(Z):mj(Z)}function NG(Z,I=[],V=!1){if(I==null&&(I=[]),typeof Z=="boolean"||typeof Z=="number"||typeof Z=="string"||Cf(Z)||Z==null||NU(Z)&&V)I.push(Z);else if(Array.isArray(Z)||NU(Z))for(let re=0;re<Z.length;++re)NG(Z[re],I,V);else{let re=-1;for(const ae of Object.keys(Z))/^([1-9]+[0-9]*|0)$/.test(ae)&&(re=Math.max(re,Number(ae)));for(let ae=0;ae<=re;ae++)NG(Z[ae],I,V)}return I}class Nu{constructor(I,V){this.backendTimer=I,this.logger=V,V==null&&(this.logger=new NM)}profileKernel(I,V,re){let ae;const le=()=>{ae=re()};let he;const ue=Nk();if(this.backendTimer.timerAvailable())he=this.backendTimer.time(le);else{le();for(const pe of ae)pe.dataSync();he=Promise.resolve({kernelMs:Nk()-ue})}if(Cd().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let pe=0;pe<ae.length;pe++){const ve=ae[pe];ve.data().then(we=>{NY(we,ve.dtype,I)})}return{kernelName:I,outputs:ae,inputs:V,timeMs:he.then(pe=>pe.kernelMs),extraInfo:he.then(pe=>pe.getExtraProfileInfo!=null?pe.getExtraProfileInfo():"")}}logKernelProfile(I){const{kernelName:V,outputs:re,timeMs:ae,inputs:le,extraInfo:he}=I;re.forEach(ue=>{Promise.all([ue.data(),ae,he]).then(pe=>{this.logger.logKernelProfile(V,ue,pe[0],pe[1],le,pe[2])})})}}function NY(Z,I,V){if(I!=="float32")return!1;for(let re=0;re<Z.length;re++){const ae=Z[re];if(isNaN(ae)||!isFinite(ae))return console.warn("Found "+ae+" in the result of '"+V+"'"),!0}return!1}class NM{logKernelProfile(I,V,re,ae,le,he){const ue=typeof ae=="number"?T(ae+"ms",9):ae.error,pe=T(I,25),ve=V.rank,we=V.size,Me=T(V.shape.toString(),14);let Le="";for(const Ue in le){const Ge=le[Ue];if(Ge!=null){const ze=Ge.shape||V.shape,He=ze.length;Le+=Ue+": "+He+"D "+(He>0?ze:"")+" "}}console.log("%c"+pe+"	%c"+ue+"	%c"+ve+"D "+Me+"	%c"+we+"	%c"+Le+"	%c"+he,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Nh(Z,I,V){const re={},ae={};for(let pe=0;pe<I.length;pe++)re[I[pe].id]=!0;for(let pe=0;pe<Z.length;pe++){const ve=Z[pe],we=ve.inputs;for(const Me in we){const Le=we[Me];let Ue=!1;for(let Ge=0;Ge<I.length;Ge++)if(re[Le.id]){ve.outputs.forEach(ze=>re[ze.id]=!0),Ue=!0,ae[ve.id]=!0;break}if(Ue)break}}const le={};le[V.id]=!0;const he={};for(let pe=Z.length-1;pe>=0;pe--){const ve=Z[pe],we=ve.inputs;for(let Me=0;Me<ve.outputs.length;Me++)if(le[ve.outputs[Me].id]){for(const Le in we)le[we[Le].id]=!0,he[ve.id]=!0;break}}const ue=[];for(let pe=0;pe<Z.length;pe++){const ve=Z[pe];if(ae[ve.id]&&he[ve.id]){const we={};for(const Le in ve.inputs){const Ue=ve.inputs[Le];re[Ue.id]&&(we[Le]=Ue)}const Me=Object.assign({},ve);Me.inputs=we,Me.outputs=ve.outputs,ue.push(Me)}}return ue}function Nj(Z,I,V,re){for(let ae=I.length-1;ae>=0;ae--){const le=I[ae],he=[];if(le.outputs.forEach(pe=>{const ve=Z[pe.id];ve!=null?he.push(ve):he.push(null)}),le.gradient==null)throw new Error("Cannot compute gradient: gradient function not found for "+le.kernelName+".");const ue=le.gradient(he);for(const pe in le.inputs){if(!(pe in ue))throw new Error("Cannot backprop through input "+pe+". Available gradients found: "+Object.keys(ue)+".");const ve=V(()=>ue[pe]());if(ve.dtype!=="float32")throw new Error("Error in gradient for op "+le.kernelName+". The gradient of input "+pe+" must have 'float32' dtype, but has '"+ve.dtype+"'");const we=le.inputs[pe];if(!X(ve.shape,we.shape))throw new Error("Error in gradient for op "+le.kernelName+". The gradient of input '"+pe+"' has shape '"+ve.shape+"', which does not match the shape of the input '"+we.shape+"'");if(Z[we.id]==null)Z[we.id]=ve;else{const Me=Z[we.id];Z[we.id]=re(Me,ve),Me.dispose()}}}}const Nr=20,J0=3,J1=7;function J2(Z,I,V,re){const ae=C5(I),le=J3(Z,I,V,ae),he=I.length,ue=J6(Z,I,V,ae,le),pe=["Tensor"];return re&&(pe.push("  dtype: "+V),pe.push("  rank: "+he),pe.push("  shape: ["+I+"]"),pe.push("  values:")),pe.push(ue.map(ve=>"    "+ve).join(`
`)),pe.join(`
`)}function J3(Z,I,V,re){const ae=F(I),le=re[re.length-1],he=new Array(le).fill(0),ue=I.length,pe=V==="complex64"?J7(Z):Z;if(ue>1)for(let ve=0;ve<ae/le;ve++){const we=ve*le;for(let Me=0;Me<le;Me++)he[Me]=Math.max(he[Me],J4(pe[we+Me],0,V).length)}return he}function J4(Z,I,V){let re;return Array.isArray(Z)?re=parseFloat(Z[0].toFixed(J1))+" + "+parseFloat(Z[1].toFixed(J1))+"j":j(Z)?re="'"+Z+"'":V==="bool"?re=J5(Z):re=parseFloat(Z.toFixed(J1)).toString(),T(re,I)}function J5(Z){return Z===0?"false":"true"}function J6(Z,I,V,re,ae,le=!0){const he=V==="complex64"?2:1,ue=I[0],pe=I.length;if(pe===0){if(V==="complex64"){const ze=J7(Z);return[J4(ze[0],0,V)]}return V==="bool"?[J5(Z[0])]:[Z[0].toString()]}if(pe===1){if(ue>Nr){const ze=J0*he;let He=Array.from(Z.slice(0,ze)),Ke=Array.from(Z.slice((ue-J0)*he,ue*he));return V==="complex64"&&(He=J7(He),Ke=J7(Ke)),["["+He.map((Ye,$e)=>J4(Ye,ae[$e],V)).join(", ")+", ..., "+Ke.map((Ye,$e)=>J4(Ye,ae[ue-J0+$e],V)).join(", ")+"]"]}return["["+(V==="complex64"?J7(Z):Array.from(Z)).map((ze,He)=>J4(ze,ae[He],V)).join(", ")+"]"]}const ve=I.slice(1),we=re.slice(1),Me=re[0]*he,Le=[];if(ue>Nr){for(let ze=0;ze<J0;ze++){const He=ze*Me,Ke=He+Me;Le.push(...J6(Z.slice(He,Ke),ve,V,we,ae,!1))}Le.push("...");for(let ze=ue-J0;ze<ue;ze++){const He=ze*Me,Ke=He+Me;Le.push(...J6(Z.slice(He,Ke),ve,V,we,ae,ze===ue-1))}}else for(let ze=0;ze<ue;ze++){const He=ze*Me,Ke=He+Me;Le.push(...J6(Z.slice(He,Ke),ve,V,we,ae,ze===ue-1))}const Ue=pe===2?",":"";Le[0]="["+(ue>0?Le[0]+Ue:"");for(let ze=1;ze<Le.length-1;ze++)Le[ze]=" "+Le[ze]+Ue;let Ge=`,
`;for(let ze=2;ze<pe;ze++)Ge+=`
`;return Le[Le.length-1]=" "+Le[Le.length-1]+"]"+(le?"":Ge),Le}function J7(Z){const I=[];for(let V=0;V<Z.length;V+=2)I.push([Z[V],Z[V+1]]);return I}class J8{constructor(I,V,re){if(this.dtype=V,this.shape=I.slice(),this.size=F(I),re!=null){const ae=re.length;e(ae===this.size,()=>"Length of values '"+ae+"' does not match the size inferred by the shape '"+this.size+"'.")}if(V==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=re||x(V,this.size),this.strides=C5(I)}set(I,...V){V.length===0&&(V=[0]),e(V.length===this.rank,()=>"The number of provided coordinates ("+V.length+") must match the rank ("+this.rank+")");const re=this.locToIndex(V);this.values[re]=I}get(...I){I.length===0&&(I=[0]);let V=0;for(const ae of I){if(ae<0||ae>=this.shape[V]){const le="Requested out of range element at "+I+".   Buffer shape="+this.shape;throw new Error(le)}V++}let re=I[I.length-1];for(let ae=0;ae<I.length-1;++ae)re+=this.strides[ae]*I[ae];return this.values[re]}locToIndex(I){if(this.rank===0)return 0;if(this.rank===1)return I[0];let V=I[I.length-1];for(let re=0;re<I.length-1;++re)V+=this.strides[re]*I[re];return V}indexToLoc(I){if(this.rank===0)return[];if(this.rank===1)return[I];const V=new Array(this.shape.length);for(let re=0;re<V.length-1;++re)V[re]=Math.floor(I/this.strides[re]),I-=V[re]*this.strides[re];return V[V.length-1]=I,V}get rank(){return this.shape.length}toTensor(){return J9().makeTensor(this.values,this.shape,this.dtype)}}let J9=null,JC=null;function Jm(Z){J9=Z}function JN(Z){JC=Z}class JJ{constructor(I,V,re,ae){this.kept=!1,this.isDisposedInternal=!1,this.shape=I.slice(),this.dtype=V||"float32",this.size=F(I),this.strides=C5(I),this.dataId=re,this.id=ae,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const I=await this.data();return JC.buffer(this.shape,this.dtype,I)}bufferSync(){return JC.buffer(this.shape,this.dtype,this.dataSync())}async array(){const I=await this.data();return C7(this.shape,I,this.dtype==="complex64")}arraySync(){return C7(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const I=J9().read(this.dataId);if(this.dtype==="string"){const V=await I;try{return V.map(re=>Nx(re))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return I}dataToGPU(I){return this.throwIfDisposed(),J9().readToGPU(this.dataId,I)}dataSync(){this.throwIfDisposed();const I=J9().readSync(this.dataId);if(this.dtype==="string")try{return I.map(V=>Nx(V))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return I}async bytes(){this.throwIfDisposed();const I=await J9().read(this.dataId);return this.dtype==="string"?I:new Uint8Array(I.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),J9().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(I=!1){return JC.print(this,I)}clone(){return this.throwIfDisposed(),JC.clone(this)}toString(I=!1){const V=this.dataSync();return J2(V,this.shape,this.dtype,I)}cast(I){return this.throwIfDisposed(),JC.cast(this,I)}variable(I=!0,V,re){return this.throwIfDisposed(),J9().makeVariable(this,I,V,re)}}Object.defineProperty(JJ,Symbol.hasInstance,{value:Z=>!!Z&&Z.data!=null&&Z.dataSync!=null&&Z.throwIfDisposed!=null});function Jf(){return Cg("Tensor",()=>JJ)}Jf();class Ji extends JJ{constructor(I,V,re,ae){super(I.shape,I.dtype,I.dataId,ae),this.trainable=V,this.name=re}assign(I){if(I.dtype!==this.dtype)throw new Error("dtype of the new value ("+I.dtype+") and previous value ("+this.dtype+") must match");if(!X(I.shape,this.shape))throw new Error("shape of the new value ("+I.shape+") and previous value ("+this.shape+") must match");J9().disposeTensor(this),this.dataId=I.dataId,J9().incRef(this,null)}dispose(){J9().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ji,Symbol.hasInstance,{value:Z=>Z instanceof JJ&&Z.assign!=null&&Z.assign instanceof Function});var JO;(function(Z){Z.R0="R0",Z.R1="R1",Z.R2="R2",Z.R3="R3",Z.R4="R4",Z.R5="R5",Z.R6="R6"})(JO||(JO={}));var Jt;(function(Z){Z.float32="float32",Z.int32="int32",Z.bool="int32",Z.complex64="complex64"})(Jt||(Jt={}));var JB;(function(Z){Z.float32="float32",Z.int32="int32",Z.bool="bool",Z.complex64="complex64"})(JB||(JB={}));var JS;(function(Z){Z.float32="float32",Z.int32="float32",Z.bool="float32",Z.complex64="complex64"})(JS||(JS={}));var Jd;(function(Z){Z.float32="complex64",Z.int32="complex64",Z.bool="complex64",Z.complex64="complex64"})(Jd||(Jd={}));const JV={float32:JS,int32:Jt,bool:JB,complex64:Jd};function Jb(Z,I){if(Z==="string"||I==="string"){if(Z==="string"&&I==="string")return"string";throw new Error("Can not upcast "+Z+" with "+I)}return JV[Z][I]}function JP(Z){return Jb(Z,"int32")}function JE(Z){return Z!=null&&typeof Z=="object"&&"texture"in Z&&Z.texture instanceof WebGLTexture}function JD(Z){return typeof GPUBuffer<"u"&&Z!=null&&typeof Z=="object"&&"buffer"in Z&&Z.buffer instanceof GPUBuffer}function Jg(Z,I){if(Z.dtype===I.dtype)return[Z,I];const V=Jb(Z.dtype,I.dtype);return[Z.cast(V),I.cast(V)]}function JZ(Z){const I=[];return Jo(Z,I,new Set),I}function Jo(Z,I,V){if(Z==null)return;if(Z instanceof JJ){I.push(Z);return}if(!Je(Z))return;const re=Z;for(const ae in re){const le=re[ae];V.has(le)||(V.add(le),Jo(le,I,V))}}function Je(Z){return Array.isArray(Z)||typeof Z=="object"}function JQ(Z){return Z.kernelName!=null}class Js{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(I=>I.name)))}}}dispose(){for(const I in this.registeredVariables)this.registeredVariables[I].dispose()}}class JF{constructor(I){this.ENV=I,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Js}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const I=this.getSortedBackends();for(let V=0;V<I.length;V++){const re=I[V];if(await this.initializeBackend(re).success){await this.setBackend(re);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(this.backendInstance==null){const{name:I,asyncInit:V}=this.initializeBackendsAndReturnBest();if(V)throw new Error("The highest priority backend '"+I+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(I)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(I){if(!(I in this.registry))if(I in this.registryFactory){const{asyncInit:V}=this.initializeBackend(I);if(V)return null}else return null;return this.registry[I]}findBackendFactory(I){return I in this.registryFactory?this.registryFactory[I].factory:null}registerBackend(I,V,re=1){return I in this.registryFactory?(mk(I+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[I]={factory:V,priority:re},!0)}async setBackend(I){if(this.registryFactory[I]==null)throw new Error("Backend name '"+I+"' not found in registry");if(this.backendName=I,this.registry[I]==null){this.backendInstance=null;const{success:V,asyncInit:re}=this.initializeBackend(I);if(!(re?await V:V))return!1}return this.backendInstance=this.registry[I],this.setupRegisteredKernels(),this.profiler=new Nu(this.backendInstance),!0}setupRegisteredKernels(){mY(this.backendName).forEach(I=>{I.setupFunc!=null&&I.setupFunc(this.backendInstance)})}disposeRegisteredKernels(I){mY(I).forEach(V=>{V.disposeFunc!=null&&V.disposeFunc(this.registry[I])})}initializeBackend(I){const V=this.registryFactory[I];if(V==null)throw new Error("Cannot initialize backend "+I+", no registration found.");try{const re=V.factory();if(re&&!(re instanceof i)&&typeof re.then=="function"){const ae=++this.pendingBackendInitId,le=re.then(he=>ae<this.pendingBackendInitId?!1:(this.registry[I]=he,this.pendingBackendInit=null,!0)).catch(he=>(ae<this.pendingBackendInitId||(this.pendingBackendInit=null,mk("Initialization of backend "+I+" failed"),mk(he.stack||he.message)),!1));return this.pendingBackendInit=le,{success:le,asyncInit:!0}}else return this.registry[I]=re,{success:!0,asyncInit:!1}}catch(re){return mk("Initialization of backend "+I+" failed"),mk(re.stack||re.message),{success:!1,asyncInit:!1}}}removeBackend(I){if(!(I in this.registryFactory))throw new Error(I+" backend not found in registry");this.backendName===I&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,I in this.registry&&(this.disposeRegisteredKernels(I),this.registry[I].dispose(),delete this.registry[I]),delete this.registryFactory[I],this.backendName===I&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((I,V)=>this.registryFactory[V].priority-this.registryFactory[I].priority)}initializeBackendsAndReturnBest(){const I=this.getSortedBackends();for(let V=0;V<I.length;V++){const re=I[V],{success:ae,asyncInit:le}=this.initializeBackend(re);if(le||ae)return{name:re,asyncInit:le}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(I,V){const re=this.state.tensorInfo.get(V),ae=re.backend,le=this.readSync(V),he=ae.refCount(V);ae.disposeData(V,!0),re.backend=I,I.move(V,le,re.shape,re.dtype,he),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(I,V){let re=null;if(V==null){if(typeof I!="function")throw new Error("Please provide a function to tidy()");V=I}else{if(typeof I!="string"&&!(I instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof V!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");re=I}let ae;return this.scopedRun(()=>this.startScope(re),()=>this.endScope(ae),()=>(ae=V(),ae instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),ae))}scopedRun(I,V,re){I();try{const ae=re();return V(),ae}catch(ae){throw V(),ae}}nextTensorId(){return JF.nextTensorId++}nextVariableId(){return JF.nextVariableId++}clone(I){const V=JA.runKernel(Cj,{x:I}),re={x:I},ae=he=>({x:()=>{const ue="float32",pe={x:he},ve={dtype:ue};return JA.runKernel(CA,pe,ve)}}),le=[];return this.addTapeNode(this.state.activeScope.name,re,[V],ae,le,{}),V}runKernel(I,V,re){if(this.backendName==null&&this.backend,mG(I,this.backendName)==null)throw new Error("Kernel '"+I+"' not registered for backend '"+this.backendName+"'");return this.runKernelFunc({kernelName:I,inputs:V,attrs:re})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(I,V,re){const ae=this.backend.numDataIds();let le=0;re.forEach(pe=>{le+=pe.dtype==="complex64"?3:1});const he=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],ue=ae-V-le-he;if(ue>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+ue+" data ids) after running '"+I+"'")}runKernelFunc(I){let V,re=[];const ae=this.isTapeOn(),le=this.state.numBytes,he=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let ue;this.backendName==null&&this.backend;let pe;const ve=JQ(I)?I.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(JQ(I)){const{kernelName:Ge,inputs:ze,attrs:He}=I;this.backendName==null&&this.backend;const Ke=mG(Ge,this.backendName);e(Ke!=null,()=>"Cannot find registered kernel '"+Ge+"' for backend '"+this.backendName+"'"),ue=()=>{const Ye=this.backend.numDataIds();pe=Ke.kernelFunc({inputs:ze,attrs:He,backend:this.backend});const $e=Array.isArray(pe)?pe:[pe];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Ge,Ye,$e);const je=$e.map(rt=>rt.rank!=null?rt:this.makeTensorFromTensorInfo(rt));if(ae){const rt=this.getTensorsForGradient(Ge,ze,je);re=this.saveTensorsForBackwardMode(rt)}return je}}else{const{forwardFunc:Ge}=I,ze=He=>{ae&&(re=He.map(Ke=>this.keep(this.clone(Ke))))};ue=()=>{const He=this.backend.numDataIds();pe=this.tidy(()=>Ge(this.backend,ze));const Ke=Array.isArray(pe)?pe:[pe];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(ve,He,Ke),Ke}}const{inputs:we,attrs:Me}=I,Le=JQ(I)?null:I.backwardsFunc;let Ue;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?V=ue():(Ue=this.profiler.profileKernel(ve,we,()=>ue()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Ue),V=Ue.outputs)}),ae&&this.addTapeNode(ve,we,V,Le,re,Me),this.state.profiling&&this.state.activeProfile.kernels.push({name:ve,bytesAdded:this.state.numBytes-le,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-he,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(we).map(Ge=>we[Ge]!=null?we[Ge].shape:null),outputShapes:V.map(Ge=>Ge.shape),kernelTimeMs:Ue.timeMs,extraInfo:Ue.extraInfo}),Array.isArray(pe)?V:V[0]}saveTensorsForBackwardMode(I){return I.map(V=>this.keep(this.clone(V)))}getTensorsForGradient(I,V,re){const ae=mu(I);if(ae!=null){const le=ae.inputsToSave||[],he=ae.outputsToSave||[];let ue;ae.saveAllInputs?(e(Array.isArray(V),()=>"saveAllInputs is true, expected inputs to be an array."),ue=Object.keys(V).map(ve=>V[ve])):ue=le.map(ve=>V[ve]);const pe=re.filter((ve,we)=>he[we]);return ue.concat(pe)}return[]}makeTensor(I,V,re,ae){if(I==null)throw new Error("Values passed to engine.makeTensor() are null");re=re||"float32",ae=ae||this.backend;let le=I;re==="string"&&j(I[0])&&(le=I.map(pe=>Nz(pe)));const he=ae.write(le,V,re),ue=new JJ(V,re,he,this.nextTensorId());if(this.trackTensor(ue,ae),re==="string"){const pe=this.state.tensorInfo.get(he),ve=h(le);this.state.numBytes+=ve-pe.bytes,pe.bytes=ve}return ue}makeTensorFromDataId(I,V,re,ae){re=re||"float32";const le={dataId:I,shape:V,dtype:re};return this.makeTensorFromTensorInfo(le,ae)}makeTensorFromTensorInfo(I,V){const{dataId:re,shape:ae,dtype:le}=I,he=new JJ(ae,le,re,this.nextTensorId());return this.trackTensor(he,V),he}makeVariable(I,V=!0,re,ae){re=re||this.nextVariableId().toString(),ae!=null&&ae!==I.dtype&&(I=I.cast(ae));const le=new Ji(I,V,re,this.nextTensorId());if(this.state.registeredVariables[le.name]!=null)throw new Error("Variable with name "+le.name+" was already registered");return this.state.registeredVariables[le.name]=le,this.incRef(le,this.backend),le}trackTensor(I,V){this.state.numTensors++,I.dtype==="string"&&this.state.numStringTensors++;let re=0;I.dtype!=="complex64"&&I.dtype!=="string"&&(re=I.size*M(I.dtype)),this.state.numBytes+=re,this.state.tensorInfo.has(I.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(I.dataId,{backend:V||this.backend,dtype:I.dtype,shape:I.shape,bytes:re})),I instanceof Ji||this.track(I)}incRef(I,V){this.trackTensor(I,V),this.backend.incRef(I.dataId)}removeDataId(I,V){this.state.tensorInfo.has(I)&&this.state.tensorInfo.get(I).backend===V&&(this.state.tensorInfo.delete(I),this.state.numDataBuffers--)}disposeTensor(I){if(!this.state.tensorInfo.has(I.dataId))return;const V=this.state.tensorInfo.get(I.dataId);if(this.state.numTensors--,I.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=V.bytes),I.dtype!=="complex64"&&I.dtype!=="string"){const re=I.size*M(I.dtype);this.state.numBytes-=re}V.backend.disposeData(I.dataId)&&this.removeDataId(I.dataId,V.backend)}disposeVariables(){for(const I in this.state.registeredVariables){const V=this.state.registeredVariables[I];this.disposeVariable(V)}}disposeVariable(I){this.disposeTensor(I),this.state.registeredVariables[I.name]!=null&&delete this.state.registeredVariables[I.name]}memory(){const I=this.backend.memory();return I.numTensors=this.state.numTensors,I.numDataBuffers=this.state.numDataBuffers,I.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(I.unreliable=!0,I.reasons==null&&(I.reasons=[]),I.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),I}async profile(I){this.state.profiling=!0;const V=this.state.numBytes,re=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await I(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(ae=>ae.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-V,this.state.activeProfile.newTensors=this.state.numTensors-re;for(const ae of this.state.activeProfile.kernels)ae.kernelTimeMs=await ae.kernelTimeMs,ae.extraInfo=await ae.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(I,V,re,ae,le,he){const ue={id:this.state.nextTapeNodeId++,kernelName:I,inputs:V,outputs:re,saved:le},pe=mu(I);pe!=null&&(ae=pe.gradFunc),ae!=null&&(ue.gradient=ve=>(ve=ve.map((we,Me)=>{if(we==null){const Le=re[Me],Ue=CC(Le.size,Le.dtype);return this.makeTensor(Ue,Le.shape,Le.dtype)}return we}),ae(ve.length>1?ve:ve[0],le,he))),this.state.activeTape.push(ue)}keep(I){return I.kept=!0,I}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(I){const V={track:[],name:"unnamed scope",id:this.state.nextScopeId++};I&&(V.name=I),this.state.scopeStack.push(V),this.state.activeScope=V}endScope(I){const V=JZ(I),re=new Set(V.map(le=>le.id));for(let le=0;le<this.state.activeScope.track.length;le++){const he=this.state.activeScope.track[le];!he.kept&&!re.has(he.id)&&he.dispose()}const ae=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],V.forEach(le=>{!le.kept&&le.scopeId===ae.id&&this.track(le)})}gradients(I,V,re,ae=!1){if(e(V.length>0,()=>"gradients() received an empty list of xs."),re!=null&&re.dtype!=="float32")throw new Error("dy must have 'float32' dtype, but has '"+re.dtype+"'");const le=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",I));e(le instanceof JJ,()=>"The result y returned by f() must be a tensor.");const he=Nh(this.state.activeTape,V,le);if(!ae&&he.length===0&&V.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const ue={};ue[le.id]=re??JI(le.shape),Nj(ue,he,ve=>this.tidy(ve),Jp);const pe=V.map(ve=>ue[ve.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(ve=>{for(const we of ve.saved)we.dispose()}),this.state.activeTape=null),{value:le,grads:pe}})}customGrad(I){return e(C3(I),()=>"The f passed in customGrad(f) must be a function."),(...V)=>{e(V.every(ue=>ue instanceof JJ),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let re;const ae={};V.forEach((ue,pe)=>{ae[pe]=ue});const le=(ue,pe)=>(re=I(...V,pe),e(re.value instanceof JJ,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),e(C3(re.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),re.value),he=(ue,pe)=>{const ve=re.gradFunc(ue,pe),we=Array.isArray(ve)?ve:[ve];e(we.length===V.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),e(we.every(Le=>Le instanceof JJ),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const Me={};return we.forEach((Le,Ue)=>{Me[Ue]=()=>Le}),Me};return this.runKernelFunc({forwardFunc:le,backwardsFunc:he,inputs:ae})}}readSync(I){return this.state.tensorInfo.get(I).backend.readSync(I)}read(I){return this.state.tensorInfo.get(I).backend.read(I)}readToGPU(I,V){return this.state.tensorInfo.get(I).backend.readToGPU(I,V)}async time(I){const V=Nk(),re=await this.backend.time(I);return re.wallMs=Nk()-V,re}track(I){return this.state.activeScope!=null&&(I.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(I)),I}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Js;for(const I in this.registry)this.disposeRegisteredKernels(I),this.registry[I].dispose(),delete this.registry[I];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}JF.nextTensorId=0,JF.nextVariableId=0;function JI(Z){const I=C9(F(Z),"float32");return JA.makeTensor(I,Z,"float32")}function Jy(){const Z=CE();if(Z._tfengine==null){const I=new CO(Z);Z._tfengine=new JF(I)}return Cb(Z._tfengine.ENV),Jm(()=>Z._tfengine),Z._tfengine}const JA=Jy();function Jp(Z,I){const V={a:Z,b:I};return JA.runKernel(Co,V)}function Jw(){return typeof navigator<"u"&&navigator!=null}function JX(Z){if(Z||Jw()){if(Z||(Z=navigator),Z.product==="ReactNative")return!0;const I=Z.userAgent||Z.vendor||(typeof window<"u"?window.opera:"");if(!I){const V=Z;return V.userAgentData&&V.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(I)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(I.substr(0,4))}return!1}function Jc(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const JW=Cd();JW.registerFlag("DEBUG",()=>!1,Z=>{Z&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),JW.registerFlag("IS_BROWSER",()=>Jc()),JW.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),JW.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),JW.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),JW.registerFlag("PROD",()=>!1),JW.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>JW.getBool("DEBUG")),JW.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),JW.registerFlag("IS_TEST",()=>!1),JW.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>JW.getBool("DEBUG")),JW.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),JW.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),JW.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function JR(Z,I){let V=Z;if(NU(Z))return I==="string"?[]:[Z.length];if(JE(Z)){const ae=Z.channels||"RGBA";return[Z.height,Z.width*ae.length]}else if(JD(Z))return[Z.buffer.size/(I==null?4:M(I))];if(!Array.isArray(Z))return[];const re=[];for(;Array.isArray(V)||NU(V)&&I!=="string";)re.push(V.length),V=V[0];return Array.isArray(Z)&&Cd().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&JK(Z,re,[]),re}function JK(Z,I,V){if(V=V||[],!Array.isArray(Z)&&!NU(Z)){e(I.length===0,()=>"Element arr["+V.join("][")+"] is a primitive, but should be an array/TypedArray of "+I[0]+" elements");return}e(I.length>0,()=>"Element arr["+V.join("][")+"] should be a primitive, but is an array of "+Z.length+" elements"),e(Z.length===I[0],()=>"Element arr["+V.join("][")+"] should have "+I[0]+" elements, but has "+Z.length+" elements");const re=I.slice(1);for(let ae=0;ae<Z.length;++ae)JK(Z[ae],re,V.concat(ae))}function JT(Z,I,V,re){if(Z!=="string_or_numeric"){if(Z==null)throw new Error("Expected dtype cannot be null.");if(Z!=="numeric"&&Z!==I||Z==="numeric"&&I==="string")throw new Error("Argument '"+V+"' passed to '"+re+"' must be "+Z+" tensor, but got "+I+" tensor")}}function Jv(Z,I,V,re="numeric"){if(Z instanceof Jf())return JT(re,Z.dtype,I,V),Z;let ae=C2(Z);if(ae!=="string"&&["bool","int32","float32"].indexOf(re)>=0&&(ae=re),JT(re,ae,I,V),Z==null||!NU(Z)&&!Array.isArray(Z)&&typeof Z!="number"&&typeof Z!="boolean"&&typeof Z!="string"){const ue=Z==null?"null":Z.constructor.name;throw new Error("Argument '"+I+"' passed to '"+V+"' must be a Tensor or TensorLike, but got '"+ue+"'")}const le=JR(Z,ae);!NU(Z)&&!Array.isArray(Z)&&(Z=[Z]);const he=ae!=="string"?NH(Z,ae):NG(Z,[],!0);return JA.makeTensor(he,le,ae)}function Jq(Z,I,V,re="numeric"){if(!Array.isArray(Z))throw new Error("Argument "+I+" passed to "+V+" must be a `Tensor[]` or `TensorLike[]`");return Z.map((ae,le)=>Jv(ae,I+"["+le+"]",V,re))}const Jl="__op";function Ja(Z){const I=Object.keys(Z);if(I.length!==1)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+I.length+" keys.");let V=I[0];const re=Z[V];V.endsWith("_")&&(V=V.substring(0,V.length-1)),V=V+Jl;const ae=(...le)=>{JA.startScope(V);try{const he=re(...le);return Cf(he)&&console.error("Cannot return a Promise inside of tidy."),JA.endScope(he),he}catch(he){throw JA.endScope(null),he}};return Object.defineProperty(ae,"name",{value:V,configurable:!0}),ae}function Jn(Z,I){const V=Jv(Z,"real","complex"),re=Jv(I,"imag","complex");Q(V.shape,re.shape,"real and imag shapes, "+V.shape+" and "+re.shape+", must match in call to tf.complex().");const ae={real:V,imag:re};return JA.runKernel(Cw,ae)}const JL=Ja({complex_:Jn});function JH(Z,I,V,re){if(re==null)re=C2(Z);else if(re==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(JD(Z)||JE(Z)){if(re!=="float32"&&re!=="int32")throw new Error("Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is "+re+".");return JA.backend.createTensorFromGPUData(Z,I||V,re)}if(!NU(Z)&&!Array.isArray(Z)&&typeof Z!="number"&&typeof Z!="boolean"&&typeof Z!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(I!=null){Cm(I);const ae=F(I),le=F(V);e(ae===le,()=>"Based on the provided shape, ["+I+"], the tensor should have "+ae+" values but has "+le);for(let he=0;he<V.length;++he){const ue=V[he],pe=he===V.length-1?ue!==F(I.slice(he)):!0;e(V[he]===I[he]||!pe,()=>"Error creating a new Tensor. Inferred shape ("+V+") does not match the provided shape ("+I+"). ")}}return!NU(Z)&&!Array.isArray(Z)&&(Z=[Z]),I=I||V,Z=re!=="string"?NH(Z,re):NG(Z,[],!0),JA.makeTensor(Z,I,re)}function Jk(Z,I,V){const re=JR(Z,V);return JH(Z,I,re,V)}const Jz={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Jx{static join(I){return new Jx(I).slice()}constructor(I){if(this.shards=[],this.previousShardIndex=0,I==null||(I instanceof Array||(I=[I]),I=I.map(re=>NU(re)?re.buffer:re),I.length===0))return;this.bufferUniformSize=I[0].byteLength;let V=0;for(let re=0;re<I.length;re++){const ae=I[re];re!==I.length-1&&ae.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const le=V+ae.byteLength;this.shards.push({buffer:ae,start:V,end:le}),V=le}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(I=0,V=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(I=isNaN(Number(I))?0:I,V=isNaN(Number(V))?0:V,I=Math.max(0,I),V=Math.min(this.byteLength,V),V<=I)return new ArrayBuffer(0);const re=this.findShardForByte(I);if(re===-1)throw new Error("Could not find start shard for byte "+I);const ae=V-I,le=new ArrayBuffer(ae),he=new Uint8Array(le);let ue=0;for(let pe=re;pe<this.shards.length;pe++){const ve=this.shards[pe],we=I+ue-ve.start,Me=ue,Le=Math.min(V,ve.end)-ve.start,Ue=new Uint8Array(ve.buffer,we,Le-we);if(he.set(Ue,Me),ue+=Ue.length,V<ve.end)break}return le}findShardForByte(I){if(this.shards.length===0||I<0||I>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(I/this.bufferUniformSize),this.previousShardIndex;function V(ae){return I<ae.start?-1:I>=ae.end?1:0}if(V(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const re=JU(this.shards,V);return re===-1?-1:(this.previousShardIndex=re,this.previousShardIndex)}}function JU(Z,I){let V=0,re=Z.length;for(;V<=re;){const ae=Math.floor((re-V)/2)+V,le=I(Z[ae]);if(le===0)return ae;le<0?re=ae:V=ae+1}return-1}function JG(){Cd().set("PROD",!0)}function Ju(){return JA}function JY(Z,I){return JA.tidy(Z,I)}function JM(Z){JZ(Z).forEach(I=>I.dispose())}function Jh(Z){return JA.keep(Z)}function Jj(Z){return JA.setBackend(Z)}function Jr(){return JA.backendName}function f0(Z,I,V=1){return JA.registerBackend(Z,I,V)}function f1(){return JA.backend}const f2=4;async function f3(Z,I){const V=[],re=[],ae=Array.isArray(Z)?Z.map(he=>he.name):Object.keys(Z);for(let he=0;he<ae.length;++he){const ue=ae[he],pe=Array.isArray(Z)?Z[he].tensor:Z[ue];if(pe.dtype!=="float32"&&pe.dtype!=="int32"&&pe.dtype!=="bool"&&pe.dtype!=="string"&&pe.dtype!=="complex64")throw new Error("Unsupported dtype in weight '"+ue+"': "+pe.dtype);const ve={name:ue,shape:pe.shape,dtype:pe.dtype};if(pe.dtype==="string"){const we=new Promise(async Me=>{const Le=await pe.bytes(),Ue=Le.reduce((He,Ke)=>He+Ke.length,0)+f2*Le.length,Ge=new Uint8Array(Ue);let ze=0;for(let He=0;He<Le.length;He++){const Ke=Le[He],Ye=new Uint8Array(new Uint32Array([Ke.length]).buffer);Ge.set(Ye,ze),ze+=f2,Ge.set(Ke,ze),ze+=Ke.length}Me(Ge)});re.push(we)}else re.push(pe.data());I!=null&&(ve.group=I),V.push(ve)}const le=await Promise.all(re);return{data:fC(le),specs:V}}function f4(Z,I){const V=new Jx(Z),re={};let ae=0;for(const le of I){const he=f5(le,(ue,pe)=>V.slice(ae+ue,ae+pe));re[le.name]=f7(le,V.slice(ae,ae+he)),ae+=he}return re}function f5(Z,I){const V=F(Z.shape);let re;if("quantization"in Z){const ae=Z.quantization;re=Jz[ae.dtype]}else if(Z.dtype==="string"){let ae=0;for(let le=0;le<V;le++)ae+=f2+new Uint32Array(I(ae,ae+f2))[0];return ae}else re=Jz[Z.dtype];return V*re}async function f6(Z,I){const V=F(Z.shape);let re;if("quantization"in Z){const ae=Z.quantization;re=Jz[ae.dtype]}else if(Z.dtype==="string"){let ae=0;for(let le=0;le<V;le++)ae+=f2+new Uint32Array(await I(ae,ae+f2))[0];return ae}else re=Jz[Z.dtype];return V*re}function f7(Z,I){const V=Z.name,re=Z.dtype,ae=Z.shape,le=F(ae);let he,ue=0;if("quantization"in Z){const pe=Z.quantization;if(pe.dtype==="uint8"||pe.dtype==="uint16"){if(!("min"in pe&&"scale"in pe))throw new Error("Weight "+Z.name+" with quantization "+pe.dtype+" doesn't have corresponding metadata min and scale.")}else if(pe.dtype==="float16"){if(re!=="float32")throw new Error("Weight "+Z.name+" is quantized with "+pe.dtype+" which only supports weights of type float32 not "+re+".")}else throw new Error("Weight "+Z.name+" has unknown quantization dtype "+pe.dtype+". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");const ve=Jz[pe.dtype],we=pe.dtype==="uint8"?new Uint8Array(I):new Uint16Array(I);if(re==="float32")if(pe.dtype==="uint8"||pe.dtype==="uint16"){he=new Float32Array(we.length);for(let Me=0;Me<we.length;Me++){const Le=we[Me];he[Me]=Le*pe.scale+pe.min}}else if(pe.dtype==="float16")he=fD()(we);else throw new Error("Unsupported quantization type "+pe.dtype+" for weight type float32.");else if(re==="int32"){if(pe.dtype!=="uint8"&&pe.dtype!=="uint16")throw new Error("Unsupported quantization type "+pe.dtype+" for weight type int32.");he=new Int32Array(we.length);for(let Me=0;Me<we.length;Me++){const Le=we[Me];he[Me]=Math.round(Le*pe.scale+pe.min)}}else throw new Error("Unsupported dtype in weight '"+V+"': "+re);ue+=le*ve}else if(re==="string"){const pe=F(Z.shape);he=[];for(let ve=0;ve<pe;ve++){const we=new Uint32Array(I.slice(ue,ue+f2))[0];ue+=f2;const Me=new Uint8Array(I.slice(ue,ue+we));he.push(Me),ue+=we}}else{const pe=Jz[re];if(re==="float32")he=new Float32Array(I);else if(re==="int32")he=new Int32Array(I);else if(re==="bool")he=new Uint8Array(I);else if(re==="complex64"){he=new Float32Array(I);const ve=new Float32Array(he.length/2),we=new Float32Array(he.length/2);for(let Ge=0;Ge<ve.length;Ge++)ve[Ge]=he[Ge*2],we[Ge]=he[Ge*2+1];const Me=Jk(ve,ae,"float32"),Le=Jk(we,ae,"float32"),Ue=JL(Me,Le);return Me.dispose(),Le.dispose(),Ue}else throw new Error("Unsupported dtype in weight '"+V+"': "+re);ue+=le*pe}return Jk(he,ae,re)}async function f8(Z,I,V){let re=new Uint8Array(I);for(;re.byteLength<V;){const{done:ae,value:le}=await Z.read();if(ae&&le==null){const ue=V-re.byteLength;throw new Error("Reader is done but "+ue+" bytes are still expected")}const he=new Uint8Array(re.length+le.byteLength);he.set(re,0),he.set(new Uint8Array(le),re.length),re=he}return re.buffer}async function f9(Z,I){const V={},re=Z.getReader();let ae=new ArrayBuffer(0);for(const le of I){const he=await f6(le,async(ve,we)=>(ae=await f8(re,ae,we),ae.slice(ve,we)));ae=await f8(re,ae,he);const ue=ae.slice(0,he);ae=ae.slice(he);const pe=f7(le,ue);if(V[le.name]=pe,Jr()==="webgpu"){const ve=f1();"uploadToGPU"in ve&&F(pe.shape)>=Cd().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&ve.uploadToGPU(pe.dataId)}}return V}function fC(Z){if(Z===null)throw new Error("Invalid input value: "+JSON.stringify(Z));let I=0;const V=[];Z.forEach(le=>{if(I+=le.byteLength,V.push(le.byteLength===le.buffer.byteLength?le:new le.constructor(le)),!(le instanceof Float32Array||le instanceof Int32Array||le instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+le.constructor.name)});const re=new Uint8Array(I);let ae=0;return V.forEach(le=>{re.set(new Uint8Array(le.buffer),ae),ae+=le.byteLength}),re.buffer}const fm=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function fN(Z){return fm?Buffer.byteLength(Z,"utf8"):new Blob([Z]).size}function fJ(Z){if(fm)return Buffer.from(Z).toString("base64");const I=new Uint8Array(Z);let V="";for(let re=0,ae=I.length;re<ae;re++)V+=String.fromCharCode(I[re]);return btoa(V)}function ff(Z){if(fm){const re=Buffer.from(Z,"base64");return re.buffer.slice(re.byteOffset,re.byteOffset+re.byteLength)}const I=atob(Z),V=new Uint8Array(I.length);for(let re=0;re<I.length;++re)V.set([I.charCodeAt(re)],re);return V.buffer}function fi(Z){return Jx.join(Z)}function fO(Z){const I="/";for(Z=Z.trim();Z.endsWith(I);)Z=Z.slice(0,Z.length-1);const V=Z.split(I);return V[V.length-1]}function ft(Z,I){const V={modelTopology:Z.modelTopology,format:Z.format,generatedBy:Z.generatedBy,convertedBy:Z.convertedBy,weightsManifest:I};return Z.signature!=null&&(V.signature=Z.signature),Z.userDefinedMetadata!=null&&(V.userDefinedMetadata=Z.userDefinedMetadata),Z.modelInitializer!=null&&(V.modelInitializer=Z.modelInitializer),Z.initializerSignature!=null&&(V.initializerSignature=Z.initializerSignature),Z.trainingConfig!=null&&(V.trainingConfig=Z.trainingConfig),V}function fB(Z,I,V){const re={modelTopology:Z.modelTopology,format:Z.format,generatedBy:Z.generatedBy,convertedBy:Z.convertedBy};if(Z.trainingConfig!=null&&(re.trainingConfig=Z.trainingConfig),Z.weightsManifest!=null){if(!I)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!V)throw new Error("modelJSON has weightsManifest but weightData is null");re.weightSpecs=I,re.weightData=V}return Z.signature!=null&&(re.signature=Z.signature),Z.userDefinedMetadata!=null&&(re.userDefinedMetadata=Z.userDefinedMetadata),Z.modelInitializer!=null&&(re.modelInitializer=Z.modelInitializer),Z.initializerSignature!=null&&(re.initializerSignature=Z.initializerSignature),re}async function fS(Z,I){let V,re;return Z.weightsManifest!=null&&([V,re]=await I(Z.weightsManifest)),fB(Z,V,re)}function fd(Z){if(Z.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:Z.modelTopology==null?0:fN(JSON.stringify(Z.modelTopology)),weightSpecsBytes:Z.weightSpecs==null?0:fN(JSON.stringify(Z.weightSpecs)),weightDataBytes:Z.weightData==null?0:new Jx(Z.weightData).byteLength}}function fV(Z){const I=[];for(const V of Z)I.push(...V.weights);return I}function fb(){const Z=V=>{let re=V<<13,ae=0;for(;!(re&8388608);)ae-=8388608,re<<=1;return re&=-8388609,ae+=947912704,re|ae},I=new Uint32Array(2048);I[0]=0;for(let V=1;V<1024;V++)I[V]=Z(V);for(let V=1024;V<2048;V++)I[V]=939524096+(V-1024<<13);return I}function fP(){const Z=new Uint32Array(64);Z[0]=0,Z[31]=1199570944,Z[32]=2147483648,Z[63]=3347054592;for(let I=1;I<31;I++)Z[I]=I<<23;for(let I=33;I<63;I++)Z[I]=2147483648+(I-32<<23);return Z}function fE(){const Z=new Uint32Array(64);for(let I=0;I<64;I++)Z[I]=1024;return Z[0]=Z[32]=0,Z}function fD(){const Z=fb(),I=fP(),V=fE();return re=>{const ae=new ArrayBuffer(4*re.length),le=new Uint32Array(ae);for(let he=0;he<re.length;he++){const ue=re[he],pe=Z[V[ue>>10]+(ue&1023)]+I[ue>>10];le[he]=pe}return new Float32Array(ae)}}class fg{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return fg.instance==null&&(fg.instance=new fg),fg.instance}static registerSaveRouter(I){fg.getInstance().saveRouters.push(I)}static registerLoadRouter(I){fg.getInstance().loadRouters.push(I)}static getSaveHandlers(I){return fg.getHandlers(I,"save")}static getLoadHandlers(I,V){return fg.getHandlers(I,"load",V)}static getHandlers(I,V,re){const ae=[];return(V==="load"?fg.getInstance().loadRouters:fg.getInstance().saveRouters).forEach(le=>{const he=le(I,re);he!==null&&ae.push(he)}),ae}}const fZ=Z=>fg.registerSaveRouter(Z),fo=Z=>fg.registerLoadRouter(Z),fe=Z=>fg.getSaveHandlers(Z),fQ=(Z,I)=>fg.getLoadHandlers(Z,I),fs="tensorflowjs",fF=1,fI="models_store",fy="model_info_store";function fA(){if(!Cd().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const Z=typeof window>"u"?self:window,I=Z.indexedDB||Z.mozIndexedDB||Z.webkitIndexedDB||Z.msIndexedDB||Z.shimIndexedDB;if(I==null)throw new Error("The current browser does not appear to support IndexedDB.");return I}function fp(Z){const I=Z.result;I.createObjectStore(fI,{keyPath:"modelPath"}),I.createObjectStore(fy,{keyPath:"modelPath"})}class fw{constructor(I){if(this.indexedDB=fA(),I==null||!I)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=I}async save(I){if(I.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,I)}async load(){return this.databaseAction(this.modelPath)}databaseAction(I,V){return new Promise((re,ae)=>{const le=this.indexedDB.open(fs,fF);le.onupgradeneeded=()=>fp(le),le.onsuccess=()=>{const he=le.result;if(V==null){const ue=he.transaction(fI,"readonly"),pe=ue.objectStore(fI).get(this.modelPath);pe.onsuccess=()=>{if(pe.result==null)return he.close(),ae(new Error("Cannot find model with path '"+this.modelPath+"' in IndexedDB."));re(pe.result.modelArtifacts)},pe.onerror=ve=>(he.close(),ae(pe.error)),ue.oncomplete=()=>he.close()}else{V.weightData=Jx.join(V.weightData);const ue=fd(V),pe=he.transaction(fy,"readwrite");let ve=pe.objectStore(fy),we;try{we=ve.put({modelPath:this.modelPath,modelArtifactsInfo:ue})}catch(Le){return ae(Le)}let Me;we.onsuccess=()=>{Me=he.transaction(fI,"readwrite");const Le=Me.objectStore(fI);let Ue;try{Ue=Le.put({modelPath:this.modelPath,modelArtifacts:V,modelArtifactsInfo:ue})}catch(Ge){return ae(Ge)}Ue.onsuccess=()=>re({modelArtifactsInfo:ue}),Ue.onerror=Ge=>{ve=pe.objectStore(fy);const ze=ve.delete(this.modelPath);ze.onsuccess=()=>(he.close(),ae(Ue.error)),ze.onerror=He=>(he.close(),ae(Ue.error))}},we.onerror=Le=>(he.close(),ae(we.error)),pe.oncomplete=()=>{Me==null?he.close():Me.oncomplete=()=>he.close()}}},le.onerror=he=>ae(le.error)})}}fw.URL_SCHEME="indexeddb://";const fX=Z=>Cd().getBool("IS_BROWSER")&&!Array.isArray(Z)&&Z.startsWith(fw.URL_SCHEME)?fc(Z.slice(fw.URL_SCHEME.length)):null;fg.registerSaveRouter(fX),fg.registerLoadRouter(fX);function fc(Z){return new fw(Z)}function fW(Z){return Z.startsWith(fw.URL_SCHEME)?Z.slice(fw.URL_SCHEME.length):Z}class fR{constructor(){this.indexedDB=fA()}async listModels(){return new Promise((I,V)=>{const re=this.indexedDB.open(fs,fF);re.onupgradeneeded=()=>fp(re),re.onsuccess=()=>{const ae=re.result,le=ae.transaction(fy,"readonly"),he=le.objectStore(fy).getAll();he.onsuccess=()=>{const ue={};for(const pe of he.result)ue[pe.modelPath]=pe.modelArtifactsInfo;I(ue)},he.onerror=ue=>(ae.close(),V(he.error)),le.oncomplete=()=>ae.close()},re.onerror=ae=>V(re.error)})}async removeModel(I){return I=fW(I),new Promise((V,re)=>{const ae=this.indexedDB.open(fs,fF);ae.onupgradeneeded=()=>fp(ae),ae.onsuccess=()=>{const le=ae.result,he=le.transaction(fy,"readwrite"),ue=he.objectStore(fy),pe=ue.get(I);let ve;pe.onsuccess=()=>{if(pe.result==null)return le.close(),re(new Error("Cannot find model with path '"+I+"' in IndexedDB."));{const we=ue.delete(I),Me=()=>{ve=le.transaction(fI,"readwrite");const Le=ve.objectStore(fI).delete(I);Le.onsuccess=()=>V(pe.result.modelArtifactsInfo),Le.onerror=Ue=>re(pe.error)};we.onsuccess=Me,we.onerror=Le=>(Me(),le.close(),re(pe.error))}},pe.onerror=we=>(le.close(),re(pe.error)),he.oncomplete=()=>{ve==null?le.close():ve.oncomplete=()=>le.close()}},ae.onerror=le=>re(ae.error)})}}const fK="/",fT="tensorflowjs_models",fv="info",fq="model_topology",fl="weight_specs",fa="weight_data",fn="model_metadata";function fL(Z){return{info:[fT,Z,fv].join(fK),topology:[fT,Z,fq].join(fK),weightSpecs:[fT,Z,fl].join(fK),weightData:[fT,Z,fa].join(fK),modelMetadata:[fT,Z,fn].join(fK)}}function fH(Z){for(const I of Object.values(Z))window.localStorage.removeItem(I)}function fk(Z){const I=Z.split(fK);if(I.length<3)throw new Error("Invalid key format: "+Z);return I.slice(1,I.length-1).join(fK)}function fz(Z){return Z.startsWith(fx.URL_SCHEME)?Z.slice(fx.URL_SCHEME.length):Z}class fx{constructor(I){if(!Cd().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,I==null||!I)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=I,this.keys=fL(this.modelPath)}async save(I){if(I.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const V=JSON.stringify(I.modelTopology),re=JSON.stringify(I.weightSpecs),ae=fd(I),le=Jx.join(I.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(ae)),this.LS.setItem(this.keys.topology,V),this.LS.setItem(this.keys.weightSpecs,re),this.LS.setItem(this.keys.weightData,fJ(le));const he={format:I.format,generatedBy:I.generatedBy,convertedBy:I.convertedBy,signature:I.signature!=null?I.signature:void 0,userDefinedMetadata:I.userDefinedMetadata!=null?I.userDefinedMetadata:void 0,modelInitializer:I.modelInitializer!=null?I.modelInitializer:void 0,initializerSignature:I.initializerSignature!=null?I.initializerSignature:void 0,trainingConfig:I.trainingConfig!=null?I.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(he)),{modelArtifactsInfo:ae}}catch{throw fH(this.keys),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+ae.modelTopologyBytes+", weightSpecsBytes="+ae.weightSpecsBytes+", weightDataBytes="+ae.weightDataBytes+".")}}}async load(){const I=JSON.parse(this.LS.getItem(this.keys.info));if(I==null)throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if(I.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const V={},re=JSON.parse(this.LS.getItem(this.keys.topology));if(re==null)throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");V.modelTopology=re;const ae=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(ae==null)throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");V.weightSpecs=ae;const le=this.LS.getItem(this.keys.modelMetadata);if(le!=null){const ue=JSON.parse(le);V.format=ue.format,V.generatedBy=ue.generatedBy,V.convertedBy=ue.convertedBy,ue.signature!=null&&(V.signature=ue.signature),ue.userDefinedMetadata!=null&&(V.userDefinedMetadata=ue.userDefinedMetadata),ue.modelInitializer!=null&&(V.modelInitializer=ue.modelInitializer),ue.initializerSignature!=null&&(V.initializerSignature=ue.initializerSignature),ue.trainingConfig!=null&&(V.trainingConfig=ue.trainingConfig)}const he=this.LS.getItem(this.keys.weightData);if(he==null)throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return V.weightData=ff(he),V}}fx.URL_SCHEME="localstorage://";const fU=Z=>Cd().getBool("IS_BROWSER")&&!Array.isArray(Z)&&Z.startsWith(fx.URL_SCHEME)?fG(Z.slice(fx.URL_SCHEME.length)):null;fg.registerSaveRouter(fU),fg.registerLoadRouter(fU);function fG(Z){return new fx(Z)}class fu{constructor(){e(Cd().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),e(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const I={},V=fT+fK,re=fK+fv;for(let ae=0;ae<this.LS.length;++ae){const le=this.LS.key(ae);if(le.startsWith(V)&&le.endsWith(re)){const he=fk(le);I[he]=JSON.parse(this.LS.getItem(le))}}return I}async removeModel(I){I=fz(I);const V=fL(I);if(this.LS.getItem(V.info)==null)throw new Error("Cannot find model at path '"+I+"'");const re=JSON.parse(this.LS.getItem(V.info));return fH(V),re}}const fY="model",fM=".json",fh=".weights.bin";function fj(Z){return new Promise(I=>setTimeout(I)).then(Z)}class fr{constructor(I){if(!Cd().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");I.startsWith(fr.URL_SCHEME)&&(I=I.slice(fr.URL_SCHEME.length)),(I==null||I.length===0)&&(I=fY),this.modelJsonFileName=I+fM,this.weightDataFileName=I+fh}async save(I){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const V=Jx.join(I.weightData),re=window.URL.createObjectURL(new Blob([V],{type:"application/octet-stream"}));if(I.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const ae=[{paths:["./"+this.weightDataFileName],weights:I.weightSpecs}],le=ft(I,ae),he=window.URL.createObjectURL(new Blob([JSON.stringify(le)],{type:"application/json"})),ue=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(ue.download=this.modelJsonFileName,ue.href=he,await fj(()=>ue.dispatchEvent(new MouseEvent("click"))),I.weightData!=null){const pe=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;pe.download=this.weightDataFileName,pe.href=re,await fj(()=>pe.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:fd(I)}}}}fr.URL_SCHEME="downloads://";class i0{constructor(I){if(I==null||I.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+I);this.jsonFile=I[0],this.weightsFiles=I.slice(1)}async load(){return new Promise((I,V)=>{const re=new FileReader;re.onload=ae=>{const le=JSON.parse(ae.target.result),he=le.modelTopology;if(he==null){V(new Error("modelTopology field is missing from file "+this.jsonFile.name));return}if(le.weightsManifest==null){V(new Error("weightManifest field is missing from file "+this.jsonFile.name));return}if(this.weightsFiles.length===0){I({modelTopology:he});return}const ue=fS(le,pe=>this.loadWeights(pe));I(ue)},re.onerror=ae=>V("Failed to read model topology and weights manifest JSON from file '"+this.jsonFile.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only."),re.readAsText(this.jsonFile)})}loadWeights(I){const V=[],re=[];for(const he of I)V.push(...he.weights),re.push(...he.paths);const ae=this.checkManifestAndWeightFiles(I),le=re.map(he=>this.loadWeightsFile(he,ae[he]));return Promise.all(le).then(he=>[V,he])}loadWeightsFile(I,V){return new Promise((re,ae)=>{const le=new FileReader;le.onload=he=>{const ue=he.target.result;re(ue)},le.onerror=he=>ae("Failed to weights data from file of path '"+I+"'."),le.readAsArrayBuffer(V)})}checkManifestAndWeightFiles(I){const V=[],re=this.weightsFiles.map(le=>fO(le.name)),ae={};for(const le of I)le.paths.forEach(he=>{const ue=fO(he);if(V.indexOf(ue)!==-1)throw new Error("Duplicate file basename found in weights manifest: '"+ue+"'");if(V.push(ue),re.indexOf(ue)===-1)throw new Error("Weight file with basename '"+ue+"' is not provided.");ae[he]=this.weightsFiles[re.indexOf(ue)]});if(V.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest ("+V.length+") and the number of weight files provided ("+this.weightsFiles.length+").");return ae}}const i1=Z=>Cd().getBool("IS_BROWSER")&&!Array.isArray(Z)&&Z.startsWith(fr.URL_SCHEME)?i2(Z.slice(fr.URL_SCHEME.length)):null;fg.registerSaveRouter(i1);function i2(Z="model"){return new fr(Z)}function i3(Z){return new i0(Z)}function i4(Z,I,V,re){he(Z),V=V??0,re=re??1,ue(V,re);let ae=0;const le=pe=>(pe.then(ve=>{const we=V+ ++ae/Z.length*(re-V);return I(we),ve}),pe);function he(pe){e(pe!=null&&Array.isArray(pe)&&pe.length>0,()=>"promises must be a none empty array")}function ue(pe,ve){e(pe>=0&&pe<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction "+pe),e(ve>=0&&ve<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction "+ve),e(ve>=pe,()=>"startFraction must be no more than endFraction, but got startFraction "+pe+" and endFraction "+ve)}return Promise.all(Z.map(le))}async function i5(Z,I){I==null&&(I={});const V=I.fetchFunc==null?Cd().platform.fetch:I.fetchFunc,re=Z.map(ve=>V(ve,I.requestInit,{isBinary:!0})),ae=0,le=.5,he=(I.onProgress==null?await Promise.all(re):await i4(re,I.onProgress,ae,le)).map(ve=>ve.arrayBuffer()),ue=.5,pe=1;return I.onProgress==null?await Promise.all(he):await i4(he,I.onProgress,ue,pe)}function i6(Z,I){var V;const re=I.fetchFunc==null?Cd().platform.fetch:I.fetchFunc;let ae=0,le;return(V=I.onProgress)===null||V===void 0||V.call(I,0),new ReadableStream({pull:async he=>{for(var ue;ae<Z.length;){le||(le=(await re(Z[ae],I.requestInit,{isBinary:!0})).body.getReader());const{done:pe,value:ve}=await le.read();if(pe){ae++,le=void 0,(ue=I.onProgress)===null||ue===void 0||ue.call(I,ae/Z.length);continue}he.enqueue(ve);return}he.close()}})}async function i7(Z,I="",V,re){return i8(ae=>i5(ae,{requestInit:re}))(Z,I,V)}function i8(Z){return async(I,V="",re)=>{const ae=I.map(()=>!1),le={},he=re!=null?re.map(()=>!1):[],ue=[];if(I.forEach((Ue,Ge)=>{let ze=0;Ue.weights.forEach(He=>{const Ke="quantization"in He?He.quantization.dtype:He.dtype,Ye=Jz[Ke]*F(He.shape),$e=()=>{ae[Ge]=!0,le[Ge]==null&&(le[Ge]=[]),le[Ge].push({manifestEntry:He,groupOffset:ze,sizeBytes:Ye})};re!=null?re.forEach((je,rt)=>{je===He.name&&($e(),he[rt]=!0)}):$e(),ue.push(He.name),ze+=Ye})}),!he.every(Ue=>Ue)){const Ue=re.filter((Ge,ze)=>!he[ze]);throw new Error("Could not find weights in manifest with names: "+Ue.join(", ")+`. 
Manifest JSON has weights with names: `+ue.join(", ")+".")}const pe=ae.reduce((Ue,Ge,ze)=>(Ge&&Ue.push(ze),Ue),[]),ve=[];pe.forEach(Ue=>{I[Ue].paths.forEach(Ge=>{const ze=V+(V.endsWith("/")?"":"/")+Ge;ve.push(ze)})});const we=await Z(ve),Me={};let Le=0;return pe.forEach(Ue=>{const Ge=I[Ue].paths.length,ze=new Jx(we.slice(Le,Le+Ge));le[Ue].forEach(He=>{const Ke=ze.slice(He.groupOffset,He.groupOffset+He.sizeBytes),Ye=f4(Ke,[He.manifestEntry]);for(const $e in Ye)Me[$e]=Ye[$e]}),Le+=Ge}),Me}}const i9="application/octet-stream",iC="application/json";class im{constructor(I,V){if(this.DEFAULT_METHOD="POST",V==null&&(V={}),this.weightPathPrefix=V.weightPathPrefix,this.weightUrlConverter=V.weightUrlConverter,V.fetchFunc!=null?(e(typeof V.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=V.fetchFunc):this.fetch=Cd().platform.fetch,e(I!=null&&I.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(I)&&e(I.length===2,()=>"URL paths for http must have a length of 2, (actual length is "+I.length+")."),this.path=I,V.requestInit!=null&&V.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=V.requestInit||{},this.loadOptions=V}async save(I){if(I.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const V=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);V.body=new FormData;const re=[{paths:["./model.weights.bin"],weights:I.weightSpecs}],ae=ft(I,re);if(V.body.append("model.json",new Blob([JSON.stringify(ae)],{type:iC}),"model.json"),I.weightData!=null){const he=Jx.join(I.weightData);V.body.append("model.weights.bin",new Blob([he],{type:i9}),"model.weights.bin")}const le=await this.fetch(this.path,V);if(le.ok)return{modelArtifactsInfo:fd(I),responses:[le]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+le.status+".")}async loadModelJSON(){const I=await this.fetch(this.path,this.requestInit);if(!I.ok)throw new Error("Request to "+this.path+" failed with status code "+I.status+". Please verify this URL points to the model JSON of the model to load.");let V;try{V=await I.json()}catch{let he="Failed to parse model JSON of response from "+this.path+".";throw this.path.endsWith(".pb")?he+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":he+=" Please make sure the server is serving valid JSON for this request.",new Error(he)}const re=V.modelTopology,ae=V.weightsManifest;if(re==null&&ae==null)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return V}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const I=await this.loadModelJSON();return fS(I,V=>this.loadWeights(V))}async loadStream(){const I=await this.loadModelJSON(),V=await this.getWeightUrls(I.weightsManifest),re=fV(I.weightsManifest),ae=()=>i6(V,this.loadOptions);return Object.assign(Object.assign({},I),{weightSpecs:re,getWeightStream:ae})}async getWeightUrls(I){const V=Array.isArray(this.path)?this.path[1]:this.path,[re,ae]=iN(V),le=this.weightPathPrefix||re,he=[],ue=[];for(const pe of I)for(const ve of pe.paths)this.weightUrlConverter!=null?ue.push(this.weightUrlConverter(ve)):he.push(le+ve+ae);return this.weightUrlConverter&&he.push(...await Promise.all(ue)),he}async loadWeights(I){const V=await this.getWeightUrls(I),re=fV(I),ae=await i5(V,this.loadOptions);return[re,ae]}}im.URL_SCHEME_REGEX=/^https?:\/\//;function iN(Z){const I=Z.lastIndexOf("/"),V=Z.lastIndexOf("?"),re=Z.substring(0,I),ae=V>I?Z.substring(V):"";return[re+"/",ae]}function iJ(Z){return Z.match(im.URL_SCHEME_REGEX)!=null}const ii=(Z,I)=>{if(typeof fetch>"u"&&(I==null||I.fetchFunc==null))return null;{let V=!0;if(Array.isArray(Z)?V=Z.every(re=>iJ(re)):V=iJ(Z),V)return iO(Z,I)}return null};fg.registerSaveRouter(ii),fg.registerLoadRouter(ii);function iO(Z,I){return new im(Z,I)}function it(Z,I){return iO(Z,I)}class iB{constructor(I){this.modelArtifacts=I}load(){return this.modelArtifacts}}class iS{constructor(I){this.saveHandler=I}save(I){return this.saveHandler(I)}}class id{constructor(I){I.load&&(this.load=()=>Promise.resolve(I.load())),I.save&&(this.save=V=>Promise.resolve(I.save(V)))}}function iV(Z,I,V,re){const ae=arguments;return new id(ib(...ae))}function ib(Z,I,V,re){return arguments.length===1?Z.modelTopology!=null||Z.weightSpecs!=null?new iB(Z):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new iB({modelTopology:Z})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new iB({modelTopology:Z,weightSpecs:I,weightData:V,trainingConfig:re}))}function iP(Z){return new iS(Z)}function iE(Z){return new iS(Z)}const iD="://";class ig{constructor(){this.managers={}}static getInstance(){return ig.instance==null&&(ig.instance=new ig),ig.instance}static registerManager(I,V){e(I!=null,()=>"scheme must not be undefined or null."),I.endsWith(iD)&&(I=I.slice(0,I.indexOf(iD))),e(I.length>0,()=>"scheme must not be an empty string.");const re=ig.getInstance();e(re.managers[I]==null,()=>"A model store manager is already registered for scheme '"+I+"'."),re.managers[I]=V}static getManager(I){const V=ig.getInstance().managers[I];if(V==null)throw new Error("Cannot find model manager for scheme '"+I+"'");return V}static getSchemes(){return Object.keys(ig.getInstance().managers)}}function iZ(Z){if(Z.indexOf(iD)===-1)throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+ig.getSchemes().join(","));return{scheme:Z.split(iD)[0],path:Z.split(iD)[1]}}async function ie(Z,I,V=!1){e(Z!==I,()=>"Old path and new path are the same: '"+Z+"'");const re=fg.getLoadHandlers(Z);e(re.length>0,()=>"Copying failed because no load handler is found for source URL "+Z+"."),e(re.length<2,()=>"Copying failed because more than one ("+re.length+") load handlers for source URL "+Z+".");const ae=re[0],le=fg.getSaveHandlers(I);e(le.length>0,()=>"Copying failed because no save handler is found for destination URL "+I+"."),e(le.length<2,()=>"Copying failed because more than one ("+re.length+") save handlers for destination URL "+I+".");const he=le[0],ue=iZ(Z).scheme,pe=iZ(Z).path,ve=ue===iZ(Z).scheme,we=await ae.load();V&&ve&&await ig.getManager(ue).removeModel(pe);const Me=await he.save(we);return V&&!ve&&await ig.getManager(ue).removeModel(pe),Me.modelArtifactsInfo}async function iQ(){const Z=ig.getSchemes(),I={};for(const V of Z){const re=await ig.getManager(V).listModels();for(const ae in re){const le=V+iD+ae;I[le]=re[ae]}}return I}async function is(Z){const I=iZ(Z);return ig.getManager(I.scheme).removeModel(I.path)}async function iF(Z,I){return ie(Z,I,!1)}async function iI(Z,I){return ie(Z,I,!0)}var iy=Object.freeze({__proto__:null,CompositeArrayBuffer:Jx,browserFiles:i3,browserHTTPRequest:it,concatenateArrayBuffers:fi,copyModel:iF,decodeWeights:f4,decodeWeightsStream:f9,encodeWeights:f3,fromMemory:iV,fromMemorySync:ib,getLoadHandlers:fQ,getModelArtifactsForJSON:fS,getModelArtifactsForJSONSync:fB,getModelArtifactsInfoForJSON:fd,getSaveHandlers:fe,getWeightSpecs:fV,http:iO,isHTTPScheme:iJ,listModels:iQ,loadWeights:i7,moveModel:iI,registerLoadRouter:fo,registerSaveRouter:fZ,removeModel:is,weightsLoaderFactory:i8,withSaveHandler:iP,withSaveHandlerSync:iE});function iA(Z,I){const V=Jv(Z,"x","cast");if(!G(I))throw new Error("Failed to cast to unknown dtype "+I);if(I==="string"&&V.dtype!=="string"||I!=="string"&&V.dtype==="string")throw new Error("Only strings can be casted to strings");const re={x:V},ae={dtype:I};return JA.runKernel(CA,re,ae)}const ip=Ja({cast_:iA});function iw(Z,I,V=!1,re=!1){let ae=Jv(Z,"a","matMul"),le=Jv(I,"b","matMul");[ae,le]=Jg(ae,le);const he={a:ae,b:le},ue={transposeA:V,transposeB:re};return JA.runKernel(CF,he,ue)}const iX=Ja({matMul_:iw});function ic(Z){const I={input:Jv(Z,"input","imag")};return JA.runKernel(Cr,I)}const iW=Ja({imag_:ic});function iR(Z){const I={x:Jv(Z,"x","neg")};return JA.runKernel(mN,I)}const iK=Ja({neg_:iR});function iT(Z){const I={input:Jv(Z,"input","real")};return JA.runKernel(mV,I)}const iv=Ja({real_:iT});function iq(Z,I,V){const re=Jv(Z,"x","transpose");if(I==null&&(I=re.shape.map((he,ue)=>ue).reverse()),e(re.rank===I.length,()=>"Error in transpose: rank of input "+re.rank+" must match length of perm "+I+"."),I.forEach(he=>{e(he>=0&&he<re.rank,()=>"All entries in 'perm' must be between 0 and "+(re.rank-1)+" but got "+I)}),re.rank<=1)return re.clone();const ae={x:re},le={perm:I};return re.dtype==="complex64"?JY(()=>{let he=iv(re),ue=iW(re);return he=JA.runKernel(mK,{x:he},le),ue=JA.runKernel(mK,{x:ue},le),V&&(ue=iK(ue)),JL(he,ue)}):JA.runKernel(mK,ae,le)}const il=Ja({transpose_:iq});function ia(Z,I){const V=Z.length,re=[];for(let ae=0;ae<V;ae++){const le=V-1-ae,he=Z[le]||1;(I[I.length-1-ae]||1)>1&&he===1&&re.unshift(le)}return re}function iL(Z,I){const V=[];for(let re=0;re<I.length;re++){const ae=Z[Z.length-re-1],le=I.length-re-1,he=I[le];(ae==null||ae===1&&he>1)&&V.unshift(le)}return V}function iH(Z,I){const V=Math.max(Z.length,I.length),re=new Array(V);for(let ae=0;ae<V;ae++){let le=Z[Z.length-ae-1];le==null&&(le=1);let he=I[I.length-ae-1];if(he==null&&(he=1),le===1)re[V-ae-1]=he;else if(he===1)re[V-ae-1]=le;else if(le!==he){const ue="Operands could not be broadcast together with shapes "+Z+" and "+I+".";throw Error(ue)}else re[V-ae-1]=le}return re}function ik(Z,I,V){if(s(Z),I!=null&&I.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const re=JR(Z,V);if(re.length!==3&&re.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(re.length===1&&I==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return JH(Z,I,re,V)}let iz;function ix(Z,I=3){if(I>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(Z==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let V=!1,re=!1,ae=!1,le=!1,he=!1,ue=!1;if(Z.data instanceof Uint8Array)V=!0;else if(typeof ImageData<"u"&&Z instanceof ImageData)re=!0;else if(typeof HTMLVideoElement<"u"&&Z instanceof HTMLVideoElement)ae=!0;else if(typeof HTMLImageElement<"u"&&Z instanceof HTMLImageElement)le=!0;else if(Z.getContext!=null)he=!0;else if(typeof ImageBitmap<"u"&&Z instanceof ImageBitmap)ue=!0;else throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+Z.constructor.name);if(mG(ml,JA.backendName)!=null){const Le={pixels:Z},Ue={numChannels:I};return JA.runKernel(ml,Le,Ue)}const[pe,ve]=ae?[Z.videoWidth,Z.videoHeight]:[Z.width,Z.height];let we;if(he)we=Z.getContext("2d").getImageData(0,0,pe,ve).data;else if(re||V)we=Z.data;else if(le||ae||ue){if(iz==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")iz=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else iz=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});iz.canvas.width=pe,iz.canvas.height=ve,iz.drawImage(Z,0,0,pe,ve),we=iz.getImageData(0,0,pe,ve).data}let Me;if(I===4)Me=new Int32Array(we);else{const Le=pe*ve;Me=new Int32Array(Le*I);for(let Ue=0;Ue<Le;Ue++)for(let Ge=0;Ge<I;++Ge)Me[Ue*I+Ge]=we[Ue*4+Ge]}return ik(Me,[ve,pe,I],"int32")}const iU=Ja({fromPixels_:ix});function iG(Z,I){const V=Z.shape.length,re=I.shape.length;if(V<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+V+".");if(re<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+re+".");if(I.dtype!=="int32")throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+I.dtype+".");if(I.shape[re-1]>V)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+I.shape[re-1]+" vs. "+V);if(F(Z.shape)===0)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+Z.shape+".");const ae=I.shape,le=ae[ae.length-1];let he=1;for(let Me=0;Me<ae.length-1;++Me)he*=ae[Me];const ue=Z.shape,pe=ae.slice();pe.pop();let ve=1;for(let Me=le;Me<V;++Me)ve*=ue[Me],pe.push(ue[Me]);const we=[...C5(Z.shape).map(Me=>Me/ve),1].slice(0,le);return[pe,he,ve,we]}function iu(Z,I,V){const re=I.rank>1?I.shape[I.rank-1]:1,ae=I.rank>1?I.rank-1:1,le="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+V.shape+", indices.shape: "+I.shape+", shape: "+Z+", sliceDim: "+re+", and batchDim: "+ae+".";if(V.rank<ae)throw new Error(le+(" update.rank < "+ae+". "));if(Z.length<re+(V.rank-ae))throw new Error(le+(" Output shape length < "+(re+(V.rank-ae))));if(V.rank!==ae+Z.length-re)throw new Error(le+(" update.rank != "+(ae+Z.length-re)));for(let he=0;he<ae;++he)if(V.shape[he]!==I.shape[he])throw new Error(le+(" updates.shape["+he+"] ("+V.shape[he]+") != indices.shape["+he+"] ("+I.shape[he]+")."));for(let he=0;he<V.rank-ae;++he)if(V.shape[he+ae]!==Z[he+re])throw new Error(le+(" updates.shape["+(he+ae)+"] ("+V.shape[he+ae]+") != shape["+(he+ae)+"] ("+Z[he+ae]+")"))}function iY(Z,I,V){if(I.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+I.rank+".");if(Z.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+Z.rank+".");if(I.dtype!=="int32")throw new Error("The dtype of 'indices' should be int32, but got dtype: "+I.dtype);if(V.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+V);if(V.length===0){if(I.size===0)throw new Error("Indices specified for empty output. indices shape: "+I.shape);if(Z.size===0)throw new Error("Updates specified for empty output. updates shape: "+Z.shape)}iu(V,I,Z)}function iM(Z,I,V){const re=I.shape.length,ae=re>1?I.shape[re-1]:1,le=V.length;let he=1;for(let Me=ae;Me<le;++Me)he*=V[Me];const ue=ae<1?1:ae,pe=F(I.shape)/ue,ve=[...C5(V.slice(0,ae)),1],we=F(V);return{sliceRank:ae,numUpdates:pe,sliceSize:he,strides:ve,outputSize:we}}const ih=-2,ij=-1;function ir(Z,I,V){const re=Z.shape.length;e(re===I.length,()=>"Error in slice"+re+"D: Length of begin "+I+" must match the rank of the array ("+re+")."),e(re===V.length,()=>"Error in slice"+re+"D: Length of size "+V+" must match the rank of the array ("+re+").");for(let ae=0;ae<re;++ae)e(I[ae]+V[ae]<=Z.shape[ae],()=>"Error in slice"+re+"D: begin["+ae+"] + size["+ae+"] ("+(I[ae]+V[ae])+") would overflow input.shape["+ae+"] ("+Z.shape[ae]+")")}function O0(Z){const I=[];let V=0;for(;Z>0;)Z&1&&I.push(V),Z/=2,V++;return I}function O1(Z,I,V){const re=[];for(let ae=0;ae<Z.length;ae++)re[ae]=Math.ceil((I[ae]-Z[ae])/V[ae]);return re}function O2(Z,I,V,re){const ae=[...Z];for(let le=ae.length;le<re.length;le++)ae.push(1);for(let le=0;le<V;le++)le===0?ae[I]=1:(ae.splice(I,0,1),ae.pop());return ae}function O3(Z,I,V){return V<=Z?V:V-(I-1)}function O4(Z,I){const V=[];for(let re=0;re<Z;re++)V.push(I+re);return V}function O5(Z,I,V,re,ae,le,he,ue,pe){const ve=Z.length;let we=new Array(ve),Me=new Array(ve),Le=new Array(ve);if(I.length&&V>0){const Ue=I[0],Ge=V+1;we=O6(he,Ue,Ge,re,Z),Me=O7(ue,Ue,Ge,ae,Z),Le=O2(le,Ue,Ge,Z)}else for(let Ue=0;Ue<ve;Ue++)we[Ue]=O9(he,re,le,Z,Ue,pe),Me[Ue]=OC(ue,ae,le,Z,Ue,pe),Le[Ue]=O8(le,Ue,pe);return{begin:we,end:Me,strides:Le}}function O6(Z,I,V,re,ae){const le=[...ae],he=O4(V,I);for(let ue=0;ue<le.length;ue++)if(he.indexOf(ue)>-1)le[ue]=0;else{const pe=O3(I,V,ue);let ve=re[pe];Z&1<<pe&&(ve=0),le[ue]=ve}return le}function O7(Z,I,V,re,ae){const le=[...ae],he=O4(V,I);for(let ue=0;ue<le.length;ue++)if(he.indexOf(ue)>-1)le[ue]=Number.MAX_SAFE_INTEGER;else{const pe=O3(I,V,ue);let ve=re[pe];Z&1<<pe&&(ve=Number.MAX_SAFE_INTEGER),le[ue]=ve}for(let ue=0;ue<le.length;ue++){const pe=ae[ue];le[ue]<0&&(le[ue]+=pe),le[ue]=t(0,le[ue],ae[ue])}return le}function O8(Z,I,V){let re=Z[I];return(V&1<<I||re==null)&&(re=1),re}function O9(Z,I,V,re,ae,le){let he=I[ae];const ue=V[ae]||1;(Z&1<<ae||le&1<<ae||he==null)&&(ue>0?he=Number.MIN_SAFE_INTEGER:he=Number.MAX_SAFE_INTEGER);const pe=re[ae];return he<0&&(he+=pe),he=t(0,he,pe-1),he}function OC(Z,I,V,re,ae,le){let he=I[ae];const ue=V[ae]||1;(Z&1<<ae||le&1<<ae||he==null)&&(ue>0?he=Number.MAX_SAFE_INTEGER:he=Number.MIN_SAFE_INTEGER);const pe=re[ae];return he<0&&(he+=pe),ue>0?he=t(0,he,pe):he=t(-1,he,pe-1),he}function Om(Z,I,V){let re=V.length;for(let ae=0;ae<V.length;ae++)if(V[ae]>1){re=ae;break}for(let ae=re+1;ae<V.length;ae++)if(I[ae]>0||V[ae]!==Z[ae])return!1;return!0}function ON(Z,I){let V=Z.length>0?Z[Z.length-1]:1;for(let re=0;re<Z.length-1;re++)V+=Z[re]*I[re];return V}function OJ(Z,I,V){let re;const ae=Z.shape.length;typeof I=="number"?re=[I,...new Array(ae-1).fill(0)]:I.length<ae?re=I.concat(new Array(ae-I.length).fill(0)):re=I.slice(),re.forEach(he=>{e(he!==-1,()=>"slice() does not support negative begin indexing.")});let le;return V==null?le=new Array(ae).fill(-1):typeof V=="number"?le=[V,...new Array(ae-1).fill(-1)]:V.length<ae?le=V.concat(new Array(ae-V.length).fill(-1)):le=V,le=le.map((he,ue)=>he>=0?he:(e(he===-1,()=>"Negative size values should be exactly -1 but got "+he+" for the slice() size at index "+ue+"."),Z.shape[ue]-re[ue])),[re,le]}function Of(Z,I,V,re,ae,le,he,ue,pe){let ve;if(re==null?(ve=new Array(I.length),ve.fill(1)):ve=re,he!=null&&he&he-1)throw new Error("Multiple ellipses in slice is not allowed.");let we=!1;const Me={dims:ve.length,numAddAxisAfterEllipsis:0,begin:I.slice(),end:V.slice(),strides:ve.slice(),beginMask:ae,endMask:le,ellipsisMask:he,newAxisMask:ue,shrinkAxisMask:pe};for(let Ye=0;Ye<Me.dims;Ye++)we&&1<<Ye&ue&&Me.numAddAxisAfterEllipsis++,1<<Ye&he&&(we=!0);we||(Me.ellipsisMask|=1<<Me.dims,Me.dims++);const Le={dims:Z.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Oi(Me,Le);let Ue=!0,Ge=!0,ze=!0;const He=[],Ke=[];for(let Ye=0;Ye<Z.length;++Ye){if(Le.strides[Ye]===0)throw Error("strides["+Ye+"] must be non-zero");const $e=!!(Le.shrinkAxisMask&1<<Ye),je=Z[Ye];if(je===-1){He.push($e?1:-1);continue}const rt=[Le.beginMask&1<<Ye,Le.endMask&1<<Ye],at=[Le.strides[Ye]>0?0:-1,Le.strides[Ye]>0?je:je-1];if($e&&Le.strides[Ye]<=0)throw Error("only stride 1 allowed on non-range indexing.");ze=ze&&Le.strides[Ye]===1;const Rt=!!(Le.beginMask&1<<Ye&&Le.endMask&1<<Ye);if(Le.beginValid&&Le.endValid){if($e){const Kt=Le.begin[Ye]<0?je+Le.begin[Ye]:Le.begin[Ye];if(Le.begin[Ye]=Kt,Le.end[Ye]=Le.begin[Ye]+1,Kt<0||Kt>=je)throw Error("slice index "+Le.begin[Ye]+" of dimension "+Ye+" out of bounds.")}else Le.begin[Ye]=OO(Le.begin[Ye],0,Le.strides[Ye],je,rt,at),Le.end[Ye]=OO(Le.end[Ye],1,Le.strides[Ye],je,rt,at);const qt=Le.strides[Ye]===1&&Le.begin[Ye]===0&&Le.end[Ye]===je;Ue=Ue&&qt,Ge=Ge&&(Ye===0&&Le.strides[Ye]===1||qt)}else Ue=Ue&&Le.strides[Ye]===1&&Rt,Ge=Ge&&(Ye===0&&Le.strides[Ye]===1||Rt);let lt,kt=!1;if(Le.beginValid&&Le.endValid?(lt=Le.end[Ye]-Le.begin[Ye],kt=!0):$e?(lt=1,kt=!0):Rt&&je>=0&&(Le.strides[Ye]<0?lt=-je:lt=je,kt=!0),kt){let qt;lt===0||lt<0!=Le.strides[Ye]<0?qt=0:qt=Math.trunc(lt/Le.strides[Ye])+(lt%Le.strides[Ye]!==0?1:0),He.push(qt)}else He.push(-1)}for(let Ye=0;Ye<Le.finalShapeGatherIndices.length;++Ye){const $e=Le.finalShapeGatherIndices[Ye];$e>=0?Ke.push(He[$e]):$e===ih&&Ke.push(1)}return{finalShapeSparse:Ke.filter((Ye,$e)=>Le.finalShapeGatherIndices[$e]!==ih),finalShape:Ke,isIdentity:Ue,sliceDim0:Ge,isSimpleSlice:ze,begin:Le.begin,end:Le.end,strides:Le.strides}}function Oi(Z,I){I.beginMask=0,I.endMask=0,I.shrinkAxisMask=0;let V=0;I.beginValid=Z.begin!=null,I.endValid=Z.end!=null,I.begin=new Array(I.dims),I.end=new Array(I.dims),I.strides=new Array(I.dims),I.finalShapeGatherIndices=[],I.finalShapeGatherIndicesSparse=[],I.inputShapeGatherIndicesSparse=new Array(I.dims);for(let re=0;re<Z.dims;re++)if(1<<re&Z.ellipsisMask){const ae=Math.min(I.dims-(Z.dims-re)+1+Z.numAddAxisAfterEllipsis,I.dims);for(;V<ae;V++)I.begin[V]=0,I.end[V]=0,I.strides[V]=1,I.beginMask|=1<<V,I.endMask|=1<<V,I.finalShapeGatherIndices.push(V),I.finalShapeGatherIndicesSparse.push(-1),I.inputShapeGatherIndicesSparse[V]=re}else if(1<<re&Z.newAxisMask)I.finalShapeGatherIndices.push(ih),I.finalShapeGatherIndicesSparse.push(-1);else{if(V===I.begin.length)throw Error("Index out of range using input dim "+V+"; input has only "+I.dims+" dims, "+I.begin.length+".");Z.begin!=null&&(I.begin[V]=Z.begin[re]),Z.end!=null&&(I.end[V]=Z.end[re]),I.strides[V]=Z.strides[re],Z.beginMask&1<<re&&(I.beginMask|=1<<V),Z.endMask&1<<re&&(I.endMask|=1<<V),Z.shrinkAxisMask&1<<re?(I.finalShapeGatherIndices.push(ij),I.finalShapeGatherIndicesSparse.push(-1),I.shrinkAxisMask|=1<<V):(I.finalShapeGatherIndices.push(V),I.finalShapeGatherIndicesSparse.push(re)),I.inputShapeGatherIndicesSparse[V]=re,V++}}function OO(Z,I,V,re,ae,le){if(ae[I])return V>0?le[I]:le[I+1&1];{const he=Z<0?re+Z:Z;return he<le[0]?le[0]:he>le[1]?le[1]:he}}var Ot=Object.freeze({__proto__:null,assertParamsValid:ir,computeFlatOffset:ON,computeOutShape:O1,getNormalizedAxes:O5,isSliceContinous:Om,maskToAxes:O0,parseSliceParams:OJ,sliceInfo:Of,startForAxis:O9,startIndicesWithElidedDims:O6,stopForAxis:OC,stopIndicesWithElidedDims:O7,stridesForAxis:O8,stridesWithElidedDims:O2});function OB(Z,I){let V=Jv(Z,"a","add"),re=Jv(I,"b","add");[V,re]=Jg(V,re);const ae={a:V,b:re};return JA.runKernel(Co,ae)}const OS=Ja({add_:OB});function Od(Z,I){let V=Jv(Z,"a","floorDiv"),re=Jv(I,"b","floorDiv");[V,re]=Jg(V,re);const ae={a:V,b:re};return JA.runKernel(Cu,ae)}const OV=Ja({floorDiv_:Od});function Ob(Z,I){let V=Jv(Z,"a","div"),re=Jv(I,"b","div");if([V,re]=Jg(V,re),V.dtype==="int32"&&re.dtype==="int32")return OV(V,re);const ae={a:V,b:re},le={};return JA.runKernel(CL,ae,le)}const OP=Ja({div_:Ob});function OE(Z,I){let V=Jv(Z,"a","mul"),re=Jv(I,"b","mul");[V,re]=Jg(V,re);const ae={a:V,b:re};return JA.runKernel(mm,ae)}const OD=Ja({mul_:OE});function Og(Z){const I=Jv(Z,"x","abs");if(I.dtype==="complex64"){const V={x:I};return JA.runKernel(CX,V)}else{const V={x:I};return JA.runKernel(CZ,V)}}const OZ=Ja({abs_:Og});function Oo(Z){e(Array.isArray(Z),()=>"The argument passed to tf.addN() must be a list of tensors"),e(Z.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+Z.length);const I=Z.map((ae,le)=>Jv(ae,"tensors"+le,"addN")),V=I[0];I.forEach(ae=>{if(ae.dtype!==V.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),I.forEach(ae=>{if(!X(ae.shape,V.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const re=I;return JA.runKernel(Ce,re)}const Oe=Ja({addN_:Oo});function OQ(Z,I){let V=Jv(Z,"a","atan2"),re=Jv(I,"b","atan2");[V,re]=Jg(V,re);const ae={a:V,b:re};return JA.runKernel(CQ,ae)}const Os=Ja({atan2_:OQ});function OF(Z,I,V,re,ae="NHWC",le){const he=Z[3],ue=[...I,he],pe=OL(ae);return OA(Z,ue,V,le,re,null,null,pe)}function OI(Z,I,V,re,ae,le,he="channelsLast"){const[ue,pe]=OW(I);let ve;if(he==="channelsLast")ve=[ue,pe,Z[3],Z[3]];else if(he==="channelsFirst")ve=[ue,pe,Z[1],Z[1]];else throw new Error("Unknown dataFormat "+he);return OA(Z,ve,V,re,ae,le,!1,he)}function Oy(Z,I,V,re,ae,le,he="NDHWC"){const[ue,pe,ve]=OR(I);let we,Me;if(he==="NDHWC")Me="channelsLast",we=[ue,pe,ve,Z[4],Z[4]];else if(he==="NCDHW")Me="channelsFirst",we=[ue,pe,ve,Z[1],Z[1]];else throw new Error("Unknown dataFormat "+he);return Op(Z,we,V,re,ae,!1,Me,le)}function OA(Z,I,V,re,ae,le,he=!1,ue="channelsLast"){let[pe,ve,we,Me]=[-1,-1,-1,-1];if(ue==="channelsLast")[pe,ve,we,Me]=Z;else if(ue==="channelsFirst")[pe,Me,ve,we]=Z;else throw new Error("Unknown dataFormat "+ue);const[Le,Ue,,Ge]=I,[ze,He]=OW(V),[Ke,Ye]=OW(re),$e=OK(Le,Ke),je=OK(Ue,Ye),{padInfo:rt,outHeight:at,outWidth:Rt}=OT(ae,ve,we,ze,He,$e,je,le,ue),lt=he?Ge*Me:Ge;let kt;return ue==="channelsFirst"?kt=[pe,lt,at,Rt]:ue==="channelsLast"&&(kt=[pe,at,Rt,lt]),{batchSize:pe,dataFormat:ue,inHeight:ve,inWidth:we,inChannels:Me,outHeight:at,outWidth:Rt,outChannels:lt,padInfo:rt,strideHeight:ze,strideWidth:He,filterHeight:Le,filterWidth:Ue,effectiveFilterHeight:$e,effectiveFilterWidth:je,dilationHeight:Ke,dilationWidth:Ye,inShape:Z,outShape:kt,filterShape:I}}function Op(Z,I,V,re,ae,le=!1,he="channelsLast",ue){let[pe,ve,we,Me,Le]=[-1,-1,-1,-1,-1];if(he==="channelsLast")[pe,ve,we,Me,Le]=Z;else if(he==="channelsFirst")[pe,Le,ve,we,Me]=Z;else throw new Error("Unknown dataFormat "+he);const[Ue,Ge,ze,,He]=I,[Ke,Ye,$e]=OR(V),[je,rt,at]=OR(re),Rt=OK(Ue,je),lt=OK(Ge,rt),kt=OK(ze,at),{padInfo:qt,outDepth:Kt,outHeight:_i,outWidth:ci}=Ov(ae,ve,we,Me,Ke,Ye,$e,Rt,lt,kt,ue),li=le?He*Le:He;let qi;return he==="channelsFirst"?qi=[pe,li,Kt,_i,ci]:he==="channelsLast"&&(qi=[pe,Kt,_i,ci,li]),{batchSize:pe,dataFormat:he,inDepth:ve,inHeight:we,inWidth:Me,inChannels:Le,outDepth:Kt,outHeight:_i,outWidth:ci,outChannels:li,padInfo:qt,strideDepth:Ke,strideHeight:Ye,strideWidth:$e,filterDepth:Ue,filterHeight:Ge,filterWidth:ze,effectiveFilterDepth:Rt,effectiveFilterHeight:lt,effectiveFilterWidth:kt,dilationDepth:je,dilationHeight:rt,dilationWidth:at,inShape:Z,outShape:qi,filterShape:I}}function Ow(Z,I,V,re,ae){re==null&&(re=Oc(Z,I,V));const le=Z[0],he=Z[1],ue=Oq((le-I+2*re)/V+1,ae),pe=Oq((he-I+2*re)/V+1,ae);return[ue,pe]}function OX(Z,I,V,re,ae,le){ae==null&&(ae=Oc(Z,I[0],re[0]));const he=[0,0,0,V];for(let ue=0;ue<3;ue++)Z[ue]+2*ae>=I[ue]&&(he[ue]=Oq((Z[ue]-I[ue]+2*ae)/re[ue]+1,le));return he}function Oc(Z,I,V,re=1){const ae=OK(I,re);return Math.floor((Z[0]*(V-1)-V+ae)/2)}function OW(Z){return typeof Z=="number"?[Z,Z,Z]:Z.length===2?[Z[0],Z[1],1]:Z}function OR(Z){return typeof Z=="number"?[Z,Z,Z]:Z}function OK(Z,I){return I<=1?Z:Z+(Z-1)*(I-1)}function OT(Z,I,V,re,ae,le,he,ue,pe){let ve,we,Me;if(typeof Z=="number"){ve={top:Z,bottom:Z,left:Z,right:Z,type:Z===0?"VALID":"NUMBER"};const Le=Ow([I,V],le,re,Z,ue);we=Le[0],Me=Le[1]}else if(Z==="same"){we=Math.ceil(I/re),Me=Math.ceil(V/ae);const Le=Math.max(0,(we-1)*re+le-I),Ue=Math.max(0,(Me-1)*ae+he-V),Ge=Math.floor(Le/2),ze=Le-Ge,He=Math.floor(Ue/2),Ke=Ue-He;ve={top:Ge,bottom:ze,left:He,right:Ke,type:"SAME"}}else if(Z==="valid")ve={top:0,bottom:0,left:0,right:0,type:"VALID"},we=Math.ceil((I-le+1)/re),Me=Math.ceil((V-he+1)/ae);else if(typeof Z=="object"){const Le=pe==="channelsLast"?Z[1][0]:Z[2][0],Ue=pe==="channelsLast"?Z[1][1]:Z[2][1],Ge=pe==="channelsLast"?Z[2][0]:Z[3][0],ze=pe==="channelsLast"?Z[2][1]:Z[3][1];ve={top:Le,bottom:Ue,left:Ge,right:ze,type:Le===0&&Ue===0&&Ge===0&&ze===0?"VALID":"EXPLICIT"},we=Oq((I-le+Le+Ue)/re+1,ue),Me=Oq((V-he+Ge+ze)/ae+1,ue)}else throw Error("Unknown padding parameter: "+Z);return{padInfo:ve,outHeight:we,outWidth:Me}}function Ov(Z,I,V,re,ae,le,he,ue,pe,ve,we){let Me,Le,Ue,Ge;if(Z==="valid"&&(Z=0),typeof Z=="number"){Me={top:Z,bottom:Z,left:Z,right:Z,front:Z,back:Z,type:Z===0?"VALID":"NUMBER"};const ze=OX([I,V,re,1],[ue,pe,ve],1,[ae,le,he],Z,we);Le=ze[0],Ue=ze[1],Ge=ze[2]}else if(Z==="same"){Le=Math.ceil(I/ae),Ue=Math.ceil(V/le),Ge=Math.ceil(re/he);const ze=(Le-1)*ae+ue-I,He=(Ue-1)*le+pe-V,Ke=(Ge-1)*he+ve-re,Ye=Math.floor(ze/2),$e=ze-Ye,je=Math.floor(He/2),rt=He-je,at=Math.floor(Ke/2),Rt=Ke-at;Me={top:je,bottom:rt,left:at,right:Rt,front:Ye,back:$e,type:"SAME"}}else throw Error("Unknown padding parameter: "+Z);return{padInfo:Me,outDepth:Le,outHeight:Ue,outWidth:Ge}}function Oq(Z,I){if(!I)return Math.trunc(Z);switch(I){case"round":return Math.round(Z);case"ceil":return Math.ceil(Z);case"floor":return Math.floor(Z);default:throw new Error("Unknown roundingMode "+I)}}function Ol(Z){const[I,V,re]=OW(Z);return I===1&&V===1&&re===1}function Oa(Z,I){return Ol(Z)||Ol(I)}function On(Z){return OW(Z).every(I=>I>0)}function OL(Z){if(Z==="NHWC")return"channelsLast";if(Z==="NCHW")return"channelsFirst";throw new Error("Unknown dataFormat "+Z)}function OH(Z,I,V){if(V!=null){if(typeof I=="string")throw Error("Error in "+Z+": pad must be an integer when using dimRoundingMode "+V+" but got pad "+I+".");if(typeof I=="number")e(R(I),()=>"Error in "+Z+": pad must be an integer when using dimRoundingMode "+V+" but got pad "+I+".");else if(typeof I=="object")I.forEach(re=>{re.forEach(ae=>{e(R(ae),()=>"Error in "+Z+": pad must be an integer when using dimRoundingMode "+V+" but got pad "+ae+".")})});else throw Error("Error in "+Z+": Unknown padding parameter: "+I)}}function Ok(Z,I){const V={x:Jv(Z,"x","reshape","string_or_numeric")},re={shape:I};return JA.runKernel(mP,V,re)}const Oz=Ja({reshape_:Ok});function Ox(Z,I,V,re,ae){const le=Jv(Z,"x","avgPool","float32"),he=1;e(Oa(V,he),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+he+"'");let ue=le,pe=!1;le.rank===3&&(pe=!0,ue=Oz(le,[1,le.shape[0],le.shape[1],le.shape[2]])),e(ue.rank===4,()=>"Error in avgPool: x must be rank 4 but got rank "+ue.rank+"."),OH("avgPool",re,ae);const ve={x:ue},we={filterSize:I,strides:V,pad:re,dimRoundingMode:ae};let Me=JA.runKernel(Cs,ve,we);return Me=ip(Me,le.dtype),pe?Oz(Me,[Me.shape[1],Me.shape[2],Me.shape[3]]):Me}const OU=Ja({avgPool_:Ox});function OG(Z){const I={x:Jv(Z,"x","clone","string_or_numeric")};return JA.runKernel(Cj,I)}const Ou=Ja({clone_:OG});function OY(Z,I=0){e(Z.length>=1,()=>"Pass at least one tensor to concat");const V=Jq(Z,"tensors","concat","string_or_numeric");if(V[0].dtype==="complex64"&&V.forEach(le=>{if(le.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype `+le.dtype+". ")}),V.length===1)return Ou(V[0]);const re=V,ae={axis:I};return JA.runKernel(Cc,re,ae)}const OM=Ja({concat_:OY});function Oh(Z){const I={x:Jv(Z,"x","sigmoid","float32")};return JA.runKernel(mF,I)}const Oj=Ja({sigmoid_:Oh});function Or(Z,I,V){const re=Jv(Z,"x","slice","string_or_numeric");if(re.rank===0)throw new Error("Slicing scalar is not possible");const ae={x:re},le={begin:I,size:V};return JA.runKernel(mQ,ae,le)}const t0=Ja({slice_:Or});function t1(Z,I,V){const re=Jv(Z,"x","batchToSpaceND"),ae=I.reduce((ue,pe)=>ue*pe);e(re.rank>=1+I.length,()=>"input rank is "+re.rank+" but should be > than blockShape.length "+I.length),e(V.length===I.length,()=>"crops.length is "+V.length+" but should be equal to blockShape.length  "+I.length),e(re.shape[0]%ae===0,()=>"input tensor batch is "+re.shape[0]+" but is not divisible by the product of the elements of blockShape "+I.join(" * ")+" === "+ae);const le={x:re},he={blockShape:I,crops:V};return JA.runKernel(CI,le,he)}const t2=Ja({batchToSpaceND_:t1});function t3(Z,I,V){const re=Jv(Z,"x","bincount"),ae=Jv(I,"weights","bincount");e(re.dtype==="int32",()=>"Error in bincount: input dtype must be int32, but got "+re.dtype),e(V>=0,()=>"size must be non-negative, but got "+V+"."),e(ae.size===re.size||ae.size===0,()=>"Error in bincount: weights must have the same size as input or0-length, but got input shape: "+re.shape+", weights shape: "+ae.shape+".");const le={x:re,weights:ae},he={size:V};return JA.runKernel(Cy,le,he)}const t4=Ja({bincount_:t3});function t5(Z,I){let V=Jv(Z,"broadcastTo","x");const re=V.shape;if(Cm(I),I.length<V.rank)throw new Error("broadcastTo(): shape.length="+I.length+" < input.rank="+V.rank+".");if(I.length>V.rank){const pe=V.shape.slice();for(;pe.length<I.length;)pe.unshift(1);V=Oz(V,pe)}const ae=V.shape,le=Array.from(I);for(let pe=I.length-1;pe>=0;pe--)if(ae[pe]===I[pe])le[pe]=1;else if(V.shape[pe]!==1)throw new Error("broadcastTo(): ["+re+"] cannot be broadcast to ["+I+"].");if(le.map((pe,ve)=>pe>1?ve:-1).filter(pe=>pe>=0).length===0)return Ou(V);const he={x:V},ue={reps:le};return JA.runKernel(mW,he,ue)}const t6=Ja({broadcastTo_:t5});function t7(Z,I="float32",V){return I=I||"float32",Cm(Z),new J8(Z,I,V)}function t8(Z,I,V){Cm(Z),V=V||C2(I);const re={shape:Z,value:I,dtype:V};return JA.runKernel(Cx,{},re)}function t9(Z,I,V){const re=Jv(Z,"x","clipByValue");if(e(I<=V,()=>"Error in clip: min ("+I+") must be less than or equal to max ("+V+")."),I===V)return t8(re.shape,I,re.dtype);const ae={x:re},le={clipValueMin:I,clipValueMax:V};return JA.runKernel(Cp,ae,le)}const tC=Ja({clipByValue_:t9});function tm(Z,I){return OM(Z,I)}const tN=Ja({concat2d_:tm});function tJ(Z,I){return OM(Z,I)}const tf=Ja({concat3d_:tJ});function ti(Z,I,V,re,ae="NHWC",le=[1,1],he){const ue=Jv(Z,"x","conv2d","float32"),pe=Jv(I,"filter","conv2d","float32");let ve=ue,we=!1;ue.rank===3&&(we=!0,ve=Oz(ue,[1,ue.shape[0],ue.shape[1],ue.shape[2]])),e(ve.rank===4,()=>"Error in conv2d: input must be rank 4, but got rank "+ve.rank+"."),e(pe.rank===4,()=>"Error in conv2d: filter must be rank 4, but got rank "+pe.rank+"."),OH("conv2d",re,he);const Me=ae==="NHWC"?ve.shape[3]:ve.shape[1];e(Me===pe.shape[2],()=>"Error in conv2d: depth of input ("+Me+") must match input depth for filter "+pe.shape[2]+"."),e(Oa(V,le),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+le+"'"),e(On(le),()=>"Error in conv2D: Dilated rates should be larger than 0."),e(On(V),()=>"Error in conv2D: Strides should be larger than 0.");const Le={x:ve,filter:pe},Ue={strides:V,pad:re,dataFormat:ae,dilations:le,dimRoundingMode:he},Ge=JA.runKernel(CW,Le,Ue);return we?Oz(Ge,[Ge.shape[1],Ge.shape[2],Ge.shape[3]]):Ge}const tO=Ja({conv2d_:ti});function tt(Z,I,V,re,ae,le="NHWC",he){e(Z.length===I.rank,()=>"Length of inShape ("+Z.length+") and rank of dy ("+I.rank+") must match");let ue=Z,pe=I,ve=!1;I.rank===3&&(ve=!0,pe=Oz(I,[1,I.shape[0],I.shape[1],I.shape[2]]),ue=[1,Z[0],Z[1],Z[2]]),e(ue.length===4,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+ue.length+"."),e(pe.rank===4,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+pe.rank),e(V.rank===4,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+V.rank);const we=le==="NHWC"?ue[3]:ue[1],Me=le==="NHWC"?pe.shape[3]:pe.shape[1];e(we===V.shape[2],()=>"Error in conv2dDerInput: depth of input ("+we+") must match input depth for filter "+V.shape[2]+"."),e(Me===V.shape[3],()=>"Error in conv2dDerInput: depth of output ("+Me+") must match output depth for filter "+V.shape[3]+"."),OH("conv2dDerInput",ae,he);const Le={dy:pe,filter:V},Ue={strides:re,pad:ae,dataFormat:le,dimRoundingMode:he,inputShape:ue},Ge=JA.runKernel(CK,Le,Ue);return ve?Oz(Ge,[Ge.shape[1],Ge.shape[2],Ge.shape[3]]):Ge}const tB=Ja({conv2DBackpropInput_:tt});function tS(Z,I,V,re,ae,le){const he=Jv(Z,"x","conv2dTranspose"),ue=Jv(I,"filter","conv2dTranspose");return tB(V,he,ue,re,ae,"NHWC",le)}const td=Ja({conv2dTranspose_:tS});function tV(Z){const I={x:Jv(Z,"x","cos","float32")};return JA.runKernel(CT,I)}const tb=Ja({cos_:tV});function tP(Z,I,V="NHWC"){const re=Jv(Z,"x","depthToSpace","float32"),ae=V==="NHWC"?re.shape[1]:re.shape[2],le=V==="NHWC"?re.shape[2]:re.shape[3],he=V==="NHWC"?re.shape[3]:re.shape[1];e(I>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+I),e(ae*I>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+ae+" and "+I+`  for depthToSpace with input shape
    `+re.shape),e(le*I>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+le+" and "+I+` for depthToSpace with input shape
        `+re.shape),e(he%(I*I)===0,()=>"Dimension size must be evenly divisible by "+I*I+" but is "+he+" for depthToSpace with input shape "+re.shape);const ue={x:re},pe={blockSize:I,dataFormat:V};return JA.runKernel(Cq,ue,pe)}const tE=Ja({depthToSpace_:tP});function tD(Z,I,V,re,ae="NHWC",le=[1,1],he){const ue=Jv(Z,"x","depthwiseConv2d","float32"),pe=Jv(I,"filter","depthwiseConv2d","float32");let ve=ue,we=!1;ue.rank===3&&(we=!0,ve=Oz(ue,[1,ue.shape[0],ue.shape[1],ue.shape[2]])),e(ve.rank===4,()=>"Error in depthwiseConv2d: input must be rank 4, but got rank "+ve.rank+"."),e(pe.rank===4,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+pe.rank+".");const Me=ae==="NHWC"?ve.shape[3]:ve.shape[1];e(Me===pe.shape[2],()=>"Error in depthwiseConv2d: number of input channels ("+Me+") must match the inChannels dimension in filter "+pe.shape[2]+"."),OH("depthwiseConv2d",re,he);const Le={x:ve,filter:pe},Ue={strides:V,pad:re,dataFormat:ae,dilations:le,dimRoundingMode:he},Ge=JA.runKernel(Cl,Le,Ue);return we?Oz(Ge,[Ge.shape[1],Ge.shape[2],Ge.shape[3]]):Ge}const tg=Ja({depthwiseConv2d_:tD});function tZ(Z,I,V){const re=Jv(I,"a","where"),ae=Jv(V,"b","where"),le=Jv(Z,"condition","where","bool"),he=iH(iH(le.shape,re.shape),ae.shape),ue=t6(le,he),pe=t6(re,he),ve=t6(ae,he),we={condition:ue,t:pe,e:ve};return JA.runKernel(me,we)}const to=Ja({where_:tZ});function te(Z){const I={x:Jv(Z,"x","zerosLike")};return JA.runKernel(mv,I)}const tQ=Ja({zerosLike_:te});function ts(Z,...I){const V=I.map((ae,le)=>Jv(ae,"tensors"+le,"einsum")),re={equation:Z};return JA.runKernel(CH,V,re)}const tF=Ja({einsum_:ts});function tI(Z){const I={x:Jv(Z,"x","elu","float32")};return JA.runKernel(Ck,I)}const ty=Ja({elu_:tI});function tA(Z,I){for(let V=0;V<Z.length;++V)if(Z[Z.length-V-1]!==I-1-V)return!1;return!0}function tp(Z,I,V){const re=Z.length+I.length,ae=[];let le=0,he=0;for(let ue=0;ue<re;ue++)V.indexOf(ue)===-1?ae.push(Z[le++]):ae.push(I[he++]);return ae}function tw(Z,I){const V=[],re=Z.length;for(let le=0;le<re;le++)I.indexOf(le)===-1&&V.push(Z[le]);const ae=I.map(le=>Z[le]);return[V,ae]}function tX(Z,I){const V=I.map(re=>1);return tp(Z,V,I)}function tc(Z,I,V){e(tA(I,V),()=>Z+" supports only inner-most axes for now. Got axes "+I+" and rank-"+V+" input.")}function tW(Z,I){if(tA(Z,I))return null;const V=[];for(let re=0;re<I;++re)Z.indexOf(re)===-1&&V.push(re);return Z.forEach(re=>V.push(re)),V}function tR(Z){return Z.map((I,V)=>[V,I]).sort((I,V)=>I[1]-V[1]).map(I=>I[0])}function tK(Z,I){const V=[];for(let re=I-Z;re<I;++re)V.push(re);return V}function tT(Z,I=null,V=!1){const re={x:Jv(Z,"x","max")},ae={reductionIndices:I,keepDims:V};return JA.runKernel(m5,re,ae)}const tv=Ja({max_:tT});function tq(Z,I=null,V=!1){const re={x:Jv(Z,"x","min")},ae={axis:I,keepDims:V};return JA.runKernel(m9,re,ae)}const tl=Ja({min_:tq});function ta(Z,I){let V=Jv(Z,"base","pow"),re=Jv(I,"exp","pow");[V,re]=Jg(V,re);const ae={a:V,b:re};return JA.runKernel(mB,ae)}const tn=Ja({pow_:ta});function tL(Z,I){if((NU(Z)&&I!=="string"||Array.isArray(Z))&&I!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(I==="string"&&NU(Z)&&!(Z instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return JH(Z,[],[],I)}function tH(Z){const I={x:Jv(Z,"x","sqrt","float32")};return JA.runKernel(mI,I)}const tk=Ja({sqrt_:tH});function tz(Z){const I=Jv(Z,"x","square"),V={};return JA.runKernel("Square",{x:I},V)}const tx=Ja({square_:tz});function tU(Z,I=null,V=!1){let re=Jv(Z,"x","sum");re.dtype==="bool"&&(re=ip(re,"int32"));const ae={x:re},le={axis:I,keepDims:V};return JA.runKernel(my,ae,le)}const tG=Ja({sum_:tU});function tu(Z,I="euclidean",V=null,re=!1){Z=Jv(Z,"x","norm");const ae=tY(Z,I,V);let le=ae.shape;if(re){const he=n(V,Z.shape);le=tX(ae.shape,he)}return Oz(ae,le)}function tY(Z,I,V=null){if(Z.rank===0)return OZ(Z);if(Z.rank!==1&&V===null)return tY(Oz(Z,[-1]),I,V);if(Z.rank===1||typeof V=="number"||Array.isArray(V)&&V.length===1){if(I===1)return tG(OZ(Z),V);if(I===1/0)return tv(OZ(Z),V);if(I===-1/0)return tl(OZ(Z),V);if(I==="euclidean"||I===2)return tk(tG(tn(OZ(Z),tL(2,"int32")),V));throw new Error("Error in norm: invalid ord value: "+I)}if(Array.isArray(V)&&V.length===2){if(I===1)return tv(tG(OZ(Z),V[0]),V[1]-1);if(I===1/0)return tv(tG(OZ(Z),V[1]),V[0]);if(I===-1/0)return tl(tG(OZ(Z),V[1]),V[0]);if(I==="fro"||I==="euclidean")return tk(tG(tx(Z),V));throw new Error("Error in norm: invalid ord value: "+I)}throw new Error("Error in norm: invalid axis: "+V)}const tM=Ja({norm_:tu});function th(Z,I=null,V=!1){return tM(Z,"euclidean",I,V)}const tj=Ja({euclideanNorm_:th});function tr(Z,I=0){const V=Jv(Z,"x","expandDims","string_or_numeric");e(I<=V.rank,()=>"Axis must be <= rank of the tensor");const re={input:V},ae={dim:I};return JA.runKernel(Cz,re,ae)}const B0=Ja({expandDims_:tr});function B1(Z,I){const V=Jv(Z,"x","tile","string_or_numeric");e(V.rank===I.length,()=>"Error in transpose: rank of input "+V.rank+" must match length of reps "+I+".");const re={x:V},ae={reps:I};return JA.runKernel(mW,re,ae)}const B2=Ja({tile_:B1});function B3(Z){const I={x:Jv(Z,"x","floor","float32")};return JA.runKernel(CG,I)}const B4=Ja({floor_:B3});function B5(Z,I,V=0,re=0){const ae=Jv(Z,"x","gather"),le=Jv(I,"indices","gather","int32"),he={x:ae,indices:le},ue={axis:V,batchDims:re};return JA.runKernel(CY,he,ue)}const B6=Ja({gather_:B5});function B7(Z,I){let V=Jv(Z,"a","greater","string_or_numeric"),re=Jv(I,"b","greater","string_or_numeric");[V,re]=Jg(V,re),iH(V.shape,re.shape);const ae={a:V,b:re};return JA.runKernel(CM,ae)}const B8=Ja({greater_:B7});function B9(Z,I){let V=Jv(Z,"a","greaterEqual","string_or_numeric"),re=Jv(I,"b","greaterEqual","string_or_numeric");[V,re]=Jg(V,re),iH(V.shape,re.shape);const ae={a:V,b:re};return JA.runKernel(Ch,ae)}const BC=Ja({greaterEqual_:B9});function Bm(Z,I=.2){const V={x:Jv(Z,"x","leakyRelu")},re={alpha:I};return JA.runKernel(m0,V,re)}const BN=Ja({leakyRelu_:Bm});function BJ(Z,I){let V=Jv(Z,"a","less","string_or_numeric"),re=Jv(I,"b","less","string_or_numeric");[V,re]=Jg(V,re),iH(V.shape,re.shape);const ae={a:V,b:re};return JA.runKernel(m1,ae)}const Bf=Ja({less_:BJ});function Bi(Z,I){let V=Jv(Z,"a","lessEqual","string_or_numeric"),re=Jv(I,"b","lessEqual","string_or_numeric");[V,re]=Jg(V,re),iH(V.shape,re.shape);const ae={a:V,b:re};return JA.runKernel(m2,ae)}const BO=Ja({lessEqual_:Bi});function Bt(Z){return JA.customGrad(Z)}function BB(Z,I){let V=Jv(Z,"a","sub"),re=Jv(I,"b","sub");[V,re]=Jg(V,re);const ae={a:V,b:re};return JA.runKernel(mc,ae)}const BS=Ja({sub_:BB});function Bd(Z,I){const V=Jv(Z,"a","logicalAnd","bool"),re=Jv(I,"b","logicalAnd","bool");iH(V.shape,re.shape);const ae={a:V,b:re};return JA.runKernel(m3,ae)}const BV=Ja({logicalAnd_:Bd});function Bb(Z,I){const V=Jv(Z,"a","logicalOr","bool"),re=Jv(I,"b","logicalOr","bool");iH(V.shape,re.shape);const ae={a:V,b:re};return JA.runKernel(m4,ae)}const BP=Ja({logicalOr_:Bb});function BE(Z,I,V,re,ae){const le=Jv(Z,"x","maxPool"),he=1;let ue=le,pe=!1;le.rank===3&&(pe=!0,ue=Oz(le,[1,le.shape[0],le.shape[1],le.shape[2]])),e(ue.rank===4,()=>"Error in maxPool: input must be rank 4 but got rank "+ue.rank+"."),e(Oa(V,he),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+he+"'"),OH("maxPool",re,ae);const ve={x:ue},we={filterSize:I,strides:V,pad:re,dimRoundingMode:ae},Me=JA.runKernel(m7,ve,we);return pe?Oz(Me,[Me.shape[1],Me.shape[2],Me.shape[3]]):Me}const BD=Ja({maxPool_:BE});function Bg(Z,I){let V=Jv(Z,"a","maximum"),re=Jv(I,"b","maximum");[V,re]=Jg(V,re),V.dtype==="bool"&&(V=ip(V,"int32"),re=ip(re,"int32")),iH(V.shape,re.shape);const ae={a:V,b:re};return JA.runKernel(m6,ae)}const BZ=Ja({maximum_:Bg});function Bo(Z,I=null,V=!1){const re={x:Jv(Z,"x","mean")},ae={axis:I,keepDims:V};return JA.runKernel(m8,re,ae)}const Be=Ja({mean_:Bo});function BQ(Z,I="float32"){if(Cm(Z),I==="complex64"){const re=BQ(Z,"float32"),ae=BQ(Z,"float32");return JL(re,ae)}const V=CC(F(Z),I);return JA.makeTensor(V,Z,I)}function Bs(Z,I="float32"){if(Cm(Z),I==="complex64"){const re=Bs(Z,"float32"),ae=BQ(Z,"float32");return JL(re,ae)}const V=C9(F(Z),I);return JA.makeTensor(V,Z,I)}function BF(Z,I){let V=Jv(Z,"a","minimum"),re=Jv(I,"b","minimum");[V,re]=Jg(V,re),V.dtype==="bool"&&(V=ip(V,"int32"),re=ip(re,"int32")),iH(V.shape,re.shape);const ae={a:V,b:re};return JA.runKernel(mC,ae)}const BI=Ja({minimum_:BF});function By(Z,I,V=0){const re=Jv(Z,"x","pad");if(re.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const ae={paddings:I,constantValue:V},le={x:re};return JA.runKernel(mt,le,ae)}const BA=Ja({pad_:By});function Bp(Z,I,V){const re=Jv(Z,"x","spaceToBatchND");e(re.rank>=1+I.length,()=>"input rank "+re.rank+" should be > than [blockShape] "+I.length),e(V.length===I.length,()=>"paddings.shape[0] "+V.length+" must be equal to [blockShape] "+I.length),e(re.shape.reduce((he,ue,pe)=>pe>0&&pe<=I.length?he&&(ue+V[pe-1][0]+V[pe-1][1])%I[pe-1]===0:he,!0),()=>"input spatial dimensions "+re.shape.slice(1)+" with paddings "+V.toString()+" must be divisible by blockShapes "+I.toString());const ae={x:re},le={blockShape:I,paddings:V};return JA.runKernel(mA,ae,le)}const Bw=Ja({spaceToBatchND_:Bp});function BX(Z,I,V,re,ae,le,he){ae==null&&(ae=[1,1]),le==null&&(le=1),re===0&&(re="valid");const ue=Jv(Z,"x","maxPool");let pe=ue,ve=!1;ue.rank===3&&(ve=!0,pe=Oz(ue,[1,ue.shape[0],ue.shape[1],ue.shape[2]])),e(Oa(le,ae),()=>"Error in pool: Either strides or dilations must be 1. Got strides "+le+" and dilations '"+ae+"'");const we=OI(pe.shape,I,le,ae,re),Me=[we.dilationHeight,we.dilationWidth];let Le;re==="same"?Le=BW([we.filterHeight,we.filterWidth],Me):Le=[[0,0],[0,0]];const Ue=Me[0]===1&&Me[1]===1,[Ge,ze]=Bc([we.inHeight,we.inWidth],Me,Le),He=Ue?re:"valid",Ke=Ue?pe:Bw(pe,Me,Ge),Ye=(V==="avg"?()=>OU(Ke,I,le,He,he):()=>BD(Ke,I,le,He,he))(),$e=Ue?Ye:t2(Ye,Me,ze);return ve?Oz($e,[$e.shape[1],$e.shape[2],$e.shape[3]]):$e}function Bc(Z,I,V){const re=V.map(we=>we[0]),ae=V.map(we=>we[1]),le=Z.concat(re,ae),he=I.map((we,Me)=>(we-le[Me]%we)%we),ue=ae.map((we,Me)=>we+he[Me]),pe=I.map((we,Me)=>[re[Me],ue[Me]]),ve=I.map((we,Me)=>[0,he[Me]]);return[pe,ve]}function BW(Z,I){const V=Z.map((le,he)=>le+(le-1)*(I[he]-1)).map(le=>le-1),re=V.map(le=>Math.floor(le/2)),ae=V.map((le,he)=>le-re[he]);return V.map((le,he)=>[re[he],ae[he]])}const BR=Ja({pool_:BX});function BK(Z,I){const V=Jv(Z,"x","prelu"),re=Jv(I,"alpha","prelu"),ae={x:V,alpha:re};return JA.runKernel(mS,ae)}const BT=Ja({prelu_:BK});function Bv(Z,I=!1){console.log(Z.toString(I))}var Bq={exports:{}};Bq.exports,function(Z){(function(I,V,re){function ae(pe){var ve=this,we=ue();ve.next=function(){var Me=2091639*ve.s0+ve.c*23283064365386963e-26;return ve.s0=ve.s1,ve.s1=ve.s2,ve.s2=Me-(ve.c=Me|0)},ve.c=1,ve.s0=we(" "),ve.s1=we(" "),ve.s2=we(" "),ve.s0-=we(pe),ve.s0<0&&(ve.s0+=1),ve.s1-=we(pe),ve.s1<0&&(ve.s1+=1),ve.s2-=we(pe),ve.s2<0&&(ve.s2+=1),we=null}function le(pe,ve){return ve.c=pe.c,ve.s0=pe.s0,ve.s1=pe.s1,ve.s2=pe.s2,ve}function he(pe,ve){var we=new ae(pe),Me=ve&&ve.state,Le=we.next;return Le.int32=function(){return we.next()*4294967296|0},Le.double=function(){return Le()+(Le()*2097152|0)*11102230246251565e-32},Le.quick=Le,Me&&(typeof Me=="object"&&le(Me,we),Le.state=function(){return le(we,{})}),Le}function ue(){var pe=4022871197,ve=function(we){we=String(we);for(var Me=0;Me<we.length;Me++){pe+=we.charCodeAt(Me);var Le=.02519603282416938*pe;pe=Le>>>0,Le-=pe,Le*=pe,pe=Le>>>0,Le-=pe,pe+=Le*4294967296}return(pe>>>0)*23283064365386963e-26};return ve}V&&V.exports?V.exports=he:re&&re.amd?re(function(){return he}):this.alea=he})(mr,Z,!1)}(Bq);var Bl=Bq.exports,Ba={exports:{}};Ba.exports,function(Z){(function(I,V,re){function ae(ue){var pe=this,ve="";pe.x=0,pe.y=0,pe.z=0,pe.w=0,pe.next=function(){var Me=pe.x^pe.x<<11;return pe.x=pe.y,pe.y=pe.z,pe.z=pe.w,pe.w^=pe.w>>>19^Me^Me>>>8},ue===(ue|0)?pe.x=ue:ve+=ue;for(var we=0;we<ve.length+64;we++)pe.x^=ve.charCodeAt(we)|0,pe.next()}function le(ue,pe){return pe.x=ue.x,pe.y=ue.y,pe.z=ue.z,pe.w=ue.w,pe}function he(ue,pe){var ve=new ae(ue),we=pe&&pe.state,Me=function(){return(ve.next()>>>0)/4294967296};return Me.double=function(){do var Le=ve.next()>>>11,Ue=(ve.next()>>>0)/4294967296,Ge=(Le+Ue)/(1<<21);while(Ge===0);return Ge},Me.int32=ve.next,Me.quick=Me,we&&(typeof we=="object"&&le(we,ve),Me.state=function(){return le(ve,{})}),Me}V&&V.exports?V.exports=he:re&&re.amd?re(function(){return he}):this.xor128=he})(mr,Z,!1)}(Ba);var Bn=Ba.exports,BL={exports:{}};BL.exports,function(Z){(function(I,V,re){function ae(ue){var pe=this,ve="";pe.next=function(){var Me=pe.x^pe.x>>>2;return pe.x=pe.y,pe.y=pe.z,pe.z=pe.w,pe.w=pe.v,(pe.d=pe.d+362437|0)+(pe.v=pe.v^pe.v<<4^(Me^Me<<1))|0},pe.x=0,pe.y=0,pe.z=0,pe.w=0,pe.v=0,ue===(ue|0)?pe.x=ue:ve+=ue;for(var we=0;we<ve.length+64;we++)pe.x^=ve.charCodeAt(we)|0,we==ve.length&&(pe.d=pe.x<<10^pe.x>>>4),pe.next()}function le(ue,pe){return pe.x=ue.x,pe.y=ue.y,pe.z=ue.z,pe.w=ue.w,pe.v=ue.v,pe.d=ue.d,pe}function he(ue,pe){var ve=new ae(ue),we=pe&&pe.state,Me=function(){return(ve.next()>>>0)/4294967296};return Me.double=function(){do var Le=ve.next()>>>11,Ue=(ve.next()>>>0)/4294967296,Ge=(Le+Ue)/(1<<21);while(Ge===0);return Ge},Me.int32=ve.next,Me.quick=Me,we&&(typeof we=="object"&&le(we,ve),Me.state=function(){return le(ve,{})}),Me}V&&V.exports?V.exports=he:re&&re.amd?re(function(){return he}):this.xorwow=he})(mr,Z,!1)}(BL);var BH=BL.exports,Bk={exports:{}};Bk.exports,function(Z){(function(I,V,re){function ae(ue){var pe=this;pe.next=function(){var we=pe.x,Me=pe.i,Le,Ue;return Le=we[Me],Le^=Le>>>7,Ue=Le^Le<<24,Le=we[Me+1&7],Ue^=Le^Le>>>10,Le=we[Me+3&7],Ue^=Le^Le>>>3,Le=we[Me+4&7],Ue^=Le^Le<<7,Le=we[Me+7&7],Le=Le^Le<<13,Ue^=Le^Le<<9,we[Me]=Ue,pe.i=Me+1&7,Ue};function ve(we,Me){var Le,Ue=[];if(Me===(Me|0))Ue[0]=Me;else for(Me=""+Me,Le=0;Le<Me.length;++Le)Ue[Le&7]=Ue[Le&7]<<15^Me.charCodeAt(Le)+Ue[Le+1&7]<<13;for(;Ue.length<8;)Ue.push(0);for(Le=0;Le<8&&Ue[Le]===0;++Le);for(Le==8?Ue[7]=-1:Ue[Le],we.x=Ue,we.i=0,Le=256;Le>0;--Le)we.next()}ve(pe,ue)}function le(ue,pe){return pe.x=ue.x.slice(),pe.i=ue.i,pe}function he(ue,pe){ue==null&&(ue=+new Date);var ve=new ae(ue),we=pe&&pe.state,Me=function(){return(ve.next()>>>0)/4294967296};return Me.double=function(){do var Le=ve.next()>>>11,Ue=(ve.next()>>>0)/4294967296,Ge=(Le+Ue)/(1<<21);while(Ge===0);return Ge},Me.int32=ve.next,Me.quick=Me,we&&(we.x&&le(we,ve),Me.state=function(){return le(ve,{})}),Me}V&&V.exports?V.exports=he:re&&re.amd?re(function(){return he}):this.xorshift7=he})(mr,Z,!1)}(Bk);var Bz=Bk.exports,Bx={exports:{}};Bx.exports,function(Z){(function(I,V,re){function ae(ue){var pe=this;pe.next=function(){var we=pe.w,Me=pe.X,Le=pe.i,Ue,Ge;return pe.w=we=we+1640531527|0,Ge=Me[Le+34&127],Ue=Me[Le=Le+1&127],Ge^=Ge<<13,Ue^=Ue<<17,Ge^=Ge>>>15,Ue^=Ue>>>12,Ge=Me[Le]=Ge^Ue,pe.i=Le,Ge+(we^we>>>16)|0};function ve(we,Me){var Le,Ue,Ge,ze,He,Ke=[],Ye=128;for(Me===(Me|0)?(Ue=Me,Me=null):(Me=Me+"\0",Ue=0,Ye=Math.max(Ye,Me.length)),Ge=0,ze=-32;ze<Ye;++ze)Me&&(Ue^=Me.charCodeAt((ze+32)%Me.length)),ze===0&&(He=Ue),Ue^=Ue<<10,Ue^=Ue>>>15,Ue^=Ue<<4,Ue^=Ue>>>13,ze>=0&&(He=He+1640531527|0,Le=Ke[ze&127]^=Ue+He,Ge=Le==0?Ge+1:0);for(Ge>=128&&(Ke[(Me&&Me.length||0)&127]=-1),Ge=127,ze=512;ze>0;--ze)Ue=Ke[Ge+34&127],Le=Ke[Ge=Ge+1&127],Ue^=Ue<<13,Le^=Le<<17,Ue^=Ue>>>15,Le^=Le>>>12,Ke[Ge]=Ue^Le;we.w=He,we.X=Ke,we.i=Ge}ve(pe,ue)}function le(ue,pe){return pe.i=ue.i,pe.w=ue.w,pe.X=ue.X.slice(),pe}function he(ue,pe){ue==null&&(ue=+new Date);var ve=new ae(ue),we=pe&&pe.state,Me=function(){return(ve.next()>>>0)/4294967296};return Me.double=function(){do var Le=ve.next()>>>11,Ue=(ve.next()>>>0)/4294967296,Ge=(Le+Ue)/(1<<21);while(Ge===0);return Ge},Me.int32=ve.next,Me.quick=Me,we&&(we.X&&le(we,ve),Me.state=function(){return le(ve,{})}),Me}V&&V.exports?V.exports=he:re&&re.amd?re(function(){return he}):this.xor4096=he})(mr,Z,!1)}(Bx);var BU=Bx.exports,BG={exports:{}};BG.exports,function(Z){(function(I,V,re){function ae(ue){var pe=this,ve="";pe.next=function(){var Me=pe.b,Le=pe.c,Ue=pe.d,Ge=pe.a;return Me=Me<<25^Me>>>7^Le,Le=Le-Ue|0,Ue=Ue<<24^Ue>>>8^Ge,Ge=Ge-Me|0,pe.b=Me=Me<<20^Me>>>12^Le,pe.c=Le=Le-Ue|0,pe.d=Ue<<16^Le>>>16^Ge,pe.a=Ge-Me|0},pe.a=0,pe.b=0,pe.c=-1640531527,pe.d=1367130551,ue===Math.floor(ue)?(pe.a=ue/4294967296|0,pe.b=ue|0):ve+=ue;for(var we=0;we<ve.length+20;we++)pe.b^=ve.charCodeAt(we)|0,pe.next()}function le(ue,pe){return pe.a=ue.a,pe.b=ue.b,pe.c=ue.c,pe.d=ue.d,pe}function he(ue,pe){var ve=new ae(ue),we=pe&&pe.state,Me=function(){return(ve.next()>>>0)/4294967296};return Me.double=function(){do var Le=ve.next()>>>11,Ue=(ve.next()>>>0)/4294967296,Ge=(Le+Ue)/(1<<21);while(Ge===0);return Ge},Me.int32=ve.next,Me.quick=Me,we&&(typeof we=="object"&&le(we,ve),Me.state=function(){return le(ve,{})}),Me}V&&V.exports?V.exports=he:re&&re.amd?re(function(){return he}):this.tychei=he})(mr,Z,!1)}(BG);var Bu=BG.exports,BY={exports:{}};(function(Z){(function(I,V,re){var ae=256,le=6,he=52,ue="random",pe=re.pow(ae,le),ve=re.pow(2,he),we=ve*2,Me=ae-1,Le;function Ue(je,rt,at){var Rt=[];rt=rt==!0?{entropy:!0}:rt||{};var lt=Ke(He(rt.entropy?[je,$e(V)]:je??Ye(),3),Rt),kt=new Ge(Rt),qt=function(){for(var Kt=kt.g(le),_i=pe,ci=0;Kt<ve;)Kt=(Kt+ci)*ae,_i*=ae,ci=kt.g(1);for(;Kt>=we;)Kt/=2,_i/=2,ci>>>=1;return(Kt+ci)/_i};return qt.int32=function(){return kt.g(4)|0},qt.quick=function(){return kt.g(4)/4294967296},qt.double=qt,Ke($e(kt.S),V),(rt.pass||at||function(Kt,_i,ci,li){return li&&(li.S&&ze(li,kt),Kt.state=function(){return ze(kt,{})}),ci?(re[ue]=Kt,_i):Kt})(qt,lt,"global"in rt?rt.global:this==re,rt.state)}function Ge(je){var rt,at=je.length,Rt=this,lt=0,kt=Rt.i=Rt.j=0,qt=Rt.S=[];for(at||(je=[at++]);lt<ae;)qt[lt]=lt++;for(lt=0;lt<ae;lt++)qt[lt]=qt[kt=Me&kt+je[lt%at]+(rt=qt[lt])],qt[kt]=rt;(Rt.g=function(Kt){for(var _i,ci=0,li=Rt.i,qi=Rt.j,Ki=Rt.S;Kt--;)_i=Ki[li=Me&li+1],ci=ci*ae+Ki[Me&(Ki[li]=Ki[qi=Me&qi+_i])+(Ki[qi]=_i)];return Rt.i=li,Rt.j=qi,ci})(ae)}function ze(je,rt){return rt.i=je.i,rt.j=je.j,rt.S=je.S.slice(),rt}function He(je,rt){var at=[],Rt=typeof je,lt;if(rt&&Rt=="object")for(lt in je)try{at.push(He(je[lt],rt-1))}catch{}return at.length?at:Rt=="string"?je:je+"\0"}function Ke(je,rt){for(var at=je+"",Rt,lt=0;lt<at.length;)rt[Me&lt]=Me&(Rt^=rt[Me&lt]*19)+at.charCodeAt(lt++);return $e(rt)}function Ye(){try{var je;return Le&&(je=Le.randomBytes)?je=je(ae):(je=new Uint8Array(ae),(I.crypto||I.msCrypto).getRandomValues(je)),$e(je)}catch{var rt=I.navigator,at=rt&&rt.plugins;return[+new Date,I,at,I.screen,$e(V)]}}function $e(je){return String.fromCharCode.apply(0,je)}if(Ke(re.random(),V),Z.exports){Z.exports=Ue;try{Le=__webpack_require__(653)}catch{}}else re["seed"+ue]=Ue})(typeof self<"u"?self:mr,[],Math)})(BY);var BM=BY.exports,Bh=Bl,Bj=Bn,Br=BH,S0=Bz,S1=BU,S2=Bu,S3=BM;S3.alea=Bh,S3.xor128=Bj,S3.xorwow=Br,S3.xorshift7=S0,S3.xor4096=S1,S3.tychei=S2;function S4(Z,I,V=1,re="float32"){if(V===0)throw new Error("Cannot have a step of zero");const ae={start:Z,stop:I,step:V,dtype:re};return JA.runKernel(md,{},ae)}function S5(Z){const I={x:Jv(Z,"x","relu")};return JA.runKernel(mb,I)}const S6=Ja({relu_:S5});function S7(Z){const I={x:Jv(Z,"x","relu6")};return JA.runKernel(mg,I)}const S8=Ja({relu6_:S7});function S9(Z){const I={x:Jv(Z,"x","round")};return JA.runKernel(mZ,I)}const SC=Ja({round_:S9});function Sm(Z){const I={x:Jv(Z,"x","sin","float32")};return JA.runKernel(ms,I)}const SN=Ja({sin_:Sm});function SJ(Z,I,V){const re=Jv(Z,"x","slice3d");return e(re.rank===3,()=>"slice3d expects a rank-3 tensor, but got a rank-"+re.rank+" tensor"),t0(re,I,V)}const Sf=Ja({slice3d_:SJ});function Si(Z,I,V=0){const re={x:Jv(Z,"x","split")},ae={numOrSizeSplits:I,axis:V};return JA.runKernel(mp,re,ae)}const SO=Ja({split_:Si});function St(Z,I){const V=Jv(Z,"x","squeeze","string_or_numeric");return Oz(V,L(V.shape,I).newShape)}const SB=Ja({squeeze_:St});function SS(Z,I=0){const V=Jq(Z,"tensors","stack","string_or_numeric");e(V.length>=1,()=>"Pass at least one tensor to tf.stack"),V.length>0&&e(I<=V[0].rank,()=>"Axis must be <= rank of the tensor");const re=V,ae={axis:I};return JA.runKernel(mO,re,ae)}const Sd=Ja({stack_:SS});function SV(Z,I=0){const V={x:Jv(Z,"x","step")},re={alpha:I};return JA.runKernel(mq,V,re)}const Sb=Ja({step_:SV});function SP(Z,I,V,re,ae=0,le=0,he=0,ue=0,pe=0){const ve={x:Jv(Z,"x","stridedSlice","string_or_numeric")},we={begin:I,end:V,strides:re,beginMask:ae,endMask:le,ellipsisMask:he,newAxisMask:ue,shrinkAxisMask:pe};return JA.runKernel(mX,ve,we)}const SE=Ja({stridedSlice_:SP});function SD(Z,I){s(Z);const V=JR(Z,I);if(V.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return JH(Z,null,V,I)}function Sg(Z,I,V){if(s(Z),I!=null&&I.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const re=JR(Z,V);if(re.length!==2&&re.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(re.length===1&&I==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return JH(Z,I,re,V)}function SZ(Z,I,V){const re=Jv(Z,"tensor","tensorScatterupdate"),ae=Jv(I,"indices","tensorScatterupdate","int32"),le=Jv(V,"updates","tensorScatterupdate");if(iY(le,ae,re.shape),re.dtype!==le.dtype)throw new Error("tensor and updates must have the same dtype, instead they are "+re.dtype+" and "+le.dtype+".");const he={tensor:re,indices:ae,updates:le},ue={};return JA.runKernel(mo,he,ue)}Ja({tensorScatterUpdate_:SZ});function So(Z,I=0){const V=Jv(Z,"x","unstack","string_or_numeric");e(I>=-V.shape.length&&I<V.shape.length,()=>"Axis = "+I+" is not in [-"+V.shape.length+", "+V.shape.length+")");const re={value:V},ae={axis:I};return JA.runKernel(mT,re,ae)}const Se=Ja({unstack_:So});function SQ(Z,I){const V=[];for(let le=0;le<I.length;le++)I[le]&&V.push(le);const re=t7(Z,"int32"),ae=t7([V.length,Z.length],"int32");for(let le=0;le<V.length;le++){const he=re.indexToLoc(V[le]),ue=le*Z.length;ae.values.set(he,ue)}return ae.toTensor()}function Ss(Z,I,V,re,ae,le="NHWC",he){let ue=Z;Z.rank===3&&(ue=Oz(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2]]));let pe=I;pe.rank===3&&(pe=Oz(I,[1,I.shape[0],I.shape[1],I.shape[2]])),e(ue.rank===4,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+ue.shape+"."),e(pe.rank===4,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+pe.shape+"."),e(V.length===4,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+V+".");const ve=le==="NHWC"?ue.shape[3]:ue.shape[1],we=le==="NHWC"?pe.shape[3]:pe.shape[1];e(ve===V[2],()=>"Error in conv2dDerFilter: depth of input "+ve+") must match input depth in filter ("+V[2]+"."),e(we===V[3],()=>"Error in conv2dDerFilter: depth of dy ("+we+") must match output depth for filter ("+V[3]+")."),OH("conv2dDerFilter",ae,he);const Me={x:ue,dy:pe},Le={strides:re,pad:ae,dataFormat:le,dimRoundingMode:he,filterShape:V};return JA.runKernel(CR,Me,Le)}const SF=Ja({conv2DBackpropFilter_:Ss});function SI(Z,I,V){if(V==null||V==="linear")return Z;if(V==="relu")return OD(Z,Sb(I));throw new Error("Cannot compute gradient for fused activation "+V+".")}function Sy(Z,I){let V=I;const re=iL(Z.shape,I.shape);return re.length>0&&(V=tG(V,re)),Oz(V,Z.shape)}function SA(Z,I,V,re){if(I==="linear")return Z;if(I==="relu")return S6(Z);if(I==="elu")return ty(Z);if(I==="relu6")return S8(Z);if(I==="prelu")return BT(Z,V);if(I==="leakyrelu")return BN(Z,re);if(I==="sigmoid")return Oj(Z);throw new Error("Unknown fused activation "+I+".")}const Sp=(Z,I)=>!(Z>0)||I==="linear";function Sw({x:Z,filter:I,strides:V,pad:re,dataFormat:ae="NHWC",dilations:le=[1,1],dimRoundingMode:he,bias:ue,activation:pe="linear",preluActivationWeights:ve,leakyreluAlpha:we}){if(pe=pe||"linear",Sp(JA.state.gradientDepth,pe)===!1){e(ae==="NHWC",()=>"Error in fused conv2d: got dataFormat of "+ae+" but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let at=tO(Z,I,V,re,ae,le,he);return ue!=null&&(at=OS(at,ue)),SA(at,pe,ve,we)}const Me=Jv(Z,"x","conv2d","float32"),Le=Jv(I,"filter","conv2d","float32");let Ue=Me,Ge=!1;Me.rank===3&&(Ge=!0,Ue=Oz(Me,[1,Me.shape[0],Me.shape[1],Me.shape[2]])),e(Ue.rank===4,()=>"Error in fused conv2d: input must be rank 4, but got rank "+Ue.rank+"."),e(Le.rank===4,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+Le.rank+"."),OH("fused conv2d",re,he);const ze=ae==="NHWC"?Ue.shape[3]:Ue.shape[1];e(Le.shape[2]===ze,()=>"Error in conv2d: depth of input ("+ze+") must match input depth for filter "+Le.shape[2]+"."),e(Oa(V,le),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+le+"'");const He=OA(Ue.shape,Le.shape,V,le,re,he);let Ke;ue!=null&&(Ke=Jv(ue,"bias","fused conv2d"),[Ke]=Jg(Ke,Me),ae==="NHWC"?iH(He.outShape,Ke.shape):(e(Ke.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-"+Ke.shape.length+"."),e(Ke.shape.length===0||Ke.shape[0]===He.outChannels||Ke.shape[0]===1,()=>"Error in fused conv2d: bias shape ("+Ke.shape+") is not compatible with the number of output channels ("+He.outChannels+")")));let Ye;if(ve!=null){const at=ve.shape;if(e(at.length<=1||at.length===3,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-"+at.length+"."),at.length===1)e(at[0]===1||at[0]===He.outChannels,()=>"Error in fused conv2d: PReLU activation weights ("+at+") is not compatible with the number of output channels ("+He.outChannels+").");else if(at.length===3)try{iH(at,He.outShape)}catch{const lt="Error in fused conv2d: PReLU activation weights ("+at+") is not compatible with the output shape of the conv2d ("+He.outShape+").";throw Error(lt)}Ye=Jv(ve,"prelu weights","fused conv2d")}const $e=(at,Rt)=>{e(ae==="NHWC",()=>"Error in gradient of fused conv2D: got dataFormat of "+ae+" but only NHWC is currently supported.");const[lt,kt,qt,Kt]=Rt,_i=SI(at,qt,pe);e(Ol(le),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+le+"'");const ci=tB(kt.shape,_i,lt,V,re),li=SF(kt,_i,lt.shape,V,re),qi=[ci,li];if(Kt!=null){const Ki=Sy(Kt,_i);qi.push(Ki)}return qi},je={x:Ue,filter:Le,bias:Ke,preluActivationWeights:Ye},rt={strides:V,pad:re,dataFormat:ae,dilations:le,dimRoundingMode:he,activation:pe,leakyreluAlpha:we};return ue==null?Bt((at,Rt,lt)=>{let kt=JA.runKernel(mL,je,rt);return lt([Rt,at,kt]),Ge&&(kt=Oz(kt,[kt.shape[1],kt.shape[2],kt.shape[3]])),{value:kt,gradFunc:$e}})(Ue,Le):Bt((at,Rt,lt,kt)=>{let qt=JA.runKernel(mL,je,rt);return kt([Rt,at,qt,lt]),Ge&&(qt=Oz(qt,[qt.shape[1],qt.shape[2],qt.shape[3]])),{value:qt,gradFunc:$e}})(Ue,Le,Ke)}const SX=Ja({fusedConv2d_:Sw});function Sc(Z,I,V,re,ae,le=[1,1],he){let ue=Z;Z.rank===3&&(ue=Oz(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2]]));let pe=I;pe.rank===3&&(pe=Oz(I,[1,I.shape[0],I.shape[1],I.shape[2]]));const ve={x:ue,dy:pe},we={strides:re,pad:ae,dimRoundingMode:he,dilations:le,filterShape:V};return JA.runKernel(Ca,ve,we)}const SW=Ja({depthwiseConv2dNativeBackpropFilter_:Sc});function SR(Z,I,V,re,ae,le=[1,1],he){let ue=I,pe=!1;I.rank===3&&(pe=!0,ue=Oz(I,[1,I.shape[0],I.shape[1],I.shape[2]]));const ve={dy:ue,filter:V},we={strides:re,pad:ae,dimRoundingMode:he,dilations:le,inputShape:Z},Me=JA.runKernel(Cn,ve,we);return pe?Oz(Me,[Me.shape[1],Me.shape[2],Me.shape[3]]):Me}const SK=Ja({depthwiseConv2dNativeBackpropInput_:SR});function ST({x:Z,filter:I,strides:V,pad:re,dataFormat:ae="NHWC",dilations:le=[1,1],dimRoundingMode:he,bias:ue,activation:pe="linear",preluActivationWeights:ve,leakyreluAlpha:we}){if(Sp(JA.state.gradientDepth,pe)===!1){let rt=tg(Z,I,V,re,ae,le,he);return ue!=null&&(rt=OS(rt,ue)),SA(rt,pe,ve,we)}const Me=Jv(Z,"x","depthwiseConv2d","float32"),Le=Jv(I,"filter","depthwiseConv2d","float32");let Ue=Me,Ge=!1;Me.rank===3&&(Ge=!0,Ue=Oz(Me,[1,Me.shape[0],Me.shape[1],Me.shape[2]])),e(Ue.rank===4,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+Ue.rank+"."),e(Le.rank===4,()=>"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+Le.rank+"."),e(Ue.shape[3]===Le.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels ("+Ue.shape[3]+") must match the inChannels dimension in filter "+Le.shape[2]+"."),le==null&&(le=[1,1]),e(Oa(V,le),()=>"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+le+"'"),OH("fused depthwiseConv2d",re,he);const ze=OA(Ue.shape,Le.shape,V,le,re,he,!0);let He;ue!=null&&(He=Jv(ue,"bias","fused conv2d"),[He]=Jg(He,Me),iH(ze.outShape,He.shape));let Ke;ve!=null&&(Ke=Jv(ve,"prelu weights","fused depthwiseConv2d"));const Ye=(rt,at)=>{e(Ol(le),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+le+"'");const[Rt,lt,kt,qt]=at,Kt=SI(rt,kt,pe),_i=SK(lt.shape,Kt,Rt,V,re,le,he),ci=SW(lt,Kt,Rt.shape,V,re,le,he);if(qt!=null){const li=Sy(He,Kt);return[_i,ci,li]}return[_i,ci]},$e={x:Ue,filter:Le,bias:He,preluActivationWeights:Ke},je={strides:V,pad:re,dataFormat:ae,dilations:le,dimRoundingMode:he,activation:pe,leakyreluAlpha:we};return ue==null?Bt((rt,at,Rt)=>{let lt=JA.runKernel(mH,$e,je);return Rt([at,rt,lt]),Ge&&(lt=Oz(lt,[lt.shape[1],lt.shape[2],lt.shape[3]])),{value:lt,gradFunc:Ye}})(Ue,Le):Bt((rt,at,Rt,lt)=>{let kt=JA.runKernel(mH,$e,je);return lt([at,rt,kt,Rt]),Ge&&(kt=Oz(kt,[kt.shape[1],kt.shape[2],kt.shape[3]])),{value:kt,gradFunc:Ye}})(Ue,Le,He)}const Sv=Ja({fusedDepthwiseConv2d_:ST});function Sq({a:Z,b:I,transposeA:V=!1,transposeB:re=!1,bias:ae,activation:le="linear",preluActivationWeights:he,leakyreluAlpha:ue=.2}){if(Sp(JA.state.gradientDepth,le)===!1){let qt=iX(Z,I,V,re);return ae!=null&&(qt=OS(qt,ae)),SA(qt,le,he,ue)}let pe=Jv(Z,"a","fused matMul"),ve=Jv(I,"b","fused matMul");[pe,ve]=Jg(pe,ve);const we=V?pe.shape[pe.rank-2]:pe.shape[pe.rank-1],Me=re?ve.shape[ve.rank-1]:ve.shape[ve.rank-2],Le=V?pe.shape[pe.rank-1]:pe.shape[pe.rank-2],Ue=re?ve.shape[ve.rank-2]:ve.shape[ve.rank-1],Ge=pe.shape.slice(0,-2),ze=ve.shape.slice(0,-2),He=F(Ge),Ke=F(ze);e(we===Me,()=>"Error in fused matMul: inner shapes ("+we+") and ("+Me+") of Tensors with shapes "+pe.shape+" and "+ve.shape+" and transposeA="+V+" and transposeB="+re+" must match.");const Ye=iH(pe.shape.slice(0,-2),ve.shape.slice(0,-2)).concat([Le,Ue]),$e=V?Oz(pe,[He,we,Le]):Oz(pe,[He,Le,we]),je=re?Oz(ve,[Ke,Ue,Me]):Oz(ve,[Ke,Me,Ue]);let rt;ae!=null&&(rt=Jv(ae,"bias","fused matMul"),[rt]=Jg(rt,pe),iH(Ye,rt.shape));let at;he!=null&&(at=Jv(he,"prelu weights","fused matMul"));const Rt=(qt,Kt)=>{const[_i,ci,li,qi]=Kt,Ki=SI(Oz(qt,li.shape),li,le);let hs,Yi;if(!V&&!re?(hs=iX(Ki,ci,!1,!0),Yi=iX(_i,Ki,!0,!1)):!V&&re?(hs=iX(Ki,ci,!1,!1),Yi=iX(Ki,_i,!0,!1)):V&&!re?(hs=iX(ci,Ki,!1,!0),Yi=iX(_i,Ki,!1,!1)):(hs=iX(ci,Ki,!0,!0),Yi=iX(Ki,_i,!0,!0)),ae!=null){const ns=Sy(qi,Ki);return[hs,Yi,ns]}else return[hs,Yi]},lt={a:$e,b:je,bias:rt,preluActivationWeights:at},kt={transposeA:V,transposeB:re,activation:le,leakyreluAlpha:ue};return ae==null?Bt((qt,Kt,_i)=>{const ci=JA.runKernel(mn,lt,kt);return _i([qt,Kt,ci]),{value:Oz(ci,Ye),gradFunc:Rt}})($e,je):Bt((qt,Kt,_i,ci)=>{const li=JA.runKernel(mn,lt,kt);return ci([qt,Kt,li,_i]),{value:Oz(li,Ye),gradFunc:Rt}})($e,je,rt)}const Sl=Ja({fusedMatMul_:Sq});function Sa(Z,I,V,re,ae="bilinear",le=0){const he=Jv(Z,"image","cropAndResize"),ue=Jv(I,"boxes","cropAndResize","float32"),pe=Jv(V,"boxInd","cropAndResize","int32"),ve=ue.shape[0];e(he.rank===4,()=>"Error in cropAndResize: image must be rank 4,but got rank "+he.rank+"."),e(ue.rank===2&&ue.shape[1]===4,()=>"Error in cropAndResize: boxes must be have size ["+ve+",4] but had shape "+ue.shape+"."),e(pe.rank===1&&pe.shape[0]===ve,()=>"Error in cropAndResize: boxInd must be have size ["+ve+"] but had shape "+ue.shape+"."),e(re.length===2,()=>"Error in cropAndResize: cropSize must be of length 2, but got length "+re.length+"."),e(re[0]>=1&&re[1]>=1,()=>"cropSize must be atleast [1,1], but was "+re),e(ae==="bilinear"||ae==="nearest",()=>"method must be bilinear or nearest, but was "+ae);const we={image:he,boxes:ue,boxInd:pe},Me={method:ae,extrapolationValue:le,cropSize:re};return JA.runKernel(Cv,we,Me)}const Sn=Ja({cropAndResize_:Sa});function SL(Z){const I=Jv(Z,"image","flipLeftRight","float32");e(I.rank===4,()=>"Error in flipLeftRight: image must be rank 4,but got rank "+I.rank+".");const V={image:I};return JA.runKernel(CU,V,{})}const SH=Ja({flipLeftRight_:SL});function Sk(Z){const I=Jv(Z,"image","grayscaleToRGB"),V=I.rank-1,re=I.shape[V];e(I.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, but got rank "+I.rank+"."),e(re===1,()=>"Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size "+re+".");const ae=new Array(I.rank);return ae.fill(1,0,V),ae[V]=3,B2(I,ae)}const Sz=Ja({grayscaleToRGB_:Sk});function Sx(Z){const I=Jv(Z,"image","RGBToGrayscale"),V=I.rank-1,re=I.shape[V];e(I.rank>=2,()=>"Error in RGBToGrayscale: images must be at least rank 2, but got rank "+I.rank+"."),e(re===3,()=>"Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size "+re+".");const ae=I.dtype,le=ip(I,"float32"),he=SD([.2989,.587,.114]);let ue;switch(I.rank){case 2:ue=tF("ij,j->i",le,he);break;case 3:ue=tF("ijk,k->ij",le,he);break;case 4:ue=tF("ijkl,l->ijk",le,he);break;case 5:ue=tF("ijklm,m->ijkl",le,he);break;case 6:ue=tF("ijklmn,n->ijklm",le,he);break;default:throw new Error("Not a valid tensor rank.")}return ue=B0(ue,-1),ip(ue,ae)}const SU=Ja({rgbToGrayscale_:Sx});function SG(Z,I,V=0,re=.5){const ae=Jv(Z,"image","rotateWithOffset","float32");e(ae.rank===4,()=>"Error in rotateWithOffset: image must be rank 4,but got rank "+ae.rank+".");const le={image:ae},he={radians:I,fillValue:V,center:re};return JA.runKernel(ma,le,he)}const Su=Ja({rotateWithOffset_:SG});function SY(Z,I,V,re,ae,le){re==null&&(re=.5),ae==null&&(ae=Number.NEGATIVE_INFINITY),le==null&&(le=0);const he=Z.shape[0];return V=Math.min(V,he),e(0<=re&&re<=1,()=>"iouThreshold must be in [0, 1], but was '"+re+"'"),e(Z.rank===2,()=>"boxes must be a 2D tensor, but was of rank '"+Z.rank+"'"),e(Z.shape[1]===4,()=>"boxes must have 4 columns, but 2nd dimension was "+Z.shape[1]),e(I.rank===1,()=>"scores must be a 1D tensor"),e(I.shape[0]===he,()=>"scores has incompatible shape with boxes. Expected "+he+", but was "+I.shape[0]),e(0<=le&&le<=1,()=>"softNmsSigma must be in [0, 1], but was '"+le+"'"),{maxOutputSize:V,iouThreshold:re,scoreThreshold:ae,softNmsSigma:le}}function SM(Z,I,V,re=.5,ae=Number.NEGATIVE_INFINITY){const le=Jv(Z,"boxes","nonMaxSuppression","float32"),he=Jv(I,"scores","nonMaxSuppression","float32"),ue=SY(le,he,V,re,ae);V=ue.maxOutputSize,re=ue.iouThreshold,ae=ue.scoreThreshold;const pe={maxOutputSize:V,iouThreshold:re,scoreThreshold:ae};return JA.runKernel(mJ,{boxes:le,scores:he},pe)}const Sh=Ja({nonMaxSuppression_:SM});function Sj(Z,I,V){const re=Sr(Z,I,V),ae=re<0?-(re+1):re;Z.splice(ae,0,I)}function Sr(Z,I,V){return d1(Z,I,V||d0)}function d0(Z,I){return Z>I?1:Z<I?-1:0}function d1(Z,I,V){let re=0,ae=Z.length,le=0,he=!1;for(;re<ae;){le=re+(ae-re>>>1);const ue=V(I,Z[le]);ue>0?re=le+1:(ae=le,he=!ue)}return he?re:-re-1}function d2(Z,I,V,re,ae){return d5(Z,I,V,re,ae,0)}function d3(Z,I,V,re,ae,le){return d5(Z,I,V,re,ae,0,!1,le,!0)}function d4(Z,I,V,re,ae,le){return d5(Z,I,V,re,ae,le,!0)}function d5(Z,I,V,re,ae,le,he=!1,ue=!1,pe=!1){const ve=[];for(let He=0;He<I.length;He++)I[He]>ae&&ve.push({score:I[He],boxIndex:He,suppressBeginIndex:0});ve.sort(d8);const we=le>0?-.5/le:0,Me=[],Le=[];for(;Me.length<V&&ve.length>0;){const He=ve.pop(),{score:Ke,boxIndex:Ye,suppressBeginIndex:$e}=He;if(Ke<ae)break;let je=!1;for(let rt=Me.length-1;rt>=$e;--rt){const at=d6(Z,Ye,Me[rt]);if(at>=re){je=!0;break}if(He.score=He.score*d7(re,we,at),He.score<=ae)break}He.suppressBeginIndex=Me.length,je||(He.score===Ke?(Me.push(Ye),Le.push(He.score)):He.score>ae&&Sj(ve,He,d8))}const Ue=Me.length,Ge=V-Ue;ue&&Ge>0&&(Me.push(...new Array(Ge).fill(0)),Le.push(...new Array(Ge).fill(0)));const ze={selectedIndices:Me};return he&&(ze.selectedScores=Le),pe&&(ze.validOutputs=Ue),ze}function d6(Z,I,V){const re=Z.subarray(I*4,I*4+4),ae=Z.subarray(V*4,V*4+4),le=Math.min(re[0],re[2]),he=Math.min(re[1],re[3]),ue=Math.max(re[0],re[2]),pe=Math.max(re[1],re[3]),ve=Math.min(ae[0],ae[2]),we=Math.min(ae[1],ae[3]),Me=Math.max(ae[0],ae[2]),Le=Math.max(ae[1],ae[3]),Ue=(ue-le)*(pe-he),Ge=(Me-ve)*(Le-we);if(Ue<=0||Ge<=0)return 0;const ze=Math.max(le,ve),He=Math.max(he,we),Ke=Math.min(ue,Me),Ye=Math.min(pe,Le),$e=Math.max(Ke-ze,0)*Math.max(Ye-He,0);return $e/(Ue+Ge-$e)}function d7(Z,I,V){const re=Math.exp(I*V*V);return V<=Z?re:0}function d8(Z,I){return Z.score-I.score||Z.score===I.score&&I.boxIndex-Z.boxIndex}async function d9(Z,I,V,re=.5,ae=Number.NEGATIVE_INFINITY){const le=Jv(Z,"boxes","nonMaxSuppressionAsync"),he=Jv(I,"scores","nonMaxSuppressionAsync"),ue=SY(le,he,V,re,ae);V=ue.maxOutputSize,re=ue.iouThreshold,ae=ue.scoreThreshold;const pe=await Promise.all([le.data(),he.data()]),ve=pe[0],we=pe[1],{selectedIndices:Me}=d2(ve,we,V,re,ae);return le!==Z&&le.dispose(),he!==I&&he.dispose(),SD(Me,"int32")}const dC=d9;function dm(Z,I,V,re=.5,ae=Number.NEGATIVE_INFINITY,le=0){const he=Jv(Z,"boxes","nonMaxSuppression"),ue=Jv(I,"scores","nonMaxSuppression"),pe=SY(he,ue,V,re,ae,le);V=pe.maxOutputSize,re=pe.iouThreshold,ae=pe.scoreThreshold,le=pe.softNmsSigma;const ve={boxes:he,scores:ue},we={maxOutputSize:V,iouThreshold:re,scoreThreshold:ae,softNmsSigma:le},Me=JA.runKernel(mi,ve,we);return{selectedIndices:Me[0],selectedScores:Me[1]}}const dN=Ja({nonMaxSuppressionWithScore_:dm});async function dJ(Z,I,V,re=.5,ae=Number.NEGATIVE_INFINITY,le=0){const he=Jv(Z,"boxes","nonMaxSuppressionAsync"),ue=Jv(I,"scores","nonMaxSuppressionAsync"),pe=SY(he,ue,V,re,ae,le);V=pe.maxOutputSize,re=pe.iouThreshold,ae=pe.scoreThreshold,le=pe.softNmsSigma;const ve=await Promise.all([he.data(),ue.data()]),we=ve[0],Me=ve[1],{selectedIndices:Le,selectedScores:Ue}=d4(we,Me,V,re,ae,le);return he!==Z&&he.dispose(),ue!==I&&ue.dispose(),{selectedIndices:SD(Le,"int32"),selectedScores:SD(Ue)}}const df=dJ;function di(Z,I,V,re=.5,ae=Number.NEGATIVE_INFINITY,le=!1){const he=Jv(Z,"boxes","nonMaxSuppression"),ue=Jv(I,"scores","nonMaxSuppression"),pe=SY(he,ue,V,re,ae,null),ve=pe.maxOutputSize,we=pe.iouThreshold,Me=pe.scoreThreshold,Le={boxes:he,scores:ue},Ue={maxOutputSize:ve,iouThreshold:we,scoreThreshold:Me,padToMaxOutputSize:le},Ge=JA.runKernel(mf,Le,Ue);return{selectedIndices:Ge[0],validOutputs:Ge[1]}}const dO=Ja({nonMaxSuppressionPadded_:di});async function dt(Z,I,V,re=.5,ae=Number.NEGATIVE_INFINITY,le=!1){const he=Jv(Z,"boxes","nonMaxSuppressionAsync"),ue=Jv(I,"scores","nonMaxSuppressionAsync"),pe=SY(he,ue,V,re,ae,null),ve=pe.maxOutputSize,we=pe.iouThreshold,Me=pe.scoreThreshold,[Le,Ue]=await Promise.all([he.data(),ue.data()]),{selectedIndices:Ge,validOutputs:ze}=d3(Le,Ue,ve,we,Me,le);return he!==Z&&he.dispose(),ue!==I&&ue.dispose(),{selectedIndices:SD(Ge,"int32"),validOutputs:tL(ze,"int32")}}const dB=dt;function dS(Z,I,V=!1,re=!1){const ae=Jv(Z,"images","resizeBilinear");e(ae.rank===3||ae.rank===4,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+ae.rank+"."),e(I.length===2,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+I+"."),e(re===!1||V===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let le=ae,he=!1;ae.rank===3&&(he=!0,le=Oz(ae,[1,ae.shape[0],ae.shape[1],ae.shape[2]]));const ue={images:le},pe={alignCorners:V,halfPixelCenters:re,size:I},ve=JA.runKernel(mD,ue,pe);return he?Oz(ve,[ve.shape[1],ve.shape[2],ve.shape[3]]):ve}const dd=Ja({resizeBilinear_:dS});function dV(Z,I,V=!1,re=!1){const ae=Jv(Z,"images","resizeNearestNeighbor");e(ae.rank===3||ae.rank===4,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+ae.rank+"."),e(I.length===2,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+I+"."),e(ae.dtype==="float32"||ae.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),e(re===!1||V===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let le=ae,he=!1;ae.rank===3&&(he=!0,le=Oz(ae,[1,ae.shape[0],ae.shape[1],ae.shape[2]]));const ue={images:le},pe={alignCorners:V,halfPixelCenters:re,size:I},ve=JA.runKernel(mE,ue,pe);return he?Oz(ve,[ve.shape[1],ve.shape[2],ve.shape[3]]):ve}const db=Ja({resizeNearestNeighbor_:dV});function dP(Z,I="binary",V=!1,re=.5){const ae=Jv(Z,"image","threshold"),le=.2989,he=.587,ue=.114,pe=ae.shape[0]*ae.shape[1];let ve=OD(SD([re]),255),we,Me,Le,Ue;if(e(ae.rank===3,()=>"Error in threshold: image must be rank 3,but got rank "+ae.rank+"."),e(ae.shape[2]===3||ae.shape[2]===1,()=>"Error in threshold: image color channel must be equal to 3 or 1but got "+ae.shape[2]+"."),e(ae.dtype==="int32"||ae.dtype==="float32",()=>"Error in dtype: image dtype must be int32 or float32,but got dtype "+ae.dtype+"."),e(I==="otsu"||I==="binary",()=>"Method must be binary or otsu, but was "+I),ae.shape[2]===3){[we,Me,Le]=SO(ae,[1,1,1],-1);const ze=OD(we,le),He=OD(Me,he),Ke=OD(Le,ue);Ue=OS(OS(ze,He),Ke)}else Ue=Z;if(I==="otsu"){const ze=t4(ip(SC(Ue),"int32"),Jk([]),256);ve=dE(ze,pe)}const Ge=V?BO(Ue,ve):B8(Ue,ve);return ip(OD(Ge,255),"int32")}function dE(Z,I){let V=SD([-1]),re=SD([0]),ae=SD([0]),le,he,ue,pe,ve,we;for(let Me=0;Me<Z.size-1;Me++){le=t0(Z,0,Me+1),he=t0(Z,Me+1),ve=OP(tG(le),I),we=OP(tG(he),I);const Le=tG(OD(le,S4(0,le.size)));ue=OP(Le,tG(le));const Ue=t8(he.shape,le.size),Ge=OS(S4(0,he.size),Ue),ze=OD(he,Ge);pe=OP(tG(ze),tG(he));const He=BS(ue,pe),Ke=BS(ue,pe),Ye=OD(ve,we);ae=OD(OD(Ye,He),Ke);const $e=B8(ae,re);re=to($e,ae,re),V=to($e,SD([Me]),V)}return V}const dD=Ja({threshold_:dP});function dg(Z,I,V="nearest",re="constant",ae=0,le){const he=Jv(Z,"image","transform","float32"),ue=Jv(I,"transforms","transform","float32");e(he.rank===4,()=>"Error in transform: image must be rank 4,but got rank "+he.rank+"."),e(ue.rank===2&&(ue.shape[0]===he.shape[0]||ue.shape[0]===1)&&ue.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),e(le==null||le.length===2,()=>"Error in transform: outputShape must be [height, width] or null, but got "+le+".");const pe={image:he,transforms:ue},ve={interpolation:V,fillMode:re,fillValue:ae,outputShape:le};return JA.runKernel(mR,pe,ve)}const dZ=Ja({transform_:dg});var de;(function(Z){Z[Z.NONE=0]="NONE",Z[Z.MEAN=1]="MEAN",Z[Z.SUM=2]="SUM",Z[Z.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(de||(de={}));const dQ={flipLeftRight:SH,grayscaleToRGB:Sz,resizeNearestNeighbor:db,resizeBilinear:dd,rgbToGrayscale:SU,rotateWithOffset:Su,cropAndResize:Sn,nonMaxSuppression:Sh,nonMaxSuppressionAsync:dC,nonMaxSuppressionWithScore:dN,nonMaxSuppressionWithScoreAsync:df,nonMaxSuppressionPadded:dO,nonMaxSuppressionPaddedAsync:dB,threshold:dD,transform:dZ},ds=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:Z=>Z())();function dF(){return new Promise(Z=>ds(()=>Z()))}function dI(Z,I){const V=Z[0].length;Z.forEach((ae,le)=>{e(ae.length===V,()=>"Error in concat"+V+"D: rank of tensors["+le+"] must be the same as the rank of the rest ("+V+")")}),e(I>=0&&I<V,()=>"Error in concat"+V+"D: axis must be between 0 and "+(V-1)+".");const re=Z[0];Z.forEach((ae,le)=>{for(let he=0;he<V;he++)e(he===I||ae[he]===re[he],()=>"Error in concat"+V+"D: Shape of tensors["+le+"] ("+ae+") does not match the shape of the rest ("+re+") along the non-concatenated axis "+le+".")})}function dy(Z,I){const V=Z[0].slice();for(let re=1;re<Z.length;re++)V[I]+=Z[re][I];return V}var dA;(function(Z){Z[Z.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",Z[Z.VALUE_ROWIDS=1]="VALUE_ROWIDS",Z[Z.ROW_LENGTHS=2]="ROW_LENGTHS",Z[Z.ROW_SPLITS=3]="ROW_SPLITS",Z[Z.ROW_LIMITS=4]="ROW_LIMITS",Z[Z.ROW_STARTS=5]="ROW_STARTS"})(dA||(dA={}));function dp(Z,I,V){let re=new Array;if(V==null&&I==null)return re;if(I==null)for(;re.length<Z+V.length;)re.push(-1);else re=I.slice();if(V==null)return re;if(Z+V.length!==re.length)throw new Error("rt input.shape and shape="+I+" are incompatible: rt input.rank = "+(Z+V.length)+", but shape.rank = "+re.length);for(let ae=1;ae<V.length;++ae){const le=V[ae],he=re[re.length-V.length+ae],ue=re[he];if(le>=0)if(ue>=0){if(ue!==le)throw new Error("rt input.shape and shape="+I+" are incompatible: rt input.shape["+(ae+Z)+"] = "+le+" but shape["+(ae+Z)+"] = "+ue)}else re[he]=le}return re}function dw(Z){const I={FIRST_DIM_SIZE:dA.FIRST_DIM_SIZE,VALUE_ROWIDS:dA.VALUE_ROWIDS,ROW_LENGTHS:dA.ROW_LENGTHS,ROW_SPLITS:dA.ROW_SPLITS,ROW_LIMITS:dA.ROW_LIMITS,ROW_STARTS:dA.ROW_STARTS},V=[];for(const re of Z)if(re in I)V.push(I[re]);else break;return V}function dX(Z){return Z.length===0?0:Z[0]===dA.FIRST_DIM_SIZE?Z.length-1:Z.length}function dc(Z,I){if(Z==null||I==null)return;const V=Z.length,re=I.length;if(V>=re)throw new Error("defaultValue.shape="+Z+" and ragged tensor flatValues.shape="+I+", are incompatible: defaultValue.rank = "+V+" must be less than ragged tensor input flatValues.rank = "+re+")");for(let ae=0;ae<Math.min(V,re-1);++ae){const le=Z[ae],he=I[ae+1];if(le>=0&&he>=0&&le!==1&&le!==he)throw new Error("defaultValue.shape="+Z+", and ragged tensor input flatValues.shape="+I+" are incompatible: defaultValue.shape["+(ae-Z.length)+"] = "+le+" but ragged tensor input.flatValues.shape["+(ae-Z.length)+"] = "+he)}}const dW=30;function dR(Z){return Z<=dW?Z:C4(Z,Math.floor(Math.sqrt(Z)))}function dK(Z,I,V){const re=V*(typeof Z=="number"?Z:Z[0]),ae=I*(typeof Z=="number"?Z:Z[1]);return[re,ae]}function dT(Z,I,V,re=!0){let ae=[];if(re)ae=ae.concat(I.slice(0)),ae.push(Z[0]/V),ae=ae.concat(Z.slice(1));else{ae=ae.concat(Z[0]);const le=I.length;for(let he=0;he<le;++he)ae=ae.concat([Z[he+1]/I[he],I[he]]);ae=ae.concat(Z.slice(le+1))}return ae}function dv(Z,I,V=!0){const re=[];if(V){re.push(I);for(let ae=I+1;ae<Z;++ae)ae<=2*I?(re.push(ae),re.push(ae-(I+1))):re.push(ae)}else{const ae=[],le=[];for(let he=1;he<Z;++he)he>=I*2+1||he%2===1?le.push(he):ae.push(he);re.push(...ae),re.push(0),re.push(...le)}return re}function dq(Z,I,V,re=!0){const ae=[];re?ae.push(Z[0]/V):ae.push(Z[0]*V);for(let le=1;le<Z.length;++le)le<=I.length?re?ae.push(I[le-1]*Z[le]):ae.push(Z[le]/I[le-1]):ae.push(Z[le]);return ae}function dl(Z,I){const V=[0];for(let re=0;re<I;++re)V.push(Z[re][0]);return V}function da(Z,I,V){const re=Z.slice(0,1);for(let ae=0;ae<V;++ae)re.push(Z[ae+1]-I[ae][0]-I[ae][1]);return re}const dn=1.7580993408473768,dL=1.0507009873554805,dH=.3275911,dk=.254829592,dz=-.284496736,dx=1.421413741,dU=-1.453152027,dG=1.061405429;function du(Z,I){if(Z.length!==I.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+Z.length+", imag: "+I.length+".");const V=new Float32Array(Z.length*2);for(let re=0;re<V.length;re+=2)V[re]=Z[re/2],V[re+1]=I[re/2];return V}function dY(Z){const I=new Float32Array(Z.length/2),V=new Float32Array(Z.length/2);for(let re=0;re<Z.length;re+=2)I[re/2]=Z[re],V[re/2]=Z[re+1];return{real:I,imag:V}}function dM(Z){const I=Math.ceil(Z.length/4),V=new Float32Array(I),re=new Float32Array(I);for(let ae=0;ae<Z.length;ae+=4)V[Math.floor(ae/4)]=Z[ae],re[Math.floor(ae/4)]=Z[ae+1];return{real:V,imag:re}}function dh(Z){const I=Math.floor(Z.length/4),V=new Float32Array(I),re=new Float32Array(I);for(let ae=2;ae<Z.length;ae+=4)V[Math.floor(ae/4)]=Z[ae],re[Math.floor(ae/4)]=Z[ae+1];return{real:V,imag:re}}function dj(Z,I){const V=Z[I*2],re=Z[I*2+1];return{real:V,imag:re}}function dr(Z,I,V,re){Z[re*2]=I,Z[re*2+1]=V}function V0(Z,I){const V=new Float32Array(Z/2),re=new Float32Array(Z/2);for(let ae=0;ae<Math.ceil(Z/2);ae++){const le=(I?2:-2)*Math.PI*(ae/Z);V[ae]=Math.cos(le),re[ae]=Math.sin(le)}return{real:V,imag:re}}function V1(Z,I,V){const re=(V?2:-2)*Math.PI*(Z/I),ae=Math.cos(re),le=Math.sin(re);return{real:ae,imag:le}}const V2="->",V3=/->/g,V4=",",V5="...";function V6(Z,I){Z=Z.replace(/\s/g,"");const V=(Z.length-Z.replace(V3,"").length)/V2.length;if(V<1)throw new Error("Equations without an arrow are not supported.");if(V>1)throw new Error('Equation must contain exactly one arrow ("'+V2+'").');const[re,ae]=Z.split(V2);e(re.indexOf(V5)===-1,()=>'The ellipsis notation ("'+V5+'") is not supported yet.');const le=re.split(V4),he=le.length;if(I!==he)throw new Error("Expected "+he+" input tensors, received "+I);if(he>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const ue=[];for(let Le=0;Le<ae.length;++Le){const Ue=ae[Le];if(!le.some(Ge=>Ge.indexOf(Ue)!==-1))throw new Error("Output subscripts contain the label "+Ue+" not present in the input subscripts.");ue.indexOf(Ue)===-1&&ue.push(Ue)}for(let Le=0;Le<re.length;++Le){const Ue=re[Le];ue.indexOf(Ue)===-1&&Ue!==V4&&ue.push(Ue)}const pe=new Array(le.length);for(let Le=0;Le<he;++Le){if(new Set(le[Le].split("")).size!==le[Le].length)throw new Error("Found duplicate axes in input component "+le[Le]+". Support for duplicate axes in input is not implemented yet.");pe[Le]=[];for(let Ue=0;Ue<le[Le].length;++Ue)pe[Le].push(ue.indexOf(le[Le][Ue]))}const ve=ue.length,we=ae.length,Me=[];for(let Le=we;Le<ve;++Le)Me.push(Le);return{allDims:ue,summedDims:Me,idDims:pe}}function V7(Z,I){let V=new Array(Z);V.fill(-1);for(let ae=0;ae<I.length;++ae)V[I[ae]]=ae;const re=[];for(let ae=0;ae<Z;++ae)V[ae]===-1&&re.push(ae);return V=V.filter(ae=>ae!==-1),{permutationIndices:V,expandDims:re}}function V8(Z,I,V){const re=new Array(Z);for(let ae=0;ae<V.length;++ae){const le=V[ae].shape;for(let he=0;he<I[ae].length;++he)re[I[ae][he]]===void 0?re[I[ae][he]]=le[he]:e(re[I[ae][he]]===le[he],()=>"Expected dimension "+re[I[ae][he]]+" at axis "+he+" of input shaped "+JSON.stringify(le)+", but got dimension "+le[he])}}function V9(Z,I){const V=Z,re=[];let ae=0;Z.length===0&&V.push(-1),ae=Z.length+1;for(let he=0;he<ae;++he)re.push([]);const le=[];for(let he=0;he<V.length;++he){const ue=V[he],pe=Vm(I,ue);for(const ve of pe)le.indexOf(ve)===-1&&(re[he].push(ve),le.push(ve))}return{path:V,steps:re}}function VC(Z){return Z.every((I,V)=>I===V)}function Vm(Z,I){const V=[];for(let re=0;re<Z.length;++re)(Z[re].length===0||Z[re].indexOf(I)!==-1||I===-1)&&V.push(re);return V}function VN(Z,I,V=0){let re=[];if(typeof I=="number")e(Z.shape[V]%I===0,()=>"Number of splits must evenly divide the axis."),re=new Array(I).fill(Z.shape[V]/I);else{const ae=I.reduce((he,ue)=>(ue===-1&&(he+=1),he),0);e(ae<=1,()=>"There should be only one negative value in split array.");const le=I.indexOf(-1);if(le!==-1){const he=I.reduce((ue,pe)=>pe>0?ue+pe:ue);I[le]=Z.shape[V]-he}e(Z.shape[V]===I.reduce((he,ue)=>he+ue),()=>"The sum of sizes must match the size of the axis dimension."),re=I}return re}function VJ(Z){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = `+Z}function Vf(Z,I){return"indices("+Z+", 0) is invalid: "+I+" < 0"}function Vi(Z,I,V){return"indices("+Z+", 0) is invalid: "+I+" >= "+V}function VO(Z,I){return"only one output dimension may be -1, not both "+Z+" and "+I}function Vt(Z,I){return"size "+Z+" must be non-negative, not "+I}function VB(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function VS(Z,I){const V=F(Z),re=F(I);return"Input to reshape is a SparseTensor with "+V+`
  dense values, but the requested shape requires a multiple of `+re+". inputShape="+Z+" outputShape= "+I}function Vd(Z,I){const V=F(Z),re=F(I);return"Input to reshape is a tensor with "+V+" dense values, but the requested shape has "+re+". inputShape="+Z+" outputShape="+I}function VV(){return"segment ids must be >= 0"}function Vb(){return"segment ids are not increasing"}function VP(Z,I){return"Segment id "+Z+" out of range [0, "+I+"), possibly because segmentIds input is not sorted."}function VE(Z,I,V){return"Bad: indices["+Z+"] == "+I+" out of range [0, "+V+")"}function VD(Z,I){let V=!1,re;for(Z<=dW?(re=Z,V=!0):re=C4(Z,Math.floor(Math.sqrt(Z)));!V;)re>I||re===Z?V=!0:re=C4(Z,re+1);return re}function Vg(Z,I,V){const re=[],ae=Z.length;for(let le=0;le<ae;le++)le!==I?re.push(Z[le]):re.push(V);return re}function VZ(Z,I,V,re){const ae=I.shape.length,le=Z.shape.length;if(re!==0&&(re<-ae||re>ae))throw new Error("Expect batchDims in the range of [-"+ae+", "+ae+"], but got "+re);if(re<0&&(re+=ae),re>le)throw new Error("batchDims ("+re+`) must be less than rank(x) (
    `+le+").");if(V<re)throw new Error("batchDims ("+re+") must be less than or equal to axis ("+V+").");for(let Me=0;Me<re;++Me)if(Z.shape[Me]!==I.shape[Me])throw new Error("x.shape["+Me+"]: "+Z.shape[Me]+" should be equal to indices.shape["+Me+"]: "+I.shape[Me]+".");const he=Z.shape[V],ue=[];let pe=1,ve=1,we=1;for(let Me=0;Me<re;++Me)ue.push(Z.shape[Me]),pe*=Z.shape[Me];for(let Me=re;Me<V;Me++)ue.push(Z.shape[Me]),ve*=Z.shape[Me];for(let Me=re;Me<ae;Me++)ue.push(I.shape[Me]);for(let Me=V+1;Me<le;Me++)ue.push(Z.shape[Me]),we*=Z.shape[Me];return{batchSize:pe,sliceSize:we,outerSize:ve,dimSize:he,outputShape:ue}}var Vo=Object.freeze({__proto__:null,collectGatherOpShapeInfo:VZ,computeOutShape:Vg,segOpComputeOptimalWindowSize:VD});function Ve(Z){try{return Z.map(I=>Nx(I))}catch(I){throw new Error("Failed to decode encoded string bytes into utf-8, error: "+I)}}function VQ(Z){return Z.map(I=>Nz(I))}var Vs=Object.freeze({__proto__:null,ERF_A1:dk,ERF_A2:dz,ERF_A3:dx,ERF_A4:dU,ERF_A5:dG,ERF_P:dH,PARALLELIZE_THRESHOLD:dW,get RowPartitionType(){return dA},SELU_SCALE:dL,SELU_SCALEALPHA:dn,applyActivation:SA,assertAndGetBroadcastShape:iH,assertAxesAreInnerMostDims:tc,assertParamsConsistent:dI,assignToTypedArray:dr,axesAreInnerMostDims:tA,calculateShapes:iM,checkEinsumDimSizes:V8,checkPadOnDimRoundingMode:OH,combineLocations:tp,combineRaggedTensorToTensorShapes:dp,complexWithEvenIndex:dM,complexWithOddIndex:dh,computeConv2DInfo:OA,computeConv3DInfo:Op,computeDefaultPad:Oc,computeDilation2DInfo:OF,computeOptimalWindowSize:dR,computeOutAndReduceShapes:tw,computeOutShape:dy,computePool2DInfo:OI,computePool3DInfo:Oy,convertConv2DDataFormat:OL,decodeEinsumEquation:V6,eitherStridesOrDilationsAreOne:Oa,expandShapeToKeepDim:tX,exponent:V1,exponents:V0,fromStringArrayToUint8:VQ,fromUint8ToStringArray:Ve,getAxesPermutation:tW,getBroadcastDims:ia,getComplexWithIndex:dj,getEinsumComputePath:V9,getEinsumPermutation:V7,getFusedBiasGradient:Sy,getFusedDyActivation:SI,getImageCenter:dK,getInnerMostAxes:tK,getPermuted:dv,getRaggedRank:dX,getReductionAxes:iL,getReshaped:dT,getReshapedPermuted:dq,getRowPartitionTypesHelper:dw,getSliceBeginCoords:dl,getSliceSize:da,getSparseFillEmptyRowsIndicesDenseShapeMismatch:VJ,getSparseFillEmptyRowsNegativeIndexErrorMessage:Vf,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Vi,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:VB,getSparseReshapeInputOutputMismatchErrorMessage:Vd,getSparseReshapeInputOutputMultipleErrorMessage:VS,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:VO,getSparseReshapeNegativeOutputDimErrorMessage:Vt,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:VE,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:VV,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Vb,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:VP,getUndoAxesPermutation:tR,isIdentityPermutation:VC,log:mz,mergeRealAndImagArrays:du,prepareAndValidate:iG,prepareSplitSize:VN,segment_util:Vo,shouldFuse:Sp,slice_util:Ot,splitRealAndImagArrays:dY,stridesOrDilationsArePositive:On,tupleValuesAreOne:Ol,upcastType:Jb,validateDefaultValueShape:dc,validateInput:iY,validateUpdateShape:iu,warn:mk});class VF{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(I,V){return fetch(I,V)}now(){return performance.now()}encode(I,V){if(V!=="utf-8"&&V!=="utf8")throw new Error("Browser's encoder only supports utf-8, but got "+V);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(I)}decode(I,V){return new TextDecoder(V).decode(I)}setTimeoutCustom(I,V){if(typeof window>"u"||!Cd().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(I,V);return}this.functionRefs.push(I),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},V),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",re=>{if(re.source===window&&re.data.name===this.messageName){re.stopPropagation();const ae=this.functionRefs[re.data.index];ae(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(I){return mj(I)}}if(Cd().get("IS_BROWSER")){Cd().setPlatform("browser",new VF);try{ig.registerManager(fx.URL_SCHEME,new fu)}catch{}try{ig.registerManager(fw.URL_SCHEME,new fR)}catch{}}const VI={importFetch:()=>__webpack_require__(300)};let Vy;class VA{constructor(){this.util=__webpack_require__(539),this.textEncoder=new this.util.TextEncoder}fetch(I,V){return Cd().global.fetch!=null?Cd().global.fetch(I,V):(Vy==null&&(Vy=VI.importFetch()),Vy(I,V))}now(){const I=process.hrtime();return I[0]*1e3+I[1]/1e6}encode(I,V){if(V!=="utf-8"&&V!=="utf8")throw new Error("Node built-in encoder only supports utf-8, but got "+V);return this.textEncoder.encode(I)}decode(I,V){return I.length===0?"":new this.util.TextDecoder(V).decode(I)}isTypedArray(I){return this.util.types.isFloat32Array(I)||this.util.types.isInt32Array(I)||this.util.types.isUint8Array(I)||this.util.types.isUint8ClampedArray(I)}}Cd().get("IS_NODE")&&!Cd().get("IS_BROWSER")&&Cd().setPlatform("node",new VA),Jy();const Vp={buffer:t7,cast:ip,clone:Ou,print:Bv};JN(Vp);var Vw=Object.defineProperty,VX=Object.getOwnPropertySymbols,Vc=Object.prototype.hasOwnProperty,VW=Object.prototype.propertyIsEnumerable,VR=(Z,I,V)=>I in Z?Vw(Z,I,{enumerable:!0,configurable:!0,writable:!0,value:V}):Z[I]=V,VK=(Z,I)=>{for(var V in I||(I={}))Vc.call(I,V)&&VR(Z,V,I[V]);if(VX)for(var V of VX(I))VW.call(I,V)&&VR(Z,V,I[V]);return Z};class VT{constructor(I){this.model=I,this.posesMax=1,this.iouThresh=.3,this.scoreThresh=.5,this.model=I,this.modelSize=I.inputs[0].shape?{width:I.inputs[0].shape[2],height:I.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=SD(this.anchorsData.map(V=>V.x)),this.anchorsY=SD(this.anchorsData.map(V=>V.y))}async process(I){let V={x:0,y:0};const[re,ae]=JY(()=>{const ve={width:I.shape[2],height:I.shape[1]},we=ve.width/ve.height;let Me=VK({},ve),Le={x:0,y:0};we>this.modelRatio?(Me.height=I.shape[2]/this.modelRatio,Le.y=Math.floor((Me.height-I.shape[1])*.5),V.y=Le.y/Me.height):we<this.modelRatio&&(Me.width=I.shape[1]*this.modelRatio,Le.x=Math.floor((Me.width-I.shape[2])*.5),V.x=Le.x/Me.width);const Ue=BA(I,[[0,0],[Le.y,Le.y],[Le.x,Le.x],[0,0]],0),Ge=dQ.resizeBilinear(Ue,[this.modelSize.height,this.modelSize.width]),ze=this.model.execute(Ge,"person"),He=SB(t0(ze,[0,0,1],[1,-1,-1])),Ke=SB(t0(ze,[0,0,0],[1,-1,1])),Ye=Oj(tC(Ke,-100,100));return[this.decodeBoxes(He,[this.anchorsX,this.anchorsY],this.modelSize),Ye]}),le=await re.data(),he=await ae.data();let ue=[];for(let ve=0;ve<he.length;ve++){if(he[ve]<this.scoreThresh)continue;const we=le[ve*12+2]-le[ve*12+0],Me=le[ve*12+3]-le[ve*12+1];we<0||Me<0||ue.push({box:[[le[ve*12+0],le[ve*12+1]],[le[ve*12+2],le[ve*12+3]]],points:[[le[ve*12+4],le[ve*12+5]],[le[ve*12+6],le[ve*12+7]],[le[ve*12+8],le[ve*12+9]],[le[ve*12+10],le[ve*12+11]]],score:he[ve]})}if(re.dispose(),ae.dispose(),ue.length<1)return[];if(ue.length>1){const ve=Sg(ue.map(Ge=>[Ge.box[0][1],Ge.box[0][0],Ge.box[1][1],Ge.box[1][0]])),we=SD(ue.map(Ge=>Ge.score)),Me=await dQ.nonMaxSuppressionAsync(ve,we,this.posesMax,this.iouThresh,this.scoreThresh),Le=await Me.data();Me.dispose();const Ue=[];for(let Ge=0;Ge<Le.length;Ge++)Ue.push(ue[Le[Ge]]);ue=Ue}if(ue.length<1)return[];const pe={width:1-2*V.x,height:1-2*V.y};return ue.map(ve=>({box:ve.box.map(we=>[(we[0]-V.x)/pe.width,(we[1]-V.y)/pe.height]),points:ve.points.map(we=>[(we[0]-V.x)/pe.width,(we[1]-V.y)/pe.height]),score:ve.score}))}decodeBoxes(I,V,re){let ae=SB(t0(I,[0,0],[-1,1])),le=SB(t0(I,[0,1],[-1,1])),he=SB(t0(I,[0,2],[-1,1])),ue=SB(t0(I,[0,3],[-1,1]));ae=OS(OP(ae,re.width),V[0]),le=OS(OP(le,re.height),V[1]),he=OP(he,re.width*2),ue=OP(ue,re.height*2);const pe=Oz(BS(ae,he),[2254,1]),ve=Oz(BS(le,ue),[2254,1]),we=Oz(OS(ae,he),[2254,1]),Me=Oz(OS(le,ue),[2254,1]);let Le=tN([pe,ve,we,Me],1);for(let Ue=0;Ue<4;Ue++){let Ge=SB(t0(I,[0,4+Ue*2],[-1,1])),ze=SB(t0(I,[0,4+Ue*2+1],[-1,1]));Ge=Oz(OS(OP(Ge,re.width),V[0]),[2254,1]),ze=Oz(OS(OP(ze,re.height),V[1]),[2254,1]),Le=tN([Le,Ge,ze],1)}return Le}buildAnchors(I){const V=[8,16,32,32,32],re=[];let ae=0;for(;ae<5;){let le=0,he=ae;for(;he<V.length&&V[he]===V[ae];)le+=2,he++;const ue=V[ae],pe=Math.ceil(I.height/ue),ve=Math.ceil(I.width/ue);for(let we=0;we<pe;++we)for(let Me=0;Me<ve;++Me)for(let Le=0;Le<le;++Le)re.push({x:(Me+.5)/ve,y:(we+.5)/pe});ae=he}return re}async prepare(){const{width:I,height:V}=this.modelSize,re=BQ([1,V,I,3]),ae=this.model.execute(re,"person");await ae.data(),re.dispose(),ae.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}class Vv{constructor(I){if(this.size=I,Jr()!=="webgl")return;const{width:V,height:re}=I;this.backend=f1(),this.prog={variableNames:["maskT","prevT"],outputShape:[re,V],userCode:`
                void main() {
                    ivec2 c = getOutputCoords();
                    float mask = getMaskT(c[0], c[1]);
                    float prev = getPrevT(c[0], c[1]);
                    float t = mask - 0.5;
                    float x = t * t;
                    float alpha = 1.0 - min(
                        x * (5.74062006 + x * (-2.90180189 + x * (-30.34594285 +
                        x * (153.83657925 + x * (-387.53530186))))), 1.0);
                    float smoothed = mask + (prev - mask) * (alpha * 0.9);
                    setOutput(smoothed);
                }
        `}}process(I){var V;if(!this.backend||!this.prog)return;const re=this.backend.compileAndRun(this.prog,[I,this.prev||I]),ae=Ju().makeTensorFromTensorInfo(re);return(V=this.prev)==null||V.dispose(),this.prev=ae,ae}reset(){var I;(I=this.prev)==null||I.dispose(),delete this.prev}async prepare(){if(!this.backend||!this.prog)return;const{width:I,height:V}=this.size,re=BQ([V,I]),ae=Bs([V,I]),le=this.backend.compileAndRun(this.prog,[re,ae]),he=Ju().makeTensorFromTensorInfo(le);await he.data(),re.dispose(),ae.dispose(),he.dispose()}dispose(){this.reset(),delete this.prog,delete this.backend}}class Vq{constructor(I,V=!1){this.model=I,this.mask=V,this.sizeFactor=1.2,this.model=I,this.modelSize=I.inputs[0].shape?{width:I.inputs[0].shape[2],height:I.inputs[0].shape[1]}:{width:256,height:256},typeof V=="object"&&V.smooth&&(this.maskFilter=new Vv(this.modelSize))}process(I,V){const[re,ae]=[I.shape[1],I.shape[2]],{modelSize:le}=this;return V.map(he=>{var ue;const pe=[he.center[0]*ae,he.center[1]*re],ve=[he.top[0]*ae,he.top[1]*re],we=[ve[0]-pe[0],ve[1]-pe[1]],Me=Math.sqrt(we[0]*we[0]+we[1]*we[1])*this.sizeFactor,Le=Math.atan2(we[0],-we[1]),Ue=[pe[1]-Me,pe[0]-Me,pe[1]+Me,pe[0]+Me],Ge=JY(()=>{const qt=this.rotatedRect(I,Ue,Le,le);return OS(OD(qt,.5),.5)}),ze=["ld_3d","world_3d","output_poseflag","activation_heatmap"];this.mask&&ze.push("activation_segmentation");const[He,Ke,Ye,$e,je]=this.model.execute(Ge,ze),rt=He.dataSync(),at=Ke.dataSync(),Rt=Ye.dataSync()[0];let lt=[];for(let qt=0;qt<39;qt++)lt.push([rt[qt*5+0]/le.width,rt[qt*5+1]/le.height,rt[qt*5+2]/le.width]);let kt;if(je){const qt=dQ.rotateWithOffset(je,-Le),Kt=SB(qt),_i=((ue=this.maskFilter)==null?void 0:ue.process(Kt))||Kt,ci=OD(_i,255);kt=new Uint8Array(ci.dataSync()),je.dispose(),qt.dispose(),Kt.dispose(),ci.dispose()}return Ge.dispose(),He.dispose(),Ke.dispose(),Ye.dispose(),lt=this.refinePoints(lt,$e),$e.dispose(),{points:lt,pointsData:rt,metricData:at,maskData:kt,score:Rt,center:pe,top:ve,radius:Me,angle:Le}}).map(he=>{const{points:ue,pointsData:pe,metricData:ve,maskData:we,score:Me,center:Le,top:Ue,radius:Ge,angle:ze}=he;let He=ue.map((Rt,lt)=>({pixel:Rt,metric:[ve[lt*3+0],ve[lt*3+1],ve[lt*3+2]],norm:[ve[lt*3+0],ve[lt*3+1],ve[lt*3+2]],score:1/(1+Math.exp(-pe[lt*5+3])),visibility:1/(1+Math.exp(-pe[lt*5+4]))}));He.forEach(Rt=>{Rt.pixel[0]=(Rt.pixel[0]-.5)*2*Ge,Rt.pixel[1]=(Rt.pixel[1]-.5)*2*Ge,Rt.pixel[2]*=2*Ge});const Ke=Math.sin(ze),Ye=Math.cos(ze);He.forEach(Rt=>{const lt=Rt.pixel[0],kt=Rt.pixel[1];Rt.pixel[0]=(lt*Ye-kt*Ke+Le[0])/ae,Rt.pixel[1]=(lt*Ke+kt*Ye+Le[1])/re,Rt.pixel[2]/=ae;const qt=Rt.metric[0],Kt=Rt.metric[1];Rt.metric[0]=qt*Ye-Kt*Ke,Rt.metric[1]=qt*Ke+Kt*Ye});const $e=He.map(Rt=>Rt.pixel[0]),je=He.map(Rt=>Rt.pixel[1]),rt=[[Math.min(...$e),Math.min(...je)],[Math.max(...$e),Math.max(...je)]],at=we&&{buffer:we,size:{width:256,height:256},box:[[(Le[0]-Ge)/ae,(Le[1]-Ge)/re],[(Le[0]+Ge)/ae,(Le[1]+Ge)/re]]};return{keypoints:He,score:Me,mask:at,center:[He[33].pixel[0],He[33].pixel[1]],top:[He[34].pixel[0],He[34].pixel[1]],debug:{center:Le,top:Ue,box:rt,radius:Ge,angle:ze}}})}refinePoints(I,V){const re=SB(V,[0]),ae=re.bufferSync(),[le,he,ue]=re.shape;return I.map((pe,ve)=>{const we=pe,Me=Math.trunc(we[0]*he),Le=Math.trunc(we[1]*le);if(Me<0||Me>=he||Le<0||Le>=le)return pe;const Ue=Math.trunc((7-1)/2),Ge=Math.max(Me-Ue,0),ze=Math.min(Me+Ue+1,he),He=Math.max(Le-Ue,0),Ke=Math.min(Le+Ue+1,le);let Ye=0,$e=0,je=0,rt=0;for(let at=He;at<Ke;at++)for(let Rt=Ge;Rt<ze;Rt++){const lt=ae.get(at,Rt,ve);Ye+=lt,$e=Math.max(lt,$e),je+=Rt*lt,rt+=at*lt}return re.dispose(),$e>=.5&&Ye>0?[je/Ye/he,rt/Ye/le,we[2]]:pe})}rotatedRect(I,V,re,ae){const[le,he]=[V[2]-V[0],V[3]-V[1]],[ue,pe]=[(V[2]+V[0])*.5,(V[3]+V[1])*.5],[ve,we]=[le/ae.height,he/ae.width],[Me,Le]=[Math.cos(re),Math.sin(re)],Ue=[Me*we,-Le*ve,(-Me*he+Le*le)*.5+pe,Le*we,Me*ve,(-Le*he-Me*le)*.5+ue,0,0];return dQ.transform(I,[Ue],"bilinear","constant",0,[ae.height,ae.width])}reset(){var I;(I=this.maskFilter)==null||I.reset()}async prepare(){var I;const{width:V,height:re}=this.modelSize,ae=BQ([1,re,V,3]),le=this.model.execute(ae);await Promise.all(le.map(async he=>{await he.data(),he.dispose()})),await((I=this.maskFilter)==null?void 0:I.prepare()),ae.dispose()}async dispose(){var I,V;(I=this.model)==null||I.dispose(),(V=this.maskFilter)==null||V.dispose(),delete this.maskFilter}}var Vl=Object.defineProperty,Va=Object.getOwnPropertySymbols,Vn=Object.prototype.hasOwnProperty,VL=Object.prototype.propertyIsEnumerable,VH=(Z,I,V)=>I in Z?Vl(Z,I,{enumerable:!0,configurable:!0,writable:!0,value:V}):Z[I]=V,Vk=(Z,I)=>{for(var V in I||(I={}))Vn.call(I,V)&&VH(Z,V,I[V]);if(Va)for(var V of Va(I))VL.call(I,V)&&VH(Z,V,I[V]);return Z};class Vz{constructor(){this.freq=30,this.pixelParams={minCutOff:1,minCutOffD:1,beta:50},this.metricParams={minCutOff:.5,minCutOffD:1,beta:30},this.boxParams={minCutOff:1,minCutOffD:1,beta:50},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(I,V,re=1){return this.time>=V?I:(this.time!==0&&(this.freq=1/(V-this.time)),this.time=V,!this.raw||!this.smooth||!this.der?(this.raw=this.clonePose(I),this.smooth=this.clonePose(I),this.der={keypoints:I.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0],norm:[0,0,0],score:0,visibility:0})),score:0,center:[0,0],top:[0,0],debug:{box:[[0,0],[0,0]],center:[0,0],top:[0,0],radius:0,angle:0}},this.clonePose(this.smooth)):(this.filterKeypoints(I.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,re),this.filterCoord2D(I.center,this.raw.center,this.der.center,this.smooth.center,re,this.boxParams),this.filterCoord2D(I.top,this.raw.top,this.der.top,this.smooth.top,re,this.boxParams),this.smooth.score=I.score,this.smooth.mask=I.mask&&{buffer:I.mask.buffer,size:Vk({},I.mask.size),box:[[...I.mask.box[0]],[...I.mask.box[1]]]},this.smooth.debug=I.debug&&{center:[...I.debug.center],top:[...I.debug.top],box:[[...I.debug.box[0]],[...I.debug.box[1]]],radius:I.debug.radius,angle:I.debug.angle},this.clonePose(this.smooth)))}filterKeypoints(I,V,re,ae,le){const he=this.alpha(this.visibilityCutOff),ue=this.alpha(this.scoreCutOff);for(let pe=0;pe<I.length;pe++)this.filterCoord3D(I[pe].pixel,V[pe].pixel,re[pe].pixel,ae[pe].pixel,le,this.pixelParams),this.filterCoord3D(I[pe].metric,V[pe].metric,re[pe].metric,ae[pe].metric,le,this.metricParams),this.filterCoord3D(I[pe].norm,V[pe].norm,re[pe].norm,ae[pe].norm,le,this.metricParams),ae[pe].score=ae[pe].score+ue*(I[pe].score-ae[pe].score),ae[pe].visibility=ae[pe].visibility+he*(I[pe].visibility-ae[pe].visibility)}filterCoord3D(I,V,re,ae,le,he){const ue=[(I[0]-ae[0])*le*this.freq,(I[1]-ae[1])*le*this.freq,(I[2]-ae[2])*le*this.freq],pe=this.alpha(he.minCutOffD);re[0]=re[0]+pe*(ue[0]-re[0]),re[1]=re[1]+pe*(ue[1]-re[1]),re[2]=re[2]+pe*(ue[2]-re[2]);const ve=[this.alpha(he.minCutOff+he.beta*Math.abs(re[0])),this.alpha(he.minCutOff+he.beta*Math.abs(re[1])),this.alpha(he.minCutOff+he.beta*Math.abs(re[2]))];ae[0]=ae[0]+ve[0]*(I[0]-ae[0]),ae[1]=ae[1]+ve[1]*(I[1]-ae[1]),ae[2]=ae[2]+ve[2]*(I[2]-ae[2]),V[0]=I[0],V[1]=I[1],V[2]=I[2]}filterCoord2D(I,V,re,ae,le,he){const ue=[(I[0]-ae[0])*le*this.freq,(I[1]-ae[1])*le*this.freq],pe=this.alpha(he.minCutOffD);re[0]=re[0]+pe*(ue[0]-re[0]),re[1]=re[1]+pe*(ue[1]-re[1]);const ve=[this.alpha(he.minCutOff+he.beta*Math.abs(re[0])),this.alpha(he.minCutOff+he.beta*Math.abs(re[1]))];ae[0]=ae[0]+ve[0]*(I[0]-ae[0]),ae[1]=ae[1]+ve[1]*(I[1]-ae[1]),V[0]=I[0],V[1]=I[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(I){return 1/(1+this.freq/(2*Math.PI*I))}clonePose(I){return{keypoints:I.keypoints.map(V=>({pixel:[...V.pixel],metric:[...V.metric],norm:[...V.norm],score:V.score,visibility:V.visibility})),score:I.score,center:[...I.center],top:[...I.top],mask:I.mask&&{buffer:I.mask.buffer,size:Vk({},I.mask.size),box:[[...I.mask.box[0]],[...I.mask.box[1]]]},debug:I.debug&&{box:[[...I.debug.box[0]],[...I.debug.box[1]]],center:[...I.debug.center],top:[...I.debug.top],radius:I.debug.radius,angle:I.debug.angle}}}}function Vx(Z,I){const V=[Math.max(Z.xy.x,I.xy.x),Math.max(Z.xy.y,I.xy.y)],re=[Math.min(Z.xy.x+Z.size.width,Z.xy.x+Z.size.width),Math.min(Z.xy.y+Z.size.height,Z.xy.y+Z.size.height)],ae=(re[0]-V[0])*(re[1]-V[1]);return ae/(Z.size.width*Z.size.height+I.size.width*I.size.height-ae)}function VU(Z,I){const V=[[Math.max(Z[0][0],I[0][0]),Math.max(Z[0][1],I[0][1])],[Math.min(Z[1][0],I[1][0]),Math.min(Z[1][1],I[1][1])]],re=(V[1][0]-V[0][0])*(V[1][1]-V[0][1]);return re/((Z[1][0]-Z[0][0])*(Z[1][1]-Z[0][1])+(I[1][0]-I[0][0])*(I[1][1]-I[0][1])-re)}function VG(Z){return{xy:{x:Z[0][0],y:Z[0][1]},size:{width:Z[1][0]-Z[0][0],height:Z[1][1]-Z[0][1]}}}function Vu(Z){return[[Z.xy.x,Z.xy.y],[Z.xy.x+Z.size.width,Z.xy.y+Z.size.height]]}var VY=(()=>{var Z=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(I={}){var V=I,re,ae;V.ready=new Promise((Tt,pt)=>{re=Tt,ae=pt});var le=Object.assign({},V),he="./this.program",ue=(Tt,pt)=>{throw pt},pe=!0,ve=!1,we="";function Me(Tt){return V.locateFile?V.locateFile(Tt,we):we+Tt}typeof document<"u"&&document.currentScript&&(we=document.currentScript.src),Z&&(we=Z),we.startsWith("blob:")?we="":we=we.substr(0,we.replace(/[?#].*/,"").lastIndexOf("/")+1),V.print||console.log.bind(console);var Le=V.printErr||console.error.bind(console);Object.assign(V,le),le=null,V.arguments&&V.arguments,V.thisProgram&&(he=V.thisProgram),V.quit&&(ue=V.quit);var Ue;V.wasmBinary&&(Ue=V.wasmBinary);var Ge,ze=!1,He,Ke,Ye,$e,je,rt,at,Rt,lt;function kt(){var Tt=Ge.buffer;V.HEAP8=Ke=new Int8Array(Tt),V.HEAP16=$e=new Int16Array(Tt),V.HEAPU8=Ye=new Uint8Array(Tt),V.HEAPU16=je=new Uint16Array(Tt),V.HEAP32=rt=new Int32Array(Tt),V.HEAPU32=at=new Uint32Array(Tt),V.HEAPF32=Rt=new Float32Array(Tt),V.HEAPF64=lt=new Float64Array(Tt)}var qt=[],Kt=[],_i=[];function ci(){if(V.preRun)for(typeof V.preRun=="function"&&(V.preRun=[V.preRun]);V.preRun.length;)Ki(V.preRun.shift());ln(qt)}function li(){ln(Kt)}function qi(){if(V.postRun)for(typeof V.postRun=="function"&&(V.postRun=[V.postRun]);V.postRun.length;)Yi(V.postRun.shift());ln(_i)}function Ki(Tt){qt.unshift(Tt)}function hs(Tt){Kt.unshift(Tt)}function Yi(Tt){_i.unshift(Tt)}var ns=0,Gs=null;function Xs(Tt){var pt;ns++,(pt=V.monitorRunDependencies)==null||pt.call(V,ns)}function $i(Tt){var pt;if(ns--,(pt=V.monitorRunDependencies)==null||pt.call(V,ns),ns==0&&Gs){var Xt=Gs;Gs=null,Xt()}}function xs(Tt){var pt;(pt=V.onAbort)==null||pt.call(V,Tt),Tt="Aborted("+Tt+")",Le(Tt),ze=!0,He=1,Tt+=". Build with -sASSERTIONS for more info.";var Xt=new WebAssembly.RuntimeError(Tt);throw ae(Xt),Xt}var hi="data:application/octet-stream;base64,",Ri=Tt=>Tt.startsWith(hi),Wi;Wi="bodyutils.wasm",Ri(Wi)||(Wi=Me(Wi));function us(Tt){if(Tt==Wi&&Ue)return new Uint8Array(Ue);throw"both async and sync fetching of the wasm failed"}function Ks(Tt){return!Ue&&pe&&typeof fetch=="function"?fetch(Tt,{credentials:"same-origin"}).then(pt=>{if(!pt.ok)throw"failed to load wasm binary file at '"+Tt+"'";return pt.arrayBuffer()}).catch(()=>us(Tt)):Promise.resolve().then(()=>us(Tt))}function ur(Tt,pt,Xt){return Ks(Tt).then(Ti=>WebAssembly.instantiate(Ti,pt)).then(Xt,Ti=>{Le("failed to asynchronously prepare wasm: "+Ti),xs(Ti)})}function js(Tt,pt,Xt,Ti){return!Tt&&typeof WebAssembly.instantiateStreaming=="function"&&!Ri(pt)&&typeof fetch=="function"?fetch(pt,{credentials:"same-origin"}).then(ji=>{var rs=WebAssembly.instantiateStreaming(ji,Xt);return rs.then(Ti,function(Ts){return Le("wasm streaming compile failed: "+Ts),Le("falling back to ArrayBuffer instantiation"),ur(pt,Xt,Ti)})}):ur(pt,Xt,Ti)}function sr(){var Tt={a:ab};function pt(Ti,ji){return qo=Ti.exports,Ge=qo.E,kt(),X2=qo.H,hs(qo.F),$i(),qo}Xs();function Xt(Ti){pt(Ti.instance)}if(V.instantiateWasm)try{return V.instantiateWasm(Tt,pt)}catch(Ti){Le("Module.instantiateWasm callback failed with error: "+Ti),ae(Ti)}return js(Ue,Wi,Tt,Xt).catch(ae),{}}function cr(Tt){this.name="ExitStatus",this.message="Program terminated with exit("+Tt+")",this.status=Tt}var ln=Tt=>{for(;Tt.length>0;)Tt.shift()(V)},kr=V.noExitRuntime||!0;class $r{constructor(pt){this.excPtr=pt,this.ptr=pt-24}set_type(pt){at[this.ptr+4>>2]=pt}get_type(){return at[this.ptr+4>>2]}set_destructor(pt){at[this.ptr+8>>2]=pt}get_destructor(){return at[this.ptr+8>>2]}set_caught(pt){pt=pt?1:0,Ke[this.ptr+12]=pt}get_caught(){return Ke[this.ptr+12]!=0}set_rethrown(pt){pt=pt?1:0,Ke[this.ptr+13]=pt}get_rethrown(){return Ke[this.ptr+13]!=0}init(pt,Xt){this.set_adjusted_ptr(0),this.set_type(pt),this.set_destructor(Xt)}set_adjusted_ptr(pt){at[this.ptr+16>>2]=pt}get_adjusted_ptr(){return at[this.ptr+16>>2]}get_exception_ptr(){var pt=s_(this.get_type());if(pt)return at[this.excPtr>>2];var Xt=this.get_adjusted_ptr();return Xt!==0?Xt:this.excPtr}}var Rn=0,Ln=(Tt,pt,Xt)=>{var Ti=new $r(Tt);throw Ti.init(pt,Xt),Rn=Tt,Rn},zn=(Tt,pt,Xt,Ti,ji)=>{},ra=()=>{for(var Tt=new Array(256),pt=0;pt<256;++pt)Tt[pt]=String.fromCharCode(pt);aa=Tt},aa,ps=Tt=>{for(var pt="",Xt=Tt;Ye[Xt];)pt+=aa[Ye[Xt++]];return pt},l0={},Ro={},rx={},Ma,pn=Tt=>{throw new Ma(Tt)},jr,uo=Tt=>{throw new jr(Tt)},hn=(Tt,pt,Xt)=>{Tt.forEach(function(ls){rx[ls]=pt});function Ti(ls){var lr=Xt(ls);lr.length!==Tt.length&&uo("Mismatched type converter count");for(var Rr=0;Rr<Tt.length;++Rr)c0(Tt[Rr],lr[Rr])}var ji=new Array(pt.length),rs=[],Ts=0;pt.forEach((ls,lr)=>{Ro.hasOwnProperty(ls)?ji[lr]=Ro[ls]:(rs.push(ls),l0.hasOwnProperty(ls)||(l0[ls]=[]),l0[ls].push(()=>{ji[lr]=Ro[ls],++Ts,Ts===rs.length&&Ti(ji)}))}),rs.length===0&&Ti(ji)};function Wo(Tt,pt,Xt={}){var Ti=pt.name;if(Tt||pn('type "'+Ti+'" must have a positive integer typeid pointer'),Ro.hasOwnProperty(Tt)){if(Xt.ignoreDuplicateRegistrations)return;pn("Cannot register type '"+Ti+"' twice")}if(Ro[Tt]=pt,delete rx[Tt],l0.hasOwnProperty(Tt)){var ji=l0[Tt];delete l0[Tt],ji.forEach(rs=>rs())}}function c0(Tt,pt,Xt={}){if(!("argPackAdvance"in pt))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Wo(Tt,pt,Xt)}var U0=8,U2=(Tt,pt,Xt,Ti)=>{pt=ps(pt),c0(Tt,{name:pt,fromWireType:function(ji){return!!ji},toWireType:function(ji,rs){return rs?Xt:Ti},argPackAdvance:U0,readValueFromPointer:function(ji){return this.fromWireType(Ye[ji])},destructorFunction:null})},kh=Tt=>({count:Tt.count,deleteScheduled:Tt.deleteScheduled,preservePointerOnDelete:Tt.preservePointerOnDelete,ptr:Tt.ptr,ptrType:Tt.ptrType,smartPtr:Tt.smartPtr,smartPtrType:Tt.smartPtrType}),$x=Tt=>{function pt(Xt){return Xt.$$.ptrType.registeredClass.name}pn(pt(Tt)+" instance already deleted")},Tl=!1,Mi=Tt=>{},Uh=Tt=>{Tt.smartPtr?Tt.smartPtrType.rawDestructor(Tt.smartPtr):Tt.ptrType.registeredClass.rawDestructor(Tt.ptr)},Gn=Tt=>{Tt.count.value-=1;var pt=Tt.count.value===0;pt&&Uh(Tt)},u0=(Tt,pt,Xt)=>{if(pt===Xt)return Tt;if(Xt.baseClass===void 0)return null;var Ti=u0(Tt,pt,Xt.baseClass);return Ti===null?null:Xt.downcast(Ti)},wa={},Ho=()=>Object.keys(vi).length,px=()=>{var Tt=[];for(var pt in vi)vi.hasOwnProperty(pt)&&Tt.push(vi[pt]);return Tt},Y0=[],$l=()=>{for(;Y0.length;){var Tt=Y0.pop();Tt.$$.deleteScheduled=!1,Tt.delete()}},wr,rl=Tt=>{wr=Tt,Y0.length&&wr&&wr($l)},Tr=()=>{V.getInheritedInstanceCount=Ho,V.getLiveInheritedInstances=px,V.flushPendingDeletes=$l,V.setDelayFunction=rl},vi={},r2=(Tt,pt)=>{for(pt===void 0&&pn("ptr should not be undefined");Tt.baseClass;)pt=Tt.upcast(pt),Tt=Tt.baseClass;return pt},vc=(Tt,pt)=>(pt=r2(Tt,pt),vi[pt]),j0=(Tt,pt)=>{(!pt.ptrType||!pt.ptr)&&uo("makeClassHandle requires ptr and ptrType");var Xt=!!pt.smartPtrType,Ti=!!pt.smartPtr;return Xt!==Ti&&uo("Both smartPtrType and smartPtr must be specified"),pt.count={value:1},io(Object.create(Tt,{$$:{value:pt,writable:!0}}))};function Rc(Tt){var pt=this.getPointee(Tt);if(!pt)return this.destructor(Tt),null;var Xt=vc(this.registeredClass,pt);if(Xt!==void 0){if(Xt.$$.count.value===0)return Xt.$$.ptr=pt,Xt.$$.smartPtr=Tt,Xt.clone();var Ti=Xt.clone();return this.destructor(Tt),Ti}function ji(){return this.isSmartPointer?j0(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:pt,smartPtrType:this,smartPtr:Tt}):j0(this.registeredClass.instancePrototype,{ptrType:this,ptr:Tt})}var rs=this.registeredClass.getActualType(pt),Ts=wa[rs];if(!Ts)return ji.call(this);var ls;this.isConst?ls=Ts.constPointerType:ls=Ts.pointerType;var lr=u0(pt,this.registeredClass,ls.registeredClass);return lr===null?ji.call(this):this.isSmartPointer?j0(ls.registeredClass.instancePrototype,{ptrType:ls,ptr:lr,smartPtrType:this,smartPtr:Tt}):j0(ls.registeredClass.instancePrototype,{ptrType:ls,ptr:lr})}var io=Tt=>typeof FinalizationRegistry>"u"?(io=pt=>pt,Tt):(Tl=new FinalizationRegistry(pt=>{Gn(pt.$$)}),io=pt=>{var Xt=pt.$$,Ti=!!Xt.smartPtr;if(Ti){var ji={$$:Xt};Tl.register(pt,ji,pt)}return pt},Mi=pt=>Tl.unregister(pt),io(Tt)),G2=()=>{Object.assign(Wn.prototype,{isAliasOf(Tt){if(!(this instanceof Wn)||!(Tt instanceof Wn))return!1;var pt=this.$$.ptrType.registeredClass,Xt=this.$$.ptr;Tt.$$=Tt.$$;for(var Ti=Tt.$$.ptrType.registeredClass,ji=Tt.$$.ptr;pt.baseClass;)Xt=pt.upcast(Xt),pt=pt.baseClass;for(;Ti.baseClass;)ji=Ti.upcast(ji),Ti=Ti.baseClass;return pt===Ti&&Xt===ji},clone(){if(this.$$.ptr||$x(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var Tt=io(Object.create(Object.getPrototypeOf(this),{$$:{value:kh(this.$$)}}));return Tt.$$.count.value+=1,Tt.$$.deleteScheduled=!1,Tt},delete(){this.$$.ptr||$x(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&pn("Object already scheduled for deletion"),Mi(this),Gn(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||$x(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&pn("Object already scheduled for deletion"),Y0.push(this),Y0.length===1&&wr&&wr($l),this.$$.deleteScheduled=!0,this}})};function Wn(){}var _x=(Tt,pt)=>Object.defineProperty(pt,"name",{value:Tt}),z2=(Tt,pt,Xt)=>{if(Tt[pt].overloadTable===void 0){var Ti=Tt[pt];Tt[pt]=function(...ji){return Tt[pt].overloadTable.hasOwnProperty(ji.length)||pn("Function '"+Xt+"' called with an invalid number of arguments ("+ji.length+") - expects one of ("+Tt[pt].overloadTable+")!"),Tt[pt].overloadTable[ji.length].apply(this,ji)},Tt[pt].overloadTable=[],Tt[pt].overloadTable[Ti.argCount]=Ti}},Mc=(Tt,pt,Xt)=>{V.hasOwnProperty(Tt)?((Xt===void 0||V[Tt].overloadTable!==void 0&&V[Tt].overloadTable[Xt]!==void 0)&&pn("Cannot register public name '"+Tt+"' twice"),z2(V,Tt,Tt),V.hasOwnProperty(Xt)&&pn("Cannot register multiple overloads of a function with the same number of arguments ("+Xt+")!"),V[Tt].overloadTable[Xt]=pt):(V[Tt]=pt,Xt!==void 0&&(V[Tt].numArguments=Xt))},wc=48,Xa=57,n2=Tt=>{if(Tt===void 0)return"_unknown";Tt=Tt.replace(/[^a-zA-Z0-9_]/g,"$");var pt=Tt.charCodeAt(0);return pt>=wc&&pt<=Xa?"_"+Tt:Tt};function W2(Tt,pt,Xt,Ti,ji,rs,Ts,ls){this.name=Tt,this.constructor=pt,this.instancePrototype=Xt,this.rawDestructor=Ti,this.baseClass=ji,this.getActualType=rs,this.upcast=Ts,this.downcast=ls,this.pureVirtualFunctions=[]}var Gx=(Tt,pt,Xt)=>{for(;pt!==Xt;)pt.upcast||pn("Expected null or instance of "+Xt.name+", got an instance of "+pt.name),Tt=pt.upcast(Tt),pt=pt.baseClass;return Tt};function Lc(Tt,pt){if(pt===null)return this.isReference&&pn("null is not a valid "+this.name),0;pt.$$||pn('Cannot pass "'+Yo(pt)+'" as a '+this.name),pt.$$.ptr||pn("Cannot pass deleted object as a pointer of type "+this.name);var Xt=pt.$$.ptrType.registeredClass,Ti=Gx(pt.$$.ptr,Xt,this.registeredClass);return Ti}function Gh(Tt,pt){var Xt;if(pt===null)return this.isReference&&pn("null is not a valid "+this.name),this.isSmartPointer?(Xt=this.rawConstructor(),Tt!==null&&Tt.push(this.rawDestructor,Xt),Xt):0;(!pt||!pt.$$)&&pn('Cannot pass "'+Yo(pt)+'" as a '+this.name),pt.$$.ptr||pn("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&pt.$$.ptrType.isConst&&pn("Cannot convert argument of type "+(pt.$$.smartPtrType?pt.$$.smartPtrType.name:pt.$$.ptrType.name)+" to parameter type "+this.name);var Ti=pt.$$.ptrType.registeredClass;if(Xt=Gx(pt.$$.ptr,Ti,this.registeredClass),this.isSmartPointer)switch(pt.$$.smartPtr===void 0&&pn("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:pt.$$.smartPtrType===this?Xt=pt.$$.smartPtr:pn("Cannot convert argument of type "+(pt.$$.smartPtrType?pt.$$.smartPtrType.name:pt.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:Xt=pt.$$.smartPtr;break;case 2:if(pt.$$.smartPtrType===this)Xt=pt.$$.smartPtr;else{var ji=pt.clone();Xt=this.rawShare(Xt,v0.toHandle(()=>ji.delete())),Tt!==null&&Tt.push(this.rawDestructor,Xt)}break;default:pn("Unsupporting sharing policy")}return Xt}function vl(Tt,pt){if(pt===null)return this.isReference&&pn("null is not a valid "+this.name),0;pt.$$||pn('Cannot pass "'+Yo(pt)+'" as a '+this.name),pt.$$.ptr||pn("Cannot pass deleted object as a pointer of type "+this.name),pt.$$.ptrType.isConst&&pn("Cannot convert argument of type "+pt.$$.ptrType.name+" to parameter type "+this.name);var Xt=pt.$$.ptrType.registeredClass,Ti=Gx(pt.$$.ptr,Xt,this.registeredClass);return Ti}function zx(Tt){return this.fromWireType(at[Tt>>2])}var po=()=>{Object.assign(Gi.prototype,{getPointee(Tt){return this.rawGetPointee&&(Tt=this.rawGetPointee(Tt)),Tt},destructor(Tt){var pt;(pt=this.rawDestructor)==null||pt.call(this,Tt)},argPackAdvance:U0,readValueFromPointer:zx,fromWireType:Rc})};function Gi(Tt,pt,Xt,Ti,ji,rs,Ts,ls,lr,Rr,hr){this.name=Tt,this.registeredClass=pt,this.isReference=Xt,this.isConst=Ti,this.isSmartPointer=ji,this.pointeeType=rs,this.sharingPolicy=Ts,this.rawGetPointee=ls,this.rawConstructor=lr,this.rawShare=Rr,this.rawDestructor=hr,!ji&&pt.baseClass===void 0?Ti?(this.toWireType=Lc,this.destructorFunction=null):(this.toWireType=vl,this.destructorFunction=null):this.toWireType=Gh}var va=(Tt,pt,Xt)=>{V.hasOwnProperty(Tt)||uo("Replacing nonexistent public symbol"),V[Tt].overloadTable!==void 0&&Xt!==void 0?V[Tt].overloadTable[Xt]=pt:(V[Tt]=pt,V[Tt].argCount=Xt)},Rl=(Tt,pt,Xt)=>{var Ti=V["dynCall_"+Tt];return Ti(pt,...Xt)},_o=[],X2,n0=Tt=>{var pt=_o[Tt];return pt||(Tt>=_o.length&&(_o.length=Tt+1),_o[Tt]=pt=X2.get(Tt)),pt},kc=(Tt,pt,Xt=[])=>{if(Tt.includes("j"))return Rl(Tt,pt,Xt);var Ti=n0(pt)(...Xt);return Ti},_0=(Tt,pt)=>(...Xt)=>kc(Tt,pt,Xt),To=(Tt,pt)=>{Tt=ps(Tt);function Xt(){return Tt.includes("j")?_0(Tt,pt):n0(pt)}var Ti=Xt();return typeof Ti!="function"&&pn("unknown function pointer with signature "+Tt+": "+pt),Ti},Xo=(Tt,pt)=>{var Xt=_x(pt,function(Ti){this.name=pt,this.message=Ti;var ji=new Error(Ti).stack;ji!==void 0&&(this.stack=this.toString()+`
`+ji.replace(/^Error(:[^\n]*)?\n/,""))});return Xt.prototype=Object.create(Tt.prototype),Xt.prototype.constructor=Xt,Xt.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},Xt},K2,ha=Tt=>{var pt=Ym(Tt),Xt=ps(pt);return Wx(pt),Xt},nl=(Tt,pt)=>{var Xt=[],Ti={};function ji(rs){if(!Ti[rs]&&!Ro[rs]){if(rx[rs]){rx[rs].forEach(ji);return}Xt.push(rs),Ti[rs]=!0}}throw pt.forEach(ji),new K2(Tt+": "+Xt.map(ha).join([", "]))},nx=(Tt,pt,Xt,Ti,ji,rs,Ts,ls,lr,Rr,hr,_n,un)=>{hr=ps(hr),rs=To(ji,rs),ls&&(ls=To(Ts,ls)),Rr&&(Rr=To(lr,Rr)),un=To(_n,un);var Un=n2(hr);Mc(Un,function(){nl("Cannot construct "+hr+" due to unbound types",[Ti])}),hn([Tt,pt,Xt],Ti?[Ti]:[],ca=>{var ws;ca=ca[0];var vr,na;Ti?(vr=ca.registeredClass,na=vr.instancePrototype):na=Wn.prototype;var Hs=_x(hr,function(...Gl){if(Object.getPrototypeOf(this)!==rn)throw new Ma("Use 'new' to construct "+hr);if(ua.constructor_body===void 0)throw new Ma(hr+" has no accessible constructor");var ks=ua.constructor_body[Gl.length];if(ks===void 0)throw new Ma("Tried to invoke ctor of "+hr+" with invalid number of parameters ("+Gl.length+") - expected ("+Object.keys(ua.constructor_body).toString()+") parameters instead!");return ks.apply(this,Gl)}),rn=Object.create(na,{constructor:{value:Hs}});Hs.prototype=rn;var ua=new W2(hr,Hs,rn,un,vr,rs,ls,Rr);ua.baseClass&&((ws=ua.baseClass).__derivedClasses!=null||(ws.__derivedClasses=[]),ua.baseClass.__derivedClasses.push(ua));var ka=new Gi(hr,ua,!0,!1,!1),nn=new Gi(hr+"*",ua,!1,!1,!1),R0=new Gi(hr+" const*",ua,!1,!0,!1);return wa[Tt]={pointerType:nn,constPointerType:R0},va(Un,Hs),[ka,nn,R0]})},zh=(Tt,pt)=>{for(var Xt=[],Ti=0;Ti<Tt;Ti++)Xt.push(at[pt+Ti*4>>2]);return Xt},Ko=Tt=>{for(;Tt.length;){var pt=Tt.pop(),Xt=Tt.pop();Xt(pt)}};function Uc(Tt){for(var pt=1;pt<Tt.length;++pt)if(Tt[pt]!==null&&Tt[pt].destructorFunction===void 0)return!0;return!1}function rr(Tt,pt,Xt,Ti,ji,rs){var Ts=pt.length;Ts<2&&pn("argTypes array size mismatch! Must at least get return value and 'this' types!");var ls=pt[1]!==null&&Xt!==null,lr=Uc(pt),Rr=pt[0].name!=="void",hr=Ts-2,_n=new Array(hr),un=[],Un=[],ca=function(...ws){ws.length!==hr&&pn("function "+Tt+" called with "+ws.length+" arguments, expected "+hr),Un.length=0;var vr;un.length=ls?2:1,un[0]=ji,ls&&(vr=pt[1].toWireType(Un,this),un[1]=vr);for(var na=0;na<hr;++na)_n[na]=pt[na+2].toWireType(Un,ws[na]),un.push(_n[na]);var Hs=Ti(...un);function rn(ua){if(lr)Ko(Un);else for(var ka=ls?1:2;ka<pt.length;ka++){var nn=ka===1?vr:_n[ka-2];pt[ka].destructorFunction!==null&&pt[ka].destructorFunction(nn)}if(Rr)return pt[0].fromWireType(ua)}return rn(Hs)};return _x(Tt,ca)}var Gc=(Tt,pt,Xt,Ti,ji,rs)=>{var Ts=zh(pt,Xt);ji=To(Ti,ji),hn([],[Tt],ls=>{ls=ls[0];var lr="constructor "+ls.name;if(ls.registeredClass.constructor_body===void 0&&(ls.registeredClass.constructor_body=[]),ls.registeredClass.constructor_body[pt-1]!==void 0)throw new Ma("Cannot register multiple constructors with identical number of parameters ("+(pt-1)+") for class '"+ls.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return ls.registeredClass.constructor_body[pt-1]=()=>{nl("Cannot construct "+ls.name+" due to unbound types",Ts)},hn([],Ts,Rr=>(Rr.splice(1,0,null),ls.registeredClass.constructor_body[pt-1]=rr(lr,Rr,null,ji,rs),[])),[]})},a2=Tt=>{Tt=Tt.trim();const pt=Tt.indexOf("(");return pt!==-1?Tt.substr(0,pt):Tt},T0=(Tt,pt,Xt,Ti,ji,rs,Ts,ls,lr)=>{var Rr=zh(Xt,Ti);pt=ps(pt),pt=a2(pt),rs=To(ji,rs),hn([],[Tt],hr=>{hr=hr[0];var _n=hr.name+"."+pt;pt.startsWith("@@")&&(pt=Symbol[pt.substring(2)]),ls&&hr.registeredClass.pureVirtualFunctions.push(pt);function un(){nl("Cannot call "+_n+" due to unbound types",Rr)}var Un=hr.registeredClass.instancePrototype,ca=Un[pt];return ca===void 0||ca.overloadTable===void 0&&ca.className!==hr.name&&ca.argCount===Xt-2?(un.argCount=Xt-2,un.className=hr.name,Un[pt]=un):(z2(Un,pt,_n),Un[pt].overloadTable[Xt-2]=un),hn([],Rr,ws=>{var vr=rr(_n,ws,hr,rs,Ts);return Un[pt].overloadTable===void 0?(vr.argCount=Xt-2,Un[pt]=vr):Un[pt].overloadTable[Xt-2]=vr,[]}),[]})},x2=(Tt,pt,Xt)=>(Tt instanceof Object||pn(Xt+' with invalid "this": '+Tt),Tt instanceof pt.registeredClass.constructor||pn(Xt+' incompatible with "this" of type '+Tt.constructor.name),Tt.$$.ptr||pn("cannot call emscripten binding method "+Xt+" on deleted object"),Gx(Tt.$$.ptr,Tt.$$.ptrType.registeredClass,pt.registeredClass)),ui=(Tt,pt,Xt,Ti,ji,rs,Ts,ls,lr,Rr)=>{pt=ps(pt),ji=To(Ti,ji),hn([],[Tt],hr=>{hr=hr[0];var _n=hr.name+"."+pt,un={get(){nl("Cannot access "+_n+" due to unbound types",[Xt,Ts])},enumerable:!0,configurable:!0};return lr?un.set=()=>nl("Cannot access "+_n+" due to unbound types",[Xt,Ts]):un.set=Un=>pn(_n+" is a read-only property"),Object.defineProperty(hr.registeredClass.instancePrototype,pt,un),hn([],lr?[Xt,Ts]:[Xt],Un=>{var ca=Un[0],ws={get(){var na=x2(this,hr,_n+" getter");return ca.fromWireType(ji(rs,na))},enumerable:!0};if(lr){lr=To(ls,lr);var vr=Un[1];ws.set=function(na){var Hs=x2(this,hr,_n+" setter"),rn=[];lr(Rr,Hs,vr.toWireType(rn,na)),Ko(rn)}}return Object.defineProperty(hr.registeredClass.instancePrototype,pt,ws),[]}),[]})},l2=[],Uo=[],al=Tt=>{Tt>9&&--Uo[Tt+1]===0&&(Uo[Tt]=void 0,l2.push(Tt))},h2=()=>Uo.length/2-5-l2.length,za=()=>{Uo.push(0,1,void 0,1,null,1,!0,1,!1,1),V.count_emval_handles=h2},v0={toValue:Tt=>(Tt||pn("Cannot use deleted val. handle = "+Tt),Uo[Tt]),toHandle:Tt=>{switch(Tt){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const pt=l2.pop()||Uo.length;return Uo[pt]=Tt,Uo[pt+1]=1,pt}}}},Y2={name:"emscripten::val",fromWireType:Tt=>{var pt=v0.toValue(Tt);return al(Tt),pt},toWireType:(Tt,pt)=>v0.toHandle(pt),argPackAdvance:U0,readValueFromPointer:zx,destructorFunction:null},xl=Tt=>c0(Tt,Y2),Yo=Tt=>{if(Tt===null)return"null";var pt=typeof Tt;return pt==="object"||pt==="array"||pt==="function"?Tt.toString():""+Tt},jo=(Tt,pt)=>{switch(pt){case 4:return function(Xt){return this.fromWireType(Rt[Xt>>2])};case 8:return function(Xt){return this.fromWireType(lt[Xt>>3])};default:throw new TypeError("invalid float width ("+pt+"): "+Tt)}},zc=(Tt,pt,Xt)=>{pt=ps(pt),c0(Tt,{name:pt,fromWireType:Ti=>Ti,toWireType:(Ti,ji)=>ji,argPackAdvance:U0,readValueFromPointer:jo(pt,Xt),destructorFunction:null})},Wc=(Tt,pt,Xt)=>{switch(pt){case 1:return Xt?Ti=>Ke[Ti]:Ti=>Ye[Ti];case 2:return Xt?Ti=>$e[Ti>>1]:Ti=>je[Ti>>1];case 4:return Xt?Ti=>rt[Ti>>2]:Ti=>at[Ti>>2];default:throw new TypeError("invalid integer width ("+pt+"): "+Tt)}},Wh=(Tt,pt,Xt,Ti,ji)=>{pt=ps(pt);var rs=hr=>hr;if(Ti===0){var Ts=32-8*Xt;rs=hr=>hr<<Ts>>>Ts}var ls=pt.includes("unsigned"),lr=(hr,_n)=>{},Rr;ls?Rr=function(hr,_n){return lr(_n,this.name),_n>>>0}:Rr=function(hr,_n){return lr(_n,this.name),_n},c0(Tt,{name:pt,fromWireType:rs,toWireType:Rr,argPackAdvance:U0,readValueFromPointer:Wc(pt,Xt,Ti!==0),destructorFunction:null})},c2=(Tt,pt,Xt)=>{var Ti=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],ji=Ti[pt];function rs(Ts){var ls=at[Ts>>2],lr=at[Ts+4>>2];return new ji(Ke.buffer,lr,ls)}Xt=ps(Xt),c0(Tt,{name:Xt,fromWireType:rs,argPackAdvance:U0,readValueFromPointer:rs},{ignoreDuplicateRegistrations:!0})},u2=(Tt,pt,Xt,Ti)=>{if(!(Ti>0))return 0;for(var ji=Xt,rs=Xt+Ti-1,Ts=0;Ts<Tt.length;++Ts){var ls=Tt.charCodeAt(Ts);if(ls>=55296&&ls<=57343){var lr=Tt.charCodeAt(++Ts);ls=65536+((ls&1023)<<10)|lr&1023}if(ls<=127){if(Xt>=rs)break;pt[Xt++]=ls}else if(ls<=2047){if(Xt+1>=rs)break;pt[Xt++]=192|ls>>6,pt[Xt++]=128|ls&63}else if(ls<=65535){if(Xt+2>=rs)break;pt[Xt++]=224|ls>>12,pt[Xt++]=128|ls>>6&63,pt[Xt++]=128|ls&63}else{if(Xt+3>=rs)break;pt[Xt++]=240|ls>>18,pt[Xt++]=128|ls>>12&63,pt[Xt++]=128|ls>>6&63,pt[Xt++]=128|ls&63}}return pt[Xt]=0,Xt-ji},Mo=(Tt,pt,Xt)=>u2(Tt,Ye,pt,Xt),Hc=Tt=>{for(var pt=0,Xt=0;Xt<Tt.length;++Xt){var Ti=Tt.charCodeAt(Xt);Ti<=127?pt++:Ti<=2047?pt+=2:Ti>=55296&&Ti<=57343?(pt+=4,++Xt):pt+=3}return pt},Hh=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,_2=(Tt,pt,Xt)=>{for(var Ti=pt+Xt,ji=pt;Tt[ji]&&!(ji>=Ti);)++ji;if(ji-pt>16&&Tt.buffer&&Hh)return Hh.decode(Tt.subarray(pt,ji));for(var rs="";pt<ji;){var Ts=Tt[pt++];if(!(Ts&128)){rs+=String.fromCharCode(Ts);continue}var ls=Tt[pt++]&63;if((Ts&224)==192){rs+=String.fromCharCode((Ts&31)<<6|ls);continue}var lr=Tt[pt++]&63;if((Ts&240)==224?Ts=(Ts&15)<<12|ls<<6|lr:Ts=(Ts&7)<<18|ls<<12|lr<<6|Tt[pt++]&63,Ts<65536)rs+=String.fromCharCode(Ts);else{var Rr=Ts-65536;rs+=String.fromCharCode(55296|Rr>>10,56320|Rr&1023)}}return rs},G0=(Tt,pt)=>Tt?_2(Ye,Tt,pt):"",Ml=(Tt,pt)=>{pt=ps(pt);var Xt=pt==="std::string";c0(Tt,{name:pt,fromWireType(Ti){var ji=at[Ti>>2],rs=Ti+4,Ts;if(Xt)for(var ls=rs,lr=0;lr<=ji;++lr){var Rr=rs+lr;if(lr==ji||Ye[Rr]==0){var hr=Rr-ls,_n=G0(ls,hr);Ts===void 0?Ts=_n:(Ts+=String.fromCharCode(0),Ts+=_n),ls=Rr+1}}else{for(var un=new Array(ji),lr=0;lr<ji;++lr)un[lr]=String.fromCharCode(Ye[rs+lr]);Ts=un.join("")}return Wx(Ti),Ts},toWireType(Ti,ji){ji instanceof ArrayBuffer&&(ji=new Uint8Array(ji));var rs,Ts=typeof ji=="string";Ts||ji instanceof Uint8Array||ji instanceof Uint8ClampedArray||ji instanceof Int8Array||pn("Cannot pass non-string to std::string"),Xt&&Ts?rs=Hc(ji):rs=ji.length;var ls=Yc(4+rs+1),lr=ls+4;if(at[ls>>2]=rs,Xt&&Ts)Mo(ji,lr,rs+1);else if(Ts)for(var Rr=0;Rr<rs;++Rr){var hr=ji.charCodeAt(Rr);hr>255&&(Wx(lr),pn("String has UTF-16 code units that do not fit in 8 bits")),Ye[lr+Rr]=hr}else for(var Rr=0;Rr<rs;++Rr)Ye[lr+Rr]=ji[Rr];return Ti!==null&&Ti.push(Wx,ls),ls},argPackAdvance:U0,readValueFromPointer:zx,destructorFunction(Ti){Wx(Ti)}})},wl=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,j2=(Tt,pt)=>{for(var Xt=Tt,Ti=Xt>>1,ji=Ti+pt/2;!(Ti>=ji)&&je[Ti];)++Ti;if(Xt=Ti<<1,Xt-Tt>32&&wl)return wl.decode(Ye.subarray(Tt,Xt));for(var rs="",Ts=0;!(Ts>=pt/2);++Ts){var ls=$e[Tt+Ts*2>>1];if(ls==0)break;rs+=String.fromCharCode(ls)}return rs},La=(Tt,pt,Xt)=>{if(Xt!=null||(Xt=2147483647),Xt<2)return 0;Xt-=2;for(var Ti=pt,ji=Xt<Tt.length*2?Xt/2:Tt.length,rs=0;rs<ji;++rs){var Ts=Tt.charCodeAt(rs);$e[pt>>1]=Ts,pt+=2}return $e[pt>>1]=0,pt-Ti},Xh=Tt=>Tt.length*2,q2=(Tt,pt)=>{for(var Xt=0,Ti="";!(Xt>=pt/4);){var ji=rt[Tt+Xt*4>>2];if(ji==0)break;if(++Xt,ji>=65536){var rs=ji-65536;Ti+=String.fromCharCode(55296|rs>>10,56320|rs&1023)}else Ti+=String.fromCharCode(ji)}return Ti},T2=(Tt,pt,Xt)=>{if(Xt!=null||(Xt=2147483647),Xt<4)return 0;for(var Ti=pt,ji=Ti+Xt-4,rs=0;rs<Tt.length;++rs){var Ts=Tt.charCodeAt(rs);if(Ts>=55296&&Ts<=57343){var ls=Tt.charCodeAt(++rs);Ts=65536+((Ts&1023)<<10)|ls&1023}if(rt[pt>>2]=Ts,pt+=4,pt+4>ji)break}return rt[pt>>2]=0,pt-Ti},Ll=Tt=>{for(var pt=0,Xt=0;Xt<Tt.length;++Xt){var Ti=Tt.charCodeAt(Xt);Ti>=55296&&Ti<=57343&&++Xt,pt+=4}return pt},Tx=(Tt,pt,Xt)=>{Xt=ps(Xt);var Ti,ji,rs,Ts;pt===2?(Ti=j2,ji=La,Ts=Xh,rs=ls=>je[ls>>1]):pt===4&&(Ti=q2,ji=T2,Ts=Ll,rs=ls=>at[ls>>2]),c0(Tt,{name:Xt,fromWireType:ls=>{for(var lr=at[ls>>2],Rr,hr=ls+4,_n=0;_n<=lr;++_n){var un=ls+4+_n*pt;if(_n==lr||rs(un)==0){var Un=un-hr,ca=Ti(hr,Un);Rr===void 0?Rr=ca:(Rr+=String.fromCharCode(0),Rr+=ca),hr=un+pt}}return Wx(ls),Rr},toWireType:(ls,lr)=>{typeof lr!="string"&&pn("Cannot pass non-string to C++ string type "+Xt);var Rr=Ts(lr),hr=Yc(4+Rr+pt);return at[hr>>2]=Rr/pt,ji(lr,hr+4,Rr+pt),ls!==null&&ls.push(Wx,hr),hr},argPackAdvance:U0,readValueFromPointer:zx,destructorFunction(ls){Wx(ls)}})},$2=(Tt,pt)=>{pt=ps(pt),c0(Tt,{isVoid:!0,name:pt,argPackAdvance:0,fromWireType:()=>{},toWireType:(Xt,Ti)=>{}})};function Kh(Tt){if(Ut.xhrs.has(Tt)){var pt=Ut.xhrs.get(Tt);Ut.xhrs.free(Tt),pt.readyState>0&&pt.readyState<4&&pt.abort()}}var kl=(Tt,pt)=>{var Xt=Ro[Tt];return Xt===void 0&&pn(pt+" has unknown type "+ha(Tt)),Xt},Xc=(Tt,pt,Xt)=>{var Ti=[],ji=Tt.toWireType(Ti,Xt);return Ti.length&&(at[pt>>2]=v0.toHandle(Ti)),ji},Ul=(Tt,pt,Xt)=>(Tt=v0.toValue(Tt),pt=kl(pt,"emval::as"),Xc(pt,Xt,Tt)),Yh={},Kc=Tt=>{var pt=Yh[Tt];return pt===void 0?ps(Tt):pt},ro=()=>{if(typeof globalThis=="object")return globalThis;function Tt(pt){pt.$$$embind_global$$$=pt;var Xt=typeof $$$embind_global$$$=="object"&&pt.$$$embind_global$$$==pt;return Xt||delete pt.$$$embind_global$$$,Xt}if(typeof $$$embind_global$$$=="object"||(typeof __webpack_require__.g=="object"&&Tt(__webpack_require__.g)?$$$embind_global$$$=__webpack_require__.g:typeof self=="object"&&Tt(self)&&($$$embind_global$$$=self),typeof $$$embind_global$$$=="object"))return $$$embind_global$$$;throw Error("unable to get global object.")},vx=Tt=>Tt===0?v0.toHandle(ro()):(Tt=Kc(Tt),v0.toHandle(ro()[Tt])),v2=(Tt,pt)=>(Tt=v0.toValue(Tt),pt=v0.toValue(pt),v0.toHandle(Tt[pt])),zs=Tt=>v0.toHandle(Kc(Tt)),a0=Tt=>{var pt=v0.toValue(Tt);Ko(pt),al(Tt)},z0=(Tt,pt)=>{Tt=kl(Tt,"_emval_take_value");var Xt=Tt.readValueFromPointer(pt);return v0.toHandle(Xt)},q0=()=>{xs("")},Lt=()=>!ve,ct=(Tt,pt,Xt)=>Ye.copyWithin(Tt,pt,pt+Xt),ai=()=>2147483648,ki=Tt=>{var pt=Ge.buffer,Xt=(Tt-pt.byteLength+65535)/65536;try{return Ge.grow(Xt),kt(),1}catch{}},_t=Tt=>{var pt=Ye.length;Tt>>>=0;var Xt=ai();if(Tt>Xt)return!1;for(var Ti=(lr,Rr)=>lr+(Rr-lr%Rr)%Rr,ji=1;ji<=4;ji*=2){var rs=pt*(1+.2/ji);rs=Math.min(rs,Tt+100663296);var Ts=Math.min(Xt,Ti(Math.max(Tt,rs),65536)),ls=ki(Ts);if(ls)return!0}return!1};class vt{constructor(){this.allocated=[void 0],this.freelist=[]}get(pt){return this.allocated[pt]}has(pt){return this.allocated[pt]!==void 0}allocate(pt){var Xt=this.freelist.pop()||this.allocated.length;return this.allocated[Xt]=pt,Xt}free(pt){this.allocated[pt]=void 0,this.freelist.push(pt)}}var Ut={openDatabase(Tt,pt,Xt,Ti){try{var ji=indexedDB.open(Tt,pt)}catch(rs){return Ti(rs)}ji.onupgradeneeded=rs=>{var Ts=rs.target.result;Ts.objectStoreNames.contains("FILES")&&Ts.deleteObjectStore("FILES"),Ts.createObjectStore("FILES")},ji.onsuccess=rs=>Xt(rs.target.result),ji.onerror=Ti},init(){Ut.xhrs=new vt;var Tt=Xt=>{Ut.dbInstance=Xt,$i()},pt=()=>{Ut.dbInstance=!1,$i()};Xs(),Ut.openDatabase("emscripten_filesystem",1,Tt,pt)}};function jt(Tt,pt,Xt,Ti,ji){var rs=at[Tt+8>>2];if(!rs){Xt(Tt,0,"no url specified!");return}var Ts=G0(rs),ls=Tt+112,lr=G0(ls+0);lr||(lr="GET");var Rr=at[ls+56>>2],hr=at[ls+68>>2],_n=at[ls+72>>2],un=at[ls+76>>2],Un=at[ls+80>>2],ca=at[ls+84>>2],ws=at[ls+88>>2],vr=at[ls+52>>2],na=!!(vr&1),Hs=!!(vr&2),rn=!!(vr&64),ua=hr?G0(hr):void 0,ka=_n?G0(_n):void 0,nn=new XMLHttpRequest;if(nn.withCredentials=!!Ye[ls+60],nn.open(lr,Ts,!rn,ua,ka),rn||(nn.timeout=Rr),nn.url_=Ts,nn.responseType="arraybuffer",Un){var R0=G0(Un);nn.overrideMimeType(R0)}if(un)for(;;){var Gl=at[un>>2];if(!Gl)break;var ks=at[un+4>>2];if(!ks)break;un+=8;var Gt=G0(Gl),Kn=G0(ks);nn.setRequestHeader(Gt,Kn)}var ja=Ut.xhrs.allocate(nn);at[Tt>>2]=ja;var jm=ca&&ws?Ye.slice(ca,ca+ws):null;function jc(){var jn=0,Hx=0;nn.response&&na&&at[Tt+12>>2]===0&&(Hx=nn.response.byteLength),Hx>0&&(jn=Yc(Hx),Ye.set(new Uint8Array(nn.response),jn)),at[Tt+12>>2]=jn,cn(Tt+16,Hx),cn(Tt+24,0);var ll=nn.response?nn.response.byteLength:0;ll&&cn(Tt+32,ll),$e[Tt+40>>1]=nn.readyState,$e[Tt+42>>1]=nn.status,nn.statusText&&Mo(nn.statusText,Tt+44,64)}nn.onload=jn=>{Ut.xhrs.has(ja)&&(jc(),nn.status>=200&&nn.status<300?pt?.(Tt,nn,jn):Xt?.(Tt,nn,jn))},nn.onerror=jn=>{Ut.xhrs.has(ja)&&(jc(),Xt?.(Tt,nn,jn))},nn.ontimeout=jn=>{Ut.xhrs.has(ja)&&Xt?.(Tt,nn,jn)},nn.onprogress=jn=>{if(Ut.xhrs.has(ja)){var Hx=na&&Hs&&nn.response?nn.response.byteLength:0,ll=0;Hx>0&&na&&Hs&&(ll=Yc(Hx),Ye.set(new Uint8Array(nn.response),ll)),at[Tt+12>>2]=ll,cn(Tt+16,Hx),cn(Tt+24,jn.loaded-Hx),cn(Tt+32,jn.total),$e[Tt+40>>1]=nn.readyState,nn.readyState>=3&&nn.status===0&&jn.loaded>0&&(nn.status=200),$e[Tt+42>>1]=nn.status,nn.statusText&&Mo(nn.statusText,Tt+44,64),Ti?.(Tt,nn,jn),ll&&Wx(ll)}},nn.onreadystatechange=jn=>{Ut.xhrs.has(ja)&&($e[Tt+40>>1]=nn.readyState,nn.readyState>=2&&($e[Tt+42>>1]=nn.status),ji?.(Tt,nn,jn))};try{nn.send(jm)}catch(jn){Xt?.(Tt,nn,jn)}}var ni=Tt=>{if(Tt instanceof cr||Tt=="unwind")return He;ue(1,Tt)},ri=0,Li=()=>kr||ri>0,zi=Tt=>{var pt;He=Tt,Li()||((pt=V.onExit)==null||pt.call(V,Tt),ze=!0),ue(Tt,new cr(Tt))},Rs=(Tt,pt)=>{He=Tt,zi(Tt)},as=Rs,Ms=()=>{if(!Li())try{as(He)}catch(Tt){ni(Tt)}},an=Tt=>{if(!ze)try{Tt(),Ms()}catch(pt){ni(pt)}},cn=(Tt,pt)=>{at[Tt>>2]=pt;var Xt=at[Tt>>2];at[Tt+4>>2]=(pt-Xt)/4294967296};function Mn(Tt,pt,Xt,Ti,ji){if(!Tt){ji(pt,0,"IndexedDB not available!");return}var rs=pt+112,Ts=at[rs+64>>2];Ts||(Ts=at[pt+8>>2]);var ls=G0(Ts);try{var lr=Tt.transaction(["FILES"],"readwrite"),Rr=lr.objectStore("FILES"),hr=Rr.put(Xt,ls);hr.onsuccess=_n=>{$e[pt+40>>1]=4,$e[pt+42>>1]=200,Mo("OK",pt+44,64),Ti(pt,0,ls)},hr.onerror=_n=>{$e[pt+40>>1]=4,$e[pt+42>>1]=413,Mo("Payload Too Large",pt+44,64),ji(pt,0,_n)}}catch(_n){ji(pt,0,_n)}}function wn(Tt,pt,Xt,Ti){if(!Tt){Ti(pt,0,"IndexedDB not available!");return}var ji=pt+112,rs=at[ji+64>>2];rs||(rs=at[pt+8>>2]);var Ts=G0(rs);try{var ls=Tt.transaction(["FILES"],"readonly"),lr=ls.objectStore("FILES"),Rr=lr.get(Ts);Rr.onsuccess=hr=>{if(hr.target.result){var _n=hr.target.result,un=_n.byteLength||_n.length,Un=Yc(un);Ye.set(new Uint8Array(_n),Un),at[pt+12>>2]=Un,cn(pt+16,un),cn(pt+24,0),cn(pt+32,un),$e[pt+40>>1]=4,$e[pt+42>>1]=200,Mo("OK",pt+44,64),Xt(pt,0,_n)}else $e[pt+40>>1]=4,$e[pt+42>>1]=404,Mo("Not Found",pt+44,64),Ti(pt,0,"no data")},Rr.onerror=hr=>{$e[pt+40>>1]=4,$e[pt+42>>1]=404,Mo("Not Found",pt+44,64),Ti(pt,0,hr)}}catch(hr){Ti(pt,0,hr)}}function xr(Tt,pt,Xt,Ti){if(!Tt){Ti(pt,0,"IndexedDB not available!");return}var ji=pt+112,rs=at[ji+64>>2];rs||(rs=at[pt+8>>2]);var Ts=G0(rs);try{var ls=Tt.transaction(["FILES"],"readwrite"),lr=ls.objectStore("FILES"),Rr=lr.delete(Ts);Rr.onsuccess=hr=>{var _n=hr.target.result;at[pt+12>>2]=0,cn(pt+16,0),cn(pt+24,0),cn(pt+32,0),$e[pt+40>>1]=4,$e[pt+42>>1]=200,Mo("OK",pt+44,64),Xt(pt,0,_n)},Rr.onerror=hr=>{$e[pt+40>>1]=4,$e[pt+42>>1]=404,Mo("Not Found",pt+44,64),Ti(pt,0,hr)}}catch(hr){Ti(pt,0,hr)}}function nt(Tt,pt,Xt,Ti,ji){var rs=Tt+112,Ts=at[rs+36>>2],ls=at[rs+40>>2],lr=at[rs+44>>2],Rr=at[rs+48>>2],hr=at[rs+52>>2],_n=!!(hr&64);function un(Gt){_n?Gt():an(Gt)}var Un=(Gt,Kn,ja)=>{un(()=>{Ts?n0(Ts)(Gt):pt?.(Gt)})},ca=(Gt,Kn,ja)=>{un(()=>{lr?n0(lr)(Gt):Ti?.(Gt)})},ws=(Gt,Kn,ja)=>{un(()=>{ls?n0(ls)(Gt):Xt?.(Gt)})},vr=(Gt,Kn,ja)=>{un(()=>{Rr?n0(Rr)(Gt):ji?.(Gt)})},na=(Gt,Kn,ja)=>{jt(Gt,Un,ws,ca,vr)},Hs=(Gt,Kn,ja)=>{var jm=(jn,Hx,ll)=>{un(()=>{Ts?n0(Ts)(jn):pt?.(jn)})},jc=(jn,Hx,ll)=>{un(()=>{Ts?n0(Ts)(jn):pt?.(jn)})};Mn(Ut.dbInstance,Gt,Kn.response,jm,jc)},rn=(Gt,Kn,ja)=>{jt(Gt,Hs,ws,ca,vr)},ua=G0(rs+0),ka=!!(hr&16),nn=!!(hr&4),R0=!!(hr&32);if(ua==="EM_IDB_STORE"){var Gl=at[rs+84>>2],ks=at[rs+88>>2];Mn(Ut.dbInstance,Tt,Ye.slice(Gl,Gl+ks),Un,ws)}else if(ua==="EM_IDB_DELETE")xr(Ut.dbInstance,Tt,Un,ws);else if(!ka)wn(Ut.dbInstance,Tt,Un,R0?ws:nn?rn:na);else if(!R0)jt(Tt,nn?Hs:Un,ws,ca,vr);else return 0;return Tt}var Gr={},_s=()=>he||"./this.program",Yt=()=>{if(!Yt.strings){var Tt=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",pt={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:Tt,_:_s()};for(var Xt in Gr)Gr[Xt]===void 0?delete pt[Xt]:pt[Xt]=Gr[Xt];var Ti=[];for(var Xt in pt)Ti.push(Xt+"="+pt[Xt]);Yt.strings=Ti}return Yt.strings},Us=(Tt,pt)=>{for(var Xt=0;Xt<Tt.length;++Xt)Ke[pt++]=Tt.charCodeAt(Xt);Ke[pt]=0},pi=(Tt,pt)=>{var Xt=0;return Yt().forEach((Ti,ji)=>{var rs=pt+Xt;at[Tt+ji*4>>2]=rs,Us(Ti,rs),Xt+=Ti.length+1}),0},Rx=(Tt,pt)=>{var Xt=Yt();at[Tt>>2]=Xt.length;var Ti=0;return Xt.forEach(ji=>Ti+=ji.length+1),at[pt>>2]=Ti,0},Mx=Tt=>Tt%4===0&&(Tt%100!==0||Tt%400===0),rh=(Tt,pt)=>{for(var Xt=0,Ti=0;Ti<=pt;Xt+=Tt[Ti++]);return Xt},Tu=[31,29,31,30,31,30,31,31,30,31,30,31],$p=[31,28,31,30,31,30,31,31,30,31,30,31],qy=(Tt,pt)=>{for(var Xt=new Date(Tt.getTime());pt>0;){var Ti=Mx(Xt.getFullYear()),ji=Xt.getMonth(),rs=(Ti?Tu:$p)[ji];if(pt>rs-Xt.getDate())pt-=rs-Xt.getDate()+1,Xt.setDate(1),ji<11?Xt.setMonth(ji+1):(Xt.setMonth(0),Xt.setFullYear(Xt.getFullYear()+1));else return Xt.setDate(Xt.getDate()+pt),Xt}return Xt};function Mt(Tt,pt,Xt){var Ti=Xt>0?Xt:Hc(Tt)+1,ji=new Array(Ti),rs=u2(Tt,ji,0,ji.length);return pt&&(ji.length=rs),ji}var $y=(Tt,pt)=>{Ke.set(Tt,pt)},rb=(Tt,pt,Xt,Ti)=>{var ji=at[Ti+40>>2],rs={tm_sec:rt[Ti>>2],tm_min:rt[Ti+4>>2],tm_hour:rt[Ti+8>>2],tm_mday:rt[Ti+12>>2],tm_mon:rt[Ti+16>>2],tm_year:rt[Ti+20>>2],tm_wday:rt[Ti+24>>2],tm_yday:rt[Ti+28>>2],tm_isdst:rt[Ti+32>>2],tm_gmtoff:rt[Ti+36>>2],tm_zone:ji?G0(ji):""},Ts=G0(Xt),ls={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var lr in ls)Ts=Ts.replace(new RegExp(lr,"g"),ls[lr]);var Rr=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],hr=["January","February","March","April","May","June","July","August","September","October","November","December"];function _n(Hs,rn,ua){for(var ka=typeof Hs=="number"?Hs.toString():Hs||"";ka.length<rn;)ka=ua[0]+ka;return ka}function un(Hs,rn){return _n(Hs,rn,"0")}function Un(Hs,rn){function ua(nn){return nn<0?-1:nn>0?1:0}var ka;return(ka=ua(Hs.getFullYear()-rn.getFullYear()))===0&&(ka=ua(Hs.getMonth()-rn.getMonth()))===0&&(ka=ua(Hs.getDate()-rn.getDate())),ka}function ca(Hs){switch(Hs.getDay()){case 0:return new Date(Hs.getFullYear()-1,11,29);case 1:return Hs;case 2:return new Date(Hs.getFullYear(),0,3);case 3:return new Date(Hs.getFullYear(),0,2);case 4:return new Date(Hs.getFullYear(),0,1);case 5:return new Date(Hs.getFullYear()-1,11,31);case 6:return new Date(Hs.getFullYear()-1,11,30)}}function ws(Hs){var rn=qy(new Date(Hs.tm_year+1900,0,1),Hs.tm_yday),ua=new Date(rn.getFullYear(),0,4),ka=new Date(rn.getFullYear()+1,0,4),nn=ca(ua),R0=ca(ka);return Un(nn,rn)<=0?Un(R0,rn)<=0?rn.getFullYear()+1:rn.getFullYear():rn.getFullYear()-1}var vr={"%a":Hs=>Rr[Hs.tm_wday].substring(0,3),"%A":Hs=>Rr[Hs.tm_wday],"%b":Hs=>hr[Hs.tm_mon].substring(0,3),"%B":Hs=>hr[Hs.tm_mon],"%C":Hs=>{var rn=Hs.tm_year+1900;return un(rn/100|0,2)},"%d":Hs=>un(Hs.tm_mday,2),"%e":Hs=>_n(Hs.tm_mday,2," "),"%g":Hs=>ws(Hs).toString().substring(2),"%G":ws,"%H":Hs=>un(Hs.tm_hour,2),"%I":Hs=>{var rn=Hs.tm_hour;return rn==0?rn=12:rn>12&&(rn-=12),un(rn,2)},"%j":Hs=>un(Hs.tm_mday+rh(Mx(Hs.tm_year+1900)?Tu:$p,Hs.tm_mon-1),3),"%m":Hs=>un(Hs.tm_mon+1,2),"%M":Hs=>un(Hs.tm_min,2),"%n":()=>`
`,"%p":Hs=>Hs.tm_hour>=0&&Hs.tm_hour<12?"AM":"PM","%S":Hs=>un(Hs.tm_sec,2),"%t":()=>"	","%u":Hs=>Hs.tm_wday||7,"%U":Hs=>{var rn=Hs.tm_yday+7-Hs.tm_wday;return un(Math.floor(rn/7),2)},"%V":Hs=>{var rn=Math.floor((Hs.tm_yday+7-(Hs.tm_wday+6)%7)/7);if((Hs.tm_wday+371-Hs.tm_yday-2)%7<=2&&rn++,rn){if(rn==53){var ua=(Hs.tm_wday+371-Hs.tm_yday)%7;ua!=4&&(ua!=3||!Mx(Hs.tm_year))&&(rn=1)}}else{rn=52;var ka=(Hs.tm_wday+7-Hs.tm_yday-1)%7;(ka==4||ka==5&&Mx(Hs.tm_year%400-1))&&rn++}return un(rn,2)},"%w":Hs=>Hs.tm_wday,"%W":Hs=>{var rn=Hs.tm_yday+7-(Hs.tm_wday+6)%7;return un(Math.floor(rn/7),2)},"%y":Hs=>(Hs.tm_year+1900).toString().substring(2),"%Y":Hs=>Hs.tm_year+1900,"%z":Hs=>{var rn=Hs.tm_gmtoff,ua=rn>=0;return rn=Math.abs(rn)/60,rn=rn/60*100+rn%60,(ua?"+":"-")+("0000"+rn).slice(-4)},"%Z":Hs=>Hs.tm_zone,"%%":()=>"%"};Ts=Ts.replace(/%%/g,"\0\0");for(var lr in vr)Ts.includes(lr)&&(Ts=Ts.replace(new RegExp(lr,"g"),vr[lr](rs)));Ts=Ts.replace(/\0\0/g,"%");var na=Mt(Ts,!1);return na.length>pt?0:($y(na,Tt),na.length-1)},nb=(Tt,pt,Xt,Ti,ji)=>rb(Tt,pt,Xt,Ti);ra(),Ma=V.BindingError=class extends Error{constructor(Tt){super(Tt),this.name="BindingError"}},jr=V.InternalError=class extends Error{constructor(Tt){super(Tt),this.name="InternalError"}},G2(),Tr(),po(),K2=V.UnboundTypeError=Xo(Error,"UnboundTypeError"),za(),Ut.init();var ab={a:Ln,s:zn,z:U2,l:nx,f:Gc,c:T0,o:ui,y:xl,r:zc,e:Wh,b:c2,q:Ml,m:Tx,A:$2,B:Kh,g:Ul,d:al,n:vx,h:v2,k:zs,j:a0,i:z0,p:q0,D:Lt,x:ct,w:_t,C:nt,u:pi,v:Rx,t:nb},qo=sr(),Yc=Tt=>(Yc=qo.G)(Tt),Wx=Tt=>(Wx=qo.I)(Tt),Ym=Tt=>(Ym=qo.J)(Tt),s_=Tt=>(s_=qo.K)(Tt);V.dynCall_viijii=(Tt,pt,Xt,Ti,ji,rs,Ts)=>(V.dynCall_viijii=qo.L)(Tt,pt,Xt,Ti,ji,rs,Ts),V.dynCall_iiiiij=(Tt,pt,Xt,Ti,ji,rs,Ts)=>(V.dynCall_iiiiij=qo.M)(Tt,pt,Xt,Ti,ji,rs,Ts),V.dynCall_iiiiijj=(Tt,pt,Xt,Ti,ji,rs,Ts,ls,lr)=>(V.dynCall_iiiiijj=qo.N)(Tt,pt,Xt,Ti,ji,rs,Ts,ls,lr),V.dynCall_iiiiiijj=(Tt,pt,Xt,Ti,ji,rs,Ts,ls,lr,Rr)=>(V.dynCall_iiiiiijj=qo.O)(Tt,pt,Xt,Ti,ji,rs,Ts,ls,lr,Rr);var rm;Gs=function Tt(){rm||r_(),rm||(Gs=Tt)};function r_(){if(ns>0||(ci(),ns>0))return;function Tt(){rm||(rm=!0,V.calledRun=!0,!ze&&(li(),re(V),V.onRuntimeInitialized&&V.onRuntimeInitialized(),qi()))}V.setStatus?(V.setStatus("Running..."),setTimeout(function(){setTimeout(function(){V.setStatus("")},1),Tt()},1)):Tt()}if(V.preInit)for(typeof V.preInit=="function"&&(V.preInit=[V.preInit]);V.preInit.length>0;)V.preInit.pop()();return r_(),I.ready}})();async function VM(Z,I="./",V=!1){const re=await VY({locateFile:ae=>I+ae});return re.Loader.prototype.promisify=function(ae,...le){return ae.call(this,...le),new Promise(he=>{const ue=setInterval(()=>{if(this.ready)return clearInterval(ue),he(this.status)},5)})},re.Loader.prototype.load=function(ae){return this.promisify(this.loadAsync,ae,V)},re.Loader.prototype.remove=function(ae){return this.promisify(this.removeAsync,ae)},re.DictLoader.prototype.loadDict=function(ae){return this.promisify(this.loadDictAsync,Z,ae)},re}var Vh=(()=>{var Z=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(I={}){var V=I,re,ae;V.ready=new Promise((Lt,ct)=>{re=Lt,ae=ct});var le=Object.assign({},V),he=!0,ue="";function pe(Lt){return V.locateFile?V.locateFile(Lt,ue):ue+Lt}typeof document<"u"&&document.currentScript&&(ue=document.currentScript.src),Z&&(ue=Z),ue.startsWith("blob:")?ue="":ue=ue.substr(0,ue.replace(/[?#].*/,"").lastIndexOf("/")+1),V.print||console.log.bind(console);var ve=V.printErr||console.error.bind(console);Object.assign(V,le),le=null,V.arguments&&V.arguments,V.thisProgram&&V.thisProgram,V.quit&&V.quit;var we;V.wasmBinary&&(we=V.wasmBinary);var Me,Le=!1,Ue,Ge,ze,He,Ke,Ye,$e,je;function rt(){var Lt=Me.buffer;V.HEAP8=Ue=new Int8Array(Lt),V.HEAP16=ze=new Int16Array(Lt),V.HEAPU8=Ge=new Uint8Array(Lt),V.HEAPU16=He=new Uint16Array(Lt),V.HEAP32=Ke=new Int32Array(Lt),V.HEAPU32=Ye=new Uint32Array(Lt),V.HEAPF32=$e=new Float32Array(Lt),V.HEAPF64=je=new Float64Array(Lt)}var at=[],Rt=[],lt=[];function kt(){if(V.preRun)for(typeof V.preRun=="function"&&(V.preRun=[V.preRun]);V.preRun.length;)_i(V.preRun.shift());Ks(at)}function qt(){Ks(Rt)}function Kt(){if(V.postRun)for(typeof V.postRun=="function"&&(V.postRun=[V.postRun]);V.postRun.length;)li(V.postRun.shift());Ks(lt)}function _i(Lt){at.unshift(Lt)}function ci(Lt){Rt.unshift(Lt)}function li(Lt){lt.unshift(Lt)}var qi=0,Ki=null;function hs(Lt){var ct;qi++,(ct=V.monitorRunDependencies)==null||ct.call(V,qi)}function Yi(Lt){var ct;if(qi--,(ct=V.monitorRunDependencies)==null||ct.call(V,qi),qi==0&&Ki){var ai=Ki;Ki=null,ai()}}function ns(Lt){var ct;(ct=V.onAbort)==null||ct.call(V,Lt),Lt="Aborted("+Lt+")",ve(Lt),Le=!0,Lt+=". Build with -sASSERTIONS for more info.";var ai=new WebAssembly.RuntimeError(Lt);throw ae(ai),ai}var Gs="data:application/octet-stream;base64,",Xs=Lt=>Lt.startsWith(Gs),$i;$i="poseutils.wasm",Xs($i)||($i=pe($i));function xs(Lt){if(Lt==$i&&we)return new Uint8Array(we);throw"both async and sync fetching of the wasm failed"}function hi(Lt){return!we&&he&&typeof fetch=="function"?fetch(Lt,{credentials:"same-origin"}).then(ct=>{if(!ct.ok)throw"failed to load wasm binary file at '"+Lt+"'";return ct.arrayBuffer()}).catch(()=>xs(Lt)):Promise.resolve().then(()=>xs(Lt))}function Ri(Lt,ct,ai){return hi(Lt).then(ki=>WebAssembly.instantiate(ki,ct)).then(ai,ki=>{ve("failed to asynchronously prepare wasm: "+ki),ns(ki)})}function Wi(Lt,ct,ai,ki){return!Lt&&typeof WebAssembly.instantiateStreaming=="function"&&!Xs(ct)&&typeof fetch=="function"?fetch(ct,{credentials:"same-origin"}).then(_t=>{var vt=WebAssembly.instantiateStreaming(_t,ai);return vt.then(ki,function(Ut){return ve("wasm streaming compile failed: "+Ut),ve("falling back to ArrayBuffer instantiation"),Ri(ct,ai,ki)})}):Ri(ct,ai,ki)}function us(){var Lt={a:Kc};function ct(ki,_t){return ro=ki.exports,Me=ro.v,rt(),va=ro.z,ci(ro.w),Yi(),ro}hs();function ai(ki){ct(ki.instance)}if(V.instantiateWasm)try{return V.instantiateWasm(Lt,ct)}catch(ki){ve("Module.instantiateWasm callback failed with error: "+ki),ae(ki)}return Wi(we,$i,Lt,ai).catch(ae),{}}var Ks=Lt=>{for(;Lt.length>0;)Lt.shift()(V)};V.noExitRuntime;class ur{constructor(ct){this.excPtr=ct,this.ptr=ct-24}set_type(ct){Ye[this.ptr+4>>2]=ct}get_type(){return Ye[this.ptr+4>>2]}set_destructor(ct){Ye[this.ptr+8>>2]=ct}get_destructor(){return Ye[this.ptr+8>>2]}set_caught(ct){ct=ct?1:0,Ue[this.ptr+12]=ct}get_caught(){return Ue[this.ptr+12]!=0}set_rethrown(ct){ct=ct?1:0,Ue[this.ptr+13]=ct}get_rethrown(){return Ue[this.ptr+13]!=0}init(ct,ai){this.set_adjusted_ptr(0),this.set_type(ct),this.set_destructor(ai)}set_adjusted_ptr(ct){Ye[this.ptr+16>>2]=ct}get_adjusted_ptr(){return Ye[this.ptr+16>>2]}get_exception_ptr(){var ct=a0(this.get_type());if(ct)return Ye[this.excPtr>>2];var ai=this.get_adjusted_ptr();return ai!==0?ai:this.excPtr}}var js=0,sr=(Lt,ct,ai)=>{var ki=new ur(Lt);throw ki.init(ct,ai),js=Lt,js},cr={},ln=Lt=>{for(;Lt.length;){var ct=Lt.pop(),ai=Lt.pop();ai(ct)}};function kr(Lt){return this.fromWireType(Ye[Lt>>2])}var $r={},Rn={},Ln={},zn,ra=Lt=>{throw new zn(Lt)},aa=(Lt,ct,ai)=>{Lt.forEach(function(jt){Ln[jt]=ct});function ki(jt){var ni=ai(jt);ni.length!==Lt.length&&ra("Mismatched type converter count");for(var ri=0;ri<Lt.length;++ri)hn(Lt[ri],ni[ri])}var _t=new Array(ct.length),vt=[],Ut=0;ct.forEach((jt,ni)=>{Rn.hasOwnProperty(jt)?_t[ni]=Rn[jt]:(vt.push(jt),$r.hasOwnProperty(jt)||($r[jt]=[]),$r[jt].push(()=>{_t[ni]=Rn[jt],++Ut,Ut===vt.length&&ki(_t)}))}),vt.length===0&&ki(_t)},ps=Lt=>{var ct=cr[Lt];delete cr[Lt];var ai=ct.rawConstructor,ki=ct.rawDestructor,_t=ct.fields,vt=_t.map(Ut=>Ut.getterReturnType).concat(_t.map(Ut=>Ut.setterArgumentType));aa([Lt],vt,Ut=>{var jt={};return _t.forEach((ni,ri)=>{var Li=ni.fieldName,zi=Ut[ri],Rs=ni.getter,as=ni.getterContext,Ms=Ut[ri+_t.length],an=ni.setter,cn=ni.setterContext;jt[Li]={read:Mn=>zi.fromWireType(Rs(as,Mn)),write:(Mn,wn)=>{var xr=[];an(cn,Mn,Ms.toWireType(xr,wn)),ln(xr)}}}),[{name:ct.name,fromWireType:ni=>{var ri={};for(var Li in jt)ri[Li]=jt[Li].read(ni);return ki(ni),ri},toWireType:(ni,ri)=>{for(var Li in jt)if(!(Li in ri))throw new TypeError('Missing field: "'+Li+'"');var zi=ai();for(Li in jt)jt[Li].write(zi,ri[Li]);return ni!==null&&ni.push(ki,zi),zi},argPackAdvance:Wo,readValueFromPointer:kr,destructorFunction:ki}]})},l0=(Lt,ct,ai,ki,_t)=>{},Ro=()=>{for(var Lt=new Array(256),ct=0;ct<256;++ct)Lt[ct]=String.fromCharCode(ct);rx=Lt},rx,Ma=Lt=>{for(var ct="",ai=Lt;Ge[ai];)ct+=rx[Ge[ai++]];return ct},pn,jr=Lt=>{throw new pn(Lt)};function uo(Lt,ct,ai={}){var ki=ct.name;if(Lt||jr('type "'+ki+'" must have a positive integer typeid pointer'),Rn.hasOwnProperty(Lt)){if(ai.ignoreDuplicateRegistrations)return;jr("Cannot register type '"+ki+"' twice")}if(Rn[Lt]=ct,delete Ln[Lt],$r.hasOwnProperty(Lt)){var _t=$r[Lt];delete $r[Lt],_t.forEach(vt=>vt())}}function hn(Lt,ct,ai={}){if(!("argPackAdvance"in ct))throw new TypeError("registerType registeredInstance requires argPackAdvance");return uo(Lt,ct,ai)}var Wo=8,c0=(Lt,ct,ai,ki)=>{ct=Ma(ct),hn(Lt,{name:ct,fromWireType:function(_t){return!!_t},toWireType:function(_t,vt){return vt?ai:ki},argPackAdvance:Wo,readValueFromPointer:function(_t){return this.fromWireType(Ge[_t])},destructorFunction:null})},U0=Lt=>({count:Lt.count,deleteScheduled:Lt.deleteScheduled,preservePointerOnDelete:Lt.preservePointerOnDelete,ptr:Lt.ptr,ptrType:Lt.ptrType,smartPtr:Lt.smartPtr,smartPtrType:Lt.smartPtrType}),U2=Lt=>{function ct(ai){return ai.$$.ptrType.registeredClass.name}jr(ct(Lt)+" instance already deleted")},kh=!1,$x=Lt=>{},Tl=Lt=>{Lt.smartPtr?Lt.smartPtrType.rawDestructor(Lt.smartPtr):Lt.ptrType.registeredClass.rawDestructor(Lt.ptr)},Mi=Lt=>{Lt.count.value-=1;var ct=Lt.count.value===0;ct&&Tl(Lt)},Uh=(Lt,ct,ai)=>{if(ct===ai)return Lt;if(ai.baseClass===void 0)return null;var ki=Uh(Lt,ct,ai.baseClass);return ki===null?null:ai.downcast(ki)},Gn={},u0=()=>Object.keys(rl).length,wa=()=>{var Lt=[];for(var ct in rl)rl.hasOwnProperty(ct)&&Lt.push(rl[ct]);return Lt},Ho=[],px=()=>{for(;Ho.length;){var Lt=Ho.pop();Lt.$$.deleteScheduled=!1,Lt.delete()}},Y0,$l=Lt=>{Y0=Lt,Ho.length&&Y0&&Y0(px)},wr=()=>{V.getInheritedInstanceCount=u0,V.getLiveInheritedInstances=wa,V.flushPendingDeletes=px,V.setDelayFunction=$l},rl={},Tr=(Lt,ct)=>{for(ct===void 0&&jr("ptr should not be undefined");Lt.baseClass;)ct=Lt.upcast(ct),Lt=Lt.baseClass;return ct},vi=(Lt,ct)=>(ct=Tr(Lt,ct),rl[ct]),r2=(Lt,ct)=>{(!ct.ptrType||!ct.ptr)&&ra("makeClassHandle requires ptr and ptrType");var ai=!!ct.smartPtrType,ki=!!ct.smartPtr;return ai!==ki&&ra("Both smartPtrType and smartPtr must be specified"),ct.count={value:1},j0(Object.create(Lt,{$$:{value:ct,writable:!0}}))};function vc(Lt){var ct=this.getPointee(Lt);if(!ct)return this.destructor(Lt),null;var ai=vi(this.registeredClass,ct);if(ai!==void 0){if(ai.$$.count.value===0)return ai.$$.ptr=ct,ai.$$.smartPtr=Lt,ai.clone();var ki=ai.clone();return this.destructor(Lt),ki}function _t(){return this.isSmartPointer?r2(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:ct,smartPtrType:this,smartPtr:Lt}):r2(this.registeredClass.instancePrototype,{ptrType:this,ptr:Lt})}var vt=this.registeredClass.getActualType(ct),Ut=Gn[vt];if(!Ut)return _t.call(this);var jt;this.isConst?jt=Ut.constPointerType:jt=Ut.pointerType;var ni=Uh(ct,this.registeredClass,jt.registeredClass);return ni===null?_t.call(this):this.isSmartPointer?r2(jt.registeredClass.instancePrototype,{ptrType:jt,ptr:ni,smartPtrType:this,smartPtr:Lt}):r2(jt.registeredClass.instancePrototype,{ptrType:jt,ptr:ni})}var j0=Lt=>typeof FinalizationRegistry>"u"?(j0=ct=>ct,Lt):(kh=new FinalizationRegistry(ct=>{Mi(ct.$$)}),j0=ct=>{var ai=ct.$$,ki=!!ai.smartPtr;if(ki){var _t={$$:ai};kh.register(ct,_t,ct)}return ct},$x=ct=>kh.unregister(ct),j0(Lt)),Rc=()=>{Object.assign(io.prototype,{isAliasOf(Lt){if(!(this instanceof io)||!(Lt instanceof io))return!1;var ct=this.$$.ptrType.registeredClass,ai=this.$$.ptr;Lt.$$=Lt.$$;for(var ki=Lt.$$.ptrType.registeredClass,_t=Lt.$$.ptr;ct.baseClass;)ai=ct.upcast(ai),ct=ct.baseClass;for(;ki.baseClass;)_t=ki.upcast(_t),ki=ki.baseClass;return ct===ki&&ai===_t},clone(){if(this.$$.ptr||U2(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var Lt=j0(Object.create(Object.getPrototypeOf(this),{$$:{value:U0(this.$$)}}));return Lt.$$.count.value+=1,Lt.$$.deleteScheduled=!1,Lt},delete(){this.$$.ptr||U2(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&jr("Object already scheduled for deletion"),$x(this),Mi(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||U2(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&jr("Object already scheduled for deletion"),Ho.push(this),Ho.length===1&&Y0&&Y0(px),this.$$.deleteScheduled=!0,this}})};function io(){}var G2=(Lt,ct)=>Object.defineProperty(ct,"name",{value:Lt}),Wn=(Lt,ct,ai)=>{if(Lt[ct].overloadTable===void 0){var ki=Lt[ct];Lt[ct]=function(..._t){return Lt[ct].overloadTable.hasOwnProperty(_t.length)||jr("Function '"+ai+"' called with an invalid number of arguments ("+_t.length+") - expects one of ("+Lt[ct].overloadTable+")!"),Lt[ct].overloadTable[_t.length].apply(this,_t)},Lt[ct].overloadTable=[],Lt[ct].overloadTable[ki.argCount]=ki}},_x=(Lt,ct,ai)=>{V.hasOwnProperty(Lt)?((ai===void 0||V[Lt].overloadTable!==void 0&&V[Lt].overloadTable[ai]!==void 0)&&jr("Cannot register public name '"+Lt+"' twice"),Wn(V,Lt,Lt),V.hasOwnProperty(ai)&&jr("Cannot register multiple overloads of a function with the same number of arguments ("+ai+")!"),V[Lt].overloadTable[ai]=ct):(V[Lt]=ct,ai!==void 0&&(V[Lt].numArguments=ai))},z2=48,Mc=57,wc=Lt=>{if(Lt===void 0)return"_unknown";Lt=Lt.replace(/[^a-zA-Z0-9_]/g,"$");var ct=Lt.charCodeAt(0);return ct>=z2&&ct<=Mc?"_"+Lt:Lt};function Xa(Lt,ct,ai,ki,_t,vt,Ut,jt){this.name=Lt,this.constructor=ct,this.instancePrototype=ai,this.rawDestructor=ki,this.baseClass=_t,this.getActualType=vt,this.upcast=Ut,this.downcast=jt,this.pureVirtualFunctions=[]}var n2=(Lt,ct,ai)=>{for(;ct!==ai;)ct.upcast||jr("Expected null or instance of "+ai.name+", got an instance of "+ct.name),Lt=ct.upcast(Lt),ct=ct.baseClass;return Lt};function W2(Lt,ct){if(ct===null)return this.isReference&&jr("null is not a valid "+this.name),0;ct.$$||jr('Cannot pass "'+za(ct)+'" as a '+this.name),ct.$$.ptr||jr("Cannot pass deleted object as a pointer of type "+this.name);var ai=ct.$$.ptrType.registeredClass,ki=n2(ct.$$.ptr,ai,this.registeredClass);return ki}function Gx(Lt,ct){var ai;if(ct===null)return this.isReference&&jr("null is not a valid "+this.name),this.isSmartPointer?(ai=this.rawConstructor(),Lt!==null&&Lt.push(this.rawDestructor,ai),ai):0;(!ct||!ct.$$)&&jr('Cannot pass "'+za(ct)+'" as a '+this.name),ct.$$.ptr||jr("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&ct.$$.ptrType.isConst&&jr("Cannot convert argument of type "+(ct.$$.smartPtrType?ct.$$.smartPtrType.name:ct.$$.ptrType.name)+" to parameter type "+this.name);var ki=ct.$$.ptrType.registeredClass;if(ai=n2(ct.$$.ptr,ki,this.registeredClass),this.isSmartPointer)switch(ct.$$.smartPtr===void 0&&jr("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:ct.$$.smartPtrType===this?ai=ct.$$.smartPtr:jr("Cannot convert argument of type "+(ct.$$.smartPtrType?ct.$$.smartPtrType.name:ct.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:ai=ct.$$.smartPtr;break;case 2:if(ct.$$.smartPtrType===this)ai=ct.$$.smartPtr;else{var _t=ct.clone();ai=this.rawShare(ai,Uo.toHandle(()=>_t.delete())),Lt!==null&&Lt.push(this.rawDestructor,ai)}break;default:jr("Unsupporting sharing policy")}return ai}function Lc(Lt,ct){if(ct===null)return this.isReference&&jr("null is not a valid "+this.name),0;ct.$$||jr('Cannot pass "'+za(ct)+'" as a '+this.name),ct.$$.ptr||jr("Cannot pass deleted object as a pointer of type "+this.name),ct.$$.ptrType.isConst&&jr("Cannot convert argument of type "+ct.$$.ptrType.name+" to parameter type "+this.name);var ai=ct.$$.ptrType.registeredClass,ki=n2(ct.$$.ptr,ai,this.registeredClass);return ki}var Gh=()=>{Object.assign(vl.prototype,{getPointee(Lt){return this.rawGetPointee&&(Lt=this.rawGetPointee(Lt)),Lt},destructor(Lt){var ct;(ct=this.rawDestructor)==null||ct.call(this,Lt)},argPackAdvance:Wo,readValueFromPointer:kr,fromWireType:vc})};function vl(Lt,ct,ai,ki,_t,vt,Ut,jt,ni,ri,Li){this.name=Lt,this.registeredClass=ct,this.isReference=ai,this.isConst=ki,this.isSmartPointer=_t,this.pointeeType=vt,this.sharingPolicy=Ut,this.rawGetPointee=jt,this.rawConstructor=ni,this.rawShare=ri,this.rawDestructor=Li,!_t&&ct.baseClass===void 0?ki?(this.toWireType=W2,this.destructorFunction=null):(this.toWireType=Lc,this.destructorFunction=null):this.toWireType=Gx}var zx=(Lt,ct,ai)=>{V.hasOwnProperty(Lt)||ra("Replacing nonexistent public symbol"),V[Lt].overloadTable!==void 0&&ai!==void 0?V[Lt].overloadTable[ai]=ct:(V[Lt]=ct,V[Lt].argCount=ai)},po=(Lt,ct,ai)=>{var ki=V["dynCall_"+Lt];return ki(ct,...ai)},Gi=[],va,Rl=Lt=>{var ct=Gi[Lt];return ct||(Lt>=Gi.length&&(Gi.length=Lt+1),Gi[Lt]=ct=va.get(Lt)),ct},_o=(Lt,ct,ai=[])=>{if(Lt.includes("j"))return po(Lt,ct,ai);var ki=Rl(ct)(...ai);return ki},X2=(Lt,ct)=>(...ai)=>_o(Lt,ct,ai),n0=(Lt,ct)=>{Lt=Ma(Lt);function ai(){return Lt.includes("j")?X2(Lt,ct):Rl(ct)}var ki=ai();return typeof ki!="function"&&jr("unknown function pointer with signature "+Lt+": "+ct),ki},kc=(Lt,ct)=>{var ai=G2(ct,function(ki){this.name=ct,this.message=ki;var _t=new Error(ki).stack;_t!==void 0&&(this.stack=this.toString()+`
`+_t.replace(/^Error(:[^\n]*)?\n/,""))});return ai.prototype=Object.create(Lt.prototype),ai.prototype.constructor=ai,ai.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},ai},_0,To=Lt=>{var ct=zs(Lt),ai=Ma(ct);return vx(ct),ai},Xo=(Lt,ct)=>{var ai=[],ki={};function _t(vt){if(!ki[vt]&&!Rn[vt]){if(Ln[vt]){Ln[vt].forEach(_t);return}ai.push(vt),ki[vt]=!0}}throw ct.forEach(_t),new _0(Lt+": "+ai.map(To).join([", "]))},K2=(Lt,ct,ai,ki,_t,vt,Ut,jt,ni,ri,Li,zi,Rs)=>{Li=Ma(Li),vt=n0(_t,vt),jt&&(jt=n0(Ut,jt)),ri&&(ri=n0(ni,ri)),Rs=n0(zi,Rs);var as=wc(Li);_x(as,function(){Xo("Cannot construct "+Li+" due to unbound types",[ki])}),aa([Lt,ct,ai],ki?[ki]:[],Ms=>{var an;Ms=Ms[0];var cn,Mn;ki?(cn=Ms.registeredClass,Mn=cn.instancePrototype):Mn=io.prototype;var wn=G2(Li,function(...Us){if(Object.getPrototypeOf(this)!==xr)throw new pn("Use 'new' to construct "+Li);if(nt.constructor_body===void 0)throw new pn(Li+" has no accessible constructor");var pi=nt.constructor_body[Us.length];if(pi===void 0)throw new pn("Tried to invoke ctor of "+Li+" with invalid number of parameters ("+Us.length+") - expected ("+Object.keys(nt.constructor_body).toString()+") parameters instead!");return pi.apply(this,Us)}),xr=Object.create(Mn,{constructor:{value:wn}});wn.prototype=xr;var nt=new Xa(Li,wn,xr,Rs,cn,vt,jt,ri);nt.baseClass&&((an=nt.baseClass).__derivedClasses!=null||(an.__derivedClasses=[]),nt.baseClass.__derivedClasses.push(nt));var Gr=new vl(Li,nt,!0,!1,!1),_s=new vl(Li+"*",nt,!1,!1,!1),Yt=new vl(Li+" const*",nt,!1,!0,!1);return Gn[Lt]={pointerType:_s,constPointerType:Yt},zx(as,wn),[Gr,_s,Yt]})},ha=(Lt,ct)=>{for(var ai=[],ki=0;ki<Lt;ki++)ai.push(Ye[ct+ki*4>>2]);return ai};function nl(Lt){for(var ct=1;ct<Lt.length;++ct)if(Lt[ct]!==null&&Lt[ct].destructorFunction===void 0)return!0;return!1}function nx(Lt,ct,ai,ki,_t,vt){var Ut=ct.length;Ut<2&&jr("argTypes array size mismatch! Must at least get return value and 'this' types!");var jt=ct[1]!==null&&ai!==null,ni=nl(ct),ri=ct[0].name!=="void",Li=Ut-2,zi=new Array(Li),Rs=[],as=[],Ms=function(...an){an.length!==Li&&jr("function "+Lt+" called with "+an.length+" arguments, expected "+Li),as.length=0;var cn;Rs.length=jt?2:1,Rs[0]=_t,jt&&(cn=ct[1].toWireType(as,this),Rs[1]=cn);for(var Mn=0;Mn<Li;++Mn)zi[Mn]=ct[Mn+2].toWireType(as,an[Mn]),Rs.push(zi[Mn]);var wn=ki(...Rs);function xr(nt){if(ni)ln(as);else for(var Gr=jt?1:2;Gr<ct.length;Gr++){var _s=Gr===1?cn:zi[Gr-2];ct[Gr].destructorFunction!==null&&ct[Gr].destructorFunction(_s)}if(ri)return ct[0].fromWireType(nt)}return xr(wn)};return G2(Lt,Ms)}var zh=(Lt,ct,ai,ki,_t,vt)=>{var Ut=ha(ct,ai);_t=n0(ki,_t),aa([],[Lt],jt=>{jt=jt[0];var ni="constructor "+jt.name;if(jt.registeredClass.constructor_body===void 0&&(jt.registeredClass.constructor_body=[]),jt.registeredClass.constructor_body[ct-1]!==void 0)throw new pn("Cannot register multiple constructors with identical number of parameters ("+(ct-1)+") for class '"+jt.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return jt.registeredClass.constructor_body[ct-1]=()=>{Xo("Cannot construct "+jt.name+" due to unbound types",Ut)},aa([],Ut,ri=>(ri.splice(1,0,null),jt.registeredClass.constructor_body[ct-1]=nx(ni,ri,null,_t,vt),[])),[]})},Ko=Lt=>{Lt=Lt.trim();const ct=Lt.indexOf("(");return ct!==-1?Lt.substr(0,ct):Lt},Uc=(Lt,ct,ai,ki,_t,vt,Ut,jt,ni)=>{var ri=ha(ai,ki);ct=Ma(ct),ct=Ko(ct),vt=n0(_t,vt),aa([],[Lt],Li=>{Li=Li[0];var zi=Li.name+"."+ct;ct.startsWith("@@")&&(ct=Symbol[ct.substring(2)]),jt&&Li.registeredClass.pureVirtualFunctions.push(ct);function Rs(){Xo("Cannot call "+zi+" due to unbound types",ri)}var as=Li.registeredClass.instancePrototype,Ms=as[ct];return Ms===void 0||Ms.overloadTable===void 0&&Ms.className!==Li.name&&Ms.argCount===ai-2?(Rs.argCount=ai-2,Rs.className=Li.name,as[ct]=Rs):(Wn(as,ct,zi),as[ct].overloadTable[ai-2]=Rs),aa([],ri,an=>{var cn=nx(zi,an,Li,vt,Ut);return as[ct].overloadTable===void 0?(cn.argCount=ai-2,as[ct]=cn):as[ct].overloadTable[ai-2]=cn,[]}),[]})},rr=(Lt,ct,ai)=>(Lt instanceof Object||jr(ai+' with invalid "this": '+Lt),Lt instanceof ct.registeredClass.constructor||jr(ai+' incompatible with "this" of type '+Lt.constructor.name),Lt.$$.ptr||jr("cannot call emscripten binding method "+ai+" on deleted object"),n2(Lt.$$.ptr,Lt.$$.ptrType.registeredClass,ct.registeredClass)),Gc=(Lt,ct,ai,ki,_t,vt,Ut,jt,ni,ri)=>{ct=Ma(ct),_t=n0(ki,_t),aa([],[Lt],Li=>{Li=Li[0];var zi=Li.name+"."+ct,Rs={get(){Xo("Cannot access "+zi+" due to unbound types",[ai,Ut])},enumerable:!0,configurable:!0};return ni?Rs.set=()=>Xo("Cannot access "+zi+" due to unbound types",[ai,Ut]):Rs.set=as=>jr(zi+" is a read-only property"),Object.defineProperty(Li.registeredClass.instancePrototype,ct,Rs),aa([],ni?[ai,Ut]:[ai],as=>{var Ms=as[0],an={get(){var Mn=rr(this,Li,zi+" getter");return Ms.fromWireType(_t(vt,Mn))},enumerable:!0};if(ni){ni=n0(jt,ni);var cn=as[1];an.set=function(Mn){var wn=rr(this,Li,zi+" setter"),xr=[];ni(ri,wn,cn.toWireType(xr,Mn)),ln(xr)}}return Object.defineProperty(Li.registeredClass.instancePrototype,ct,an),[]}),[]})},a2=[],T0=[],x2=Lt=>{Lt>9&&--T0[Lt+1]===0&&(T0[Lt]=void 0,a2.push(Lt))},ui=()=>T0.length/2-5-a2.length,l2=()=>{T0.push(0,1,void 0,1,null,1,!0,1,!1,1),V.count_emval_handles=ui},Uo={toValue:Lt=>(Lt||jr("Cannot use deleted val. handle = "+Lt),T0[Lt]),toHandle:Lt=>{switch(Lt){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const ct=a2.pop()||T0.length;return T0[ct]=Lt,T0[ct+1]=1,ct}}}},al={name:"emscripten::val",fromWireType:Lt=>{var ct=Uo.toValue(Lt);return x2(Lt),ct},toWireType:(Lt,ct)=>Uo.toHandle(ct),argPackAdvance:Wo,readValueFromPointer:kr,destructorFunction:null},h2=Lt=>hn(Lt,al),za=Lt=>{if(Lt===null)return"null";var ct=typeof Lt;return ct==="object"||ct==="array"||ct==="function"?Lt.toString():""+Lt},v0=(Lt,ct)=>{switch(ct){case 4:return function(ai){return this.fromWireType($e[ai>>2])};case 8:return function(ai){return this.fromWireType(je[ai>>3])};default:throw new TypeError("invalid float width ("+ct+"): "+Lt)}},Y2=(Lt,ct,ai)=>{ct=Ma(ct),hn(Lt,{name:ct,fromWireType:ki=>ki,toWireType:(ki,_t)=>_t,argPackAdvance:Wo,readValueFromPointer:v0(ct,ai),destructorFunction:null})},xl=(Lt,ct,ai)=>{switch(ct){case 1:return ai?ki=>Ue[ki]:ki=>Ge[ki];case 2:return ai?ki=>ze[ki>>1]:ki=>He[ki>>1];case 4:return ai?ki=>Ke[ki>>2]:ki=>Ye[ki>>2];default:throw new TypeError("invalid integer width ("+ct+"): "+Lt)}},Yo=(Lt,ct,ai,ki,_t)=>{ct=Ma(ct);var vt=Li=>Li;if(ki===0){var Ut=32-8*ai;vt=Li=>Li<<Ut>>>Ut}var jt=ct.includes("unsigned"),ni=(Li,zi)=>{},ri;jt?ri=function(Li,zi){return ni(zi,this.name),zi>>>0}:ri=function(Li,zi){return ni(zi,this.name),zi},hn(Lt,{name:ct,fromWireType:vt,toWireType:ri,argPackAdvance:Wo,readValueFromPointer:xl(ct,ai,ki!==0),destructorFunction:null})},jo=(Lt,ct,ai)=>{var ki=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],_t=ki[ct];function vt(Ut){var jt=Ye[Ut>>2],ni=Ye[Ut+4>>2];return new _t(Ue.buffer,ni,jt)}ai=Ma(ai),hn(Lt,{name:ai,fromWireType:vt,argPackAdvance:Wo,readValueFromPointer:vt},{ignoreDuplicateRegistrations:!0})},zc=(Lt,ct,ai,ki)=>{if(!(ki>0))return 0;for(var _t=ai,vt=ai+ki-1,Ut=0;Ut<Lt.length;++Ut){var jt=Lt.charCodeAt(Ut);if(jt>=55296&&jt<=57343){var ni=Lt.charCodeAt(++Ut);jt=65536+((jt&1023)<<10)|ni&1023}if(jt<=127){if(ai>=vt)break;ct[ai++]=jt}else if(jt<=2047){if(ai+1>=vt)break;ct[ai++]=192|jt>>6,ct[ai++]=128|jt&63}else if(jt<=65535){if(ai+2>=vt)break;ct[ai++]=224|jt>>12,ct[ai++]=128|jt>>6&63,ct[ai++]=128|jt&63}else{if(ai+3>=vt)break;ct[ai++]=240|jt>>18,ct[ai++]=128|jt>>12&63,ct[ai++]=128|jt>>6&63,ct[ai++]=128|jt&63}}return ct[ai]=0,ai-_t},Wc=(Lt,ct,ai)=>zc(Lt,Ge,ct,ai),Wh=Lt=>{for(var ct=0,ai=0;ai<Lt.length;++ai){var ki=Lt.charCodeAt(ai);ki<=127?ct++:ki<=2047?ct+=2:ki>=55296&&ki<=57343?(ct+=4,++ai):ct+=3}return ct},c2=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,u2=(Lt,ct,ai)=>{for(var ki=ct+ai,_t=ct;Lt[_t]&&!(_t>=ki);)++_t;if(_t-ct>16&&Lt.buffer&&c2)return c2.decode(Lt.subarray(ct,_t));for(var vt="";ct<_t;){var Ut=Lt[ct++];if(!(Ut&128)){vt+=String.fromCharCode(Ut);continue}var jt=Lt[ct++]&63;if((Ut&224)==192){vt+=String.fromCharCode((Ut&31)<<6|jt);continue}var ni=Lt[ct++]&63;if((Ut&240)==224?Ut=(Ut&15)<<12|jt<<6|ni:Ut=(Ut&7)<<18|jt<<12|ni<<6|Lt[ct++]&63,Ut<65536)vt+=String.fromCharCode(Ut);else{var ri=Ut-65536;vt+=String.fromCharCode(55296|ri>>10,56320|ri&1023)}}return vt},Mo=(Lt,ct)=>Lt?u2(Ge,Lt,ct):"",Hc=(Lt,ct)=>{ct=Ma(ct);var ai=ct==="std::string";hn(Lt,{name:ct,fromWireType(ki){var _t=Ye[ki>>2],vt=ki+4,Ut;if(ai)for(var jt=vt,ni=0;ni<=_t;++ni){var ri=vt+ni;if(ni==_t||Ge[ri]==0){var Li=ri-jt,zi=Mo(jt,Li);Ut===void 0?Ut=zi:(Ut+=String.fromCharCode(0),Ut+=zi),jt=ri+1}}else{for(var Rs=new Array(_t),ni=0;ni<_t;++ni)Rs[ni]=String.fromCharCode(Ge[vt+ni]);Ut=Rs.join("")}return vx(ki),Ut},toWireType(ki,_t){_t instanceof ArrayBuffer&&(_t=new Uint8Array(_t));var vt,Ut=typeof _t=="string";Ut||_t instanceof Uint8Array||_t instanceof Uint8ClampedArray||_t instanceof Int8Array||jr("Cannot pass non-string to std::string"),ai&&Ut?vt=Wh(_t):vt=_t.length;var jt=v2(4+vt+1),ni=jt+4;if(Ye[jt>>2]=vt,ai&&Ut)Wc(_t,ni,vt+1);else if(Ut)for(var ri=0;ri<vt;++ri){var Li=_t.charCodeAt(ri);Li>255&&(vx(ni),jr("String has UTF-16 code units that do not fit in 8 bits")),Ge[ni+ri]=Li}else for(var ri=0;ri<vt;++ri)Ge[ni+ri]=_t[ri];return ki!==null&&ki.push(vx,jt),jt},argPackAdvance:Wo,readValueFromPointer:kr,destructorFunction(ki){vx(ki)}})},Hh=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,_2=(Lt,ct)=>{for(var ai=Lt,ki=ai>>1,_t=ki+ct/2;!(ki>=_t)&&He[ki];)++ki;if(ai=ki<<1,ai-Lt>32&&Hh)return Hh.decode(Ge.subarray(Lt,ai));for(var vt="",Ut=0;!(Ut>=ct/2);++Ut){var jt=ze[Lt+Ut*2>>1];if(jt==0)break;vt+=String.fromCharCode(jt)}return vt},G0=(Lt,ct,ai)=>{if(ai!=null||(ai=2147483647),ai<2)return 0;ai-=2;for(var ki=ct,_t=ai<Lt.length*2?ai/2:Lt.length,vt=0;vt<_t;++vt){var Ut=Lt.charCodeAt(vt);ze[ct>>1]=Ut,ct+=2}return ze[ct>>1]=0,ct-ki},Ml=Lt=>Lt.length*2,wl=(Lt,ct)=>{for(var ai=0,ki="";!(ai>=ct/4);){var _t=Ke[Lt+ai*4>>2];if(_t==0)break;if(++ai,_t>=65536){var vt=_t-65536;ki+=String.fromCharCode(55296|vt>>10,56320|vt&1023)}else ki+=String.fromCharCode(_t)}return ki},j2=(Lt,ct,ai)=>{if(ai!=null||(ai=2147483647),ai<4)return 0;for(var ki=ct,_t=ki+ai-4,vt=0;vt<Lt.length;++vt){var Ut=Lt.charCodeAt(vt);if(Ut>=55296&&Ut<=57343){var jt=Lt.charCodeAt(++vt);Ut=65536+((Ut&1023)<<10)|jt&1023}if(Ke[ct>>2]=Ut,ct+=4,ct+4>_t)break}return Ke[ct>>2]=0,ct-ki},La=Lt=>{for(var ct=0,ai=0;ai<Lt.length;++ai){var ki=Lt.charCodeAt(ai);ki>=55296&&ki<=57343&&++ai,ct+=4}return ct},Xh=(Lt,ct,ai)=>{ai=Ma(ai);var ki,_t,vt,Ut;ct===2?(ki=_2,_t=G0,Ut=Ml,vt=jt=>He[jt>>1]):ct===4&&(ki=wl,_t=j2,Ut=La,vt=jt=>Ye[jt>>2]),hn(Lt,{name:ai,fromWireType:jt=>{for(var ni=Ye[jt>>2],ri,Li=jt+4,zi=0;zi<=ni;++zi){var Rs=jt+4+zi*ct;if(zi==ni||vt(Rs)==0){var as=Rs-Li,Ms=ki(Li,as);ri===void 0?ri=Ms:(ri+=String.fromCharCode(0),ri+=Ms),Li=Rs+ct}}return vx(jt),ri},toWireType:(jt,ni)=>{typeof ni!="string"&&jr("Cannot pass non-string to C++ string type "+ai);var ri=Ut(ni),Li=v2(4+ri+ct);return Ye[Li>>2]=ri/ct,_t(ni,Li+4,ri+ct),jt!==null&&jt.push(vx,Li),Li},argPackAdvance:Wo,readValueFromPointer:kr,destructorFunction(jt){vx(jt)}})},q2=(Lt,ct,ai,ki,_t,vt)=>{cr[Lt]={name:Ma(ct),rawConstructor:n0(ai,ki),rawDestructor:n0(_t,vt),fields:[]}},T2=(Lt,ct,ai,ki,_t,vt,Ut,jt,ni,ri)=>{cr[Lt].fields.push({fieldName:Ma(ct),getterReturnType:ai,getter:n0(ki,_t),getterContext:vt,setterArgumentType:Ut,setter:n0(jt,ni),setterContext:ri})},Ll=(Lt,ct)=>{ct=Ma(ct),hn(Lt,{isVoid:!0,name:ct,argPackAdvance:0,fromWireType:()=>{},toWireType:(ai,ki)=>{}})},Tx=(Lt,ct)=>{var ai=Rn[Lt];return ai===void 0&&jr(ct+" has unknown type "+To(Lt)),ai},$2=(Lt,ct)=>{Lt=Tx(Lt,"_emval_take_value");var ai=Lt.readValueFromPointer(ct);return Uo.toHandle(ai)},Kh=()=>{ns("")},kl=(Lt,ct,ai)=>Ge.copyWithin(Lt,ct,ct+ai),Xc=()=>2147483648,Ul=Lt=>{var ct=Me.buffer,ai=(Lt-ct.byteLength+65535)/65536;try{return Me.grow(ai),rt(),1}catch{}},Yh=Lt=>{var ct=Ge.length;Lt>>>=0;var ai=Xc();if(Lt>ai)return!1;for(var ki=(ni,ri)=>ni+(ri-ni%ri)%ri,_t=1;_t<=4;_t*=2){var vt=ct*(1+.2/_t);vt=Math.min(vt,Lt+100663296);var Ut=Math.min(ai,ki(Math.max(Lt,vt),65536)),jt=Ul(Ut);if(jt)return!0}return!1};zn=V.InternalError=class extends Error{constructor(Lt){super(Lt),this.name="InternalError"}},Ro(),pn=V.BindingError=class extends Error{constructor(Lt){super(Lt),this.name="BindingError"}},Rc(),wr(),Gh(),_0=V.UnboundTypeError=kc(Error,"UnboundTypeError"),l2();var Kc={c:sr,m:ps,p:l0,u:c0,i:K2,h:zh,b:Uc,e:Gc,t:h2,k:Y2,d:Yo,a:jo,j:Hc,g:Xh,n:q2,f:T2,l:Ll,o:$2,q:Kh,s:kl,r:Yh},ro=us(),vx=Lt=>(vx=ro.x)(Lt),v2=Lt=>(v2=ro.y)(Lt),zs=Lt=>(zs=ro.A)(Lt),a0=Lt=>(a0=ro.B)(Lt),z0;Ki=function Lt(){z0||q0(),z0||(Ki=Lt)};function q0(){if(qi>0||(kt(),qi>0))return;function Lt(){z0||(z0=!0,V.calledRun=!0,!Le&&(qt(),re(V),V.onRuntimeInitialized&&V.onRuntimeInitialized(),Kt()))}V.setStatus?(V.setStatus("Running..."),setTimeout(function(){setTimeout(function(){V.setStatus("")},1),Lt()},1)):Lt()}if(V.preInit)for(typeof V.preInit=="function"&&(V.preInit=[V.preInit]);V.preInit.length>0;)V.preInit.pop()();return q0(),I.ready}})();const Vj=Cd();Vj.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,Z=>{Z&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Vr;(function(Z){Z[Z.DT_INVALID=0]="DT_INVALID",Z[Z.DT_FLOAT=1]="DT_FLOAT",Z[Z.DT_DOUBLE=2]="DT_DOUBLE",Z[Z.DT_INT32=3]="DT_INT32",Z[Z.DT_UINT8=4]="DT_UINT8",Z[Z.DT_INT16=5]="DT_INT16",Z[Z.DT_INT8=6]="DT_INT8",Z[Z.DT_STRING=7]="DT_STRING",Z[Z.DT_COMPLEX64=8]="DT_COMPLEX64",Z[Z.DT_INT64=9]="DT_INT64",Z[Z.DT_BOOL=10]="DT_BOOL",Z[Z.DT_QINT8=11]="DT_QINT8",Z[Z.DT_QUINT8=12]="DT_QUINT8",Z[Z.DT_QINT32=13]="DT_QINT32",Z[Z.DT_BFLOAT16=14]="DT_BFLOAT16",Z[Z.DT_QINT16=15]="DT_QINT16",Z[Z.DT_QUINT16=16]="DT_QUINT16",Z[Z.DT_UINT16=17]="DT_UINT16",Z[Z.DT_COMPLEX128=18]="DT_COMPLEX128",Z[Z.DT_HALF=19]="DT_HALF",Z[Z.DT_RESOURCE=20]="DT_RESOURCE",Z[Z.DT_VARIANT=21]="DT_VARIANT",Z[Z.DT_UINT32=22]="DT_UINT32",Z[Z.DT_UINT64=23]="DT_UINT64",Z[Z.DT_FLOAT_REF=101]="DT_FLOAT_REF",Z[Z.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",Z[Z.DT_INT32_REF=103]="DT_INT32_REF",Z[Z.DT_UINT8_REF=104]="DT_UINT8_REF",Z[Z.DT_INT16_REF=105]="DT_INT16_REF",Z[Z.DT_INT8_REF=106]="DT_INT8_REF",Z[Z.DT_STRING_REF=107]="DT_STRING_REF",Z[Z.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",Z[Z.DT_INT64_REF=109]="DT_INT64_REF",Z[Z.DT_BOOL_REF=110]="DT_BOOL_REF",Z[Z.DT_QINT8_REF=111]="DT_QINT8_REF",Z[Z.DT_QUINT8_REF=112]="DT_QUINT8_REF",Z[Z.DT_QINT32_REF=113]="DT_QINT32_REF",Z[Z.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",Z[Z.DT_QINT16_REF=115]="DT_QINT16_REF",Z[Z.DT_QUINT16_REF=116]="DT_QUINT16_REF",Z[Z.DT_UINT16_REF=117]="DT_UINT16_REF",Z[Z.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",Z[Z.DT_HALF_REF=119]="DT_HALF_REF",Z[Z.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",Z[Z.DT_VARIANT_REF=121]="DT_VARIANT_REF",Z[Z.DT_UINT32_REF=122]="DT_UINT32_REF",Z[Z.DT_UINT64_REF=123]="DT_UINT64_REF"})(Vr||(Vr={}));var b0;(function(Z){(function(I){I[I.LEGACY=0]="LEGACY",I[I.V1=1]="V1",I[I.V2=2]="V2"})(Z.CheckpointFormatVersion||(Z.CheckpointFormatVersion={}))})(b0||(b0={}));const b1={};function b2(Z){return b1[Z]}function b3(Z,I,V,re,ae){const le=I.inputParams[Z];if(le&&le.inputIndexStart!==void 0){const ue=le.inputIndexStart,pe=le.inputIndexEnd===0?void 0:le.inputIndexEnd===void 0?ue+1:le.inputIndexEnd,ve=ue<0?I.inputNames.length+ue:ue;if(le.type==="tensor")return b4(I.inputNames[ve],V,re,ae);if(le.type==="tensors"){const Le=I.inputs.slice(ue,pe);return I.inputNames.slice(ue,pe).filter((Ue,Ge)=>{var ze;return((ze=Le[Ge])===null||ze===void 0?void 0:ze.op)!=="NoOp"}).map(Ue=>b4(Ue,V,re,ae))}const we=b4(I.inputNames[ve],V,re,ae),Me=we.dataSync();return le.type==="number"?Me[0]:C7(we.shape,Me)}const he=I.attrParams[Z];return he&&he.value}function b4(Z,I,V,re){const[ae,le]=b8(Z,V);if(re!=null){const ue=re.getHashTableHandleByName(ae);if(ue!=null)return ue}const he=V.currentContextIds.find(ue=>!!I[b7(ae,ue)]);return he!==void 0?I[b7(ae,he)][le]:void 0}function b5(Z,I,V){return I[b7(Z,V.currentContextId)]}function b6(Z,I){const[V,re,ae]=b8(Z,I);return[b7(V,I&&I.currentContextId),re,ae]}function b7(Z,I){return I?Z+"-"+I:Z}function b8(Z,I){if(Z==="")return["",0,void 0];const V=I!=null&&I.parseNodeNameCache!=null;if(V){const le=I.parseNodeNameCache.get(Z);if(le!=null)return le}const re=Z.split(":");let ae;if(re.length===1)ae=[Z,0,void 0];else{const le=re[0],he=re.length===3?re[1]:void 0,ue=Number(re[re.length-1]);ae=[le,ue,he]}return V&&I.parseNodeNameCache.set(Z,ae),ae}function b9(Z,I,V){let re=b3("pad",Z,I,V);if(re==="explicit"){re=b3("explicitPaddings",Z,I,V);const ae=[[0,0],[0,0],[0,0],[0,0]];for(let le=0;le<4;le++)ae[le][0]=re[le*2],ae[le][1]=re[le*2+1];return ae}return re}function bC(Z){return Z.kept?Z:Ou(Z)}const bm=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var bN=Object.freeze({__proto__:null,json:bm});const bJ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var bf=Object.freeze({__proto__:null,json:bJ});const bi=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var bO=Object.freeze({__proto__:null,json:bi});const bt=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var bB=Object.freeze({__proto__:null,json:bt});const bS=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var bd=Object.freeze({__proto__:null,json:bS});const bV=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var bb=Object.freeze({__proto__:null,json:bV});const bP=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var bE=Object.freeze({__proto__:null,json:bP});const bD=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var bg=Object.freeze({__proto__:null,json:bD});const bZ=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var bo=Object.freeze({__proto__:null,json:bZ});const be=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var bQ=Object.freeze({__proto__:null,json:be});const bs=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];var bF=Object.freeze({__proto__:null,json:bs});const bI=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];var by=Object.freeze({__proto__:null,json:bI});const bA=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];var bp=Object.freeze({__proto__:null,json:bA});const bw=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var bX=Object.freeze({__proto__:null,json:bw});const bc=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var bW=Object.freeze({__proto__:null,json:bc});const bR=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var bK=Object.freeze({__proto__:null,json:bR});const bT=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var bv=Object.freeze({__proto__:null,json:bT});const bq=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var bl=Object.freeze({__proto__:null,json:bq});const ba=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var bn=Object.freeze({__proto__:null,json:ba});class bL{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const I=[bN,bf,bO,bB,bd,bb,bE,bg,bo,bQ,bF,by,bp,bX,bW,bK,bv,bl,bn],V=[].concat(...I.map(re=>re.json));this.opMappers=V.reduce((re,ae)=>(re[ae.tfOpName]=ae,re),{})}transformGraph(I,V={}){const re=I.node,ae=[],le=[],he=[],ue=re.reduce((ze,He)=>(ze[He.name]=this.mapNode(He),He.op.startsWith("Placeholder")?ae.push(ze[He.name]):He.op==="Const"?le.push(ze[He.name]):(He.input==null||He.input.length===0)&&he.push(ze[He.name]),ze),{});let pe=[];const ve=[];let we={},Me={};V!=null&&(we=this.mapSignatureEntries(V.inputs),Me=this.mapSignatureEntries(V.outputs));const Le=Object.keys(ue);Le.forEach(ze=>{const He=ue[ze];He.inputNames.forEach((Ke,Ye)=>{const[$e,,je]=b6(Ke),rt=ue[$e];if(rt.outputs!=null){const at=rt.outputs.indexOf(je);if(at!==-1){const Rt=$e+":"+at;He.inputNames[Ye]=Rt}}He.inputs.push(rt),rt.children.push(He)})}),Object.keys(Me).length===0?Le.forEach(ze=>{const He=ue[ze];He.children.length===0&&ve.push(He)}):Object.keys(Me).forEach(ze=>{const[He]=b6(ze),Ke=ue[He];Ke!=null&&(Ke.signatureKey=Me[ze],ve.push(Ke))}),Object.keys(we).length>0?Object.keys(we).forEach(ze=>{const[He]=b6(ze),Ke=ue[He];Ke&&(Ke.signatureKey=we[ze],pe.push(Ke))}):pe=ae;let Ue={};I.library!=null&&I.library.function!=null&&(Ue=I.library.function.reduce((ze,He)=>(ze[He.signature.name]=this.mapFunction(He),ze),{}));const Ge={nodes:ue,inputs:pe,outputs:ve,weights:le,placeholders:ae,signature:V,functions:Ue};return he.length>0&&(Ge.initNodes=he),Ge}mapSignatureEntries(I){return Object.keys(I||{}).reduce((V,re)=>(V[I[re].name]=re,V),{})}mapNode(I){const V=b2(I.op)||this.opMappers[I.op]||{};I.attr==null&&(I.attr={});const re={name:I.name,op:I.op,category:V.category,inputNames:(I.input||[]).map(ae=>ae.startsWith("^")?ae.slice(1):ae),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:I.attr,outputs:V.outputs};return V.inputs!=null&&(re.inputParams=V.inputs.reduce((ae,le)=>(ae[le.name]={type:le.type,inputIndexStart:le.start,inputIndexEnd:le.end},ae),{})),V.attrs!=null&&(re.attrParams=V.attrs.reduce((ae,le)=>{const he=le.type;let ue;switch(le.type){case"string":ue=bz(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=bz(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"string[]":ue=P0(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=P0(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"number":ue=bU(I.attr,le.tfName,le.defaultValue||0),ue===void 0&&le.tfDeprecatedName&&(ue=bU(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"number[]":ue=br(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=br(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"bool":ue=bx(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=bx(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"bool[]":ue=P2(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=P2(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"shape":ue=bj(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=bj(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"shape[]":ue=P1(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=P1(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"dtype":ue=bY(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=bY(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"dtype[]":ue=bM(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=bM(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"func":ue=bu(I.attr,le.tfName,le.defaultValue),ue===void 0&&le.tfDeprecatedName&&(ue=bu(I.attr,le.tfDeprecatedName,le.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+le.type+" for op: "+I.op)}return ae[le.name]={value:ue,type:he},ae},{})),re}mapFunction(I){const V=I.nodeDef,re=[],ae=[];let le={};V!=null&&(le=V.reduce((we,Me)=>(we[Me.name]=this.mapNode(Me),Me.op==="Const"&&ae.push(we[Me.name]),we),{}));const he=[],ue=[];I.signature.inputArg.forEach(we=>{const[Me]=b6(we.name),Le={name:Me,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:bG(we.type),type:"dtype"}},children:[]};Le.signatureKey=we.name,he.push(Le),le[Me]=Le}),Object.keys(le).forEach(we=>{const Me=le[we];Me.inputNames.forEach((Le,Ue)=>{const[Ge,,ze]=b6(Le),He=le[Ge];if(He.outputs!=null){const Ke=He.outputs.indexOf(ze);if(Ke!==-1){const Ye=Ge+":"+Ke;Me.inputNames[Ue]=Ye}}Me.inputs.push(He),He.children.push(Me)})});const pe=I.ret;I.signature.outputArg.forEach(we=>{const[Me,Le]=b6(pe[we.name]),Ue=le[Me];Ue!=null&&(Ue.defaultOutput=Le,ue.push(Ue))});const ve=this.mapArgsToSignature(I);return{nodes:le,inputs:he,outputs:ue,weights:ae,placeholders:re,signature:ve}}mapArgsToSignature(I){return{methodName:I.signature.name,inputs:I.signature.inputArg.reduce((V,re)=>(V[re.name]=this.mapArgToTensorInfo(re),V),{}),outputs:I.signature.outputArg.reduce((V,re)=>(V[re.name]=this.mapArgToTensorInfo(re,I.ret),V),{})}}mapArgToTensorInfo(I,V){let re=I.name;return V!=null&&(re=V[re]),{name:re,dtype:I.type}}}function bH(Z){const I=Cd().global;if(typeof I.atob<"u")return I.atob(Z);if(typeof Buffer<"u")return new Buffer(Z,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function bk(Z,I){const V=Array.isArray(Z)?String.fromCharCode.apply(null,Z):bH(Z);return I?V:V.toLowerCase()}function bz(Z,I,V,re=!1){const ae=Z[I];return ae!=null?bk(ae.s,re):V}function bx(Z,I,V){const re=Z[I];return re?re.b:V}function bU(Z,I,V){const re=Z[I]||{},ae=re.i!=null?re.i:re.f!=null?re.f:V;return typeof ae=="number"?ae:parseInt(ae,10)}function bG(Z){switch(typeof Z=="string"&&(Z=Vr[Z]),Z){case Vr.DT_FLOAT:case Vr.DT_HALF:return"float32";case Vr.DT_INT32:case Vr.DT_INT64:case Vr.DT_INT8:case Vr.DT_UINT8:return"int32";case Vr.DT_BOOL:return"bool";case Vr.DT_DOUBLE:return"float32";case Vr.DT_STRING:return"string";case Vr.DT_COMPLEX64:case Vr.DT_COMPLEX128:return"complex64";default:return null}}function bu(Z,I,V){const re=Z[I];return re&&re.func?re.func.name:V}function bY(Z,I,V){const re=Z[I];return re&&re.type?bG(re.type):V}function bM(Z,I,V){const re=Z[I];return re&&re.list&&re.list.type?re.list.type.map(ae=>bG(ae)):V}function bh(Z){if(!Z.unknownRank)return Z.dim!=null?Z.dim.map(I=>typeof I.size=="number"?I.size:parseInt(I.size,10)):[]}function bj(Z,I,V){const re=Z[I];return re&&re.shape?bh(re.shape):V}function br(Z,I,V){const re=Z[I];return re?((re.list.f&&re.list.f.length?re.list.f:re.list.i)||[]).map(ae=>typeof ae=="number"?ae:parseInt(ae,10)):V}function P0(Z,I,V,re=!1){const ae=Z[I];return ae&&ae.list&&ae.list.s?ae.list.s.map(le=>bk(le,re)):V}function P1(Z,I,V){const re=Z[I];return re&&re.list&&re.list.shape?re.list.shape.map(ae=>bh(ae)):V}function P2(Z,I,V){const re=Z[I];return re&&re.list&&re.list.b?re.list.b:V}class P3{constructor(I,V,re){this.node=I,this.tensorMap=V,this.context=re,this.inputs=[],this.attrs={},this.inputs=I.inputNames.map(ae=>this.getInput(ae)),I.rawAttrs!=null&&(this.attrs=Object.keys(I.rawAttrs).reduce((ae,le)=>(ae[le]=this.getAttr(le),ae),{}))}getInput(I){return b4(I,this.tensorMap,this.context)}getAttr(I,V){const re=this.node.rawAttrs[I];if(re.tensor!=null)return b4(I,this.tensorMap,this.context);if(re.i!=null||re.f!=null)return bU(this.node.rawAttrs,I,V);if(re.s!=null)return bz(this.node.rawAttrs,I,V);if(re.b!=null)return bx(this.node.rawAttrs,I,V);if(re.shape!=null)return bj(this.node.rawAttrs,I,V);if(re.type!=null)return bY(this.node.rawAttrs,I,V);if(re.list!=null){if(re.list.i!=null||re.list.f!=null)return br(this.node.rawAttrs,I,V);if(re.list.s!=null)return P0(this.node.rawAttrs,I,V);if(re.list.shape!=null)return P1(this.node.rawAttrs,I,V);if(re.list.b!=null)return P2(this.node.rawAttrs,I,V);if(re.list.type!=null)return bM(this.node.rawAttrs,I,V)}return V}}const P4={conv2d:SX,depthwiseConv2d:Sv,matMul:Sl},P5={resizeBilinear:dd};var P6=Object.freeze({__proto__:null,add:OS,addN:Oe,atan2:Os,avgPool:OU,cast:ip,concat:OM,conv2d:tO,conv2dTranspose:td,cos:tb,depthToSpace:tE,depthwiseConv2d:tg,expandDims:B0,fill:t8,floor:B4,fused:P4,gather:B6,greaterEqual:BC,image:P5,lessEqual:BO,logicalAnd:BV,matMul:iX,max:tv,maxPool:BD,maximum:BZ,mean:Be,min:tl,minimum:BI,mul:OD,neg:iK,pad:BA,prelu:BT,range:S4,relu:S6,relu6:S8,reshape:Oz,scalar:tL,sigmoid:Oj,sin:SN,squeeze:SB,stack:Sd,stridedSlice:SE,sub:BS,tensor1d:SD,tile:B2,transpose:il,zerosLike:tQ});const P7=(Z,I,V,re=P6)=>{switch(Z.op){case"BiasAdd":case"AddV2":case"Add":return[re.add(b3("a",Z,I,V),b3("b",Z,I,V))];case"AddN":return[re.addN(b3("tensors",Z,I,V))];case"FloorMod":case"Mod":return[re.mod(b3("a",Z,I,V),b3("b",Z,I,V))];case"Mul":return[re.mul(b3("a",Z,I,V),b3("b",Z,I,V))];case"RealDiv":case"Div":return[re.div(b3("a",Z,I,V),b3("b",Z,I,V))];case"DivNoNan":return[re.divNoNan(b3("a",Z,I,V),b3("b",Z,I,V))];case"FloorDiv":return[re.floorDiv(b3("a",Z,I,V),b3("b",Z,I,V))];case"Sub":return[re.sub(b3("a",Z,I,V),b3("b",Z,I,V))];case"Minimum":return[re.minimum(b3("a",Z,I,V),b3("b",Z,I,V))];case"Maximum":return[re.maximum(b3("a",Z,I,V),b3("b",Z,I,V))];case"Pow":return[re.pow(b3("a",Z,I,V),b3("b",Z,I,V))];case"SquaredDifference":return[re.squaredDifference(b3("a",Z,I,V),b3("b",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}},P8=(Z,I,V,re=P6)=>{switch(Z.op){case"Abs":case"ComplexAbs":return[re.abs(b3("x",Z,I,V))];case"Acos":return[re.acos(b3("x",Z,I,V))];case"Acosh":return[re.acosh(b3("x",Z,I,V))];case"Asin":return[re.asin(b3("x",Z,I,V))];case"Asinh":return[re.asinh(b3("x",Z,I,V))];case"Atan":return[re.atan(b3("x",Z,I,V))];case"Atan2":return[re.atan2(b3("x",Z,I,V),b3("y",Z,I,V))];case"Atanh":return[re.atanh(b3("x",Z,I,V))];case"Ceil":return[re.ceil(b3("x",Z,I,V))];case"Complex":return[re.complex(b3("real",Z,I,V),b3("imag",Z,I,V))];case"Cos":return[re.cos(b3("x",Z,I,V))];case"Cosh":return[re.cosh(b3("x",Z,I,V))];case"Elu":return[re.elu(b3("x",Z,I,V))];case"Erf":return[re.erf(b3("x",Z,I,V))];case"Exp":return[re.exp(b3("x",Z,I,V))];case"Expm1":return[re.expm1(b3("x",Z,I,V))];case"Floor":return[re.floor(b3("x",Z,I,V))];case"Log":return[re.log(b3("x",Z,I,V))];case"Log1p":return[re.log1p(b3("x",Z,I,V))];case"Imag":return[re.imag(b3("x",Z,I,V))];case"Neg":return[re.neg(b3("x",Z,I,V))];case"Reciprocal":return[re.reciprocal(b3("x",Z,I,V))];case"Real":return[re.real(b3("x",Z,I,V))];case"Relu":return[re.relu(b3("x",Z,I,V))];case"Round":return[re.round(b3("x",Z,I,V))];case"Selu":return[re.selu(b3("x",Z,I,V))];case"Sigmoid":return[re.sigmoid(b3("x",Z,I,V))];case"Sin":return[re.sin(b3("x",Z,I,V))];case"Sign":return[re.sign(b3("x",Z,I,V))];case"Sinh":return[re.sinh(b3("x",Z,I,V))];case"Softplus":return[re.softplus(b3("x",Z,I,V))];case"Sqrt":return[re.sqrt(b3("x",Z,I,V))];case"Square":return[re.square(b3("x",Z,I,V))];case"Tanh":return[re.tanh(b3("x",Z,I,V))];case"Tan":return[re.tan(b3("x",Z,I,V))];case"ClipByValue":return[re.clipByValue(b3("x",Z,I,V),b3("clipValueMin",Z,I,V),b3("clipValueMax",Z,I,V))];case"Relu6":return[re.relu6(b3("x",Z,I,V))];case"Rsqrt":return[re.rsqrt(b4(Z.inputNames[0],I,V))];case"LeakyRelu":return[re.leakyRelu(b3("x",Z,I,V),b3("alpha",Z,I,V))];case"Prelu":return[re.prelu(b3("x",Z,I,V),b3("alpha",Z,I,V))];case"IsNan":return[re.isNaN(b4(Z.inputNames[0],I,V))];case"IsInf":return[re.isInf(b4(Z.inputNames[0],I,V))];case"IsFinite":return[re.isFinite(b4(Z.inputNames[0],I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}};function P9(Z,I,V=""){if(!(typeof Z=="number"||typeof I=="number")){e(Z.length===I.length,()=>V+(" Shapes "+Z+" and "+I+" must match"));for(let re=0;re<Z.length;re++){const ae=Z[re],le=I[re];e(ae<0||le<0||ae===le,()=>V+(" Shapes "+Z+" and "+I+" must match"))}}}function PC(Z){return!(typeof Z=="number"||Z.some(I=>I<0))}function Pm(Z,I,V){let re=PN(Z,V);const ae=!PC(re);if(ae&&I.length===0)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: "+re);if(ae&&I.forEach(le=>{re=PN(le.shape,re)}),!PC(re))throw new Error("Non-fully-defined elementShape: "+re);return re}function PN(Z,I){if(typeof Z=="number")return I;if(typeof I=="number")return Z;if(Z.length!==I.length)throw new Error("Incompatible ranks during merge: "+Z+" vs. "+I);const V=[];for(let re=0;re<Z.length;++re){const ae=Z[re],le=I[re];if(ae>=0&&le>=0&&ae!==le)throw new Error("Incompatible shape during merge: "+Z+" vs. "+I);V[re]=ae>=0?ae:le}return V}class PJ{constructor(I,V,re,ae,le,he,ue){this.name=I,this.dtype=V,this.maxSize=re,this.elementShape=ae,this.identicalElementShapes=le,this.dynamicSize=he,this.clearAfterRead=ue,this.tensors=[],this.closed_=!1,this.idTensor=tL(0),Jh(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(I){this.tensors.forEach(V=>{(I==null||!I.has(V.tensor.id))&&V.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(I){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(I<0||I>=this.size())throw new Error("Tried to read from index "+I+", but array size is: "+this.size());const V=this.tensors[I];if(V.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+I+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(V.cleared=!0),V.read=!0,V.tensor}readMany(I){return I.map(V=>this.read(V))}write(I,V){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(I<0||!this.dynamicSize&&I>=this.maxSize)throw new Error("Tried to write to index "+I+", but array is not resizeable and size is: "+this.maxSize);const re=this.tensors[I]||{};if(V.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+I+`,
          because the value dtype is `+V.dtype+", but TensorArray dtype is "+this.dtype+".");if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=V.shape),P9(this.elementShape,V.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+I+"."),re.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+I+", because it has already been read.");if(re.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+I+", because it has already been written.");re.tensor=V,Jh(V),re.written=!0,this.tensors[I]=re}writeMany(I,V){if(I.length!==V.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+I.length+" is not the same as tensors size: "+V.length+".");I.forEach((re,ae)=>this.write(re,V[ae]))}gather(I,V){if(V&&V!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+V);if(I)I=I.slice(0,this.size());else{I=[];for(let ae=0;ae<this.size();ae++)I.push(ae)}if(I.length===0)return Jk([],[0].concat(this.elementShape));const re=this.readMany(I);return P9(this.elementShape,re[0].shape,"TensorArray shape mismatch: "),Sd(re,0)}concat(I){if(I&&I!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+I);if(this.size()===0)return Jk([],[0].concat(this.elementShape));const V=[];for(let ae=0;ae<this.size();ae++)V.push(ae);const re=this.readMany(V);return P9(this.elementShape,re[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+re[0].shape+")"),OM(re,0)}scatter(I,V){if(V.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+V.dtype);if(I.length!==V.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+I.length+" vs. "+V.shape[0]);const re=Math.max(...I);if(!this.dynamicSize&&re>=this.maxSize)throw new Error("Max index must be < array size ("+re+"  vs. "+this.maxSize+")");this.writeMany(I,Se(V,0))}split(I,V){if(V.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+V.dtype);let re=0;const ae=I.map(pe=>(re+=pe,re));if(re!==V.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+re+", and tensor's shape is: "+V.shape);if(!this.dynamicSize&&I.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+I.length+"), and the TensorArray is not marked as dynamically resizeable");const le=re===0?0:V.size/re,he=[];JY(()=>{V=Oz(V,[1,re,le]);for(let pe=0;pe<I.length;++pe){const ve=[0,pe===0?0:ae[pe-1],0],we=[1,I[pe],le];he[pe]=Oz(t0(V,ve,we),this.elementShape)}return he});const ue=[];for(let pe=0;pe<I.length;pe++)ue[pe]=pe;this.writeMany(ue,he)}}class Pf{get id(){return this.idTensor.id}constructor(I,V,re,ae=-1){this.tensors=I,this.elementShape=V,this.elementDtype=re,I?.forEach(le=>{if(re!==le.dtype)throw new Error("Invalid data types; op elements "+re+", but list elements "+le.dtype);P9(V,le.shape,"TensorList shape mismatch: "),Jh(le)}),this.idTensor=tL(0),this.maxNumElements=ae,Jh(this.idTensor)}copy(){return new Pf([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(I){this.tensors.forEach(V=>{(I==null||!I.has(V.id))&&V.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(I,V,re=-1){if(V!==this.elementDtype)throw new Error("Invalid data types; op elements "+V+", but list elements "+this.elementDtype);if(re!==-1&&this.tensors.length!==re)throw new Error("Operation expected a list with "+re+" elements but got a list with "+this.tensors.length+" elements.");P9(I,this.elementShape,"TensorList shape mismatch: ");const ae=Pm(this.elementShape,this.tensors,I);return JY(()=>{const le=this.tensors.map(he=>Oz(he,ae));return Sd(le,0)})}popBack(I,V){if(V!==this.elementDtype)throw new Error("Invalid data types; op elements "+V+", but list elements "+this.elementDtype);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const re=Pm(this.elementShape,this.tensors,I),ae=this.tensors.pop();return ae.kept=!1,P9(ae.shape,I,"TensorList shape mismatch: "),Oz(ae,re)}pushBack(I){if(I.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+I.dtype+", but list elements "+this.elementDtype);if(P9(I.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Jh(I),this.tensors.push(I)}resize(I){if(I<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+I);if(this.maxNumElements!==-1&&I>this.maxNumElements)throw new Error("TensorListResize input size "+I+" is greater maxNumElement "+this.maxNumElements+".");const V=new Pf([],this.elementShape,this.elementDtype,this.maxNumElements);V.tensors.length=I;for(let re=0;re<Math.min(this.tensors.length,I);++re)V.tensors[re]=this.tensors[re];return V}getItem(I,V,re){if(re!==this.elementDtype)throw new Error("Invalid data types; op elements "+re+", but list elements "+this.elementDtype);if(I<0||I>this.tensors.length)throw new Error("Trying to access element "+I+" in a list with "+this.tensors.length+" elements.");if(this.tensors[I]==null)throw new Error("element at index "+I+" is null.");P9(this.tensors[I].shape,V,"TensorList shape mismatch: ");const ae=Pm(this.elementShape,this.tensors,V);return Oz(this.tensors[I],ae)}setItem(I,V){if(V.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+V.dtype+", but list elements "+this.elementDtype);if(I<0||this.maxNumElements!==-1&&I>=this.maxNumElements)throw new Error("Trying to set element "+I+" in a list with max "+this.maxNumElements+" elements.");P9(this.elementShape,V.shape,"TensorList shape mismatch: "),Jh(V),this.tensors[I]!=null&&(this.tensors[I].kept=!1),this.tensors[I]=V}gather(I,V,re){if(V!==this.elementDtype)throw new Error("Invalid data types; op elements "+V+", but list elements "+this.elementDtype);P9(this.elementShape,re,"TensorList shape mismatch: "),I=I.slice(0,this.size());const ae=Pm(this.elementShape,this.tensors,re);return I.length===0?Jk([],[0].concat(ae)):JY(()=>{const le=I.map(he=>Oz(this.tensors[he],ae));return Sd(le,0)})}concat(I,V){if(I&&I!==this.elementDtype)throw new Error("TensorList dtype is "+this.elementDtype+" but concat requested dtype "+I);P9(this.elementShape,V,"TensorList shape mismatch: ");const re=Pm(this.elementShape,this.tensors,V);return this.size()===0?Jk([],[0].concat(re)):JY(()=>{const ae=this.tensors.map(le=>Oz(le,re));return OM(ae,0)})}}function Pi(Z,I,V){const re=Z.dtype;if(Z.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+Z.shape);if(Z.dtype!==V)throw new Error("Invalid data types; op elements "+Z.dtype+", but list elements "+V);const ae=Z.shape.slice(1);P9(ae,I,"TensorList shape mismatch: ");const le=Se(Z);return new Pf(le,I,re)}function PO(Z,I,V,re){return new Pf([],Z,I,re)}function Pt(Z,I,V,re){if(I.length!==Z.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+I.length+" vs. "+Z.shape[0]);const ae=Math.max(...I);if(re!=null&&re!==-1&&ae>=re)throw new Error("Max index must be < array size ("+ae+"  vs. "+re+")");const le=new Pf([],V,Z.dtype,re),he=Se(Z,0);return I.forEach((ue,pe)=>{le.setItem(ue,he[pe])}),le}function PB(Z,I,V){let re=0;const ae=I.map(we=>(re+=we,re));if(re!==Z.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+re+", and tensor's shape is: "+Z.shape);const le=Z.shape.slice(1),he=PN(le,V),ue=re===0?0:Z.size/re,pe=JY(()=>{const we=[];Z=Oz(Z,[1,re,ue]);for(let Me=0;Me<I.length;++Me){const Le=[0,Me===0?0:ae[Me-1],0],Ue=[1,I[Me],ue];we[Me]=Oz(t0(Z,Le,Ue),he)}return Z.dispose(),we}),ve=new Pf([],V,Z.dtype,I.length);for(let we=0;we<pe.length;we++)ve.setItem(we,pe[we]);return ve}const PS=async(Z,I,V)=>{switch(Z.op){case"If":case"StatelessIf":{const re=b3("thenBranch",Z,I,V),ae=b3("elseBranch",Z,I,V),le=b3("cond",Z,I,V),he=b3("args",Z,I,V);return(await le.data())[0]?V.functionMap[re].executeFunctionAsync(he,V.tensorArrayMap,V.tensorListMap):V.functionMap[ae].executeFunctionAsync(he,V.tensorArrayMap,V.tensorListMap)}case"While":case"StatelessWhile":{const re=b3("body",Z,I,V),ae=b3("cond",Z,I,V),le=b3("args",Z,I,V),he=await V.functionMap[ae].executeFunctionAsync(le,V.tensorArrayMap,V.tensorListMap),ue=le.map(we=>we.id);let pe=await he[0].data();he.forEach(we=>{!we.kept&&ue.indexOf(we.id)===-1&&we.dispose()});let ve=le;for(;pe[0];){const we=ve;ve=await V.functionMap[re].executeFunctionAsync(ve,V.tensorArrayMap,V.tensorListMap);const Me=ve.map(Ue=>Ue.id);we.forEach(Ue=>{!Ue.kept&&ue.indexOf(Ue.id)===-1&&Me.indexOf(Ue.id)===-1&&Ue.dispose()});const Le=await V.functionMap[ae].executeFunctionAsync(ve,V.tensorArrayMap,V.tensorListMap);pe=await Le[0].data(),Le.forEach(Ue=>{!Ue.kept&&ue.indexOf(Ue.id)===-1&&Me.indexOf(Ue.id)===-1&&Ue.dispose()})}return ve}case"LoopCond":{const re=b3("pred",Z,I,V);return[bC(re)]}case"Switch":{const re=b3("pred",Z,I,V);let ae=b3("data",Z,I,V);return ae.kept||(ae=bC(ae)),(await re.data())[0]?[void 0,ae]:[ae,void 0]}case"Merge":{const re=Z.inputNames.find(ae=>b4(ae,I,V)!==void 0);if(re){const ae=b4(re,I,V);return[bC(ae)]}return}case"Enter":{const re=b3("frameName",Z,I,V),ae=b3("tensor",Z,I,V);return V.enterFrame(re),[bC(ae)]}case"Exit":{const re=b3("tensor",Z,I,V);return V.exitFrame(),[bC(re)]}case"NextIteration":{const re=b3("tensor",Z,I,V);return V.nextIteration(),[bC(re)]}case"TensorArrayV3":{const re=b3("size",Z,I,V),ae=b3("dtype",Z,I,V),le=b3("elementShape",Z,I,V),he=b3("dynamicSize",Z,I,V),ue=b3("clearAfterRead",Z,I,V),pe=b3("identicalElementShapes",Z,I,V),ve=b3("name",Z,I,V),we=new PJ(ve,ae,re,le,pe,he,ue);return V.addTensorArray(we),[we.idTensor,tL(1)]}case"TensorArrayWriteV3":{const re=b3("tensorArrayId",Z,I,V),ae=b3("index",Z,I,V),le=b3("tensor",Z,I,V),he=V.getTensorArray(re.id);return he.write(ae,le),[he.idTensor]}case"TensorArrayReadV3":{const re=b3("tensorArrayId",Z,I,V),ae=b3("index",Z,I,V);return[V.getTensorArray(re.id).read(ae)]}case"TensorArrayGatherV3":{const re=b3("tensorArrayId",Z,I,V),ae=b3("indices",Z,I,V),le=b3("dtype",Z,I,V);return[V.getTensorArray(re.id).gather(ae,le)]}case"TensorArrayScatterV3":{const re=b3("tensorArrayId",Z,I,V),ae=b3("indices",Z,I,V),le=b3("tensor",Z,I,V),he=V.getTensorArray(re.id);return he.scatter(ae,le),[he.idTensor]}case"TensorArrayConcatV3":{const re=b3("tensorArrayId",Z,I,V),ae=V.getTensorArray(re.id),le=b3("dtype",Z,I,V);return[ae.concat(le)]}case"TensorArraySplitV3":{const re=b3("tensorArrayId",Z,I,V),ae=b3("tensor",Z,I,V),le=b3("lengths",Z,I,V),he=V.getTensorArray(re.id);return he.split(le,ae),[he.idTensor]}case"TensorArraySizeV3":{const re=b3("tensorArrayId",Z,I,V),ae=V.getTensorArray(re.id);return[tL(ae.size(),"int32")]}case"TensorArrayCloseV3":{const re=b3("tensorArrayId",Z,I,V),ae=V.getTensorArray(re.id);return ae.clearAndClose(),[ae.idTensor]}case"TensorListSetItem":{const re=b3("tensorListId",Z,I,V),ae=b3("index",Z,I,V),le=b3("tensor",Z,I,V),he=V.getTensorList(re.id);return he.setItem(ae,le),[he.idTensor]}case"TensorListGetItem":{const re=b3("tensorListId",Z,I,V),ae=b3("index",Z,I,V),le=b3("elementShape",Z,I,V),he=b3("elementDType",Z,I,V);return[V.getTensorList(re.id).getItem(ae,le,he)]}case"TensorListScatterV2":case"TensorListScatter":{const re=b3("indices",Z,I,V),ae=b3("tensor",Z,I,V),le=b3("elementShape",Z,I,V),he=b3("numElements",Z,I,V),ue=Pt(ae,re,le,he);return V.addTensorList(ue),[ue.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const re=b3("elementShape",Z,I,V),ae=b3("elementDType",Z,I,V);let le;Z.op==="TensorListReserve"?le="numElements":le="maxNumElements";const he=b3(le,Z,I,V),ue=Z.op==="TensorListReserve"?-1:he,pe=PO(re,ae,he,ue);return V.addTensorList(pe),[pe.idTensor]}case"TensorListGather":{const re=b3("tensorListId",Z,I,V),ae=b3("indices",Z,I,V),le=b3("elementShape",Z,I,V),he=b3("elementDType",Z,I,V);return[V.getTensorList(re.id).gather(ae,he,le)]}case"TensorListStack":{const re=b3("tensorListId",Z,I,V),ae=b3("elementShape",Z,I,V),le=b3("elementDType",Z,I,V),he=b3("numElements",Z,I,V);return[V.getTensorList(re.id).stack(ae,le,he)]}case"TensorListFromTensor":{const re=b3("tensor",Z,I,V),ae=b3("elementShape",Z,I,V),le=b3("elementDType",Z,I,V),he=Pi(re,ae,le);return V.addTensorList(he),[he.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const re=b3("tensorListId",Z,I,V),ae=V.getTensorList(re.id),le=b3("dtype",Z,I,V),he=b3("elementShape",Z,I,V);return[ae.concat(le,he)]}case"TensorListPushBack":{const re=b3("tensorListId",Z,I,V),ae=b3("tensor",Z,I,V),le=V.getTensorList(re.id);return le.pushBack(ae),[le.idTensor]}case"TensorListPopBack":{const re=b3("tensorListId",Z,I,V),ae=b3("elementShape",Z,I,V),le=b3("elementDType",Z,I,V);return[V.getTensorList(re.id).popBack(ae,le)]}case"TensorListSplit":{const re=b3("tensor",Z,I,V),ae=b3("elementShape",Z,I,V),le=b3("lengths",Z,I,V),he=PB(re,le,ae);return V.addTensorList(he),[he.idTensor]}case"TensorListLength":{const re=b3("tensorListId",Z,I,V),ae=V.getTensorList(re.id);return[tL(ae.size(),"int32")]}case"TensorListResize":{const re=b3("tensorListId",Z,I,V),ae=b3("size",Z,I,V),le=V.getTensorList(re.id).resize(ae);return V.addTensorList(le),[le.idTensor]}default:throw TypeError("Node type "+Z.op+" is not implemented")}};function Pd(Z,I,V){const[re,ae]=b3("fusedOps",Z,I,V),le=re==="biasadd",he=!le,ue=ae==="prelu",pe=re==="fusedbatchnorm",ve=b3("numArgs",Z,I,V);if(le){if(ue&&ve!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!ue&&le&&ve!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(pe)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const we=b3("strides",Z,I,V),Me=b9(Z,I,V),Le=b3("dataFormat",Z,I,V).toUpperCase(),Ue=b3("dilations",Z,I,V);let[Ge,ze]=b3("args",Z,I,V);he&&(ze=Ge,Ge=void 0);const He=b3("leakyreluAlpha",Z,I,V);return{stride:we,pad:Me,dataFormat:Le,dilations:Ue,biasArg:Ge,preluArg:ze,activationFunc:ae,leakyreluAlpha:He}}const PV=(Z,I,V,re=P6)=>{switch(Z.op){case"Conv1D":{const ae=b3("stride",Z,I,V),le=b3("pad",Z,I,V),he=b3("dataFormat",Z,I,V).toUpperCase(),ue=b3("dilation",Z,I,V);return[re.conv1d(b3("x",Z,I,V),b3("filter",Z,I,V),ae,le,he,ue)]}case"Conv2D":{const ae=b3("strides",Z,I,V),le=b9(Z,I,V),he=b3("dataFormat",Z,I,V).toUpperCase(),ue=b3("dilations",Z,I,V);return[re.conv2d(b3("x",Z,I,V),b3("filter",Z,I,V),[ae[1],ae[2]],le,he,[ue[1],ue[2]])]}case"_FusedConv2D":{const{stride:ae,pad:le,dataFormat:he,dilations:ue,biasArg:pe,preluArg:ve,activationFunc:we,leakyreluAlpha:Me}=Pd(Z,I,V),Le=Z.name.endsWith("batch_normalization_88/FusedBatchNormV3")||Z.name.endsWith("batch_normalization_90/FusedBatchNormV3")?Cd().get("WEBGL_USE_SHAPES_UNIFORMS"):void 0;Le&&Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!1);const Ue=[re.fused.conv2d({x:b3("x",Z,I,V),filter:b3("filter",Z,I,V),strides:[ae[1],ae[2]],pad:le,dataFormat:he,dilations:[ue[1],ue[2]],bias:pe,activation:we,preluActivationWeights:ve,leakyreluAlpha:Me})];return Le&&Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),Ue}case"FusedDepthwiseConv2dNative":{const{stride:ae,pad:le,dataFormat:he,dilations:ue,biasArg:pe,preluArg:ve,activationFunc:we,leakyreluAlpha:Me}=Pd(Z,I,V);return[re.fused.depthwiseConv2d({x:b3("x",Z,I,V),filter:b3("filter",Z,I,V),strides:[ae[1],ae[2]],pad:le,dataFormat:he,dilations:[ue[1],ue[2]],bias:pe,activation:we,preluActivationWeights:ve,leakyreluAlpha:Me})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const ae=b3("outputShape",Z,I,V),le=b3("strides",Z,I,V),he=b9(Z,I,V);return[re.conv2dTranspose(b3("x",Z,I,V),b3("filter",Z,I,V),ae,[le[1],le[2]],he)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const ae=b3("strides",Z,I,V),le=b9(Z,I,V),he=b3("dilations",Z,I,V),ue=b3("dataFormat",Z,I,V).toUpperCase();return[re.depthwiseConv2d(b3("input",Z,I,V),b3("filter",Z,I,V),[ae[1],ae[2]],le,ue,[he[1],he[2]])]}case"Conv3D":{const ae=b3("strides",Z,I,V),le=b3("pad",Z,I,V),he=b3("dataFormat",Z,I,V).toUpperCase(),ue=b3("dilations",Z,I,V);return[re.conv3d(b3("x",Z,I,V),b3("filter",Z,I,V),[ae[1],ae[2],ae[3]],le,he,[ue[1],ue[2],ue[3]])]}case"AvgPool":{const ae=b3("strides",Z,I,V),le=b3("pad",Z,I,V),he=b3("kernelSize",Z,I,V);return[re.avgPool(b3("x",Z,I,V),[he[1],he[2]],[ae[1],ae[2]],le)]}case"MaxPool":{const ae=b3("strides",Z,I,V),le=b3("pad",Z,I,V),he=b3("kernelSize",Z,I,V);return[re.maxPool(b3("x",Z,I,V),[he[1],he[2]],[ae[1],ae[2]],le)]}case"MaxPoolWithArgmax":{const ae=b3("strides",Z,I,V),le=b3("pad",Z,I,V),he=b3("kernelSize",Z,I,V),ue=b3("includeBatchInIndex",Z,I,V),{result:pe,indexes:ve}=re.maxPoolWithArgmax(b3("x",Z,I,V),[he[1],he[2]],[ae[1],ae[2]],le,ue);return[pe,ve]}case"AvgPool3D":{const ae=b3("strides",Z,I,V),le=b3("pad",Z,I,V),he=b3("kernelSize",Z,I,V);return[re.avgPool3d(b3("x",Z,I,V),[he[1],he[2],he[3]],[ae[1],ae[2],ae[3]],le)]}case"MaxPool3D":{const ae=b3("strides",Z,I,V),le=b3("pad",Z,I,V),he=b3("kernelSize",Z,I,V);return[re.maxPool3d(b3("x",Z,I,V),[he[1],he[2],he[3]],[ae[1],ae[2],ae[3]],le)]}case"Dilation2D":{const ae=b3("strides",Z,I,V),le=b3("pad",Z,I,V),he=b3("dilations",Z,I,V),ue=ae[1],pe=ae[2],ve=he[1],we=he[2];return[re.dilation2d(b3("x",Z,I,V),b3("filter",Z,I,V),[ue,pe],le,[ve,we],"NHWC")]}default:throw TypeError("Node type "+Z.op+" is not implemented")}},Pb=(Z,I,V,re=P6)=>{switch(Z.op){case"Fill":{const ae=b3("shape",Z,I,V),le=b3("dtype",Z,I,V),he=b3("value",Z,I,V);return[re.fill(ae,he,le)]}case"LinSpace":{const ae=b3("start",Z,I,V),le=b3("stop",Z,I,V),he=b3("num",Z,I,V);return[re.linspace(ae,le,he)]}case"Multinomial":{const ae=b3("logits",Z,I,V),le=b3("numSamples",Z,I,V),he=b3("seed",Z,I,V);return[re.multinomial(ae,le,he)]}case"OneHot":{const ae=b3("indices",Z,I,V),le=b3("depth",Z,I,V),he=b3("onValue",Z,I,V),ue=b3("offValue",Z,I,V),pe=b3("dtype",Z,I,V);return[re.oneHot(ae,le,he,ue,pe)]}case"Ones":return[re.ones(b3("shape",Z,I,V),b3("dtype",Z,I,V))];case"OnesLike":return[re.onesLike(b3("x",Z,I,V))];case"RandomStandardNormal":return[re.randomStandardNormal(b3("shape",Z,I,V),b3("dtype",Z,I,V),b3("seed",Z,I,V))];case"RandomUniform":return[re.randomUniform(b3("shape",Z,I,V),b3("minval",Z,I,V),b3("maxval",Z,I,V),b3("dtype",Z,I,V))];case"RandomUniformInt":return[re.randomUniformInt(b3("shape",Z,I,V),b3("minval",Z,I,V),b3("maxval",Z,I,V),b3("seed",Z,I,V))];case"Range":{const ae=b3("start",Z,I,V),le=b3("stop",Z,I,V),he=b3("step",Z,I,V);return[re.range(ae,le,he,b3("dtype",Z,I,V))]}case"TruncatedNormal":{const ae=b3("shape",Z,I,V),le=b3("mean",Z,I,V),he=b3("stdDev",Z,I,V),ue=b3("seed",Z,I,V);return[re.truncatedNormal(ae,le,he,b3("dtype",Z,I,V),ue)]}case"Zeros":return[re.zeros(b3("shape",Z,I,V),b3("dtype",Z,I,V))];case"ZerosLike":return[re.zerosLike(b3("x",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}};function PP(Z,I,V){const re=b3("boxes",Z,I,V),ae=b3("scores",Z,I,V),le=b3("maxOutputSize",Z,I,V),he=b3("iouThreshold",Z,I,V),ue=b3("scoreThreshold",Z,I,V),pe=b3("softNmsSigma",Z,I,V);return{boxes:re,scores:ae,maxOutputSize:le,iouThreshold:he,scoreThreshold:ue,softNmsSigma:pe}}const PE=async(Z,I,V,re,ae=P6)=>{switch(Z.op){case"NonMaxSuppressionV5":{const{boxes:le,scores:he,maxOutputSize:ue,iouThreshold:pe,scoreThreshold:ve,softNmsSigma:we}=PP(Z,I,V),Me=await ae.image.nonMaxSuppressionWithScoreAsync(le,he,ue,pe,ve,we);return[Me.selectedIndices,Me.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:le,scores:he,maxOutputSize:ue,iouThreshold:pe,scoreThreshold:ve}=PP(Z,I,V),we=b3("padToMaxOutputSize",Z,I,V),Me=await ae.image.nonMaxSuppressionPaddedAsync(le,he,ue,pe,ve,we);return[Me.selectedIndices,Me.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:le,scores:he,maxOutputSize:ue,iouThreshold:pe,scoreThreshold:ve}=PP(Z,I,V);return[await ae.image.nonMaxSuppressionAsync(le,he,ue,pe,ve)]}case"Where":{const le=ae.cast(b3("condition",Z,I,V),"bool"),he=[await ae.whereAsync(le)];return le.dispose(),he}case"ListDiff":return ae.setdiff1dAsync(b3("x",Z,I,V),b3("y",Z,I,V));default:throw TypeError("Node type "+Z.op+" is not implemented")}},PD=(Z,I,V,re=P6)=>{switch(Z.op){case"LowerBound":{const ae=b3("sortedSequence",Z,I,V),le=b3("values",Z,I,V);return[re.lowerBound(ae,le)]}case"TopKV2":{const ae=b3("x",Z,I,V),le=b3("k",Z,I,V),he=b3("sorted",Z,I,V),ue=re.topk(ae,le,he);return[ue.values,ue.indices]}case"UpperBound":{const ae=b3("sortedSequence",Z,I,V),le=b3("values",Z,I,V);return[re.upperBound(ae,le)]}case"Unique":{const ae=b3("x",Z,I,V),le=re.unique(ae);return[le.values,le.indices]}case"UniqueV2":{const ae=b3("x",Z,I,V),le=b3("axis",Z,I,V),he=re.unique(ae,le);return[he.values,he.indices]}default:throw TypeError("Node type "+Z.op+" is not implemented")}},Pg=(Z,I,V,re=P6)=>{switch(Z.op){case"Const":return I[Z.name];case"PlaceholderWithDefault":const ae=b3("default",Z,I,V);return[b4(Z.name,I,V)||ae];case"Placeholder":return[b4(Z.name,I,V)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const we=b3("x",Z,I,V);return[bC(we)]}case"IdentityN":return b3("x",Z,I,V).map(we=>bC(we));case"Snapshot":const le=b3("x",Z,I,V);return[bC(le)];case"Shape":return[re.tensor1d(b3("x",Z,I,V).shape,"int32")];case"ShapeN":return b3("x",Z,I,V).map(we=>re.tensor1d(we.shape));case"Size":return[re.scalar(b3("x",Z,I,V).size,"int32")];case"Rank":return[re.scalar(b3("x",Z,I,V).rank,"int32")];case"NoOp":return[re.scalar(1)];case"Print":const he=b3("x",Z,I,V),ue=b3("data",Z,I,V),pe=b3("message",Z,I,V),ve=b3("summarize",Z,I,V);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(pe);for(let we=0;we<ue.length;we++)console.log(Array.prototype.slice.call(ue[we].dataSync()).slice(0,ve));return[he];default:throw TypeError("Node type "+Z.op+" is not implemented")}};class PZ{get id(){return this.handle.id}constructor(I,V){this.keyDType=I,this.valueDType=V,this.handle=tL(0),this.tensorMap=new Map,Jh(this.handle)}clearAndClose(){this.tensorMap.forEach(I=>I.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return tL(this.size(),"int32")}async import(I,V){this.checkKeyAndValueTensor(I,V);const re=await I.data();return this.tensorMap.forEach(ae=>ae.dispose()),this.tensorMap.clear(),JY(()=>{const ae=Se(V),le=re.length,he=ae.length;e(le===he,()=>"The number of elements doesn't match, keys has "+le+" elements, the values has "+he+" elements.");for(let ue=0;ue<le;ue++){const pe=re[ue],ve=ae[ue];Jh(ve),this.tensorMap.set(pe,ve)}return this.handle})}async find(I,V){this.checkKeyAndValueTensor(I,V);const re=await I.data();return JY(()=>{const ae=[];for(let le=0;le<re.length;le++){const he=re[le],ue=this.findWithDefault(he,V);ae.push(ue)}return Sd(ae)})}findWithDefault(I,V){const re=this.tensorMap.get(I);return re??V}checkKeyAndValueTensor(I,V){if(I.dtype!==this.keyDType)throw new Error("Expect key dtype "+this.keyDType+", but got "+I.dtype);if(V.dtype!==this.valueDType)throw new Error("Expect value dtype "+this.valueDType+", but got "+V.dtype)}}const Po=async(Z,I,V,re)=>{switch(Z.op){case"HashTable":case"HashTableV2":{const ae=re.getHashTableHandleByName(Z.name);if(ae!=null)return[ae];{const le=b3("keyDType",Z,I,V),he=b3("valueDType",Z,I,V),ue=new PZ(le,he);return re.addHashTable(Z.name,ue),[ue.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const ae=b3("tableHandle",Z,I,V,re),le=b3("keys",Z,I,V),he=b3("values",Z,I,V);return[await re.getHashTableById(ae.id).import(le,he)]}case"LookupTableFind":case"LookupTableFindV2":{const ae=b3("tableHandle",Z,I,V,re),le=b3("keys",Z,I,V),he=b3("defaultValue",Z,I,V);return[await re.getHashTableById(ae.id).find(le,he)]}case"LookupTableSize":case"LookupTableSizeV2":{const ae=b3("tableHandle",Z,I,V,re);return[re.getHashTableById(ae.id).tensorSize()]}default:throw TypeError("Node type "+Z.op+" is not implemented")}},Pe=(Z,I,V,re=P6)=>{switch(Z.op){case"ResizeBilinear":{const ae=b3("images",Z,I,V),le=b3("size",Z,I,V),he=b3("alignCorners",Z,I,V),ue=b3("halfPixelCenters",Z,I,V);return[re.image.resizeBilinear(ae,[le[0],le[1]],he,ue)]}case"ResizeNearestNeighbor":{const ae=b3("images",Z,I,V),le=b3("size",Z,I,V),he=b3("alignCorners",Z,I,V),ue=b3("halfPixelCenters",Z,I,V);return[re.image.resizeNearestNeighbor(ae,[le[0],le[1]],he,ue)]}case"CropAndResize":{const ae=b3("image",Z,I,V),le=b3("boxes",Z,I,V),he=b3("boxInd",Z,I,V),ue=b3("cropSize",Z,I,V),pe=b3("method",Z,I,V),ve=b3("extrapolationValue",Z,I,V);return[re.image.cropAndResize(ae,le,he,ue,pe,ve)]}case"ImageProjectiveTransformV3":{const ae=b3("images",Z,I,V),le=b3("transforms",Z,I,V),he=b3("outputShape",Z,I,V),ue=b3("fillValue",Z,I,V),pe=b3("interpolation",Z,I,V),ve=b3("fillMode",Z,I,V);return[re.image.transform(ae,le,pe.toLowerCase(),ve.toLowerCase(),ue,he)]}default:throw TypeError("Node type "+Z.op+" is not implemented")}},PQ=(Z,I,V,re=P6)=>{switch(Z.op){case"Equal":return[re.equal(b3("a",Z,I,V),b3("b",Z,I,V))];case"NotEqual":return[re.notEqual(b3("a",Z,I,V),b3("b",Z,I,V))];case"Greater":return[re.greater(b3("a",Z,I,V),b3("b",Z,I,V))];case"GreaterEqual":return[re.greaterEqual(b3("a",Z,I,V),b3("b",Z,I,V))];case"Less":return[re.less(b3("a",Z,I,V),b3("b",Z,I,V))];case"LessEqual":return[re.lessEqual(b3("a",Z,I,V),b3("b",Z,I,V))];case"LogicalAnd":return[re.logicalAnd(b3("a",Z,I,V),b3("b",Z,I,V))];case"LogicalNot":return[re.logicalNot(b3("a",Z,I,V))];case"LogicalOr":return[re.logicalOr(b3("a",Z,I,V),b3("b",Z,I,V))];case"Select":case"SelectV2":return[re.where(b3("condition",Z,I,V),b3("a",Z,I,V),b3("b",Z,I,V))];case"BitwiseAnd":return[re.bitwiseAnd(b3("a",Z,I,V),b3("b",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}},Ps=(Z,I,V,re=P6)=>{switch(Z.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[re.matMul(b3("a",Z,I,V),b3("b",Z,I,V),b3("transposeA",Z,I,V),b3("transposeB",Z,I,V))];case"Einsum":return[re.einsum(b3("equation",Z,I,V),...b3("tensors",Z,I,V))];case"Transpose":return[re.transpose(b3("x",Z,I,V),b3("perm",Z,I,V))];case"_FusedMatMul":const[ae,le]=b3("fusedOps",Z,I,V),he=ae==="biasadd",ue=le==="prelu",pe=b3("numArgs",Z,I,V),ve=b3("leakyreluAlpha",Z,I,V);if(he){if(ue&&pe!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!ue&&pe!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[we,Me]=b3("args",Z,I,V);return[re.fused.matMul({a:b3("a",Z,I,V),b:b3("b",Z,I,V),transposeA:b3("transposeA",Z,I,V),transposeB:b3("transposeB",Z,I,V),bias:we,activation:le,preluActivationWeights:Me,leakyreluAlpha:ve})];case"MatrixBandPart":return[re.linalg.bandPart(b3("a",Z,I,V),b3("numLower",Z,I,V),b3("numUpper",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}},PF=(Z,I,V,re=P6)=>{switch(Z.op){case"EuclideanNorm":return[re.euclideanNorm(b3("x",Z,I,V),b3("axis",Z,I,V),b3("keepDims",Z,I,V))];case"FusedBatchNorm":case"FusedBatchNormV2":return[re.batchNorm(b3("x",Z,I,V),b3("mean",Z,I,V),b3("variance",Z,I,V),b3("offset",Z,I,V),b3("scale",Z,I,V),b3("epsilon",Z,I,V))];case"FusedBatchNormV3":return[re.batchNorm(b3("x",Z,I,V),b3("mean",Z,I,V),b3("variance",Z,I,V),b3("offset",Z,I,V),b3("scale",Z,I,V),b3("epsilon",Z,I,V))];case"LRN":return[re.localResponseNormalization(b3("x",Z,I,V),b3("radius",Z,I,V),b3("bias",Z,I,V),b3("alpha",Z,I,V),b3("beta",Z,I,V))];case"Softmax":return[re.softmax(b3("x",Z,I,V))];case"LogSoftmax":return[re.logSoftmax(b3("x",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}},PI=(Z,I,V,re=P6)=>{switch(Z.op){case"RaggedGather":{const{outputNestedSplits:ae,outputDenseValues:le}=re.raggedGather(b3("paramsNestedSplits",Z,I,V),b3("paramsDenseValues",Z,I,V),b3("indices",Z,I,V),b3("outputRaggedRank",Z,I,V));return ae.concat(le)}case"RaggedRange":{const{rtNestedSplits:ae,rtDenseValues:le}=re.raggedRange(b3("starts",Z,I,V),b3("limits",Z,I,V),b3("splits",Z,I,V));return[ae,le]}case"RaggedTensorToTensor":return[re.raggedTensorToTensor(b3("shape",Z,I,V),b3("values",Z,I,V),b3("defaultValue",Z,I,V),b3("rowPartitionTensors",Z,I,V),b3("rowPartitionTypes",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}},Py=(Z,I,V,re=P6)=>{switch(Z.op){case"Max":{const ue=b3("axis",Z,I,V),pe=b3("keepDims",Z,I,V);return[re.max(b3("x",Z,I,V),ue,pe)]}case"Mean":{const ue=b3("axis",Z,I,V),pe=b3("keepDims",Z,I,V);return[re.mean(b3("x",Z,I,V),ue,pe)]}case"Min":{const ue=b3("axis",Z,I,V),pe=b3("keepDims",Z,I,V);return[re.min(b3("x",Z,I,V),ue,pe)]}case"Sum":{const ue=b3("axis",Z,I,V),pe=b3("keepDims",Z,I,V);return[re.sum(b3("x",Z,I,V),ue,pe)]}case"All":{const ue=b3("axis",Z,I,V),pe=b3("keepDims",Z,I,V);return[re.all(b3("x",Z,I,V),ue,pe)]}case"Any":{const ue=b3("axis",Z,I,V),pe=b3("keepDims",Z,I,V);return[re.any(b3("x",Z,I,V),ue,pe)]}case"ArgMax":{const ue=b3("axis",Z,I,V);return[re.argMax(b3("x",Z,I,V),ue)]}case"ArgMin":{const ue=b3("axis",Z,I,V);return[re.argMin(b3("x",Z,I,V),ue)]}case"Prod":{const ue=b3("axis",Z,I,V),pe=b3("keepDims",Z,I,V);return[re.prod(b3("x",Z,I,V),ue,pe)]}case"Cumprod":{const ue=b3("axis",Z,I,V),pe=b3("exclusive",Z,I,V),ve=b3("reverse",Z,I,V);return[re.cumprod(b3("x",Z,I,V),ue,pe,ve)]}case"Cumsum":{const ue=b3("axis",Z,I,V),pe=b3("exclusive",Z,I,V),ve=b3("reverse",Z,I,V);return[re.cumsum(b3("x",Z,I,V),ue,pe,ve)]}case"Bincount":const ae=b3("x",Z,I,V),le=b3("weights",Z,I,V),he=b3("size",Z,I,V);return[re.bincount(ae,le,he)];case"DenseBincount":{const ue=b3("x",Z,I,V),pe=b3("weights",Z,I,V),ve=b3("size",Z,I,V),we=b3("binaryOutput",Z,I,V);return[re.denseBincount(ue,pe,ve,we)]}default:throw TypeError("Node type "+Z.op+" is not implemented")}},PA=(Z,I,V,re=P6)=>{switch(Z.op){case"ConcatV2":case"Concat":{const ae=b3("n",Z,I,V),le=b3("axis",Z,I,V);let he=b3("tensors",Z,I,V);return he=he.slice(0,ae),[re.concat(he,le)]}case"Gather":{const ae=b3("x",Z,I,V),le=b3("indices",Z,I,V);return[re.gather(ae,re.cast(le,"int32"),0)]}case"GatherV2":{const ae=b3("axis",Z,I,V),le=b3("batchDims",Z,I,V),he=b3("x",Z,I,V),ue=b3("indices",Z,I,V);return[re.gather(he,re.cast(ue,"int32"),ae,le)]}case"Reverse":{const ae=b3("dims",Z,I,V),le=[];for(let ue=0;ue<ae.length;ue++)ae[ue]&&le.push(ue);const he=b3("x",Z,I,V);return[re.reverse(he,le)]}case"ReverseV2":{const ae=b3("axis",Z,I,V),le=b3("x",Z,I,V);return[re.reverse(le,ae)]}case"Slice":{const ae=b3("begin",Z,I,V),le=b3("size",Z,I,V);return[re.slice(b3("x",Z,I,V),ae,le)]}case"StridedSlice":{const ae=b3("begin",Z,I,V),le=b3("end",Z,I,V),he=b3("strides",Z,I,V),ue=b3("beginMask",Z,I,V),pe=b3("endMask",Z,I,V),ve=b3("ellipsisMask",Z,I,V),we=b3("newAxisMask",Z,I,V),Me=b3("shrinkAxisMask",Z,I,V),Le=b3("x",Z,I,V);return[re.stridedSlice(Le,ae,le,he,ue,pe,ve,we,Me)]}case"Pack":return JY(()=>{const ae=b3("axis",Z,I,V),le=b3("tensors",Z,I,V),he=le[0].shape,ue=re.squeeze(le[0]).shape,pe=le.map(ve=>{const we=X(ve.shape,he);if(!we&&!X(re.squeeze(ve).shape,ue))throw new Error("the input tensors shape does not match");return we?ve:re.reshape(ve,he)});return[re.stack(pe,ae)]});case"Unpack":{const ae=b3("axis",Z,I,V),le=b3("tensor",Z,I,V);return re.unstack(le,ae)}case"Tile":{const ae=b3("reps",Z,I,V);return[re.tile(b3("x",Z,I,V),ae)]}case"Split":case"SplitV":{const ae=b3("axis",Z,I,V),le=b3("numOrSizeSplits",Z,I,V),he=b3("x",Z,I,V);return re.split(he,le,ae)}case"ScatterNd":{const ae=b3("indices",Z,I,V),le=b3("values",Z,I,V),he=b3("shape",Z,I,V);return[re.scatterND(ae,le,he)]}case"GatherNd":{const ae=b3("x",Z,I,V),le=b3("indices",Z,I,V);return[re.gatherND(ae,le)]}case"SparseToDense":{const ae=b3("sparseIndices",Z,I,V),le=b3("outputShape",Z,I,V),he=b3("sparseValues",Z,I,V),ue=b3("defaultValue",Z,I,V);return[re.sparseToDense(ae,he,le,he.dtype===ue.dtype?ue:re.cast(ue,he.dtype))]}case"TensorScatterUpdate":{const ae=b3("indices",Z,I,V),le=b3("values",Z,I,V),he=b3("tensor",Z,I,V);return[re.tensorScatterUpdate(he,ae,le)]}default:throw TypeError("Node type "+Z.op+" is not implemented")}},Pp=(Z,I,V,re=P6)=>{switch(Z.op){case"SparseFillEmptyRows":{const{outputIndices:ae,outputValues:le,emptyRowIndicator:he,reverseIndexMap:ue}=re.sparse.sparseFillEmptyRows(b3("indices",Z,I,V),b3("values",Z,I,V),b3("denseShape",Z,I,V),b3("defaultValue",Z,I,V));return[ae,le,he,ue]}case"SparseReshape":{const{outputIndices:ae,outputShape:le}=re.sparse.sparseReshape(b3("inputIndices",Z,I,V),b3("inputShape",Z,I,V),b3("newShape",Z,I,V));return[ae,le]}case"SparseSegmentMean":return[re.sparse.sparseSegmentMean(b3("data",Z,I,V),b3("indices",Z,I,V),b3("segmentIds",Z,I,V))];case"SparseSegmentSum":return[re.sparse.sparseSegmentSum(b3("data",Z,I,V),b3("indices",Z,I,V),b3("segmentIds",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}},Pw=(Z,I,V,re=P6)=>{switch(Z.op){case"FFT":return[re.fft(b3("x",Z,I,V))];case"IFFT":return[re.ifft(b3("x",Z,I,V))];case"RFFT":return[re.rfft(b3("x",Z,I,V))];case"IRFFT":return[re.irfft(b3("x",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}},PX=(Z,I,V,re=P6)=>{switch(Z.op){case"StaticRegexReplace":return[re.string.staticRegexReplace(b3("input",Z,I,V),b3("pattern",Z,I,V),b3("rewrite",Z,I,V),b3("replaceGlobal",Z,I,V))];case"StringNGrams":{const{nGrams:ae,nGramsSplits:le}=re.string.stringNGrams(b3("data",Z,I,V),b3("dataSplits",Z,I,V),b3("separator",Z,I,V),b3("nGramWidths",Z,I,V),b3("leftPad",Z,I,V),b3("rightPad",Z,I,V),b3("padWidth",Z,I,V),b3("preserveShortSequences",Z,I,V));return[ae,le]}case"StringSplit":{const{indices:ae,values:le,shape:he}=re.string.stringSplit(b3("input",Z,I,V),b3("delimiter",Z,I,V),b3("skipEmpty",Z,I,V));return[ae,le,he]}case"StringToHashBucketFast":return[re.string.stringToHashBucketFast(b3("input",Z,I,V),b3("numBuckets",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}},Pc=(Z,I,V,re=P6)=>{switch(Z.op){case"Cast":return[re.cast(b3("x",Z,I,V),b3("dtype",Z,I,V))];case"ExpandDims":{const ae=b3("axis",Z,I,V);return[re.expandDims(b3("x",Z,I,V),ae)]}case"Squeeze":{const ae=b3("axis",Z,I,V);return[re.squeeze(b3("x",Z,I,V),ae)]}case"Reshape":return[re.reshape(b3("x",Z,I,V),b3("shape",Z,I,V))];case"EnsureShape":return[re.ensureShape(b3("x",Z,I,V),b3("shape",Z,I,V))];case"MirrorPad":return[re.mirrorPad(b3("x",Z,I,V),b3("padding",Z,I,V),b3("mode",Z,I,V))];case"PadV2":case"Pad":return[re.pad(b3("x",Z,I,V),b3("padding",Z,I,V),b3("constantValue",Z,I,V))];case"SpaceToBatchND":{const ae=b3("blockShape",Z,I,V),le=b3("paddings",Z,I,V);return[re.spaceToBatchND(b3("x",Z,I,V),ae,le)]}case"BatchToSpaceND":{const ae=b3("blockShape",Z,I,V),le=b3("crops",Z,I,V);return[re.batchToSpaceND(b3("x",Z,I,V),ae,le)]}case"DepthToSpace":{const ae=b3("blockSize",Z,I,V),le=b3("dataFormat",Z,I,V).toUpperCase();return[re.depthToSpace(b3("x",Z,I,V),ae,le)]}case"BroadcastTo":return[re.broadcastTo(b3("x",Z,I,V),b3("shape",Z,I,V))];case"BroadcastArgs":return[re.broadcastArgs(b3("s0",Z,I,V),b3("s1",Z,I,V))];default:throw TypeError("Node type "+Z.op+" is not implemented")}};function PW(Z,I,V,re,ae=JY){const le=((he,ue,pe)=>{switch(he.category){case"arithmetic":return ae(()=>P7(he,ue,pe));case"basic_math":return ae(()=>P8(he,ue,pe));case"control":return PS(he,ue,pe);case"convolution":return ae(()=>PV(he,ue,pe));case"creation":return ae(()=>Pb(he,ue,pe));case"dynamic":return PE(he,ue,pe);case"evaluation":return ae(()=>PD(he,ue,pe));case"image":return ae(()=>Pe(he,ue,pe));case"graph":return ae(()=>Pg(he,ue,pe));case"logical":return ae(()=>PQ(he,ue,pe));case"matrices":return ae(()=>Ps(he,ue,pe));case"normalization":return ae(()=>PF(he,ue,pe));case"ragged":return ae(()=>PI(he,ue,pe));case"reduction":return ae(()=>Py(he,ue,pe));case"slice_join":return ae(()=>PA(he,ue,pe));case"sparse":return ae(()=>Pp(he,ue,pe));case"spectral":return ae(()=>Pw(he,ue,pe));case"string":return ae(()=>PX(he,ue,pe));case"transformation":return ae(()=>Pc(he,ue,pe));case"hash_table":return Po(he,ue,pe,re);case"custom":const ve=b2(he.op);if(ve&&ve.customExecutor)return ve.customExecutor(new P3(he,ue,pe));throw TypeError("Custom op "+he.op+" is not registered.");default:throw TypeError("Unknown op '"+he.op+"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(Z,I,V);return Cf(le)?le.then(he=>[].concat(he)):[].concat(le)}class PR{constructor(I={},V={},re={},ae={},le){this.weightMap=I,this.tensorArrayMap=V,this.tensorListMap=re,this.functionMap=ae,this.parseNodeNameCache=le,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(I,V){return{id:I,frameName:V,iterationId:0}}set currentContext(I){this.contexts!==I&&(this.contexts=I,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const I=[];for(let V=0;V<this.contexts.length-1;V++){const re=this.contexts.slice(0,this.contexts.length-V);I.push(this.contextIdforContexts(re))}I.push(""),this._currentContextIds=I}contextIdforContexts(I){return I?I.map(V=>V.id===0&&V.iterationId===0?"":V.frameName+"-"+V.iterationId).join("/"):""}enterFrame(I){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,I)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const I=Object.assign({},this.contexts[this.contexts.length-1]);I.iterationId+=1,I.id=this.lastId,this.contexts.splice(-1,1,I),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(I){return this.weightMap[I]}addTensorArray(I){this.tensorArrayMap[I.id]=I}getTensorArray(I){return this.tensorArrayMap[I]}addTensorList(I){this.tensorListMap[I.id]=I}getTensorList(I){return this.tensorListMap[I]}dispose(I){for(const V in this.tensorArrayMap)this.tensorArrayMap[V].clearAndClose(I);for(const V in this.tensorListMap)this.tensorListMap[V].clearAndClose(I)}}function PK(Z,I,V,re){const ae=new Set,le=[];let he=null,ue=null;const pe=new Set,ve=new Set(Object.keys(Z).map(Le=>b8(Le)[0]));re=re||[];const we=new Set(re.map(Le=>b8(Le.name)[0])),Me=[...I];for(;Me.length>0;){const Le=Me.pop();if((Pk(Le)||Pz(Le)||Px(Le))&&he==null&&(he=Le,ue=he.children.map(Ue=>Ue.name).filter(Ue=>ae.has(Ue))),ae.add(Le.name),V[Le.name]==null&&!ve.has(Le.name)&&!we.has(Le.name)){if(Le.inputs.length===0){le.push(Le.name);continue}Le.inputs.forEach(Ue=>{pe.has(Ue.name)||(pe.add(Ue.name),Me.push(Ue))})}}return{inputs:Z,outputs:I,usedNodes:ae,missingInputs:le,dynamicNode:he,syncInputs:ue}}function PT(Z,I){const{usedNodes:V,inputs:re}=I,ae=Object.keys(re).map(He=>b8(He)[0]).map(He=>Z.nodes[He]),le=Z.initNodes||[],he=He=>V.has(typeof He=="string"?He:He.name);function ue(He){return[...new Map(He.map(Ke=>[Ke.name,Ke])).values()]}const pe=ue([...ae,...Z.weights,...le]).filter(he),ve=ue([...pe,...Object.values(Z.nodes)]).filter(he),we=new Map(ve.map(He=>[He.name,He])),Me={};for(const He of ve){Me[He.name]=Me[He.name]||0;for(const Ke of He.children)he(Ke)||(Me[Ke.name]=Number.POSITIVE_INFINITY),Me[Ke.name]=(Me[Ke.name]||0)+1}const Le=Object.entries(Me).filter(([,He])=>He===0).map(([He])=>He),Ue=[...Le];for(;Le.length>0;){const He=Le.pop(),Ke=we.get(He);for(const Ye of Ke.children.filter(he))--Me[Ye.name]===0&&(Ue.push(Ye.name),Le.push(Ye.name))}const Ge=Ue.map(He=>we.get(He)),ze=Pv(Ge,pe);return Pl(ze,pe),ze}function Pv(Z,I){const V=new Map(Z.map(le=>[le.name,le])),re=I.map(le=>le.name),ae=new Set(re);for(;re.length>0;){const le=re.pop(),he=V.get(le);for(const ue of he.children)!V.has(ue.name)||ae.has(ue.name)||(ae.add(ue.name),re.push(ue.name))}return Z.filter(le=>ae.has(le.name))}class Pq extends Error{constructor(I){super("NodesExecutionOrderError: "+I)}}function Pl(Z,I){const V=new Map(Z.map((ue,pe)=>[ue.name,pe])),re=new Set(I.map(ue=>ue.name)),ae=ue=>re.has(typeof ue=="string"?ue:ue.name),le=new Set(Z.map(ue=>ue.name)),he=ue=>le.has(typeof ue=="string"?ue:ue.name);for(const ue of Z){for(const pe of ue.children.filter(he)){if(!V.has(pe.name))throw new Pq("Child "+pe.name+" of node "+ue.name+" is unreachable.");if(V.get(ue.name)>V.get(pe.name))throw new Pq("Node "+ue.name+" is scheduled to run after its child "+pe.name+".")}if(!ae(ue))for(const pe of ue.inputs){if(!V.has(pe.name))throw new Pq("Input "+pe.name+" of node "+ue.name+" is unreachable.");if(V.get(pe.name)>V.get(ue.name))throw new Pq("Node "+ue.name+" is scheduled to run before its input "+pe.name+".")}}}function Pa(Z){const I=new Map(Z.map((ue,pe)=>[ue.name,pe])),V=Number.MAX_SAFE_INTEGER,re=Z.map((ue,pe)=>Pk(ue)?V:pe),ae=ue=>{const pe=re[I.get(ue.name)];return pe??-1},le=Z.map((ue,pe)=>ue.children.map(ae).reduce((ve,we)=>Math.max(ve,we),re[pe])),he=new Map;for(let ue=0;ue<Z.length;++ue){const pe=le[ue];if(pe===V)continue;const ve=Z[ue],we=Z[pe];he.has(we.name)||he.set(we.name,[]),he.get(we.name).push(ve)}return he}const Pn=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),PL=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),PH=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Pk(Z){return Pn.has(Z.op)}function Pz(Z){return PL.has(Z.op)}function Px(Z){return PH.has(Z.op)}class PU{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(I){const V=Object.keys(I).map(re=>I[re].map(ae=>ae.id));this._weightIds=[].concat(...V),this._weightMap=I}set resourceManager(I){this._resourceManager=I}get inputs(){return this._inputs.map(I=>({name:I.name,shape:I.attrParams.shape?I.attrParams.shape.value:void 0,dtype:I.attrParams.dtype?I.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(I=>({name:I.name,shape:I.attrParams.shape?I.attrParams.shape.value:void 0,dtype:I.attrParams.dtype?I.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(I=>I.signatureKey||I.name)}get outputNodes(){return this._outputs.map(I=>{const V=I.signatureKey||I.name;return I.defaultOutput?V+":"+I.defaultOutput:V})}get functions(){return Object.keys(this._functions).reduce((I,V)=>(I[V]=this._functions[V].signature,I),{})}constructor(I,V){this.graph=I,this.parent=V,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=I.outputs,this._inputs=I.inputs,this._initNodes=I.initNodes,this._signature=I.signature,this._functions=I.functions,I.functions!=null&&Object.keys(I.functions).forEach(re=>{this._functionExecutorMap[re]=new PU(I.functions[re],this)})}getCompilationKey(I,V){const re=I.map(le=>le.name).sort(),ae=V.map(le=>le.name).sort();return re.join(this.SEPARATOR)+"--"+ae.join(this.SEPARATOR)}compile(I,V){const re=PK(I,V,this.weightMap,this._initNodes),{missingInputs:ae,dynamicNode:le,syncInputs:he}=re;if(le!=null)throw new Error("This execution contains the node '"+le.name+"', which has the dynamic op '"+le.op+"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs ["+he+"]");if(ae.length>0){const ve=V.map(Me=>Me.name),we=Object.keys(I);throw new Error("Cannot compute the outputs ["+ve+"] from the provided inputs ["+we+"]. Missing the following inputs: ["+ae+"]")}const ue=PT(this.graph,re),pe=Pa(ue);return{orderedNodes:ue,nodeLiveUntilMap:pe}}cloneAndKeepTensor(I){if(I==null)return null;const V=I.clone();return Jh(V),V}cloneTensorList(I){return I?I.map(V=>this.cloneAndKeepTensor(V)):null}cloneTensorMap(I){return Object.fromEntries(Object.entries(I).map(([V,re])=>[V,this.cloneTensorList(re)]))}execute(I,V){this.disposeIntermediateTensors(),I=this.mapInputs(I);const re=Object.keys(I).sort();this.checkInputs(I),this.checkInputShapeAndType(I),V=this.mapOutputs(V),this.checkOutputs(V);const ae=re.map(Le=>this.graph.nodes[b8(Le)[0]]),le=V.map(Le=>b8(Le)[0]),he=new Set(le);let ue=le.map(Le=>this.graph.nodes[Le]);ue.length===0&&(ue=this._outputs);const pe=this.getCompilationKey(ae,ue);let ve=this.compiledMap.get(pe);ve==null&&(ve=this.compile(I,ue),this.compiledMap.set(pe,ve));try{this.keepIntermediateTensors=Cd().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(Le){this.keepIntermediateTensors=!1,console.warn(Le.message)}const we={},Me={};return JY(()=>{const Le=new PR(this.weightMap,we,Me,this.functionExecutorMap,this.parseNodeNameCache),Ue=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(I).forEach(Ke=>{const[Ye,$e]=b8(Ke,Le),je=[];je[$e]=I[Ke],Ue[Ye]=je,this.keepIntermediateTensors&&(this.clonedTensorsMap[Ye]=this.cloneTensorList(je))});const Ge=this.getFrozenTensorIds(Ue),{orderedNodes:ze,nodeLiveUntilMap:He}=ve;for(const Ke of ze){if(Ue[Ke.name])continue;const Ye=PW(Ke,Ue,Le,this._resourceManager);if(Cf(Ye))throw new Error("The execution of the op '"+Ke.op+"' returned a promise. Please use model.executeAsync() instead.");Ue[Ke.name]=Ye,this.keepIntermediateTensors&&(this.clonedTensorsMap[Ke.name]=this.cloneTensorList(Ye)),this.checkTensorForDisposalWithNodeLiveUntilInfo(Ke,Ue,Le,Ge,he,He.get(Ke.name))}return this.parent==null&&Le.dispose(Ge),V.map(Ke=>b4(Ke,Ue,Le))})}getFrozenTensorIds(I){const V=[].concat.apply([],Object.keys(I).map(re=>I[re]).map(re=>re.map(ae=>ae.id)));return new Set(V)}checkTensorForDisposal(I,V,re,ae,le,he,ue){if(!(Pk(V)||he.has(I))){for(const pe of re[I])pe!=null&&(ue[pe.id]=(ue[pe.id]||0)+V.children.length);for(const pe of V.inputs){if(Pk(pe))continue;const ve=b5(pe.name,re,ae);if(ve!=null)for(const we of ve){if(!we||we.kept||le.has(we.id))continue;const Me=ue[we.id];Me===1?(we.dispose(),delete ue[we.id]):Me!=null&&ue[we.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(I,V,re,ae,le,he){function ue(pe){return Pk(pe)||le.has(pe.name)}if(!(Pk(I)||he==null))for(const pe of he){if(ue(pe))continue;const ve=b5(pe.name,V,re);for(const we of ve)!we||we.kept||ae.has(we.id)||we.dispose()}}async executeAsync(I,V){return this._executeAsync(I,V)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(I=>{for(const V of I)V&&!V.isDisposed&&V.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(I,V,re=!1,ae={},le={}){this.disposeIntermediateTensors(),re||(I=this.mapInputs(I),this.checkInputs(I),this.checkInputShapeAndType(I),V=this.mapOutputs(V),this.checkOutputs(V));try{this.keepIntermediateTensors=Cd().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(Le){this.keepIntermediateTensors=!1,console.warn(Le.message)}const he=new PR(this.weightMap,ae,le,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const ue=await this.executeWithControlFlow(I,he,V,re),pe=V.map(Le=>b4(Le,ue,he)),ve=pe.map(Le=>Le.id),we=Object.keys(I).map(Le=>I[Le].id),Me=new Set([...ve,...we,...this.weightIds]);return Object.values(ue).forEach(Le=>{Le.forEach(Ue=>{Ue&&!Ue.isDisposed&&!Me.has(Ue.id)&&Ue.dispose()})}),this.parent==null&&he.dispose(Me),pe}async executeFunctionAsync(I,V,re){const ae=I.reduce((le,he,ue)=>(le[this.inputs[ue].name]=he,le),{});return this._executeAsync(ae,this.outputNodes,!0,V,re)}async executeWithControlFlow(I,V,re,ae){const le=Object.keys(I),he=le.map(je=>this.graph.nodes[b8(je)[0]]),ue=re.map(je=>b8(je)[0]),pe=new Set(ue);let ve=ue.map(je=>this.graph.nodes[je]);ve.length===0&&(ve=this._outputs);const{usedNodes:we,missingInputs:Me,dynamicNode:Le,syncInputs:Ue}=PK(I,ve,this.weightMap,this._initNodes),Ge=[...he,...this.graph.weights,...this._initNodes||[]].map(je=>({node:je,contexts:V.currentContext})),ze=Object.assign({},this.weightMap);Object.keys(I).forEach(je=>{const[rt,at]=b8(je),Rt=[];Rt[at]=I[je],ze[rt]=Rt});const He={},Ke=this.getFrozenTensorIds(ze),Ye={};for(;Ge.length>0;){const je=this.processStack(he,Ge,V,ze,Ye,Ke,pe,He,we);await Promise.all(je)}Le==null&&!ae&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $e=ve.filter(je=>!Pk(je)&&!b4(je.name,ze,V)).map(je=>je.name);if($e.length>0){let je="";throw Le!=null&&(je="Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs ["+Ue+"]"),new Error("Cannot compute the outputs ["+$e+"] from the provided inputs ["+le+"]. Consider providing the following inputs: ["+Me+"]. "+je)}return ze}processStack(I,V,re,ae,le,he,ue,pe,ve){const we=[];for(;V.length>0;){const Me=V.pop();re.currentContext=Me.contexts;let Le="";if(Me.node.op==="Enter"&&b3("isConstant",Me.node,ae,re)&&([Le]=b6(Me.node.name,re)),ae[Me.node.name]==null){const Ue=PW(Me.node,ae,re,this._resourceManager);Le||([Le]=b6(Me.node.name,re));const Ge=re.currentContext;Cf(Ue)?we.push(Ue.then(ze=>(ae[Le]=ze,this.keepIntermediateTensors&&(this.clonedTensorsMap[Le]=this.cloneTensorList(ze)),re.currentContext=Ge,this.checkTensorForDisposal(Le,Me.node,ae,re,he,ue,pe),this.processChildNodes(Me.node,V,re,ae,le,ve),ze))):(ae[Le]=Ue,this.keepIntermediateTensors&&(this.clonedTensorsMap[Le]=this.cloneTensorList(Ue)),this.checkTensorForDisposal(Le,Me.node,ae,re,he,ue,pe),this.processChildNodes(Me.node,V,re,ae,le,ve))}else this.processChildNodes(Me.node,V,re,ae,le,ve)}return we}processChildNodes(I,V,re,ae,le,he){I.children.forEach(ue=>{const[pe]=b6(ue.name,re);le[pe]||!he.has(ue.name)||(ue.op==="Merge"?ue.inputNames.some(ve=>!!b4(ve,ae,re))&&(le[pe]=!0,V.push({contexts:re.currentContext,node:ue})):ue.inputNames.every(ve=>!!b4(ve,ae,re))&&(le[pe]=!0,V.push({contexts:re.currentContext,node:ue})))})}dispose(){Object.keys(this.weightMap).forEach(I=>this.weightMap[I].forEach(V=>V.dispose()))}checkInputShapeAndType(I){Object.keys(I).forEach(V=>{const re=I[V],[ae]=b8(V),le=this.graph.nodes[ae];if(le.attrParams.shape&&le.attrParams.shape.value){const he=le.attrParams.shape.value,ue=he.length===re.shape.length&&re.shape.every((pe,ve)=>he[ve]===-1||he[ve]===pe);e(ue,()=>"The shape of dict['"+le.name+"'] provided in model.execute(dict) must be ["+he+"], but was ["+re.shape+"]")}le.attrParams.dtype&&le.attrParams.dtype.value&&e(re.dtype===le.attrParams.dtype.value,()=>"The dtype of dict['"+le.name+"'] provided in model.execute(dict) must be "+le.attrParams.dtype.value+", but was "+re.dtype)})}mapInputs(I){var V,re;const ae={};for(const le in I){const he=(re=(V=this._signature)===null||V===void 0?void 0:V.inputs)===null||re===void 0?void 0:re[le];he!=null?ae[he.name]=I[le]:ae[le]=I[le]}return ae}checkInputs(I){const V=Object.keys(I).filter(re=>{const[ae]=b8(re);return this.graph.nodes[ae]==null});if(V.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+V+"] that are not part of graph")}mapOutputs(I){return I.map(V=>{var re,ae;const le=(ae=(re=this._signature)===null||re===void 0?void 0:re.outputs)===null||ae===void 0?void 0:ae[V];return le!=null?le.name:V},{})}checkOutputs(I){I.forEach(V=>{const[re]=b8(V);if(!this.graph.nodes[re])throw new Error("The output '"+V+"' is not found in the graph")})}}class PG{constructor(I={},V={}){this.hashTableNameToHandle=I,this.hashTableMap=V}addHashTable(I,V){this.hashTableNameToHandle[I]=V.handle,this.hashTableMap[V.id]=V}getHashTableHandleByName(I){return this.hashTableNameToHandle[I]}getHashTableById(I){return this.hashTableMap[I]}dispose(){for(const I in this.hashTableMap)this.hashTableMap[I].clearAndClose(),delete this.hashTableMap[I];for(const I in this.hashTableNameToHandle)this.hashTableNameToHandle[I].dispose(),delete this.hashTableNameToHandle[I]}}const Pu="?tfjs-format=file",PY="model.json";class PM{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(I,V={},re=iy){this.modelUrl=I,this.loadOptions=V,this.version="n/a",this.io=re,V==null&&(this.loadOptions={}),this.resourceManager=new PG}findIOHandler(){const I=this.modelUrl;if(I.load!=null)this.handler=I;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(I,this.loadOptions);else{const V=this.io.getLoadHandlers(I,this.loadOptions);if(V.length===0)V.push(this.io.browserHTTPRequest(I,this.loadOptions));else if(V.length>1)throw new Error("Found more than one ("+V.length+") load handlers for URL '"+[I]+"'");this.handler=V[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const I=this.handler.load();return Cf(I)?I.then(V=>V.getWeightStream==null?this.loadSync(V):this.loadStreaming(V)):this.loadSync(I)}loadSync(I){const V=this.io.decodeWeights(I.weightData,I.weightSpecs);return this.loadWithWeightMap(I,V)}async loadStreaming(I){if(I.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const V=await f9(I.getWeightStream(),I.weightSpecs);return this.loadWithWeightMap(I,V)}loadWithWeightMap(I,V){this.artifacts=I;const re=this.artifacts.modelTopology;let ae=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const le=this.artifacts.userDefinedMetadata;le.signature!=null&&(ae=le.signature),le.structuredOutputKeys!=null&&(this.structuredOutputKeys=le.structuredOutputKeys)}if(this.signature=ae,this.version=re.versions.producer+"."+re.versions.minConsumer,this.executor=new PU(bL.Instance.transformGraph(re,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(V),this.executor.resourceManager=this.resourceManager,I.modelInitializer!=null&&I.modelInitializer.node!=null){const le=bL.Instance.transformGraph(I.modelInitializer);this.initializer=new PU(le),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=I.initializerSignature}return!0}async save(I,V){if(typeof I=="string"){const re=this.io.getSaveHandlers(I);if(re.length===0)throw new Error("Cannot find any save handlers for URL '"+I+"'");if(re.length>1)throw new Error("Found more than one ("+re.length+") save handlers for URL '"+I+"'");I=re[0]}if(I.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return I.save(this.artifacts)}addStructuredOutputNames(I){if(this.structuredOutputKeys){const V=I instanceof JJ?[I]:I,re={};return V.forEach((ae,le)=>re[this.structuredOutputKeys[le]]=ae),re}return I}predict(I,V){const re=this.execute(I,this.outputNodes);return this.addStructuredOutputNames(re)}async predictAsync(I,V){const re=await this.executeAsync(I,this.outputNodes);return this.addStructuredOutputNames(re)}normalizeInputs(I){var V;if(!(I instanceof JJ)&&!Array.isArray(I)){const le=(V=this.signature)===null||V===void 0?void 0:V.inputs;if(le!=null)for(const he in le){const ue=le[he];ue.resourceId!=null&&(I[he]=this.resourceIdToCapturedInput[ue.resourceId])}return I}I=Array.isArray(I)?I:[I];const re=Object.keys(this.resourceIdToCapturedInput).length;if(I.length+re!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has "+(this.inputNodes.length-re)+" non-resource placeholders, while there are "+I.length+" input tensors provided.");let ae=0;return this.inputNodes.reduce((le,he)=>{var ue,pe,ve;const we=(ve=(pe=(ue=this.signature)===null||ue===void 0?void 0:ue.inputs)===null||pe===void 0?void 0:pe[he])===null||ve===void 0?void 0:ve.resourceId;return we!=null?le[he]=this.resourceIdToCapturedInput[we]:le[he]=I[ae++],le},{})}normalizeOutputs(I){return I=I||this.outputNodes,Array.isArray(I)?I:[I]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(I){if(this.resourceIdToCapturedInput={},this.initializerSignature){const V=this.initializerSignature.outputs,re=Object.keys(V);for(let ae=0;ae<re.length;ae++){const le=re[ae],he=V[le];this.resourceIdToCapturedInput[he.resourceId]=I[ae]}}}execute(I,V){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),I=this.normalizeInputs(I),V=this.normalizeOutputs(V);const re=this.executor.execute(I,V);return re.length>1?re:re[0]}async executeAsync(I,V){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),I=this.normalizeInputs(I),V=this.normalizeOutputs(V);const re=await this.executor.executeAsync(I,V);return re.length>1?re:re[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(I){return Object.keys(I).reduce((V,re)=>(V[re]=[I[re]],V),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&JM(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Ph(Z,I={},V=iy){if(Z==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");I==null&&(I={}),I.fromTFHub&&typeof Z=="string"&&(Z=Pj(Z));const re=new PM(Z,I,V);return await re.load(),re}function Pj(Z){return Z.endsWith("/")||(Z=Z+"/"),""+Z+PY+Pu}const Pr={},E0={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function E1(Z,I){Pr[Z]=I}function E2(Z,I){if(!(Z in Pr)||I!=null){const re=E4(Z,I);if(re!==null)Pr[Z]=re;else return console.log("Could not get context for WebGL version",Z),null}const V=Pr[Z];return V==null||V.isContextLost()?(delete Pr[Z],E2(Z)):(V.disable(V.DEPTH_TEST),V.disable(V.STENCIL_TEST),V.disable(V.BLEND),V.disable(V.DITHER),V.disable(V.POLYGON_OFFSET_FILL),V.disable(V.SAMPLE_COVERAGE),V.enable(V.SCISSOR_TEST),V.enable(V.CULL_FACE),V.cullFace(V.BACK),Pr[Z])}function E3(Z){if(!Cd().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&Z===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function E4(Z,I){if(Z!==1&&Z!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const V=I??E3(Z);return V.addEventListener("webglcontextlost",re=>{re.preventDefault(),delete Pr[Z]},!1),Cd().getBool("SOFTWARE_WEBGL_ENABLED")&&(E0.failIfMajorPerformanceCaveat=!1),Z===1?V.getContext("webgl",E0)||V.getContext("experimental-webgl",E0):V.getContext("webgl2",E0)}var E5;(function(Z){Z[Z.DENSE=0]="DENSE",Z[Z.SHARED_BATCH=1]="SHARED_BATCH"})(E5||(E5={}));var E6;(function(Z){Z[Z.RENDER=0]="RENDER",Z[Z.UPLOAD=1]="UPLOAD",Z[Z.PIXELS=2]="PIXELS",Z[Z.DOWNLOAD=3]="DOWNLOAD"})(E6||(E6={}));var E7;(function(Z){Z[Z.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",Z[Z.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",Z[Z.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",Z[Z.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",Z[Z.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(E7||(E7={}));function E8(Z,I){return[I,Z]}function E9(Z,I){return Z*I}function EC(Z){const I=F(Z),V=Math.ceil(I/4);return K(V)}function Em(Z,I){return[Math.max(1,Math.ceil(I/2)),Math.max(1,Math.ceil(Z/2))]}function EN(Z,I){const[V,re]=Em(Z,I);return V*re*4}function EJ(Z,I){const V=Z;let re,ae,le,he,ue,pe,ve,we,Me,Le;return Cd().getNumber("WEBGL_VERSION")===2?(re=V.R32F,ae=V.R16F,le=V.RGBA16F,he=V.RGBA32F,ue=V.RED,ve=4,we=1,Me=V.HALF_FLOAT,Le=V.FLOAT,pe=V.RGBA8):(re=Z.RGBA,ae=Z.RGBA,le=Z.RGBA,he=V.RGBA,ue=Z.RGBA,ve=4,we=4,Me=I!=null?I.HALF_FLOAT_OES:null,Le=Z.FLOAT,pe=Z.RGBA),{internalFormatFloat:re,internalFormatHalfFloat:ae,internalFormatPackedHalfFloat:le,internalFormatPackedFloat:he,textureFormatFloat:ue,downloadTextureFormat:pe,downloadUnpackNumChannels:ve,defaultNumChannels:we,textureTypeHalfFloat:Me,textureTypeFloat:Le}}function Ef(Z,I){const V=I();return Cd().getBool("DEBUG")&&Ei(Z),V}function Ei(Z){const I=Z.getError();if(I!==Z.NO_ERROR)throw new Error("WebGL Error: "+ES(Z,I))}const EO=596e-10,Et=65504;function EB(Z){return!!(Cd().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||Z===0||EO<Math.abs(Z)&&Math.abs(Z)<Et)}function ES(Z,I){switch(I){case Z.NO_ERROR:return"NO_ERROR";case Z.INVALID_ENUM:return"INVALID_ENUM";case Z.INVALID_VALUE:return"INVALID_VALUE";case Z.INVALID_OPERATION:return"INVALID_OPERATION";case Z.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case Z.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case Z.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+I}}function Ed(Z,I){return EK(Z,()=>Z.getExtension(I),'Extension "'+I+'" not supported on this browser.')}function EV(Z,I){const V=EK(Z,()=>Z.createShader(Z.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ef(Z,()=>Z.shaderSource(V,I)),Ef(Z,()=>Z.compileShader(V)),Z.getShaderParameter(V,Z.COMPILE_STATUS)===!1)throw console.log(Z.getShaderInfoLog(V)),new Error("Failed to compile vertex shader.");return V}function Eb(Z,I){const V=EK(Z,()=>Z.createShader(Z.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ef(Z,()=>Z.shaderSource(V,I)),Ef(Z,()=>Z.compileShader(V)),Cd().get("ENGINE_COMPILE_ONLY"))return V;if(Z.getShaderParameter(V,Z.COMPILE_STATUS)===!1)throw EE(I,Z.getShaderInfoLog(V)),new Error("Failed to compile fragment shader.");return V}const EP=/ERROR: [0-9]+:([0-9]+):/g;function EE(Z,I){const V=EP.exec(I);if(V==null){console.log("Couldn't parse line number in error: "+I),console.log(Z);return}const re=+V[1],ae=Z.split(`
`),le=ae.length.toString().length+2,he=ae.map((Me,Le)=>T((Le+1).toString(),le)+Me);let ue=0;for(let Me=0;Me<he.length;Me++)ue=Math.max(he[Me].length,ue);const pe=he.slice(0,re-1),ve=he.slice(re-1,re),we=he.slice(re);console.log(pe.join(`
`)),console.log(I.split(`
`)[0]),console.log("%c "+T(ve[0],ue),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(we.join(`
`))}function ED(Z){return EK(Z,()=>Z.createProgram(),"Unable to create WebGLProgram.")}function Eg(Z,I){if(Ef(Z,()=>Z.linkProgram(I)),!Cd().get("ENGINE_COMPILE_ONLY")&&Z.getProgramParameter(I,Z.LINK_STATUS)===!1)throw console.log(Z.getProgramInfoLog(I)),new Error("Failed to link vertex and fragment shaders.")}function EZ(Z,I){if(Ef(Z,()=>Z.validateProgram(I)),Z.getProgramParameter(I,Z.VALIDATE_STATUS)===!1)throw console.log(Z.getProgramInfoLog(I)),new Error("Shader program validation failed.")}function Eo(Z,I){const V=EK(Z,()=>Z.createBuffer(),"Unable to create WebGLBuffer");return Ef(Z,()=>Z.bindBuffer(Z.ARRAY_BUFFER,V)),Ef(Z,()=>Z.bufferData(Z.ARRAY_BUFFER,I,Z.STATIC_DRAW)),V}function Ee(Z,I){const V=EK(Z,()=>Z.createBuffer(),"Unable to create WebGLBuffer");return Ef(Z,()=>Z.bindBuffer(Z.ELEMENT_ARRAY_BUFFER,V)),Ef(Z,()=>Z.bufferData(Z.ELEMENT_ARRAY_BUFFER,I,Z.STATIC_DRAW)),V}function EQ(Z){return EK(Z,()=>Z.createTexture(),"Unable to create WebGLTexture.")}function Es(Z,I){const V=Cd().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(Z<=0||I<=0){const re="["+Z+"x"+I+"]";throw new Error("Requested texture size "+re+" is invalid.")}if(Z>V||I>V){const re="["+Z+"x"+I+"]",ae="["+V+"x"+V+"]";throw new Error("Requested texture size "+re+" greater than WebGL maximum on this browser / GPU "+ae+".")}}function EF(Z){return EK(Z,()=>Z.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function EI(Z,I,V,re,ae,le,he){const ue=Z.getAttribLocation(I,V);return ue===-1?!1:(Ef(Z,()=>Z.bindBuffer(Z.ARRAY_BUFFER,re)),Ef(Z,()=>Z.vertexAttribPointer(ue,ae,Z.FLOAT,!1,le,he)),Ef(Z,()=>Z.enableVertexAttribArray(ue)),!0)}function Ey(Z,I,V){ET(Z,V),Ef(Z,()=>Z.activeTexture(Z.TEXTURE0+V)),Ef(Z,()=>Z.bindTexture(Z.TEXTURE_2D,I))}function EA(Z,I,V){return EK(Z,()=>Z.getUniformLocation(I,V),'uniform "'+V+'" not present in program.')}function Ep(Z,I,V){return Z.getUniformLocation(I,V)}function Ew(Z,I,V,re){Ef(Z,()=>Ey(Z,I,re)),Ef(Z,()=>Z.uniform1i(V,re))}function EX(Z,I,V){Ef(Z,()=>Z.bindFramebuffer(Z.FRAMEBUFFER,V)),Ef(Z,()=>Z.framebufferTexture2D(Z.FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Z.TEXTURE_2D,I,0))}function Ec(Z,I){Ef(Z,()=>Z.bindFramebuffer(Z.FRAMEBUFFER,I)),Ef(Z,()=>Z.framebufferTexture2D(Z.FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Z.TEXTURE_2D,null,0))}function EW(Z){const I=Z.checkFramebufferStatus(Z.FRAMEBUFFER);if(I!==Z.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+ER(Z,I))}function ER(Z,I){switch(I){case Z.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case Z.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case Z.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case Z.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+I}}function EK(Z,I,V){const re=Ef(Z,()=>I());if(re==null)throw new Error(V);return re}function ET(Z,I){const V=Z.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,re=I+Z.TEXTURE0;if(re<Z.TEXTURE0||re>V){const ae="[gl.TEXTURE0, gl.TEXTURE"+V+"]";throw new Error("textureUnit must be in "+ae+".")}}function Ev(Z,I=2){return F(Z.slice(0,Z.length-I))}function Eq(Z){if(Z.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[Z.length>1?Z[Z.length-2]:1,Z[Z.length-1]]}function El(Z){let I=[1,1,1];return Z.length===0||Z.length===1&&Z[0]===1||(I=[Ev(Z),...Eq(Z)]),I}function Ea(Z,I=!1){let V=Cd().getNumber("WEBGL_MAX_TEXTURE_SIZE"),re=Cd().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");re===1/0&&Cd().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(re=V/2),I&&(V=V*2,re=re*2,Z=Z.map((ue,pe)=>pe>=Z.length-2?B(Z[pe]):Z[pe]),Z.length===1&&(Z=[2,Z[0]])),Z.length!==2&&(Z=L(Z).newShape);let ae=F(Z),le=null;Z.length<=1&&ae<=V?le=[1,ae]:Z.length===2&&Z[0]<=V&&Z[1]<=V?le=Z:Z.length===3&&Z[0]*Z[1]<=V&&Z[2]<=V?le=[Z[0]*Z[1],Z[2]]:Z.length===3&&Z[0]<=V&&Z[1]*Z[2]<=V?le=[Z[0],Z[1]*Z[2]]:Z.length===4&&Z[0]*Z[1]*Z[2]<=V&&Z[3]<=V?le=[Z[0]*Z[1]*Z[2],Z[3]]:Z.length===4&&Z[0]<=V&&Z[1]*Z[2]*Z[3]<=V&&(le=[Z[0],Z[1]*Z[2]*Z[3]]);const he=le!=null&&Math.max(...le)>re&&Math.min(...le)<=(I?2:1)&&Math.min(...le)>0;if(le==null||he)if(I){const ue=Ev(Z);let pe=2,ve=2;Z.length&&([pe,ve]=Eq(Z)),ae=ue*(pe/2)*(ve/2),le=K(ae).map(we=>we*2)}else le=K(ae);return le}function En(Z){return Z%2===0}function EL(Z,I){if(Z=Z.slice(-2),I=I.slice(-2),X(Z,I)||!Z.length||!I.length||Z[0]===0||Z[1]===0||I[0]===0||I[1]===0)return!0;if(Z.length!==I.length){const V=Z[Z.length-1],re=I[I.length-1];if(V===re||En(V)&&En(re)&&(Z[0]===1||I[0]===1))return!0}return Z[1]===I[1]&&En(Z[0])&&En(I[0])}let EH,Ek;function Ez(Z){if(EH==null){const I=E2(Z);EH=I.getParameter(I.MAX_TEXTURE_SIZE)}return EH}function Ex(Z){if(Ek==null){const I=E2(Z);Ek=I.getParameter(I.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ek)}function EU(Z){if(Z===0)return 0;let I;const V=E2(Z);return EG(V,"EXT_disjoint_timer_query_webgl2")&&Z===2?I=2:EG(V,"EXT_disjoint_timer_query")?I=1:I=0,I}function EG(Z,I){return Z.getExtension(I)!=null}function Eu(Z){try{if(E2(Z)!=null)return!0}catch(I){return console.log("Error when getting WebGL context: ",I),!1}return!1}function EY(Z){if(Z===0)return!1;const I=E2(Z);if(Z===1){if(!EG(I,"OES_texture_float"))return!1}else if(!EG(I,"EXT_color_buffer_float"))return!1;return Eh(I)}function EM(Z){if(Z===0)return!1;const I=E2(Z);if(Z===1){if(!EG(I,"OES_texture_float")||!EG(I,"WEBGL_color_buffer_float"))return!1}else{if(EG(I,"EXT_color_buffer_float"))return Eh(I);const V="EXT_color_buffer_half_float";if(EG(I,V)){const re=I.getExtension(V);return Ej(I,re)}return!1}return Eh(I)}function Eh(Z){const I=EJ(Z),V=Z.createTexture();Z.bindTexture(Z.TEXTURE_2D,V);const re=1,ae=1;Z.texImage2D(Z.TEXTURE_2D,0,I.internalFormatFloat,re,ae,0,I.textureFormatFloat,I.textureTypeFloat,null);const le=Z.createFramebuffer();Z.bindFramebuffer(Z.FRAMEBUFFER,le),Z.framebufferTexture2D(Z.FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Z.TEXTURE_2D,V,0);const he=Z.checkFramebufferStatus(Z.FRAMEBUFFER)===Z.FRAMEBUFFER_COMPLETE;return Z.bindTexture(Z.TEXTURE_2D,null),Z.bindFramebuffer(Z.FRAMEBUFFER,null),Z.deleteTexture(V),Z.deleteFramebuffer(le),he}function Ej(Z,I){const V=EJ(Z,I),re=Z.createTexture();Z.bindTexture(Z.TEXTURE_2D,re);const ae=1,le=1;Z.texImage2D(Z.TEXTURE_2D,0,V.internalFormatHalfFloat,ae,le,0,V.textureFormatFloat,V.textureTypeHalfFloat,null);const he=Z.createFramebuffer();Z.bindFramebuffer(Z.FRAMEBUFFER,he),Z.framebufferTexture2D(Z.FRAMEBUFFER,Z.COLOR_ATTACHMENT0,Z.TEXTURE_2D,re,0);const ue=Z.checkFramebufferStatus(Z.FRAMEBUFFER)===Z.FRAMEBUFFER_COMPLETE;return Z.bindTexture(Z.TEXTURE_2D,null),Z.bindFramebuffer(Z.FRAMEBUFFER,null),Z.deleteTexture(re),Z.deleteFramebuffer(he),ue}function Er(Z){return Z!==2?!1:E2(Z).fenceSync!=null}function D0(Z,I){Array.isArray(Z)||(Z=[Z]),Z.forEach(V=>{V!=null&&e(V.dtype!=="complex64",()=>I+" does not support complex64 tensors in the WebGL backend.")})}const D1=Cd();D1.registerFlag("HAS_WEBGL",()=>D1.getNumber("WEBGL_VERSION")>0),D1.registerFlag("WEBGL_VERSION",()=>Eu(2)?2:Eu(1)?1:0),D1.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),D1.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>D1.get("WEBGL_VERSION")===2),D1.registerFlag("WEBGL_CPU_FORWARD",()=>!0),D1.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),D1.registerFlag("WEBGL_PACK",()=>D1.getBool("HAS_WEBGL")),D1.registerFlag("WEBGL_PACK_NORMALIZATION",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_CLIP",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_REDUCE",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_LAZILY_UNPACK",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_CONV_IM2COL",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Ez(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Ex(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const Z=D1.getNumber("WEBGL_VERSION");return Z===0?0:EU(Z)}),D1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>D1.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!JX()),D1.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>EY(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>D1.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:D1.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),D1.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>EM(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Er(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>D1.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),D1.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,Z=>{if(typeof Z!="number")throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got "+Z+".");if(Z<0&&Z!==-1)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got "+Z+".")}),D1.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>JX()?1:-1,Z=>{if(typeof Z!="number")throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+Z+".");if(Z<0&&Z!==-1)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got "+Z+".")}),D1.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),D1.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),D1.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),D1.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),D1.registerFlag("WEBGL_EXP_CONV",()=>!1),D1.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>D1.getBool("IS_TEST")),D1.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),D1.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),D1.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),D1.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function D2(){let Z,I,V,re,ae,le,he,ue,pe,ve;return Cd().getNumber("WEBGL_VERSION")===2?(Z="#version 300 es",I="in",V="out",re="in",ae="texture",le="outputColor",he="out vec4 outputColor;",ue=Cd().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",pe="",ve=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(Z="",I="attribute",V="varying",re="varying",ae="texture2D",le="gl_FragColor",he="",ue=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,pe=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,ve=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:Z,attribute:I,varyingVs:V,varyingFs:re,texture2D:ae,output:le,defineOutput:he,defineSpecialNaN:ue,defineSpecialInf:pe,defineRound:ve}}function D3(Z,I,V="index"){const re=C5(I);return re.map((ae,le)=>{const he="int "+Z[le]+" = "+V+" / "+ae,ue=le===re.length-1?"int "+Z[le+1]+" = "+V+" - "+Z[le]+" * "+ae:"index -= "+Z[le]+" * "+ae;return he+"; "+ue+";"}).join("")}function D4(Z,I,V="index"){const re=C5(I);return re.map((ae,le)=>{const he="int "+Z[le]+" = "+V+" / outShapeStrides["+le+"]",ue=le===re.length-1?"int "+Z[le+1]+" = "+V+" - "+Z[le]+" * outShapeStrides["+le+"]":"index -= "+Z[le]+" * outShapeStrides["+le+"]";return he+"; "+ue+";"}).join("")}function D5(Z,I){const V=Z.length,re=Z.map(le=>I+"["+le+"]"),ae=new Array(V-1);ae[V-2]=re[V-1];for(let le=V-3;le>=0;--le)ae[le]="("+ae[le+1]+" * "+re[le+1]+")";return ae}function D6(Z,I,V="index"){const re=Z.map((le,he)=>he),ae=D5(re,I);return ae.map((le,he)=>{const ue="int "+Z[he]+" = "+V+" / "+ae[he],pe=he===ae.length-1?"int "+Z[he+1]+" = "+V+" - "+Z[he]+" * "+ae[he]:"index -= "+Z[he]+" * "+ae[he];return ue+"; "+pe+";"}).join("")}function D7(Z){const I=C5(Z).map(V=>V.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * `+I[0]+" + coords.y * "+I[1]+` + coords.z;
  }
`}function D8(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const D9=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:DC}=Vs;function Dm(Z,I,V){const re=[];if(Z.forEach(Le=>{const Ue=F(Le.shapeInfo.logicalShape);if(Le.shapeInfo.isUniform?re.push("uniform float "+Le.name+(Ue>1?"["+Ue+"]":"")+";"):(re.push("uniform sampler2D "+Le.name+";"),re.push("uniform int offset"+Le.name+";")),V.enableShapeUniforms){const{uniformShape:Ge}=Dx(V.packedInputs,Le.shapeInfo.logicalShape,Le.shapeInfo.texShape);switch(Ge.length){case 1:re.push("uniform int "+Le.name+"Shape;");break;case 2:re.push("uniform ivec2 "+Le.name+"Shape;");break;case 3:re.push("uniform ivec3 "+Le.name+"Shape;");break;case 4:re.push("uniform ivec4 "+Le.name+"Shape;");break}re.push("uniform ivec2 "+Le.name+"TexShape;")}}),V.enableShapeUniforms){switch(I.logicalShape.length){case 1:re.push("uniform int outShape;");break;case 2:re.push("uniform ivec2 outShape;"),re.push("uniform int outShapeStrides;");break;case 3:re.push("uniform ivec3 outShape;"),re.push("uniform ivec2 outShapeStrides;");break;case 4:re.push("uniform ivec4 outShape;"),re.push("uniform ivec3 outShapeStrides;");break}re.push("uniform ivec2 outTexShape;")}V.customUniforms&&V.customUniforms.forEach(Le=>{re.push("uniform "+Le.type+" "+Le.name+(Le.arrayIndex?"["+Le.arrayIndex+"]":"")+";")});const ae=re.join(`
`),le=Z.map(Le=>Df(Le,I,V.packedInputs,V.enableShapeUniforms)).join(`
`),he=I.texShape,ue=D2(),pe=Dt(ue);let ve,we,Me=Dd(ue);return I.isPacked?(ve=Di(I.logicalShape,he,V.enableShapeUniforms),we=DS(ue)):(ve=DO(I.logicalShape,he,V.enableShapeUniforms),we=DB(ue)),V.packedInputs&&(Me+=DE),[Me,pe,we,ae,ve,le,V.userCode].join(`
`)}function DN(Z,I=!1){const V=Z.shapeInfo.logicalShape;switch(V.length){case 0:return DX(Z,I);case 1:return DW(Z,I);case 2:return DK(Z,I);case 3:return Dv(Z,I);case 4:return Dl(Z,I);case 5:return Da(Z);case 6:return Dn(Z);default:throw new Error(V.length+"-D input sampling is not yet supported")}}function DJ(Z,I){switch(Z.shapeInfo.logicalShape.length){case 0:return Dw(Z);case 1:return Dc(Z,I);case 2:return DR(Z,I);case 3:return DT(Z,I);default:return Dq(Z,I)}}function Df(Z,I,V=!1,re){let ae="";V?ae+=DJ(Z,re):ae+=DN(Z,re);const le=Z.shapeInfo.logicalShape,he=I.logicalShape;return le.length<=he.length&&(V?ae+=DH(Z,I):ae+=Dk(Z,I)),ae}function Di(Z,I,V){switch(Z.length){case 0:return DD();case 1:return Dg(Z,I,V);case 2:return Dy(Z,I,V);case 3:return Do(Z,I,V);default:return DQ(Z,I,V)}}function DO(Z,I,V){switch(Z.length){case 0:return DD();case 1:return DZ(Z,I,V);case 2:return DA(Z,I,V);case 3:return De(Z,I,V);case 4:return Ds(Z,I,V);case 5:return DF(Z,I);case 6:return DI(Z,I);default:throw new Error(Z.length+"-D output sampling is not yet supported")}}function Dt(Z){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return `+Z.texture2D+`(textureSampler, uv).r;
    }
  `}function DB(Z){return`
    void setOutput(float val) {
      `+Z.output+` = vec4(val, 0, 0, 0);
    }
  `}function DS(Z){return`
    void setOutput(vec4 val) {
      `+Z.output+` = val;
    }
  `}function Dd(Z){return Z.version+`
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    `+Z.varyingFs+` vec2 resultUV;
    `+Z.defineOutput+`
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    `+Z.defineSpecialNaN+`
    `+Z.defineSpecialInf+`
    `+Z.defineRound+`

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    `+DV+`
    `+Db+`
    `+DP+`
  `}const DV=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Db=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,DP=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,DE=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function DD(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Dg(Z,I,V){const re=[Math.ceil(I[0]/2),Math.ceil(I[1]/2)];return re[0]===1?V?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * `+re[1]+`.0);
      }
    `:re[1]===1?V?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * `+re[0]+`.0);
      }
    `:V?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+re[0]+", "+re[1]+`));
      return 2 * (resTexRC.x * `+re[1]+` + resTexRC.y);
    }
  `}function DZ(Z,I,V){return I[0]===1?V?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * `+I[1]+`.0);
      }
    `:I[1]===1?V?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * `+I[0]+`.0);
      }
    `:V?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+I[0]+", "+I[1]+`));
      return resTexRC.x * `+I[1]+` + resTexRC.y;
    }
  `}function Do(Z,I,V){if(V)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const re=[Math.ceil(I[0]/2),Math.ceil(I[1]/2)],ae=Math.ceil(Z[2]/2),le=ae*Math.ceil(Z[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+re[0]+", "+re[1]+`));
      int index = resTexRC.x * `+re[1]+` + resTexRC.y;

      int b = index / `+le+`;
      index -= b * `+le+`;

      int r = 2 * (index / `+ae+`);
      int c = imod(index, `+ae+`) * 2;

      return ivec3(b, r, c);
    }
  `}function De(Z,I,V){if(V)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    `+D4(["r","c","d"],Z)+`
    return ivec3(r, c, d);
  }
`;const re=D3(["r","c","d"],Z);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+I[0]+", "+I[1]+`));
      int index = resTexRC.x * `+I[1]+` + resTexRC.y;
      `+re+`
      return ivec3(r, c, d);
    }
  `}function DQ(Z,I,V){if(V)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const re=[Math.ceil(I[0]/2),Math.ceil(I[1]/2)],ae=Math.ceil(Z[Z.length-1]/2),le=ae*Math.ceil(Z[Z.length-2]/2);let he=le,ue="",pe="b, r, c";for(let ve=2;ve<Z.length-1;ve++)he*=Z[Z.length-ve-1],ue=`
      int b`+ve+" = index / "+he+`;
      index -= b`+ve+" * "+he+`;
    `+ue,pe="b"+ve+", "+pe;return`
    ivec`+Z.length+` getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+re[0]+", "+re[1]+`));
      int index = resTexRC.x * `+re[1]+` + resTexRC.y;

      `+ue+`

      int b = index / `+le+`;
      index -= b * `+le+`;

      int r = 2 * (index / `+ae+`);
      int c = imod(index, `+ae+`) * 2;

      return ivec`+Z.length+"("+pe+`);
    }
  `}function Ds(Z,I,V){if(V)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      `+D4(["r","c","d","d2"],Z)+`
      return ivec4(r, c, d, d2);
    }
  `;const re=D3(["r","c","d","d2"],Z);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+I[0]+", "+I[1]+`));
      int index = resTexRC.x * `+I[1]+` + resTexRC.y;
      `+re+`
      return ivec4(r, c, d, d2);
    }
  `}function DF(Z,I){const V=D3(["r","c","d","d2","d3"],Z);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(`+I[0]+`,
                             `+I[1]+`));

      int index = resTexRC.x * `+I[1]+` + resTexRC.y;

      `+V+`

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function DI(Z,I){const V=D3(["r","c","d","d2","d3","d4"],Z);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+I[0]+", "+I[1]+`));
      int index = resTexRC.x * `+I[1]+` + resTexRC.y;

      `+V+`

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Dy(Z,I,V){const re=[Math.ceil(I[0]/2),Math.ceil(I[1]/2)];if(X(Z,I))return V?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(`+re[0]+", "+re[1]+`));
      }
    `;const ae=Math.ceil(Z[1]/2);return V?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+re[0]+", "+re[1]+`));

      int index = resTexRC.x * `+re[1]+` + resTexRC.y;
      int r = 2 * (index / `+ae+`);
      int c = imod(index, `+ae+`) * 2;

      return ivec2(r, c);
    }
  `}function DA(Z,I,V){return X(Z,I)?V?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(`+I[0]+", "+I[1]+`));
      }
    `:Z[1]===1?V?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+I[0]+", "+I[1]+`));
        int index = resTexRC.x * `+I[1]+` + resTexRC.y;
        return ivec2(index, 0);
      }
    `:Z[0]===1?V?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+I[0]+", "+I[1]+`));
        int index = resTexRC.x * `+I[1]+` + resTexRC.y;
        return ivec2(0, index);
      }
    `:V?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+I[0]+", "+I[1]+`));
      int index = resTexRC.x * `+I[1]+` + resTexRC.y;
      int r = index / `+Z[1]+`;
      int c = index - r * `+Z[1]+`;
      return ivec2(r, c);
    }
  `}function Dp(Z){return"offset"+Z}function Dw(Z){const I=Z.name,V="get"+I.charAt(0).toUpperCase()+I.slice(1),re=D2();return`
    vec4 `+V+`() {
      return `+re.texture2D+"("+I+`, halfCR);
    }
  `}function DX(Z,I){const V=Z.name,re="get"+V.charAt(0).toUpperCase()+V.slice(1);if(Z.shapeInfo.isUniform)return"float "+re+"() {return "+V+";}";const[ae,le]=Z.shapeInfo.texShape;if(ae===1&&le===1)return`
      float `+re+`() {
        return sampleTexture(`+V+`, halfCR);
      }
    `;const he=Dp(V);if(I)return`
    float `+re+`() {
      vec2 uv = uvFromFlat(`+V+"TexShape[0], "+V+"TexShape[1], "+he+`);
      return sampleTexture(`+V+`, uv);
    }
  `;const[ue,pe]=Z.shapeInfo.texShape;return`
    float `+re+`() {
      vec2 uv = uvFromFlat(`+ue+", "+pe+", "+he+`);
      return sampleTexture(`+V+`, uv);
    }
  `}function Dc(Z,I){const V=Z.name,re="get"+V.charAt(0).toUpperCase()+V.slice(1),ae=Z.shapeInfo.texShape,le=D2();if(I)return`
    vec4 `+re+`(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(`+V+"TexShape[0]) / 2.0), ceil(float("+V+`TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return `+le.texture2D+"("+V+`, uv);
    }
  `;const he=[Math.ceil(ae[0]/2),Math.ceil(ae[1]/2)];return`
    vec4 `+re+`(int index) {
      vec2 uv = packedUVfrom1D(
        `+he[0]+", "+he[1]+`, index);
      return `+le.texture2D+"("+V+`, uv);
    }
  `}function DW(Z,I){const V=Z.name,re="get"+V.charAt(0).toUpperCase()+V.slice(1);if(Z.shapeInfo.isUniform)return`
      float `+re+`(int index) {
        `+DL(Z)+`
      }
    `;const ae=Z.shapeInfo.texShape,le=ae[0],he=ae[1];if(he===1&&le===1)return`
      float `+re+`(int index) {
        return sampleTexture(`+V+`, halfCR);
      }
    `;const ue=Dp(V);return he===1?I?`
      float `+re+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+ue+") + 0.5) / float("+V+`TexShape[0]));
        return sampleTexture(`+V+`, uv);
      }
    `:`
      float `+re+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+ue+") + 0.5) / "+le+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `:le===1?I?`
      float `+re+`(int index) {
        vec2 uv = vec2((float(index + `+ue+") + 0.5) / float("+V+`TexShape[1]), 0.5);
        return sampleTexture(`+V+`, uv);
      }
    `:`
      float `+re+`(int index) {
        vec2 uv = vec2((float(index + `+ue+") + 0.5) / "+he+`.0, 0.5);
        return sampleTexture(`+V+`, uv);
      }
    `:I?`
    float `+re+`(int index) {
      vec2 uv = uvFromFlat(`+V+"TexShape[0], "+V+"TexShape[1], index + "+ue+`);
      return sampleTexture(`+V+`, uv);
    }
  `:`
    float `+re+`(int index) {
      vec2 uv = uvFromFlat(`+le+", "+he+", index + "+ue+`);
      return sampleTexture(`+V+`, uv);
    }
  `}function DR(Z,I){const V=Z.shapeInfo.logicalShape,re=Z.name,ae="get"+re.charAt(0).toUpperCase()+re.slice(1),le=Z.shapeInfo.texShape,he=le[0],ue=le[1],pe=D2();if(le!=null&&X(V,le))return I?`
      vec4 `+ae+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+re+"TexShape[1], "+re+`TexShape[0]);

        return `+pe.texture2D+"("+re+`, uv);
      }
    `:`
      vec4 `+ae+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+ue+".0, "+he+`.0);

        return `+pe.texture2D+"("+re+`, uv);
      }
    `;if(I)return`
    vec4 `+ae+`(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+re+"TexShape[0]) / 2.0), ceil(float("+re+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+re+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return `+pe.texture2D+"("+re+`, uv);
    }
  `;const ve=[Math.ceil(le[0]/2),Math.ceil(le[1]/2)],we=Math.ceil(V[1]/2);return`
    vec4 `+ae+`(int row, int col) {
      vec2 uv = packedUVfrom2D(`+we+", "+ve[0]+", "+ve[1]+`, row, col);
      return `+pe.texture2D+"("+re+`, uv);
    }
  `}function DK(Z,I){const V=Z.shapeInfo.logicalShape,re=Z.name,ae="get"+re.charAt(0).toUpperCase()+re.slice(1),le=Z.shapeInfo.texShape;if(le!=null&&X(V,le)){if(I)return`
      float `+ae+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+re+"TexShape[1], "+re+`TexShape[0]);
        return sampleTexture(`+re+`, uv);
      }
    `;const Le=le[0],Ue=le[1];return`
    float `+ae+`(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(`+Ue+".0, "+Le+`.0);
      return sampleTexture(`+re+`, uv);
    }
  `}const{newShape:he,keptDims:ue}=L(V),pe=he;if(pe.length<V.length){const Le=DU(Z,pe),Ue=["row","col"];return`
      `+DN(Le,I)+`
      float `+ae+`(int row, int col) {
        return `+ae+"("+DG(Ue,ue)+`);
      }
    `}if(Z.shapeInfo.isUniform)return`
      float `+ae+`(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(`+V[1]+`, 1)));
        `+DL(Z)+`
      }
    `;const ve=le[0],we=le[1],Me=Dp(re);return we===1?I?`
      float `+ae+`(int row, int col) {
        float index = dot(vec3(row, col, `+Me+"), vec3("+re+`Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(`+re+`TexShape[0]));
        return sampleTexture(`+re+`, uv);
      }
    `:`
    float `+ae+`(int row, int col) {
      float index = dot(vec3(row, col, `+Me+"), vec3("+V[1]+`, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / `+ve+`.0);
      return sampleTexture(`+re+`, uv);
    }
  `:ve===1?I?`
      float `+ae+`(int row, int col) {
        float index = dot(vec3(row, col, `+Me+"), vec3("+re+`Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(`+re+`TexShape[1]), 0.5);
        return sampleTexture(`+re+`, uv);
      }
    `:`
    float `+ae+`(int row, int col) {
      float index = dot(vec3(row, col, `+Me+"), vec3("+V[1]+`, 1, 1));
      vec2 uv = vec2((index + 0.5) / `+we+`.0, 0.5);
      return sampleTexture(`+re+`, uv);
    }
  `:I?`
      float `+ae+`(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+re+"Shape[1] + col + "+Me+`;
        vec2 uv = uvFromFlat(`+re+"TexShape[0], "+re+`TexShape[1], index);
        return sampleTexture(`+re+`, uv);
      }
    `:`
  float `+ae+`(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * `+V[1]+" + col + "+Me+`;
    vec2 uv = uvFromFlat(`+ve+", "+we+`, index);
    return sampleTexture(`+re+`, uv);
  }
`}function DT(Z,I){const V=Z.shapeInfo.logicalShape,re=Z.name,ae="get"+re.charAt(0).toUpperCase()+re.slice(1),le=Z.shapeInfo.texShape,he=[Math.ceil(le[0]/2),Math.ceil(le[1]/2)];if(V[0]===1){const Le=V.slice(1),Ue=[1,2],Ge=DU(Z,Le),ze=["b","row","col"];return`
        `+DJ(Ge,I)+`
        vec4 `+ae+`(int b, int row, int col) {
          return `+ae+"("+DG(ze,Ue)+`);
        }
      `}const ue=D2();if(I)return`
    vec4 `+ae+`(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+re+"TexShape[0]) / 2.0), ceil(float("+re+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+re+`Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+re+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return `+ue.texture2D+"("+re+`, uv);
    }
  `;const pe=he[0],ve=he[1],we=Math.ceil(V[2]/2),Me=we*Math.ceil(V[1]/2);return`
    vec4 `+ae+`(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        `+pe+", "+ve+", "+Me+", "+we+`, b, row, col);
      return `+ue.texture2D+"("+re+`, uv);
    }
  `}function Dv(Z,I){const V=Z.shapeInfo.logicalShape,re=Z.name,ae="get"+re.charAt(0).toUpperCase()+re.slice(1),le=V[1]*V[2],he=V[2],{newShape:ue,keptDims:pe}=L(V),ve=ue;if(ve.length<V.length){const ze=DU(Z,ve),He=["row","col","depth"];return`
        `+DN(ze,I)+`
        float `+ae+`(int row, int col, int depth) {
          return `+ae+"("+DG(He,pe)+`);
        }
      `}if(Z.shapeInfo.isUniform)return`
      float `+ae+`(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(`+le+", "+he+`, 1)));
        `+DL(Z)+`
      }
    `;const we=Z.shapeInfo.texShape,Me=we[0],Le=we[1],Ue=Z.shapeInfo.flatOffset;if(Le===le&&Ue==null)return I?`
      float `+ae+`(int row, int col, int depth) {
        int stride1 = `+re+`Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+re+"TexShape[1], "+re+`TexShape[0]);
        return sampleTexture(`+re+`, uv);
      }
    `:`
        float `+ae+`(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(`+he+`, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(`+Le+".0, "+Me+`.0);
          return sampleTexture(`+re+`, uv);
        }
      `;if(Le===he&&Ue==null)return I?`
      float `+ae+`(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(`+re+`Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+re+"TexShape[1], "+re+`TexShape[0]);
        return sampleTexture(`+re+`, uv);
      }
    `:`
    float `+ae+`(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(`+V[1]+`, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+Le+".0, "+Me+`.0);
      return sampleTexture(`+re+`, uv);
    }
  `;const Ge=Dp(re);return I?`
    float `+ae+`(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = `+re+"Shape[1] * "+re+`Shape[2];
      int stride1 = `+re+`Shape[2];
      int index = row * stride0 + col * stride1 + depth + `+Ge+`;
      vec2 uv = uvFromFlat(`+re+"TexShape[0], "+re+`TexShape[1], index);
      return sampleTexture(`+re+`, uv);
    }
    `:`
      float `+ae+`(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+le+" + col * "+he+" + depth + "+Ge+`;
        vec2 uv = uvFromFlat(`+Me+", "+Le+`, index);
        return sampleTexture(`+re+`, uv);
      }
  `}function Dq(Z,I){const V=Z.name,re="get"+V.charAt(0).toUpperCase()+V.slice(1),ae=D2();if(I)return`
    vec4 `+re+`(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(`+V+`Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+V+`Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= `+V+`Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(`+V+"TexShape[0]) / 2.0), ceil(float("+V+`TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return `+ae.texture2D+"("+V+`, uv);
    }
  `;const le=Z.shapeInfo.logicalShape,he=le.length,ue=Z.shapeInfo.texShape,pe=[Math.ceil(ue[0]/2),Math.ceil(ue[1]/2)],ve=pe[0],we=pe[1],Me=Math.ceil(le[he-1]/2);let Le=Me*Math.ceil(le[he-2]/2),Ue="int b, int row, int col",Ge="b * "+Le+" + (row / 2) * "+Me+" + (col / 2)";for(let ze=2;ze<he-1;ze++)Ue="int b"+ze+", "+Ue,Le*=le[he-ze-1],Ge="b"+ze+" * "+Le+" + "+Ge;return`
    vec4 `+re+"("+Ue+`) {
      int index = `+Ge+`;
      int texR = index / `+we+`;
      int texC = index - texR * `+we+`;
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+we+", "+ve+`);
      return `+ae.texture2D+"("+V+`, uv);
    }
  `}function Dl(Z,I){const V=Z.shapeInfo.logicalShape,re=Z.name,ae="get"+re.charAt(0).toUpperCase()+re.slice(1),le=V[3],he=V[2]*le,ue=V[1]*he,{newShape:pe,keptDims:ve}=L(V);if(pe.length<V.length){const Ye=DU(Z,pe),$e=["row","col","depth","depth2"];return`
      `+DN(Ye,I)+`
      float `+ae+`(int row, int col, int depth, int depth2) {
        return `+ae+"("+DG($e,ve)+`);
      }
    `}if(Z.shapeInfo.isUniform)return`
      float `+ae+`(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(`+ue+", "+he+", "+le+`, 1)));
        `+DL(Z)+`
      }
    `;const we=Z.shapeInfo.flatOffset,Me=Z.shapeInfo.texShape,Le=Me[0],Ue=Me[1],Ge="int stride2 = "+re+"Shape[3];",ze="int stride1 = "+re+"Shape[2] * stride2;",He="int stride0 = "+re+"Shape[1] * stride1;";if(Ue===ue&&we==null)return I?`
      float `+ae+`(int row, int col, int depth, int depth2) {
        `+Ge+`
        `+ze+`
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+re+"TexShape[1], "+re+`TexShape[0]);
        return sampleTexture(`+re+`, uv);
      }
    `:`
      float `+ae+`(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(`+he+", "+le+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+Ue+".0, "+Le+`.0);
        return sampleTexture(`+re+`, uv);
      }
    `;if(Ue===le&&we==null)return I?`
      float `+ae+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+re+"Shape[1] * "+re+"Shape[2], "+re+`Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+re+"TexShape[1], "+re+`TexShape[0]);
        return sampleTexture(`+re+`, uv);
      }
    `:`
      float `+ae+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+V[1]*V[2]+", "+V[2]+`, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+Ue+".0, "+Le+`.0);
        return sampleTexture(`+re+`, uv);
      }
    `;const Ke=Dp(re);return I?`
    float `+ae+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      `+Ge+`
      `+ze+`
      `+He+`
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(`+re+"TexShape[0], "+re+"TexShape[1], index + "+Ke+`);
      return sampleTexture(`+re+`, uv);
    }
  `:`
    float `+ae+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+ue+" + col * "+he+` +
          depth * `+le+` + depth2;
      vec2 uv = uvFromFlat(`+Le+", "+Ue+", index + "+Ke+`);
      return sampleTexture(`+re+`, uv);
    }
  `}function Da(Z){const I=Z.shapeInfo.logicalShape,V=Z.name,re="get"+V.charAt(0).toUpperCase()+V.slice(1),ae=I[4],le=I[3]*ae,he=I[2]*le,ue=I[1]*he,{newShape:pe,keptDims:ve}=L(I);if(pe.length<I.length){const ze=DU(Z,pe),He=["row","col","depth","depth2","depth3"];return`
      `+DN(ze)+`
      float `+re+`(int row, int col, int depth, int depth2, int depth3) {
        return `+re+"("+DG(He,ve)+`);
      }
    `}if(Z.shapeInfo.isUniform)return`
      float `+re+`(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(`+ue+", "+he+", "+le+", "+ae+`)) +
          depth3;
        `+DL(Z)+`
      }
    `;const we=Z.shapeInfo.flatOffset,Me=Z.shapeInfo.texShape,Le=Me[0],Ue=Me[1];if(Ue===ue&&we==null)return`
      float `+re+`(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(`+he+", "+le+", "+ae+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+Ue+".0, "+Le+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `;if(Ue===ae&&we==null)return`
      float `+re+`(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(`+I[1]*I[2]*I[3]+`,
               `+I[2]*I[3]+", "+I[3]+`, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+Ue+".0, "+Le+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `;const Ge=Dp(V);return`
    float `+re+`(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+ue+" + col * "+he+" + depth * "+le+` +
          depth2 * `+ae+" + depth3 + "+Ge+`;
      vec2 uv = uvFromFlat(`+Le+", "+Ue+`, index);
      return sampleTexture(`+V+`, uv);
    }
  `}function Dn(Z){const I=Z.shapeInfo.logicalShape,V=Z.name,re="get"+V.charAt(0).toUpperCase()+V.slice(1),{newShape:ae,keptDims:le}=L(I);if(ae.length<I.length){const He=DU(Z,ae),Ke=["row","col","depth","depth2","depth3","depth4"];return`
      `+DN(He)+`
      float `+re+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return `+re+"("+DG(Ke,le)+`);
      }
    `}const he=I[5],ue=I[4]*he,pe=I[3]*ue,ve=I[2]*pe,we=I[1]*ve;if(Z.shapeInfo.isUniform)return`
      float `+re+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(`+we+", "+ve+", "+pe+", "+ue+`)) +
          dot(
            vec2(depth3, depth4),
            vec2(`+he+`, 1)));
        `+DL(Z)+`
      }
    `;const Me=Z.shapeInfo.flatOffset,Le=Z.shapeInfo.texShape,Ue=Le[0],Ge=Le[1];if(Ge===we&&Me==null)return`
      float `+re+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(`+ve+", "+pe+", "+ue+", "+he+`)) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+Ge+".0, "+Ue+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `;if(Ge===he&&Me==null)return`
      float `+re+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(`+I[1]*I[2]*I[3]*I[4]+`,
               `+I[2]*I[3]*I[4]+`,
               `+I[3]*I[4]+`,
               `+I[4]+`)) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+Ge+".0, "+Ue+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `;const ze=Dp(V);return`
    float `+re+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+we+" + col * "+ve+" + depth * "+pe+` +
          depth2 * `+ue+" + depth3 * "+he+" + depth4 + "+ze+`;
      vec2 uv = uvFromFlat(`+Ue+", "+Ge+`, index);
      return sampleTexture(`+V+`, uv);
    }
  `}function DL(Z){const I=Z.name,V=F(Z.shapeInfo.logicalShape);return V<2?"return "+I+";":`
    for (int i = 0; i < `+V+`; i++) {
      if (i == index) {
        return `+I+`[i];
      }
    }
  `}function DH(Z,I){const V=Z.name,re=V.charAt(0).toUpperCase()+V.slice(1),ae="get"+re+"AtOutCoords",le=Z.shapeInfo.logicalShape.length,he=I.logicalShape.length,ue=DC(Z.shapeInfo.logicalShape,I.logicalShape),pe=Dz(he),ve=he-le;let we;const Me=["x","y","z","w","u","v"];le===0?we="":he<2&&ue.length>=1?we="coords = 0;":we=ue.map(He=>"coords."+Me[He+ve]+" = 0;").join(`
`);let Le="";he<2&&le>0?Le="coords":Le=Z.shapeInfo.logicalShape.map((He,Ke)=>"coords."+Me[Ke+ve]).join(", ");let Ue="return outputValue;";const Ge=F(Z.shapeInfo.logicalShape)===1,ze=F(I.logicalShape)===1;if(le===1&&!Ge&&!ze)Ue=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(Ge&&!ze)he===1?Ue=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:Ue=`
        return vec4(outputValue.x);
      `;else if(ue.length){const He=le-2,Ke=le-1;ue.indexOf(He)>-1&&ue.indexOf(Ke)>-1?Ue="return vec4(outputValue.x);":ue.indexOf(He)>-1?Ue="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":ue.indexOf(Ke)>-1&&(Ue="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 `+ae+`() {
      `+pe+` coords = getOutputCoords();
      `+we+`
      vec4 outputValue = get`+re+"("+Le+`);
      `+Ue+`
    }
  `}function Dk(Z,I){const V=Z.name,re=V.charAt(0).toUpperCase()+V.slice(1),ae="get"+re+"AtOutCoords",le=I.texShape,he=Z.shapeInfo.texShape,ue=Z.shapeInfo.logicalShape.length,pe=I.logicalShape.length;if(!Z.shapeInfo.isUniform&&ue===pe&&Z.shapeInfo.flatOffset==null&&X(he,le))return`
      float `+ae+`() {
        return sampleTexture(`+V+`, resultUV);
      }
    `;const ve=Dz(pe),we=DC(Z.shapeInfo.logicalShape,I.logicalShape),Me=pe-ue;let Le;const Ue=["x","y","z","w","u","v"];ue===0?Le="":pe<2&&we.length>=1?Le="coords = 0;":Le=we.map(ze=>"coords."+Ue[ze+Me]+" = 0;").join(`
`);let Ge="";return pe<2&&ue>0?Ge="coords":Ge=Z.shapeInfo.logicalShape.map((ze,He)=>"coords."+Ue[He+Me]).join(", "),`
    float `+ae+`() {
      `+ve+` coords = getOutputCoords();
      `+Le+`
      return get`+re+"("+Ge+`);
    }
  `}function Dz(Z){if(Z<=1)return"int";if(Z===2)return"ivec2";if(Z===3)return"ivec3";if(Z===4)return"ivec4";if(Z===5)return"ivec5";if(Z===6)return"ivec6";throw Error("GPU for rank "+Z+" is not yet supported")}function Dx(Z,I,V){const{newShape:re,keptDims:ae}=L(I),le=I.length,he=Z&&le===3&&I[0]===1,ue=he?I.slice(1):re,pe=!Z&&le>1&&!X(I,V)&&re.length<le||he;return{useSqueezeShape:pe,uniformShape:pe?ue:I,keptDims:ae}}function DU(Z,I){const V=JSON.parse(JSON.stringify(Z));return V.shapeInfo.logicalShape=I,V}function DG(Z,I){return I.map(V=>Z[V]).join(", ")}function Du(Z,I,V,re){const ae=V.map((we,Me)=>{const Le={logicalShape:we.shape,texShape:we.isUniform?null:we.texData.texShape,isUniform:we.isUniform,isPacked:we.isUniform?!1:we.texData.isPacked,flatOffset:null};return we.texData!=null&&we.texData.slice!=null&&we.texData.slice.flatOffset>0&&(Le.flatOffset=we.texData.slice.flatOffset),{name:I.variableNames[Me],shapeInfo:Le}}),le=ae.map(we=>we.shapeInfo),he={logicalShape:re.shape,texShape:re.texData.texShape,isUniform:!1,isPacked:re.texData.isPacked,flatOffset:null},ue=Dm(ae,he,I),pe=Eb(Z.gl,ue),ve=Z.createProgram(pe);return Cd().get("ENGINE_COMPILE_ONLY")?{program:I,fragmentShader:pe,source:ue,webGLProgram:ve,inShapeInfos:le,outShapeInfo:he,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(Z.buildVao(ve),Object.assign({program:I,fragmentShader:pe,source:ue,webGLProgram:ve,inShapeInfos:le,outShapeInfo:he},DY(Z,I,ve)))}function DY(Z,I,V){const re=[],ae=[];let le,he,ue,pe=null,ve=null;ve=Z.getUniformLocation(V,"NAN",!1),Cd().getNumber("WEBGL_VERSION")===1&&(pe=Z.getUniformLocation(V,"INFINITY",!1));const we=!1;for(const Me of I.variableNames){const Le={name:Me,uniform:Z.getUniformLocation(V,Me,we),offset:Z.getUniformLocation(V,"offset"+Me,we)};I.enableShapeUniforms&&(Le.shape=Z.getUniformLocation(V,Me+"Shape",we),Le.texShape=Z.getUniformLocation(V,Me+"TexShape",we)),re.push(Le)}if(I.enableShapeUniforms&&(le=Z.getUniformLocation(V,"outShape",we),ue=Z.getUniformLocation(V,"outShapeStrides",we),he=Z.getUniformLocation(V,"outTexShape",we)),I.customUniforms)for(const Me of I.customUniforms)ae.push(Z.getUniformLocation(V,Me.name,we));return{variablesLocations:re,customUniformLocations:ae,infLoc:pe,nanLoc:ve,outShapeLocation:le,outShapeStridesLocation:ue,outTexShapeLocation:he}}function DM(Z,I){if(Z.length!==I.length)throw Error("Binary was compiled with "+Z.length+" inputs, but was executed with "+I.length+" inputs");Z.forEach((V,re)=>{const ae=V.logicalShape,le=I[re],he=le.shape;if(!X(ae,he))throw Error("Binary was compiled with different shapes than the current args. Shapes "+ae+" and "+he+" must match");if(V.isUniform&&le.isUniform)return;const ue=V.texShape,pe=le.isUniform?null:le.texData.texShape;if(!X(ue,pe))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+ue+" and "+pe+" must match")})}function Dh(Z,I,V,re,ae){I.program.enableShapeUniforms||(DM(I.inShapeInfos,V),DM([I.outShapeInfo],[re]));const le=re.texData.texture,he=re.texData.texShape;re.texData.isPacked?Z.setOutputPackedMatrixTexture(le.texture,he[0],he[1]):Z.setOutputMatrixTexture(le.texture,he[0],he[1]),Z.setProgram(I.webGLProgram),Z.bindVertexArray(I.webGLProgram.vao),Cd().getNumber("WEBGL_VERSION")===1&&I.infLoc!==null&&Z.gl.uniform1f(I.infLoc,1/0),I.nanLoc!==null&&Z.gl.uniform1f(I.nanLoc,NaN);for(let pe=0;pe<V.length;++pe){const ve=V[pe],{uniform:we,offset:Me,shape:Le,texShape:Ue}=I.variablesLocations[pe];if(Le){const{uniformShape:Ge}=Dx(I.program.packedInputs,ve.shape,ve.texData.texShape);switch(Ge.length){case 1:Z.gl.uniform1iv(Le,new Int32Array(Ge));break;case 2:Z.gl.uniform2iv(Le,new Int32Array(Ge));break;case 3:Z.gl.uniform3iv(Le,new Int32Array(Ge));break;case 4:Z.gl.uniform4iv(Le,new Int32Array(Ge));break}}if(Ue&&Z.gl.uniform2i(Ue,ve.texData.texShape[0],ve.texData.texShape[1]),we!=null){if(ve.isUniform){if(F(ve.shape)<2)Z.gl.uniform1f(we,ve.uniformValues[0]);else{let Ge=ve.uniformValues;Ge instanceof Float32Array||(Ge=new Float32Array(Ge)),Z.gl.uniform1fv(we,Ge)}continue}ve.texData.slice!=null&&Me!=null&&Z.gl.uniform1i(Me,ve.texData.slice.flatOffset),Z.setInputMatrixTexture(ve.texData.texture.texture,we,pe)}}const ue=I.outShapeLocation;if(ue)switch(re.shape.length){case 1:Z.gl.uniform1iv(ue,new Int32Array(re.shape));break;case 2:Z.gl.uniform2iv(ue,new Int32Array(re.shape));break;case 3:Z.gl.uniform3iv(ue,new Int32Array(re.shape));break;case 4:Z.gl.uniform4iv(ue,new Int32Array(re.shape));break}if(I.outShapeStridesLocation){const pe=C5(re.shape);switch(re.shape.length){case 2:Z.gl.uniform1iv(I.outShapeStridesLocation,new Int32Array(pe));break;case 3:Z.gl.uniform2iv(I.outShapeStridesLocation,new Int32Array(pe));break;case 4:Z.gl.uniform3iv(I.outShapeStridesLocation,new Int32Array(pe));break}}if(I.outTexShapeLocation&&Z.gl.uniform2i(I.outTexShapeLocation,re.texData.texShape[0],re.texData.texShape[1]),I.program.customUniforms&&ae)for(let pe=0;pe<I.program.customUniforms.length;++pe){const ve=I.program.customUniforms[pe],we=I.customUniformLocations[pe],Me=ae[pe];if(ve.type==="float")Z.gl.uniform1fv(we,Me);else if(ve.type==="vec2")Z.gl.uniform2fv(we,Me);else if(ve.type==="vec3")Z.gl.uniform3fv(we,Me);else if(ve.type==="vec4")Z.gl.uniform4fv(we,Me);else if(ve.type==="int")Z.gl.uniform1iv(we,Me);else if(ve.type==="ivec2")Z.gl.uniform2iv(we,Me);else if(ve.type==="ivec3")Z.gl.uniform3iv(we,Me);else if(ve.type==="ivec4")Z.gl.uniform4iv(we,Me);else throw Error("uniform type "+ve.type+" is not supported yet.")}Z.executeProgram()}function Dj(Z,I,V){let re="";I.concat(V).forEach(he=>{const ue=he.texData!=null&&he.texData.slice!=null&&he.texData.slice.flatOffset>0;if(Z.enableShapeUniforms&&!he.isUniform){const pe=he.texData.texShape,{useSqueezeShape:ve,uniformShape:we,keptDims:Me}=Dx(Z.packedInputs,he.shape,pe);let Le="",Ue="",Ge="";if(we.length===1&&Z.packedInputs){const rt=[Math.ceil(pe[0]/2),Math.ceil(pe[1]/2)];Le=(rt[0]>1)+"_"+(rt[1]>1)}else if(we.length===2&&!Z.packedInputs)Ue=(we[0]>1)+"_"+(we[1]>1);else if(we.length>2&&!Z.packedInputs){const rt=C5(we);Ge=(rt[0]===pe[1])+"_"+(rt[rt.length-1]===pe[1])}const ze=he.shape.length,He=we.length===2&&X(he.shape,pe),Ke=F(he.shape)===1,Ye=ia(he.shape,V.shape),$e=!Z.packedInputs&&ze===V.shape.length&&X(pe,V.texData.texShape),je=Z.packedInputs||we.length>2?"":(pe[0]>1)+"_"+(pe[1]>1);re+=ze+"_"+$e+"_"+(ve?Me:"")+"_"+we.length+"_"+Ke+"_"+Ye+"_"+He+"_"+Le+"_"+Ue+"_"+Ge+"_"+je+"_"+ue}else{const pe=he.isUniform?"uniform":he.texData.texShape;re+=he.shape+"_"+pe+"_"+ue}});const ae=Z.userCode;let le=Z.constructor.name;return le+="_"+re+"_"+ae+(""+Cd().getNumber("WEBGL_VERSION")),le}function Dr(Z){return Cd().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&Z<=4}class g0{constructor(I){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=E5.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const V=D2();this.outputShape=I,this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?D4(["r","c","d"],I):D3(["r","c","d"],I))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        `+V.output+` = result;
      }
    `}}class g1{constructor(I){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=E5.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const V=D2();this.outputShape=I,this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?D4(["r","c","d"],I):D3(["r","c","d"],I))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        `+V.output+` = result;
      }
    `}}class g2{constructor(I){this.variableNames=["A"],this.outTexUsage=E6.DOWNLOAD;const V=D2();this.outputShape=I,this.userCode=`
      `+D9+`

      void main() {
        float x = getAAtOutCoords();
        `+V.output+` = encode_float(x);
      }
    `}}class g3{constructor(I){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=E6.DOWNLOAD;const V=D2();this.outputShape=I,this.userCode=`
      `+D9+`

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        `+V.output+` = encode_float(x);
      }
    `}}const g4={R:0,G:1,B:2,A:3};class g5{constructor(I,V=!1,re="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const ae=D2();this.outputShape=I,this.enableShapeUniforms=Dr(this.outputShape.length);let le="result";V&&(le="floor(result * 255. + 0.5)");let he="";for(let ue=0;ue<re.length;ue++){const pe=re[ue];he+=`
          if(offset == `+ue+`) {
            result = values[`+g4[pe]+`];
          }`}this.userCode=`
      `+(this.enableShapeUniforms?D8():D7(I))+`

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, `+re.length+`);

        flatIndex = idiv(flatIndex, `+re.length+`, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = `+ae.texture2D+`(A, uv);
          `+he+`
        }
        `+ae.output+" = vec4("+le+`, 0., 0., 0.);
      }
    `}}class g6{constructor(I,V=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const re=D2();this.outputShape=I,this.enableShapeUniforms=Dr(this.outputShape.length);let ae="",le="result";V&&(le="floor(result * 255. + 0.5)");for(let he=0;he<=1;he++)for(let ue=0;ue<=1;ue++){const pe=he*2+ue;ae+=`
          localCoords = coords;
          if(localCoords[2] + `+ue+" < "+(this.enableShapeUniforms?"outShape[2]":""+I[2])+`) {
          localCoords[2] += `+ue+`;
          if (localCoords[1] + `+he+" < "+(this.enableShapeUniforms?"outShape[1]":""+I[1])+`) {
            localCoords[1] += `+he+`;

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = `+re.texture2D+`(A, uv);

            if (offset == 0) {
              result[`+pe+`] = values[0];
            } else if (offset == 1) {
              result[`+pe+`] = values[1];
            } else if (offset == 2) {
              result[`+pe+`] = values[2];
            } else {
              result[`+pe+`] = values[3];
            }
          }
        }
        `}this.userCode=`
        `+(this.enableShapeUniforms?D8():D7(I))+`

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          `+ae+`

          `+re.output+" = "+le+`;
        }
    `}}function g7(Z){const I=D2(),V=I.version+`
    precision highp float;
    `+I.attribute+` vec3 clipSpacePos;
    `+I.attribute+` vec2 uv;
    `+I.varyingVs+` vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return EV(Z,V)}function g8(Z){const I=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Eo(Z,I)}function g9(Z){const I=new Uint16Array([0,1,2,2,1,3]);return Ee(Z,I)}function gC(Z,I,V,re,ae,le){Es(I,V);const he=EQ(Z),ue=Z.TEXTURE_2D;return Ef(Z,()=>Z.bindTexture(ue,he)),Ef(Z,()=>Z.texParameteri(ue,Z.TEXTURE_WRAP_S,Z.CLAMP_TO_EDGE)),Ef(Z,()=>Z.texParameteri(ue,Z.TEXTURE_WRAP_T,Z.CLAMP_TO_EDGE)),Ef(Z,()=>Z.texParameteri(ue,Z.TEXTURE_MIN_FILTER,Z.NEAREST)),Ef(Z,()=>Z.texParameteri(ue,Z.TEXTURE_MAG_FILTER,Z.NEAREST)),Cd().getNumber("WEBGL_VERSION")===1?Ef(Z,()=>Z.texImage2D(ue,0,re,I,V,0,ae,le,null)):Ef(Z,()=>Z.texStorage2D(ue,1,re,I,V)),Ef(Z,()=>Z.bindTexture(Z.TEXTURE_2D,null)),{texture:he,texShape:[V,I]}}function gm(Z){return Z.internalFormatFloat}function gN(Z,I,V,re){const[ae,le]=E8(I,V);return gC(Z,ae,le,gm(re),re.textureFormatFloat,Z.FLOAT)}function gJ(Z){return Z.internalFormatHalfFloat}function gf(Z,I,V,re){const[ae,le]=E8(I,V);return gC(Z,ae,le,gJ(re),re.textureFormatFloat,re.textureTypeHalfFloat)}function gi(Z){return Z.downloadTextureFormat}function gO(Z,I,V,re){const[ae,le]=E8(I,V);return gC(Z,ae,le,gi(re),Z.RGBA,Z.UNSIGNED_BYTE)}function gt(Z){return Z.internalFormatPackedFloat}function gB(Z,I,V,re){const[ae,le]=Em(I,V);return gC(Z,ae,le,gt(re),Z.RGBA,Z.FLOAT)}function gS(Z){return Z.internalFormatPackedHalfFloat}function gd(Z,I,V,re){const[ae,le]=Em(I,V);return gC(Z,ae,le,gS(re),Z.RGBA,re.textureTypeHalfFloat)}function gV(Z,I,V){return Ef(Z,()=>Z.bindBuffer(Z.ARRAY_BUFFER,V)),EI(Z,I,"clipSpacePos",V,3,20,0)&&EI(Z,I,"uv",V,2,20,12)}function gb(Z,I,V,re,ae,le){Ef(Z,()=>Z.bindTexture(Z.TEXTURE_2D,I));let he,ue,pe;ae instanceof Uint8Array?(he=new Uint8Array(V*re*4),ue=Z.UNSIGNED_BYTE,pe=Z.RGBA):(he=new Float32Array(V*re*4),ue=Z.FLOAT,pe=le.internalFormatPackedFloat),he.set(ae),Cd().getNumber("WEBGL_VERSION")===2?Ef(Z,()=>Z.texSubImage2D(Z.TEXTURE_2D,0,0,0,V,re,Z.RGBA,ue,he)):Ef(Z,()=>Z.texImage2D(Z.TEXTURE_2D,0,pe,V,re,0,Z.RGBA,ue,he)),Ef(Z,()=>Z.bindTexture(Z.TEXTURE_2D,null))}function gP(Z,I,V){Ef(Z,()=>Z.bindTexture(Z.TEXTURE_2D,I)),V.data instanceof Uint8Array?Cd().getNumber("WEBGL_VERSION")===2?Ef(Z,()=>Z.texSubImage2D(Z.TEXTURE_2D,0,0,0,V.width,V.height,Z.RGBA,Z.UNSIGNED_BYTE,V.data)):Ef(Z,()=>Z.texImage2D(Z.TEXTURE_2D,0,Z.RGBA,V.width,V.height,0,Z.RGBA,Z.UNSIGNED_BYTE,V.data)):Cd().getNumber("WEBGL_VERSION")===2?Ef(Z,()=>Z.texSubImage2D(Z.TEXTURE_2D,0,0,0,Z.RGBA,Z.UNSIGNED_BYTE,V)):Ef(Z,()=>Z.texImage2D(Z.TEXTURE_2D,0,Z.RGBA,Z.RGBA,Z.UNSIGNED_BYTE,V)),Ef(Z,()=>Z.bindTexture(Z.TEXTURE_2D,null))}function gE(Z,I,V,re){const ae=Z.createBuffer();Ef(Z,()=>Z.bindBuffer(Z.PIXEL_PACK_BUFFER,ae));const le=4*4*I*V;return Ef(Z,()=>Z.bufferData(Z.PIXEL_PACK_BUFFER,le,Z.STREAM_READ)),Ef(Z,()=>Z.readPixels(0,0,V,I,Z.RGBA,Z.FLOAT,0)),Ef(Z,()=>Z.bindBuffer(Z.PIXEL_PACK_BUFFER,null)),ae}function gD(Z,I,V){const re=Z,ae=new Float32Array(V);return re.bindBuffer(re.PIXEL_PACK_BUFFER,I),re.getBufferSubData(re.PIXEL_PACK_BUFFER,0,ae),re.bindBuffer(re.PIXEL_PACK_BUFFER,null),ae}function gg(Z,I,V,re){const[ae,le]=E8(I,V),he=4,ue=new Uint8Array(E9(I*V,he));return Ef(Z,()=>Z.readPixels(0,0,ae,le,re.downloadTextureFormat,Z.UNSIGNED_BYTE,ue)),new Float32Array(ue.buffer)}function gZ(Z,I,V,re,ae,le,he,ue){const pe=Z,ve=new Float32Array(EN(le,he));return pe.bindBuffer(pe.PIXEL_PACK_BUFFER,I),pe.getBufferSubData(pe.PIXEL_PACK_BUFFER,0,ve),pe.bindBuffer(pe.PIXEL_PACK_BUFFER,null),ve}function go(Z,I,V){const re=new Float32Array(I*V*4);return Ef(Z,()=>Z.readPixels(0,0,V,I,Z.RGBA,Z.FLOAT,re)),re}class ge{constructor(I){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const V=Cd().getNumber("WEBGL_VERSION");if(I!=null?(this.gl=I,E1(V,I)):this.gl=E2(V),I=this.gl,Cd().getNumber("WEBGL_VERSION")===2){const le=I;this.createVertexArray=()=>Ef(le,()=>le.createVertexArray()),this.bindVertexArray=he=>Ef(le,()=>le.bindVertexArray(he)),this.deleteVertexArray=he=>Ef(le,()=>le.deleteVertexArray(he)),this.getVertexArray=()=>Ef(le,()=>le.getParameter(le.VERTEX_ARRAY_BINDING))}else if(I!=null){const le=I.getExtension("OES_vertex_array_object");if(le==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ef(I,()=>le.createVertexArrayOES()),this.bindVertexArray=he=>Ef(I,()=>le.bindVertexArrayOES(he)),this.deleteVertexArray=he=>Ef(I,()=>le.deleteVertexArrayOES(he)),this.getVertexArray=()=>Ef(I,()=>I.getParameter(le.VERTEX_ARRAY_BINDING_OES))}let re="WEBGL_color_buffer_float";const ae="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Cd().getNumber("WEBGL_VERSION")===1){const le="OES_texture_float",he="OES_texture_half_float";if(this.textureFloatExtension=Ed(this.gl,le),EG(this.gl,he))this.textureHalfFloatExtension=Ed(this.gl,he);else if(Cd().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(re),EG(this.gl,ae))this.colorBufferHalfFloatExtension=Ed(this.gl,ae);else if(Cd().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(re="EXT_color_buffer_float",EG(this.gl,re))this.colorBufferFloatExtension=this.gl.getExtension(re);else if(EG(this.gl,ae))this.colorBufferHalfFloatExtension=this.gl.getExtension(ae);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=g8(this.gl),this.indexBuffer=g9(this.gl),this.framebuffer=EF(this.gl),this.textureConfig=EJ(this.gl,this.textureHalfFloatExtension)}get debug(){return Cd().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const I=this.gl;Ef(I,()=>I.finish()),Ef(I,()=>I.bindFramebuffer(I.FRAMEBUFFER,null)),Ef(I,()=>I.deleteFramebuffer(this.framebuffer)),Ef(I,()=>I.bindBuffer(I.ARRAY_BUFFER,null)),Ef(I,()=>I.bindBuffer(I.ELEMENT_ARRAY_BUFFER,null)),Ef(I,()=>I.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(I,V){return this.throwIfDisposed(),gN(this.gl,I,V,this.textureConfig)}createFloat16MatrixTexture(I,V){return this.throwIfDisposed(),gf(this.gl,I,V,this.textureConfig)}createUnsignedBytesMatrixTexture(I,V){return this.throwIfDisposed(),gO(this.gl,I,V,this.textureConfig)}uploadPixelDataToTexture(I,V){this.throwIfDisposed(),gP(this.gl,I,V)}uploadDenseMatrixToTexture(I,V,re,ae){this.throwIfDisposed(),gb(this.gl,I,V,re,ae,this.textureConfig)}createFloat16PackedMatrixTexture(I,V){return this.throwIfDisposed(),gd(this.gl,I,V,this.textureConfig)}createPackedMatrixTexture(I,V){return this.throwIfDisposed(),gB(this.gl,I,V,this.textureConfig)}deleteMatrixTexture(I){this.throwIfDisposed(),this.outputTexture===I&&(Ec(this.gl,this.framebuffer),this.outputTexture=null),Ef(this.gl,()=>this.gl.deleteTexture(I))}downloadByteEncodedFloatMatrixFromOutputTexture(I,V,re){return this.downloadMatrixDriver(I,()=>gg(this.gl,V,re,this.textureConfig))}downloadPackedMatrixFromBuffer(I,V,re,ae,le,he){return gZ(this.gl,I,V,re,ae,le,he,this.textureConfig)}downloadFloat32MatrixFromBuffer(I,V){return gD(this.gl,I,V)}createBufferFromTexture(I,V,re){this.bindTextureToFrameBuffer(I);const ae=gE(this.gl,V,re,this.textureConfig);return this.unbindTextureToFrameBuffer(),ae}createAndWaitForFence(){const I=this.createFence(this.gl);return this.pollFence(I)}createFence(I){let V,re;if(Cd().getBool("WEBGL_FENCE_API_ENABLED")){const ae=I,le=ae.fenceSync(ae.SYNC_GPU_COMMANDS_COMPLETE,0);I.flush(),re=()=>{const he=ae.clientWaitSync(le,0,0);return he===ae.ALREADY_SIGNALED||he===ae.CONDITION_SATISFIED},V=le}else Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(V=this.beginQuery(),this.endQuery(),re=()=>this.isQueryAvailable(V,Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):re=()=>!0;return{query:V,isFencePassed:re}}downloadMatrixFromPackedTexture(I,V,re){return this.downloadMatrixDriver(I,()=>go(this.gl,V,re))}createProgram(I){this.throwIfDisposed();const V=this.gl;this.vertexShader==null&&(this.vertexShader=g7(V));const re=ED(V);Ef(V,()=>V.attachShader(re,this.vertexShader)),Ef(V,()=>V.attachShader(re,I)),Eg(V,re);const ae=Object.assign(re,{vao:this.createVertexArray()});return this.debug&&EZ(V,ae),ae}buildVao(I){this.setProgram(I),this.bindVertexArray(I.vao);const V=this.gl;Ef(V,()=>V.bindBuffer(V.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),gV(V,I,this.vertexBuffer)}deleteProgram(I){this.throwIfDisposed(),I===this.program&&(this.program=null),I!=null&&(Ef(this.gl,()=>this.gl.deleteProgram(I)),this.deleteVertexArray(I.vao))}setProgram(I){this.throwIfDisposed(),this.program=I,this.program!=null&&this.debug&&EZ(this.gl,this.program),Ef(this.gl,()=>this.gl.useProgram(I))}getUniformLocation(I,V,re=!0){return this.throwIfDisposed(),re?EA(this.gl,I,V):Ep(this.gl,I,V)}getAttributeLocation(I,V){return this.throwIfDisposed(),Ef(this.gl,()=>this.gl.getAttribLocation(I,V))}getUniformLocationNoThrow(I,V){return this.throwIfDisposed(),this.gl.getUniformLocation(I,V)}setInputMatrixTexture(I,V,re){this.throwIfDisposed(),this.throwIfNoProgram(),Ew(this.gl,I,V,re)}setOutputMatrixTexture(I,V,re){this.setOutputMatrixTextureDriver(I,re,V)}setOutputPackedMatrixTexture(I,V,re){this.throwIfDisposed();const[ae,le]=Em(V,re);this.setOutputMatrixTextureDriver(I,ae,le)}setOutputMatrixWriteRegion(I,V,re,ae){this.setOutputMatrixWriteRegionDriver(re,I,ae,V)}setOutputPackedMatrixWriteRegion(I,V,re,ae){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&EZ(this.gl,this.program),EW(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const I=this.gl;if(this.debug){const V=this.getVertexArray();console.assert(V===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ef(I,()=>I.drawElements(I.TRIANGLES,6,I.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ef(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ed(this.gl,Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const re=this.gl,ae=this.getQueryTimerExtensionWebGL2(),le=re.createQuery();return re.beginQuery(ae.TIME_ELAPSED_EXT,le),le}const I=this.getQueryTimerExtensionWebGL1(),V=I.createQueryEXT();return I.beginQueryEXT(I.TIME_ELAPSED_EXT,V),V}endQuery(){if(Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const V=this.gl,re=this.getQueryTimerExtensionWebGL2();V.endQuery(re.TIME_ELAPSED_EXT);return}const I=this.getQueryTimerExtensionWebGL1();I.endQueryEXT(I.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(I){return await q(()=>this.disposed||this.isQueryAvailable(I,Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(I,Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(I,V){if(V===0)return null;if(V===2){const re=this.gl;return re.getQueryParameter(I,re.QUERY_RESULT)/1e6}else{const re=this.getQueryTimerExtensionWebGL1();return re.getQueryObjectEXT(I,re.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(I,V){if(V===0)return!0;if(V===2){const re=this.gl,ae=this.getQueryTimerExtensionWebGL2(),le=re.getQueryParameter(I,re.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(ae.GPU_DISJOINT_EXT)),le&&!this.disjoint}else{const re=this.getQueryTimerExtensionWebGL1(),ae=re.getQueryObjectEXT(I,re.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(re.GPU_DISJOINT_EXT)),ae&&!this.disjoint}}pollFence(I){return new Promise(V=>{this.addItemToPoll(()=>I.isFencePassed(),()=>V())})}pollItems(){const I=gQ(this.itemsToPoll.map(V=>V.isDoneFn));for(let V=0;V<=I;++V){const{resolveFn:re}=this.itemsToPoll[V];re()}this.itemsToPoll=this.itemsToPoll.slice(I+1)}addItemToPoll(I,V){if(this.itemsToPoll.push({isDoneFn:I,resolveFn:V}),this.itemsToPoll.length>1)return;let re;"setTimeoutCustom"in Cd().platform&&(re=Cd().platform.setTimeoutCustom.bind(Cd().platform)),q(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,re)}bindTextureToFrameBuffer(I){this.throwIfDisposed(),EX(this.gl,I,this.framebuffer),this.debug&&EW(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(EX(this.gl,this.outputTexture,this.framebuffer),this.debug&&EW(this.gl)):Ec(this.gl,this.framebuffer)}downloadMatrixDriver(I,V){this.bindTextureToFrameBuffer(I);const re=V();return this.unbindTextureToFrameBuffer(),re}setOutputMatrixTextureDriver(I,V,re){this.throwIfDisposed();const ae=this.gl;EX(ae,I,this.framebuffer),this.debug&&EW(ae),this.outputTexture=I,Ef(ae,()=>ae.viewport(0,0,V,re)),Ef(ae,()=>ae.scissor(0,0,V,re))}setOutputMatrixWriteRegionDriver(I,V,re,ae){this.throwIfDisposed(),Ef(this.gl,()=>this.gl.scissor(I,V,re,ae))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function gQ(Z){let I=0;for(;I<Z.length&&Z[I]();++I);return I-1}function gs(Z,I){Array.isArray(Z)||(Z=[Z]),Z.forEach(V=>{V!=null&&e(V.dtype!=="complex64",()=>I+" does not support complex64 tensors in the CPU backend.")})}function gF(Z){const I=new Float32Array(Z.length);for(let V=0;V<Z.length;++V)I[V]=Math.abs(Z[V]);return I}const gI=Z=>{const{x:I}=Z.inputs,V=Z.backend;gs(I,"abs");let re=new Float32Array(F(I.shape));const ae=V.data.get(I.dataId).values;return re=gF(ae),V.makeOutput(re,I.shape,I.dtype)},gy={kernelName:CZ,backendName:"cpu",kernelFunc:gI};function gA(Z){return(I,V,re,ae,le)=>{const he=iH(I,V),ue=he.length,pe=C5(he),ve=F(he),we=H(le,ve),Me=I.length,Le=V.length,Ue=C5(I),Ge=C5(V),ze=ia(I,he),He=ia(V,he);if(ze.length+He.length===0)for(let Ke=0;Ke<we.length;++Ke)we[Ke]=Z(re[Ke%re.length],ae[Ke%ae.length]);else for(let Ke=0;Ke<we.length;++Ke){const Ye=CJ(Ke,ue,pe),$e=Ye.slice(-Me);ze.forEach(Rt=>$e[Rt]=0);const je=CN($e,Me,Ue),rt=Ye.slice(-Le);He.forEach(Rt=>rt[Rt]=0);const at=CN(rt,Le,Ge);we[Ke]=Z(re[je],ae[at])}return[we,he]}}function gp(Z){const{inputs:I,backend:V}=Z,{real:re,imag:ae}=I,le=V.data.get(re.dataId).values,he=V.data.get(ae.dataId).values,ue=V.makeTensorInfo(re.shape,"complex64"),pe=V.data.get(ue.dataId);return pe.complexTensorInfos={real:V.makeTensorInfo(re.shape,"float32",le),imag:V.makeTensorInfo(ae.shape,"float32",he)},ue}function gw(Z,I,V="float32"){if(V==="complex64"){const ae=gw(Z,I,"float32"),le=gw(Z,I,"float32");return gp({inputs:{real:ae,imag:le},backend:Z})}const re=CC(F(I),V);return Z.makeTensorInfo(I,V,re)}function gX(Z){const{inputs:I,backend:V}=Z,{x:re}=I;return V.incRef(re.dataId),{dataId:re.dataId,shape:re.shape,dtype:re.dtype}}const gc={kernelName:Cj,backendName:"cpu",kernelFunc:gX};function gW(Z){const{inputs:I,backend:V}=Z,{input:re}=I,ae=V.data.get(re.dataId).complexTensorInfos.real,le=V.data.get(ae.dataId).values;return V.makeTensorInfo(ae.shape,ae.dtype,le)}function gR(Z,I,V,re){if(re==="int32"){const ae=Int32Array.from(Z);return[I,"int32",ae]}if(re==="bool"){const ae=NH([0],V),[le,he]=gA((ue,pe)=>ue!==pe?1:0)(I,[],Z,ae,"bool");return[he,"bool",le]}throw new Error("Error in Cast: failed to cast "+V+" to "+re)}function gK(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{dtype:le}=re;if(le==="complex64"){if(ae.dtype==="complex64")return gX({inputs:{x:ae},backend:V});const we=gw(V,ae.shape,ae.dtype),Me=gK({inputs:{x:ae},backend:V,attrs:{dtype:"float32"}}),Le=gp({inputs:{real:Me,imag:we},backend:V});return V.disposeIntermediateTensorInfo(we),V.disposeIntermediateTensorInfo(Me),Le}if(ae.dtype==="complex64"){const we=gW({inputs:{input:ae},backend:V}),Me=gK({inputs:{x:we},backend:V,attrs:{dtype:le}});return V.disposeIntermediateTensorInfo(we),Me}if(!Y(ae.dtype,le)){const we=gX({inputs:{x:ae},backend:V});return{dataId:we.dataId,shape:we.shape,dtype:le}}const he=V.data.get(ae.dataId).values,[ue,pe,ve]=gR(he,ae.shape,ae.dtype,le);return V.makeTensorInfo(ue,pe,ve)}const gT={kernelName:CA,backendName:"cpu",kernelFunc:gK};function gv(Z,I,V,re){return V==null?({inputs:ae,backend:le})=>{const{a:he,b:ue}=ae,pe=le;gs([he,ue],Z);const ve=pe.data.get(he.dataId).values,we=pe.data.get(ue.dataId).values,Me=he.dtype==="string"?Ve(ve):ve,Le=he.dtype==="string"?Ve(we):we,Ue=re||he.dtype,[Ge,ze]=I(he.shape,ue.shape,Me,Le,Ue);return pe.makeTensorInfo(ze,Ue,Ge)}:({inputs:ae,backend:le})=>{const{a:he,b:ue}=ae,pe=le;if(he.dtype==="complex64"||ue.dtype==="complex64"){const ve=gK({inputs:{x:he},backend:pe,attrs:{dtype:"complex64"}}),we=pe.data.get(ve.dataId),Me=we.complexTensorInfos.real,Le=we.complexTensorInfos.imag,Ue=pe.data.get(Me.dataId).values,Ge=pe.data.get(Le.dataId).values,ze=gK({inputs:{x:ue},backend:pe,attrs:{dtype:"complex64"}}),He=pe.data.get(ze.dataId),Ke=He.complexTensorInfos.real,Ye=He.complexTensorInfos.imag,$e=pe.data.get(Ke.dataId).values,je=pe.data.get(Ye.dataId).values,[rt,at,Rt]=V(he.shape,ue.shape,Ue,Ge,$e,je),lt=pe.makeTensorInfo(Rt,"float32",rt),kt=pe.makeTensorInfo(Rt,"float32",at),qt=gp({inputs:{real:lt,imag:kt},backend:pe});return pe.disposeIntermediateTensorInfo(ve),pe.disposeIntermediateTensorInfo(ze),pe.disposeIntermediateTensorInfo(lt),pe.disposeIntermediateTensorInfo(kt),qt}else{const ve=pe.data.get(he.dataId).values,we=pe.data.get(ue.dataId).values,Me=re||he.dtype,[Le,Ue]=I(he.shape,ue.shape,ve,we,Me);return pe.makeTensorInfo(Ue,Me,Le)}}}function gq(Z){return(I,V,re,ae,le,he)=>{const ue=iH(I,V),pe=F(ue),ve=ue.length,we=C5(ue),Me=H("float32",pe),Le=H("float32",pe),Ue=ia(I,ue),Ge=ia(V,ue),ze=du(re,ae),He=du(le,he),Ke=I.length,Ye=C5(I),$e=V.length,je=C5(V);if(Ue.length+Ge.length===0)for(let rt=0;rt<Me.length;rt++){const at=rt%ze.length,Rt=rt%He.length,lt=Z(ze[at*2],ze[at*2+1],He[Rt*2],He[Rt*2+1]);Me[rt]=lt.real,Le[rt]=lt.imag}else for(let rt=0;rt<Me.length;rt++){const at=CJ(rt,ve,we),Rt=at.slice(-Ke);Ue.forEach(_i=>Rt[_i]=0);const lt=CN(Rt,Ke,Ye),kt=at.slice(-$e);Ge.forEach(_i=>kt[_i]=0);const qt=CN(kt,$e,je),Kt=Z(ze[lt*2],ze[lt*2+1],He[qt*2],He[qt*2+1]);Me[rt]=Kt.real,Le[rt]=Kt.imag}return[Me,Le,ue]}}const gl=gA((Z,I)=>Z+I),ga=gq((Z,I,V,re)=>({real:Z+V,imag:I+re})),gn=gv(Co,gl,ga),gL={kernelName:Co,backendName:"cpu",kernelFunc:gn};function gH(Z,I,V,re,ae){const le=F(re),he=CC(ae,V);for(let ue=0;ue<Z.length;ue++){const pe=Z[ue];if(pe<0)throw new Error("Input x must be non-negative!");pe>=ae||(le>0?he[pe]+=I[ue]:he[pe]+=1)}return he}function gk(Z,I,V,re=!1){const ae=Z.shape[0],le=Z.shape[1],he=t7([ae,V],I.dtype);for(let ue=0;ue<ae;ue++)for(let pe=0;pe<le;pe++){const ve=Z.get(ue,pe);if(ve<0)throw new Error("Input x must be non-negative!");ve>=V||(re?he.set(1,ue,ve):I.size>0?he.set(he.get(ue,ve)+I.get(ue,pe),ue,ve):he.set(he.get(ue,ve)+1,ue,ve))}return he}const gz=gA((Z,I)=>Z&I);function gx(Z){return(I,V,re)=>{const ae=x(V,I.length);for(let le=0;le<I.length;++le)ae[le]=Z(I[le],re);return ae}}function gU(Z,I,V){const re=gx(I);return gG(Z,re,V)}function gG(Z,I,V){return({inputs:re,attrs:ae,backend:le})=>{const{x:he}=re;gs(he,Z);const ue=le,pe=ue.data.get(he.dataId).values;let ve;if(he.dtype==="string"){if(!Array.isArray(pe))throw new Error("String tensor's value was not an instance of Array");ve=Ve(pe)}else ve=pe;const we=V||he.dtype,Me=I(ve,we,ae);return ue.makeTensorInfo(he.shape,we,Me)}}const gu=gx(Z=>Math.ceil(Z));function gY(Z,I,V,re){const ae=x(V,F(I));if(re&&V!=="string"){let le=0;Z.forEach(he=>{const ue=F(he.shape);ae.set(he.vals,le),le+=ue})}else{let le=0;Z.forEach(he=>{const ue=V==="string"?Ve(he.vals):he.vals;let pe=0;for(let ve=0;ve<he.shape[0];++ve){const we=ve*I[1]+le;for(let Me=0;Me<he.shape[1];++Me)ae[we+Me]=ue[pe++]}le+=he.shape[1]})}return ae}const gM=gA((Z,I)=>Z===I?1:0),gh=gx(Z=>Math.exp(Z)),gj=gx(Z=>Math.expm1(Z)),gr=gx(Z=>Math.floor(Z)),Z0=gG(CG,gr),Z1={kernelName:CG,backendName:"cpu",kernelFunc:Z0},Z2=gA((Z,I)=>Math.floor(Z/I));function Z3(Z,I,V,re,ae,le,he,ue,pe){const ve=t7([re,le],V);for(let we=0;we<re;we++){const Me=[];let Le=0;for(let Ue=0;Ue<ae;Ue++){const Ge=Z[we*ae+Ue];Le+=Ge*he[Ue],Me.push(Ge)}if(Le<0||Le>=pe/le)throw new Error("Invalid indices: "+Me+" does not index into "+ue);for(let Ue=0;Ue<le;Ue++)ve.values[we*le+Ue]=I.get(...I.indexToLoc(Le*le+Ue))}return ve}function Z4(Z,I,V){const re=t7(V,Z.dtype);for(let ae=0;ae<re.size;++ae){const le=re.indexToLoc(ae).slice(),he=le[0],ue=le[2],pe=I.locToIndex([he,ue]);le[2]=I.values[pe];const ve=Z.locToIndex(le);0<=ve&&ve<Z.values.length&&(re.values[ae]=Z.values[ve])}return re}const Z5=gA((Z,I)=>Z>I?1:0),Z6=gA((Z,I)=>Z>=I?1:0),Z7=gv(Ch,Z6,null,"bool"),Z8={kernelName:Ch,backendName:"cpu",kernelFunc:Z7},Z9=gA((Z,I)=>Z<I?1:0),ZC=gv(m1,Z9,null,"bool"),Zm={kernelName:m1,backendName:"cpu",kernelFunc:ZC},ZN=gA((Z,I)=>Z<=I?1:0),ZJ=gv(m2,ZN,null,"bool"),Zf={kernelName:m2,backendName:"cpu",kernelFunc:ZJ};function Zi(Z,I,V){const re=(I-Z)/(V-1),ae=CC(V,"float32");ae[0]=Z;for(let le=1;le<ae.length;le++)ae[le]=ae[le-1]+re;return ae}const ZO=gx(Z=>Math.log(Z));function Zt(Z,I,V,re){const ae=H(re,F(V));for(let le=0;le<ae.length;++le){const he=le*I;let ue=Z[he];for(let pe=0;pe<I;++pe){const ve=Z[he+pe];(Number.isNaN(ve)||ve>ue)&&(ue=ve)}ae[le]=ue}return ae}const ZB=gA((Z,I)=>Math.max(Z,I)),ZS=gv(m6,ZB),Zd={kernelName:m6,backendName:"cpu",kernelFunc:ZS},ZV=gA((Z,I)=>Math.min(Z,I)),Zb=gv(mC,ZV),ZP={kernelName:mC,backendName:"cpu",kernelFunc:Zb},ZE=gA((Z,I)=>Z*I),ZD=gq((Z,I,V,re)=>({real:Z*V-I*re,imag:Z*re+I*V})),Zg=gv(mm,ZE,ZD),ZZ={kernelName:mm,backendName:"cpu",kernelFunc:Zg};function Zo(Z,I,V){const re=Nn(-1,V);return ZE([],I,re,Z,V)}function Ze(Z){const{inputs:I,backend:V}=Z,{x:re}=I;gs(re,"neg");const ae=V.data.get(re.dataId).values,[le,he]=Zo(ae,re.shape,re.dtype);return V.makeTensorInfo(he,re.dtype,le)}const ZQ={kernelName:mN,backendName:"cpu",kernelFunc:Ze},Zs=gA((Z,I)=>Z!==I?1:0);function ZF(Z,I,V,re,ae){const le=I.length,he=F(I),ue=C5(I),pe=C5(ae),ve=H(V,F(ae));for(let we=0;we<he;++we){const Me=CJ(we,le,ue),Le=new Array(Me.length);for(let Ge=0;Ge<Le.length;Ge++)Le[Ge]=Me[re[Ge]];const Ue=CN(Le,le,pe);ve[Ue]=Z[we]}return ve}function ZI(Z){const{inputs:I,attrs:V,backend:re}=Z,{x:ae}=I,{perm:le}=V;gs(ae,"transpose");const he=ae.shape.length,ue=new Array(he);for(let we=0;we<ue.length;we++)ue[we]=ae.shape[le[we]];const pe=re.data.get(ae.dataId).values,ve=ZF(pe,ae.shape,ae.dtype,le,ue);return{dataId:re.write(ve,ue,ae.dtype),shape:ue,dtype:ae.dtype}}const Zy={kernelName:mK,backendName:"cpu",kernelFunc:ZI};function ZA(Z,I,V,re){const[ae,le]=tw(Z,re),he=Jb(I,"int32"),ue=CC(F(ae),he),pe=F(le);for(let ve=0;ve<ue.length;++ve){const we=ve*pe;let Me=1;for(let Le=0;Le<pe;++Le)Me*=V[we+Le];ue[ve]=Me}return{outVals:ue,outShape:ae,outDtype:he}}function Zp(Z,I,V){Z.forEach((re,ae)=>{if(re<0||re>=V){const le=CJ(ae,I.length,C5(I)).join(",");throw new Error("indices["+le+"] = "+re+" is not in [0, "+V+")")}})}function Zw(Z,I){for(let V=0;V<Z.length;++V){const re=Z[V],ae=V===Z.length-1?I:Z[V+1].length;if(re.length===0)throw new Error("Ragged splits may not be empty");if(re[0]<0)throw new Error("Ragged splits must be non-negative");if(re[re.length-1]>ae)throw new Error("Ragged splits must not point past values");for(let le=1;le<re.length;++le)if(re[le-1]>re[le])throw new Error("Ragged splits must be sorted in ascending order")}}function ZX(Z,I,V,re){const ae=[];let le=0;const he=I.length-1+V.length,ue=new Array(he).fill(null).map(()=>[0]);Zw(V,re);let pe=1;for(let ve=0;ve<I.length-1;++ve){pe*=I[ve];const we=I[ve+1];for(let Me=1;Me<pe+1;++Me)ue[ve].push(Me*we)}for(let ve=0;ve<Z.length;++ve){let we=Z[ve],Me=Z[ve]+1;for(let Le=0;Le<V.length;++Le){const Ue=V[Le],Ge=Le+I.length-1;if(Ge>=0){const ze=ue[Ge],He=ze[ze.length-1]-Ue[we];for(let Ke=we;Ke<Me;++Ke)ue[Ge].push(Ue[Ke+1]+He)}we=Ue[we],Me=Ue[Me]}Me!==we&&(ae.push([we,Me]),le+=Me-we)}return{outSplits:ue,valueSlices:ae,numValues:le}}function Zc(Z){const I=[];for(let V=0;V<Z.length;++V){const re=Z[V].length,ae=x("int32",re);I.push(ae),Z[V].forEach((le,he)=>ae[he]=le)}return I}function ZW(Z,I){const V=Z.slice(0,I);for(;V.length<I;)V.push(1);for(let re=I;re<Z.length;re++)V[I-1]*=Z[re];return V}function ZR(Z,I,V,re,ae,le){const he=ZW(I,2)[1],ue=ZW(le,2)[1];let pe=0;for(const ve of V)for(let we=ve[0];we<ve[1];++we){for(let Me=0;Me<re;++Me)ae[pe*ue+Me]=Z[we*he+Me];++pe}}function ZK(Z,I,V,re,ae){const le=I.slice();le[0]=ae;const he=x(V,F(le)),ue=Z.length,pe=ue===0?0:ue/I[0];return ZR(Z,I,re,pe,he,le),[he,le]}function ZT(Z,I,V,re,ae,le,he,ue){if(Z.length===0)throw new Error("paramsNestedSplits must be non empty");if(I[0].length===0)throw new Error("Split tensors must not be scalars");const pe=I[0][0]-1;if(Zp(le,he,pe),re.length===0)throw new Error("params.rank must be nonzero");const ve=re[0],{outSplits:we,valueSlices:Me,numValues:Le}=ZX(le,he,Z,ve),Ue=Zc(we),Ge=ZK(V,re,ae,Me,Le);return[Ue,Ge[0],Ge[1]]}const Zv=2147483647;function Zq(Z,I,V,re,ae,le,he){if(I.length>1)throw new Error("starts must be a scalar or vector");if(ae.length>1)throw new Error("limits must be a scalar or vector");if(he.length>1)throw new Error("deltas must be a scalar or vector");const ue=I.length===0,pe=ae.length===0,ve=he.length===0,we=[];ue||we.push(I[0]),pe||we.push(ae[0]),ve||we.push(he[0]);for(let He=1;He<we.length;++He)if(we[He]!==we[He-1])throw new Error("starts, limits, and deltas must have the same shape");const Me=we.length===0?1:we[0],Le=x("int32",Me+1);Le[0]=0;for(let He=0;He<Me;++He){const Ke=ue?Z[0]:Z[He],Ye=pe?re[0]:re[He],$e=ve?le[0]:le[He];if($e===0)throw new Error("Requires delta != 0");let je;if($e>0&&Ye<Ke||$e<0&&Ye>Ke)je=0;else if(je=Math.ceil(Math.abs((Ye-Ke)/$e)),je>Zv)throw new Error("Requires ((limit - start) / delta) <= "+Zv);Le[He+1]=Le[He]+je}const Ue=Le[Me],Ge=x(V,Ue);let ze=0;for(let He=0;He<Me;++He){const Ke=Le[He+1]-Le[He];let Ye=ue?Z[0]:Z[He];const $e=ve?le[0]:le[He];for(let je=0;je<Ke;++je)Ge[ze++]=Ye,Ye+=$e}return[Le,Ge]}var Zl=dA;class Za{constructor(I,V,re,ae,le,he,ue,pe,ve,we){this.shape=I,this.shapeShape=V,this.values=re,this.valuesShape=ae,this.valuesDType=le,this.defaultValue=he,this.defaultValueShape=ue,this.rowPartitionValues=pe,this.rowPartitionValuesShapes=ve,this.rowPartitionTypes=dw(we),this.raggedRank=dX(this.rowPartitionTypes)}getRowPartitionTypeByDimension(I){return this.rowPartitionTypes[0]===Zl.FIRST_DIM_SIZE?this.rowPartitionTypes[I+1]:this.rowPartitionTypes[I]}getRowPartitionTensor(I){return this.rowPartitionTypes[0]===Zl.FIRST_DIM_SIZE?this.rowPartitionValues[I+1]:this.rowPartitionValues[I]}getMaxWidth(I){const V=this.getRowPartitionTensor(I-1);switch(this.getRowPartitionTypeByDimension(I-1)){case Zl.VALUE_ROWIDS:return Za.getMaxWidthValueRowID(V);case Zl.ROW_SPLITS:return Za.getMaxWidthRowSplit(V);default:throw new Error("Cannot handle partition type "+Zl[this.getRowPartitionTypeByDimension(I-1)])}}static getMaxWidthRowSplit(I){const V=I.length;if(V===0||V===1)return 0;let re=0;for(let ae=0;ae<V-1;++ae){const le=I[ae+1]-I[ae];le>re&&(re=le)}return re}static getMaxWidthValueRowID(I){const V=I.length;if(V===0)return 0;let re=0,ae=I[0],le=0;for(let he=1;he<V;++he){const ue=I[he];ue!==ae&&(ae=ue,le=Math.max(he-re,le),re=he)}return Math.max(V-re,le)}tensorShapeFromTensor(I,V,re=!0){if(V.length===0){if(I[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return ZL(I,re)}calculateOutputSize(I){const V=this.valuesShape,re=this.defaultValueShape;dc(re,V);const ae=this.tensorShapeFromTensor(this.shape,this.shapeShape),le=dp(this.raggedRank,ae,V);le[0]<0&&(le[0]=I);for(let he=1;he<=this.raggedRank;++he)le[he]<0&&(le[he]=this.getMaxWidth(he));return le}calculateFirstParentOutputIndex(I,V,re){const ae=Math.min(I,re),le=[];let he=0;for(let ue=0;ue<ae;++ue,he+=V)le.push(he);for(let ue=ae;ue<I;++ue)le.push(-1);return e(le.length===I,()=>"Final length of result must be equal to firstDimension."),le}calculateOutputIndexRowSplit(I,V,re,ae){const le=I.length,he=[];for(let ue=0;ue<le-1;++ue){const pe=I[ue+1]-I[ue];let ve=Math.min(ae,pe),we=V[ue];we===-1&&(ve=0);for(let Me=0;Me<ve;++Me)he.push(we),we+=re;for(let Me=0;Me<pe-ve;++Me)he.push(-1)}if(le>0&&he.length!==I[le-1])throw new Error("Invalid row split size.");return he}calculateOutputIndexValueRowID(I,V,re,ae){const le=I.length,he=[];if(le===0)return[];let ue=0,pe=I[0];if(pe>=V.length)throw new Error("Got currentValueRowId="+pe+", which is not less than "+V.length);let ve=V[pe];he.push(ve);for(let we=1;we<le;++we){const Me=I[we];if(Me===pe)ve>=0&&(++ue,ue<ae?ve+=re:ve=-1);else{if(ue=0,pe=Me,Me>=V.length)throw new Error("Got nextValueRowId="+Me+" which is not less than "+V.length);ve=V[Me]}he.push(ve)}if(he.length!==I.length)throw new Error("Invalid row ids.");return he}calculateOutputIndex(I,V,re,ae){const le=this.getRowPartitionTensor(I),he=this.getRowPartitionTypeByDimension(I);switch(he){case Zl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(le,V,re,ae);case Zl.ROW_SPLITS:if(le.length-1>V.length)throw new Error("Row partition size is greater than output size: "+(le.length-1)+" > "+V.length);return this.calculateOutputIndexRowSplit(le,V,re,ae);default:throw new Error("Unsupported partition type: "+Zl[he])}}getFirstDimensionSize(){const I=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const V=this.rowPartitionTypes[0];switch(V){case Zl.FIRST_DIM_SIZE:return I[0];case Zl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Zl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+Zl[V])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const I=this.getFirstDimensionSize(),V=this.calculateOutputSize(I),re=new Array(this.raggedRank+1);re[re.length-1]=1;for(let he=re.length-2;he>=0;--he)re[he]=re[he+1]*V[he+1];const ae=ZL(V,!1),le=x(this.valuesDType,F(ae));if(re[0]*V[0]>0){let he=this.calculateFirstParentOutputIndex(I,re[0],V[0]);for(let ue=1;ue<=this.raggedRank;++ue)he=this.calculateOutputIndex(ue-1,he,re[ue],V[ue]);this.setOutput(this.raggedRank,he,le,ae)}return[ae,le]}setOutput(I,V,re,ae){if(re.length===0)return;const le=this.values,he=re;let ue=ae.slice();ue=ue.slice(I+1);const pe=F(ue),ve=V.length;let we=this.defaultValue;if(we.length!==pe&&we.length!==1){const Ge=this.defaultValueShape;JY(()=>{const ze=Oz(we,Ge);we=t6(ze,ue).dataSync()})}let Me=0,Le=0,Ue=0;for(let Ge=0;Ge<=ve;++Ge){let ze=Ge<ve?V[Ge]:-1;if(ze===Ue){++Ue;continue}if(Le<Ue){const He=le.subarray(Me*pe),Ke=he.subarray(Le*pe),Ye=(Ue-Le)*pe;Zn(Ke,He,Ye)}if(Ge>=ve){const He=re.length;ze=Math.floor(He/pe)}if(ze>Ue)if(this.defaultValue.length===1)he.subarray(Ue*pe,ze*pe).fill(this.defaultValue[0]),Ue=ze;else for(;ze>Ue;){const He=he.slice(Ue*pe);Zn(He,we,pe),++Ue}ze<0?(Me=Ge+1,Le=Ue):(Me=Ge,Le=Ue,Ue=Le+1)}}}function Zn(Z,I,V){for(let re=0;re<V;re++)Z[re]=I[re]}function ZL(Z,I){const V=[];for(let re of Z){if(re<0){if(!I)throw new Error("Dimension "+re+" must be >= 0");if(re<-1)throw new Error("Dimension "+re+" must be >= -1");re=-1}V.push(re)}return V}function ZH(Z,I,V,re,ae,le,he,ue,pe,ve){return new Za(Z,I,V,re,ae,le,he,ue,pe,ve).compute()}function Zk(Z,I,V,re){const ae=Z===I,le=Z<I&&V<0,he=I<Z&&V>1;if(ae||le||he)return CC(0,re);const ue=Math.abs(Math.ceil((I-Z)/V)),pe=CC(ue,re);I<Z&&V===1&&(V=-1),pe[0]=Z;for(let ve=1;ve<pe.length;ve++)pe[ve]=pe[ve-1]+V;return pe}const Zz=gx(Z=>1/Math.sqrt(Z));function Zx(Z,I,V,re,ae,le,he,ue,pe,ve){const we=[re/ae,ae],Me=Z.values,Le=I.values;if(re===0)return t7(V,I.dtype);const Ue=pe instanceof J8?pe:t7(we,I.dtype);typeof pe=="string"||typeof pe=="number"?Ue.values.fill(pe):typeof pe=="boolean"&&Ue.values.fill(+pe);for(let Ge=0;Ge<le;Ge++){const ze=[];let He=0;for(let Ke=0;Ke<he;Ke++){const Ye=Me[Ge*he+Ke];ze.push(Ye),He+=Ye*ue[Ke]}if(He<0||He>=re/ae)throw new Error("Invalid indices: "+ze+" does not index into "+V);for(let Ke=0;Ke<ae;Ke++)ve?Ue.values[He*ae+Ke]+=Le[Ge*ae+Ke]:Ue.values[He*ae+Ke]=I.rank===0?Le[0]:Le[Ge*ae+Ke]}return Ue}const ZU=gx(Z=>1/(1+Math.exp(-Z))),ZG=gU(mF,Z=>1/(1+Math.exp(-Z))),Zu={kernelName:mF,backendName:"cpu",kernelFunc:ZG};function ZY(Z,I,V,re,ae){const le=Om(re,I,V),he=F(V),ue=C5(re);if(le){const Me=ON(I,ue);return ae==="string"?Z.slice(Me,Me+he):Z.subarray(Me,Me+he)}const pe=ae==="string"?Ve(Z):Z,ve=t7(re,ae,pe),we=t7(V,ae);for(let Me=0;Me<we.size;++Me){const Le=we.indexToLoc(Me),Ue=Le.map((Ge,ze)=>Ge+I[ze]);we.set(ve.get(...Ue),...Le)}return ae==="string"?VQ(we.values):we.values}function ZM(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{begin:le,size:he}=re;gs(ae,"slice");const[ue,pe]=OJ(ae,le,he);ir(ae,ue,pe);const ve=V.data.get(ae.dataId).values,we=ZY(ve,ue,pe,ae.shape,ae.dtype);return V.makeTensorInfo(pe,ae.dtype,we)}const Zh={kernelName:mQ,backendName:"cpu",kernelFunc:ZM};function Zj(Z,I,V,re,ae,le,he){const ue=I[0],pe=le[0],ve=new Array(pe),we=new Array(ue),Me=I[1];if(pe===0){if(ue!==0)throw new Error(VJ(ue));const He=x(V,0),Ke=x(ae,0);return[He,[0,Me],Ke,ve,we]}let Le=!0,Ue=0;const Ge=new Array(pe).fill(0);for(let He=0;He<ue;++He){const Ke=Z[He*Me];if(Ke<0)throw new Error(Vf(He,Ke));if(Ke>=pe)throw new Error(Vi(He,Ke,pe));++Ge[Ke],Le=Le&&Ke>=Ue,Ue=Ke}let ze=!0;for(let He=0;He<pe;++He){const Ke=Ge[He]===0;ve[He]=Ke,ze=ze&&!Ke,Ge[He]=Math.max(Ge[He],1),He>0&&(Ge[He]+=Ge[He-1])}if(ze&&Le){const He=Z,Ke=re;for(let Ye=0;Ye<ue;++Ye)we[Ye]=Ye;return[He,[ue,Me],Ke,ve,we]}else{const He=Ge[pe-1],Ke=x(V,He*Me),Ye=x(ae,He),$e=new Array(pe).fill(0);for(let je=0;je<ue;++je){const rt=Z[je*Me],at=$e[rt],Rt=(rt===0?0:Ge[rt-1])+at;$e[rt]++;for(let lt=0;lt<Me;++lt)Ke[Rt*Me+lt]=Z[je*Me+lt];Ye[Rt]=re[je],we[je]=Rt}for(let je=0;je<pe;++je)if($e[je]===0){const rt=je===0?0:Ge[je-1];Ke[rt*Me+0]=je;for(let at=1;at<Me;++at)Ke[rt*Me+at]=0;Ye[rt]=he}return[Ke,[He,Me],Ye,ve,we]}}function Zr(Z,I,V,re,ae){const le=F(re),he=I[0],ue=ae.length,pe=[];let ve=1,we=-1;for(let ze=0;ze<ue;++ze){const He=ae[ze];if(He===-1){if(we!==-1)throw new Error(VO(we,ze));we=ze,pe.push(1)}else{if(He<0)throw new Error(Vt(ze,He));ve*=He,pe.push(He)}}if(we!==-1){if(ve<=0)throw new Error(VB());const ze=Math.trunc(le/ve);if(ve*ze!==le)throw new Error(VS(re,pe));pe[we]=ze}if(F(pe)!==le)throw new Error(Vd(re,pe));const Me=re.length,Le=[];if(Me>0){Le[Me-1]=1;for(let ze=Me-2;ze>=0;--ze)Le[ze]=Le[ze+1]*re[ze+1]}const Ue=[];if(ue>0){Ue[ue-1]=1;for(let ze=ue-2;ze>=0;--ze)Ue[ze]=Ue[ze+1]*pe[ze+1]}const Ge=x(V,he*ue);for(let ze=0;ze<he;++ze){let He=0;for(let Ke=0;Ke<Me;++Ke)He+=Z[ze*Me+Ke]*Le[Ke];for(let Ke=0;Ke<ue;++Ke)Ge[ze*ue+Ke]=Math.trunc(He/Ue[Ke]),He%=Ue[Ke]}return[Ge,[he,ue],pe]}function o0(Z,I,V,re,ae,le=!1,he=0){const ue=re.length,pe=[I[0],Z.length/I[0]],ve=pe[1],we=ue>0?ae[ue-1]+1:0;if(we<0)throw new Error(VV());const Me=I.slice();Me[0]=we;const Le=Me.reduce((Ye,$e)=>Ye*$e,1),Ue=x(V,Le);if(ue===0)return we>0&&Ue.fill(he),[Ue,Me];if(we<=0)throw new Error(VV());let Ge=0,ze=1,He=0,Ke=ae[Ge];for(;;){let Ye=0;if(ze<ue){if(Ye=ae[ze],Ke===Ye){++ze;continue}if(Ke>=Ye)throw new Error(Vb())}if(Ke<0||Ke>=we)throw new Error(VP(Ke,we));Ke>He&&Ue.fill(he,He*ve,Ke*ve);for(let $e=Ge;$e<ze;++$e){const je=re[$e];if(je<0||je>=pe[0])throw new Error(VE($e,re[$e],pe[0]));for(let rt=0;rt<ve;rt++)Ue[Ke*ve+rt]+=Z[je*ve+rt]}if(le)for(let $e=0;$e<ve;$e++)Ue[Ke*ve+$e]/=ze-Ge;if(Ge=ze,++ze,He=Ke+1,Ke=Ye,ze>ue)break}return He<we&&Ue.fill(he,He*ve,we*ve),[Ue,Me]}const o1=gx(Z=>Math.sqrt(Z)),o2=gU(mI,Z=>Math.sqrt(Z)),o3={kernelName:mI,backendName:"cpu",kernelFunc:o2},o4=gA((Z,I)=>{const V=Z-I;return V*V}),o5=gx((Z,I)=>{const{pattern:V,replaceGlobal:re,rewrite:ae}=I;return Z.replace(new RegExp(V,re?"g":""),ae)});function o6(Z,I,V,re){const ae=t7(Z,I.dtype);for(let le=0;le<ae.size;le++){const he=ae.indexToLoc(le),ue=new Array(he.length);for(let pe=0;pe<ue.length;pe++)ue[pe]=he[pe]*V[pe]+re[pe];ae.set(I.get(...ue),...he)}return ae}class o7{constructor(I,V,re,ae,le,he){this.separator=Nz(I),this.nGramWidths=V,this.leftPad=Nz(re),this.rightPad=Nz(ae),this.padWidth=le,this.preserveShort=he}getPadWidth(I){return Math.min(this.padWidth<0?I-1:this.padWidth,I-1)}getNumNGrams(I,V){const re=this.getPadWidth(V);return Math.max(0,I+2*re-V+1)}createNGrams(I,V,re,ae,le,he){for(let ue=0;ue<le;++ue){const pe=this.getPadWidth(he),ve=Math.max(0,pe-ue),we=Math.max(0,pe-(le-(ue+1))),Me=he-(ve+we),Le=V+(ve>0?0:ue-pe);let Ue=0;Ue+=ve*this.leftPad.length;for(let Ye=0;Ye<Me;++Ye)Ue+=I[Le+Ye].length;Ue+=we*this.rightPad.length;const Ge=ve+we+Me-1;Ue+=Ge*this.separator.length,re[ae+ue]=new Uint8Array(Ue);const ze=re[ae+ue];let He=0;const Ke=Ye=>Ye.forEach($e=>ze[He++]=$e);for(let Ye=0;Ye<ve;++Ye)Ke(this.leftPad),Ke(this.separator);for(let Ye=0;Ye<Me-1;++Ye)Ke(I[Le+Ye]),Ke(this.separator);if(Me>0){Ke(I[Le+Me-1]);for(let Ye=0;Ye<we;++Ye)Ke(this.separator),Ke(this.rightPad)}else{for(let Ye=0;Ye<we-1;++Ye)Ke(this.rightPad),Ke(this.separator);Ke(this.rightPad)}}}compute(I,V){const re=I.length,ae=V.length;if(ae>0){let pe=V[0];if(pe!==0)throw new Error("First split value must be 0, got "+pe);for(let ve=1;ve<ae;++ve){let we=V[ve]>=pe;if(we=we&&V[ve]<=re,!we)throw new Error("Invalid split value "+V[ve]+", must be in ["+pe+", "+re+"]");pe=V[ve]}if(pe!==re)throw new Error("Last split value must be data size. Expected "+re+", got "+pe)}const le=ae-1,he=x("int32",ae);if(re===0||ae===0){const pe=new Array(re);for(let ve=0;ve<=le;++ve)he[ve]=0;return[pe,he]}he[0]=0;for(let pe=1;pe<=le;++pe){const ve=V[pe]-V[pe-1];let we=0;this.nGramWidths.forEach(Me=>{we+=this.getNumNGrams(ve,Me)}),this.preserveShort&&ve>0&&we===0&&(we=1),he[pe]=he[pe-1]+we}const ue=new Array(he[le]);for(let pe=0;pe<le;++pe){const ve=V[pe];let we=he[pe];if(this.nGramWidths.forEach(Me=>{const Le=V[pe+1]-V[pe],Ue=this.getNumNGrams(Le,Me);this.createNGrams(I,ve,ue,we,Ue,Me),we+=Ue}),this.preserveShort&&we===he[pe]){const Me=V[pe+1]-V[pe];if(Me===0)continue;const Le=Me+2*this.padWidth,Ue=1;this.createNGrams(I,ve,ue,we,Ue,Le)}}return[ue,he]}}function o8(Z,I,V,re,ae,le,he,ue){return new o7(V,re,ae,le,he,ue).compute(Z,I)}function o9(Z,I,V,re){if(!Z.length)return;if(I.length===0){for(let le=0;le<Z.length;++le)re.push(Z.subarray(le,le+1));return}if(I.length===1){const le=I[0];let he=Z.indexOf(le);for(;he!==-1;){const ue=Z.subarray(0,he);(!V||ue.length!==0)&&re.push(ue),Z=Z.subarray(he+1),he=Z.indexOf(le)}(!V||Z.length!==0)&&re.push(Z);return}let ae=0;for(let le=0;le<Z.length+1;le++)if(le===Z.length||I.indexOf(Z[le])!==-1){const he=Z.subarray(ae,le);(!V||he.length!==0)&&re.push(he),ae=le+1}}function oC(Z,I,V){const re=Z.length,ae=[];let le=0,he=0;const ue=new Array(re);for(let Le=0;Le<re;++Le){const Ue=ae.length;o9(Z[Le],I,V,ae);const Ge=ae.length-Ue;ue[Le]=Ge,le+=Ge,he=Math.max(he,Ge)}const pe=x("int32",le*2),ve=new Array(le),we=[re,he];let Me=0;for(let Le=0;Le<re;++Le)for(let Ue=0;Ue<ue[Le];++Ue)pe[Me*2]=Le,pe[Me*2+1]=Ue,ve[Me]=ae[Me],++Me;return[pe,ve,we]}function om(Z,I){const V=x("int32",Z.length);for(let re=0;re<Z.length;++re)V[re]=Na(Z[re]).modulo(I).getLowBitsUnsigned();return V}const oN=gA((Z,I)=>Z-I),oJ=gq((Z,I,V,re)=>({real:Z-V,imag:I-re})),of=gv(mc,oN,oJ),oi={kernelName:mc,backendName:"cpu",kernelFunc:of};function oO(Z,I){const V=new Array(Z.rank);for(let ae=0;ae<V.length;ae++)V[ae]=Z.shape[ae]*I[ae];const re=t7(V,Z.dtype);for(let ae=0;ae<re.values.length;++ae){const le=re.indexToLoc(ae),he=new Array(Z.rank);for(let pe=0;pe<he.length;pe++)he[pe]=le[pe]%Z.shape[pe];const ue=Z.locToIndex(he);re.values[ae]=Z.values[ue]}return re}const ot=(Z,I)=>{const V=I.value-Z.value;return V===0?Z.index-I.index:V};function oB(Z,I,V=0,re=Z.length-1){for(;re>V;){if(re-V>600){const ue=re-V+1,pe=I-V+1,ve=Math.log(ue),we=.5*Math.exp(2*ve/3),Me=.5*Math.sqrt(ve*we*(ue-we)/ue)*Math.sign(pe-ue/2),Le=Math.max(V,Math.floor(I-pe*we/ue+Me)),Ue=Math.min(re,Math.floor(I+(ue-pe)*we/ue+Me));oB(Z,I,Le,Ue)}const ae=Z[I];let le=V,he=re;for(P(Z,V,I),ot(Z[re],ae)>0&&P(Z,V,re);le<he;){for(P(Z,le,he),le++,he--;ot(Z[le],ae)<0;)le=le+1;for(;ot(Z[he],ae)>0;)he=he-1}ot(Z[V],ae)===0?P(Z,V,he):(he=he+1,P(Z,he,re)),he<=I&&(V=he+1),I<=he&&(re=he-1)}}function oS(Z,I,V,re,ae){const le=I[I.length-1],[he,ue]=[Z.length/le,le],pe=H(V,he*re),ve=H("int32",he*re);for(let Me=0;Me<he;Me++){const Le=Me*ue,Ue=Z.subarray(Le,Le+ue);let Ge=new Array(Ue.length);Ue.forEach((Ye,$e)=>Ge[$e]={value:Ye,index:$e}),re<Ge.length&&(oB(Ge,re),Ge=Ge.slice(0,re)),ae&&Ge.sort(ot);const ze=Me*re,He=pe.subarray(ze,ze+re),Ke=ve.subarray(ze,ze+re);for(let Ye=0;Ye<re;Ye++)He[Ye]=Ge[Ye].value,Ke[Ye]=Ge[Ye].index}const we=I.slice();return we[we.length-1]=re,[t7(we,V,pe),t7(we,"int32",ve)]}function od(Z,I,V,re){const ae=n(I,V)[0],le=[1,V[0],1];for(let Ge=0;Ge<ae;Ge++)le[0]*=V[Ge];le[1]=V[ae];for(let Ge=ae+1;Ge<V.length;Ge++)le[2]*=V[Ge];const he=new Map,ue=new Int32Array(V[ae]),pe=new J8(le,re,Z),ve=[],we=le[0]===1&&le[2]===1;for(let Ge=0;Ge<V[ae];Ge++){let ze;if(we)ze=Z[Ge].toString();else{const Ke=[];for(let Ye=0;Ye<le[0];Ye++)for(let $e=0;$e<le[2];$e++)Ke.push(pe.get(Ye,Ge,$e));ze=Ke.join(",")}const He=he.get(ze);if(He!=null)ue[Ge]=He;else{const Ke=he.size;he.set(ze,Ke),ue[Ge]=Ke,ve.push(Ge)}}const Me=le.slice();Me[1]=he.size;const Le=new J8(Me,re);ve.forEach((Ge,ze)=>{for(let He=0;He<le[0];He++)for(let Ke=0;Ke<le[2];Ke++)Le.set(pe.get(He,Ge,Ke),He,ze,Ke)});const Ue=V.slice();return Ue[ae]=Me[1],{outputValues:Le.values,outputShape:Ue,indices:ue}}var oV=Object.freeze({__proto__:null,addImpl:gl,bincountImpl:gH,bincountReduceImpl:gk,bitwiseAndImpl:gz,castImpl:gR,ceilImpl:gu,concatImpl:gY,equalImpl:gM,expImpl:gh,expm1Impl:gj,floorDivImpl:Z2,floorImpl:gr,gatherNdImpl:Z3,gatherV2Impl:Z4,greaterEqualImpl:Z6,greaterImpl:Z5,lessEqualImpl:ZN,lessImpl:Z9,linSpaceImpl:Zi,logImpl:ZO,maxImpl:Zt,maximumImpl:ZB,minimumImpl:ZV,multiplyImpl:ZE,negImpl:Zo,notEqualImpl:Zs,prodImpl:ZA,raggedGatherImpl:ZT,raggedRangeImpl:Zq,raggedTensorToTensorImpl:ZH,rangeImpl:Zk,rsqrtImpl:Zz,scatterImpl:Zx,sigmoidImpl:ZU,simpleAbsImpl:gF,sliceImpl:ZY,sparseFillEmptyRowsImpl:Zj,sparseReshapeImpl:Zr,sparseSegmentReductionImpl:o0,sqrtImpl:o1,squaredDifferenceImpl:o4,staticRegexReplaceImpl:o5,stridedSliceImpl:o6,stringNGramsImpl:o8,stringSplitImpl:oC,stringToHashBucketFastImpl:om,subImpl:oN,tileImpl:oO,topKImpl:oS,transposeImpl:ZF,uniqueImpl:od});const{addImpl:ob,bincountImpl:oP,bincountReduceImpl:oE,bitwiseAndImpl:oD,castImpl:og,ceilImpl:oZ,concatImpl:oo,equalImpl:oe,expImpl:oQ,expm1Impl:os,floorImpl:oF,gatherNdImpl:oI,gatherV2Impl:oy,greaterImpl:oA,greaterEqualImpl:ow,lessImpl:oX,lessEqualImpl:oc,linSpaceImpl:oW,logImpl:oR,maxImpl:oK,maximumImpl:oT,minimumImpl:ov,multiplyImpl:oq,negImpl:ol,notEqualImpl:oa,prodImpl:on,raggedGatherImpl:oL,raggedRangeImpl:oH,raggedTensorToTensorImpl:ok,rangeImpl:oz,rsqrtImpl:ox,scatterImpl:oU,sigmoidImpl:oG,simpleAbsImpl:ou,sliceImpl:oY,sparseFillEmptyRowsImpl:oM,sparseReshapeImpl:oh,sparseSegmentReductionImpl:oj,sqrtImpl:or,staticRegexReplaceImpl:e0,stridedSliceImpl:e1,stringNGramsImpl:e2,stringSplitImpl:e3,stringToHashBucketFastImpl:e4,subImpl:e5,tileImpl:e6,topKImpl:e7,transposeImpl:e8,uniqueImpl:e9}=oV;function eC(Z,I){return["x","y","z","w","u","v"].slice(0,I).map(V=>Z+"."+V)}function em(Z,I){return I===1?[Z]:eC(Z,I)}function eN(Z,I){if(Z===1)return"rc";let V="";for(let re=0;re<Z;re++)V+=I[re],re<Z-1&&(V+=",");return V}class eJ{constructor(I){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=I,this.rank=I.length,this.enableShapeUniforms=Dr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const V=em("rc",this.rank),re=Dz(this.rank),ae=this.getOutOfBoundsCondition(V),le=this.getSetup(V),he=this.getOutput(V);this.userCode=`
        void main() {
          `+re+` rc = getOutputCoords();

          if(`+ae+`) {
            setOutput(vec4(0));
          } else {
            `+le+`

            setOutput(vec4(`+he+`));
          }
        }
      `}}getSourceCoordsArr(I){const V=[];for(let re=0;re<=1;re++)for(let ae=0;ae<=1;ae++){let le=(re===0?"r":"rp1")+", "+(ae===0?"c":"cp1");for(let he=2;he<this.rank;he++)le=I[I.length-1-he]+","+le;V.push(le)}return V}getOutOfBoundsCondition(I){if(this.rank===1)return"rc > "+(this.enableShapeUniforms?"outShape":this.outputShape[0]);let V="";for(let re=this.rank-2;re<this.rank;re++)V+=I[re]+" >= "+(this.enableShapeUniforms?"outShape["+re+"]":this.outputShape[re]),re<this.rank-1&&(V+="||");return V}getSetup(I){if(this.rank===1)return"";const V=I.slice(-2),re=this.enableShapeUniforms?"outShape["+this.rank+" - 1]":this.outputShape[this.rank-1],ae=this.enableShapeUniforms?"outShape["+this.rank+" - 2]":this.outputShape[this.rank-2];return`
      int r = `+V[0]+`;
      int c = `+V[1]+`;
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= `+re+`;
      bool rEdge = rp1 >= `+ae+`;
    `}getOutput(I){const V=this.getSourceCoordsArr(I);return this.rank===1?"getA(rc), (rc + 1 >= "+(this.enableShapeUniforms?"outShape":this.outputShape[0])+" ? 0. : getA(rc + 1)), 0, 0":"getA("+V[0]+`),
            cEdge ? 0. : getA(`+V[1]+`),
            rEdge ? 0. : getA(`+V[2]+`),
            rEdge || cEdge ? 0. : getA(`+V[3]+")"}}class ef{constructor(I,V){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=I,this.enableShapeUniforms=Dr(this.outputShape.length);let re="";for(let ae=0;ae<4;ae++){let le="thisRC = rc;";ae%2===1&&(le+="thisRC.z += 1;"),ae>1&&(le+="thisRC.y += 1;"),re+=`
        `+le+`
        `+(ae>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+`
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[`+ae+`] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        `+(ae>0?"}":"")+`
      `}this.userCode=`
      `+ei(V,this.enableShapeUniforms)+`
      `+(this.enableShapeUniforms?D8():D7(I))+`

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = `+(this.enableShapeUniforms?"outShape[1]":I[1])+`;
        int cols = `+(this.enableShapeUniforms?"outShape[2]":I[2])+`;

        `+re+`

        setOutput(result);
      }
    `}}function ei(Z,I){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      `+(I?D6(["r","c","d"],"inputShape"):D3(["r","c","d"],Z))+`
      return ivec3(r, c, d);
    }
  `}class eO{constructor(I){this.gpgpu=I,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(I,V,re){const ae=eV(V,re),le=eb(I,ae,re);le in this.freeTextures||(this.freeTextures[le]=[]),le in this.usedTextures||(this.usedTextures[le]=[]);const he=eB(I,ae,this.gpgpu.gl,this.gpgpu.textureConfig,re);if(this.freeTextures[le].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=he,this.log();const pe=this.freeTextures[le].pop();return this.usedTextures[le].push(pe),pe}let ue;return ae===E7.PACKED_2X2_FLOAT32?ue=this.gpgpu.createPackedMatrixTexture(I[0],I[1]):ae===E7.PACKED_2X2_FLOAT16?ue=this.gpgpu.createFloat16PackedMatrixTexture(I[0],I[1]):ae===E7.UNPACKED_FLOAT32?ue=this.gpgpu.createFloat32MatrixTexture(I[0],I[1]):ae===E7.UNPACKED_FLOAT16?ue=this.gpgpu.createFloat16MatrixTexture(I[0],I[1]):ae===E7.PACKED_4X1_UNSIGNED_BYTE&&(ue=this.gpgpu.createUnsignedBytesMatrixTexture(I[0],I[1])),this.usedTextures[le].push(ue),this.numUsedTextures++,this._numBytesAllocated+=he,this.log(),ue}releaseTexture(I,V,re,ae){if(this.freeTextures==null)return;const le=eV(re,ae),he=eb(V,le,ae);he in this.freeTextures||(this.freeTextures[he]=[]);const ue=eB(V,le,this.gpgpu.gl,this.gpgpu.textureConfig,ae),pe=Cd().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");pe!==-1&&this._numBytesAllocated>pe?(this.gpgpu.deleteMatrixTexture(I.texture),this._numBytesAllocated-=ue):(this.freeTextures[he].push(I),this.numFreeTextures++,this._numBytesFree+=ue),this.numUsedTextures--;const ve=this.usedTextures[he],we=ve&&ve.indexOf(I);if(we==null||we<0)throw new Error("Cannot release a texture that was never provided by this texture manager");ve[we]=ve[ve.length-1],ve.pop(),this.log()}log(){if(!this.logEnabled)return;const I=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+I+")");const V=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log("Bytes unused: "+this._numBytesFree+" ("+Math.round(100*V)+"%)")}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const I in this.freeTextures)this.freeTextures[I].forEach(V=>{this.gpgpu.deleteMatrixTexture(V.texture)});for(const I in this.usedTextures)this.usedTextures[I].forEach(V=>{this.gpgpu.deleteMatrixTexture(V.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function et(Z,I){const V=Z;if(I===V.R32F)return 4;if(I===V.R16F)return 2;if(I===V.RGBA32F||I===Z.RGBA)return 16;if(I===V.RGBA16F)return 8;if(I===V.RGBA8)return 4;throw new Error("Unknown internal format "+I)}function eB(Z,I,V,re,ae){const le=eS(I,re);let he;if(ae){const[pe,ve]=Em(Z[0],Z[1]);he=pe*ve}else{const[pe,ve]=E8(Z[0],Z[1]);he=pe*ve}const ue=et(V,le);return he*ue}function eS(Z,I){switch(Z){case E7.PACKED_2X2_FLOAT32:return gt(I);case E7.PACKED_2X2_FLOAT16:return gS(I);case E7.UNPACKED_FLOAT32:return gm(I);case E7.UNPACKED_FLOAT16:return gJ(I);case E7.PACKED_4X1_UNSIGNED_BYTE:return gi(I);default:throw new Error("Unknown physical texture type "+Z)}}function ed(Z){return Cd().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?Z?E7.PACKED_2X2_FLOAT32:E7.UNPACKED_FLOAT32:Z?E7.PACKED_2X2_FLOAT16:E7.UNPACKED_FLOAT16}function eV(Z,I){if(Z===E6.UPLOAD)return E7.PACKED_2X2_FLOAT32;if(Z===E6.RENDER||Z==null)return ed(I);if(Z===E6.DOWNLOAD||Z===E6.PIXELS)return E7.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+Z)}function eb(Z,I,V){return Z[0]+"_"+Z[1]+"_"+I+"_"+V}class eP{constructor(I,V){this.variableNames=["A"],this.outputShape=I,this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        `+V+`
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const eE="if (isnan(x)) return x;",eD="return x;",eg="return abs(x);",eZ="return (x >= 0.0) ? x : (exp(x) - 1.0);",eo=eE+`
  return (x < 0.0) ? 0.0 : x;
`,ee=eE+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,eQ="return x;",es="return 1.0 / (1.0 + exp(-1.0 * x));",eF="return x;",eI=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,ey=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,eA=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ep="return 1.0 / (1.0 + exp(-1.0 * x));";class ew{constructor(I,V){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=I,this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        `+V+`
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class eX{constructor(I){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=I,this.enableShapeUniforms=Dr(this.outputShape.length);const V=I.length,re=em("rc",V),ae=Dz(V),le=eN(V,re),he=re.slice(-2),ue=V<=1?"rc":"vec2("+he.join(",")+")";this.userCode=`
      void main() {
        `+ae+` rc = getOutputCoords();
        vec4 packedInput = getA(`+le+`);

        setOutput(getChannel(packedInput, `+ue+`));
      }
    `}}const ec=SQ,eW=1e-7,eR=1e-4,eK={};function eT(Z){return Z in eK||(eK[Z]={}),eK[Z]}const ev=Cd().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),eq=600;function el(){return Cd().global.screen==null?1024:Cd().global.screen.height*Cd().global.screen.width*window.devicePixelRatio*eq/1024/1024}class ea extends i{nextDataId(){return ea.nextDataId++}constructor(I){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Cd().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let V;if(I!=null){if(I instanceof ge)V=I;else{const re=E2(Cd().getNumber("WEBGL_VERSION"),I);V=new ge(re)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const re=E2(Cd().getNumber("WEBGL_VERSION"));V=new ge(re),this.binaryCache=eT(Cd().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=V,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new eO(this.gpgpu),this.numMBBeforeWarning=el(),this.texData=new f(this,Ju())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(I,V,re,ae,le,he){const ue=this.makeTensorInfo(V,re),pe=this.texData.get(ue.dataId);pe.isPacked=!1,pe.texture={texture:I,texShape:[ae,le]},pe.texShape=[ae,le];const ve=El(V),we=new g5(ve,!1,he),Me=this.runWebGLProgram(we,[ue],re,[[ae,le]]);return Me.shape=V,pe.texture=null,this.disposeIntermediateTensorInfo(ue),Me.dataId}write(I,V,re){if((Cd().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Cd().getBool("DEBUG"))&&this.checkNumericalProblems(I),re==="complex64"&&I!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const ae={id:this.nextDataId()};return this.texData.set(ae,{shape:V,dtype:re,values:I,usage:E6.UPLOAD,refCount:1}),ae}refCount(I){return this.texData.has(I)?this.texData.get(I).refCount:0}incRef(I){const V=this.texData.get(I);V.refCount++}decRef(I){if(this.texData.has(I)){const V=this.texData.get(I);V.refCount--}}move(I,V,re,ae,le){if(Cd().getBool("DEBUG")&&this.checkNumericalProblems(V),ae==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(I,{shape:re,dtype:ae,values:V,usage:E6.UPLOAD,refCount:le})}disposeIntermediateTensorInfo(I){this.disposeData(I.dataId)}readSync(I){const V=this.texData.get(I),{values:re,dtype:ae,complexTensorInfos:le,slice:he,shape:ue,isPacked:pe}=V;if(he!=null){let Le;pe?Le=new ew(ue,eQ):Le=new eP(ue,eQ);const Ue=this.runWebGLProgram(Le,[{dataId:I,shape:ue,dtype:ae}],ae),Ge=this.readSync(Ue.dataId);return this.disposeIntermediateTensorInfo(Ue),Ge}if(re!=null)return this.convertAndCacheOnCPU(I);if(ae==="string")return re;const ve=this.activeTimers!=null;let we;ve&&(we=Nk());let Me;if(ae==="complex64"){const Le=this.readSync(le.real.dataId),Ue=this.readSync(le.imag.dataId);Me=du(Le,Ue)}else Me=this.getValuesFromTexture(I);return ve&&(this.downloadWaitMs+=Nk()-we),this.convertAndCacheOnCPU(I,Me)}async read(I){if(this.pendingRead.has(I)){const Ge=this.pendingRead.get(I);return new Promise(ze=>Ge.push(ze))}const V=this.texData.get(I),{values:re,shape:ae,slice:le,dtype:he,complexTensorInfos:ue,isPacked:pe}=V;if(le!=null){let Ge;pe?Ge=new ew(ae,eQ):Ge=new eP(ae,eQ);const ze=this.runWebGLProgram(Ge,[{dataId:I,shape:ae,dtype:he}],he),He=this.read(ze.dataId);return this.disposeIntermediateTensorInfo(ze),He}if(re!=null)return this.convertAndCacheOnCPU(I);if(Cd().getBool("DEBUG")&&!Cd().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Cd().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let ve=null,we;if(he!=="complex64"&&Cd().get("WEBGL_BUFFER_SUPPORTED")){we=this.decode(I);const Ge=this.texData.get(we.dataId);ve=this.gpgpu.createBufferFromTexture(Ge.texture.texture,...EC(ae))}this.pendingRead.set(I,[]),he!=="complex64"&&await this.gpgpu.createAndWaitForFence();let Me;if(he==="complex64"){const Ge=await Promise.all([this.read(ue.real.dataId),this.read(ue.imag.dataId)]),ze=Ge[0],He=Ge[1];Me=du(ze,He)}else if(ve==null)Me=this.getValuesFromTexture(I);else{const Ge=F(ae);Me=this.gpgpu.downloadFloat32MatrixFromBuffer(ve,Ge)}if(we!=null&&this.disposeIntermediateTensorInfo(we),ve!=null){const Ge=this.gpgpu.gl;Ef(Ge,()=>Ge.deleteBuffer(ve))}const Le=this.convertAndCacheOnCPU(I,Me),Ue=this.pendingRead.get(I);return this.pendingRead.delete(I),Ue.forEach(Ge=>Ge(Le)),this.pendingDisposal.has(I)&&(this.pendingDisposal.delete(I),this.disposeData(I)&&Ju().removeDataId(I,this),this.pendingDeletes--),Le}readToGPU(I,V={}){const re=this.texData.get(I),{values:ae,shape:le,slice:he,dtype:ue,isPacked:pe,texture:ve}=re;if(ue==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(he!=null){let Ue;pe?Ue=new ew(le,eQ):Ue=new eP(le,eQ);const Ge=this.runWebGLProgram(Ue,[{dataId:I,shape:le,dtype:ue}],ue),ze=this.readToGPU(Ge,V);return this.disposeIntermediateTensorInfo(Ge),ze}if(ve==null)throw ae!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const we=this.decode(I,V.customTexShape),Me=Ju().makeTensorFromTensorInfo(we),Le=this.texData.get(we.dataId);return Object.assign({tensorRef:Me},Le.texture)}bufferSync(I){const V=this.readSync(I.dataId);if(I.dtype==="string")try{const re=V.map(ae=>Nx(ae));return t7(I.shape,I.dtype,re)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return t7(I.shape,I.dtype,V)}checkNumericalProblems(I){if(I!=null)for(let V=0;V<I.length;V++){const re=I[V];if(!EB(re))throw Cd().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error("The value "+re+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"):Error("The value "+re+" cannot be represented on this device.")}}getValuesFromTexture(I){const{shape:V,dtype:re,isPacked:ae}=this.texData.get(I),le=F(V);if(Cd().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const Le=this.decode(I),Ue=this.texData.get(Le.dataId),Ge=this.gpgpu.downloadMatrixFromPackedTexture(Ue.texture.texture,...EC(V)).subarray(0,le);return this.disposeIntermediateTensorInfo(Le),Ge}const he=Cd().getBool("WEBGL_PACK")&&ae===!0,ue=he?El(V):V,pe=he?new g3(ue):new g2(ue),ve=this.runWebGLProgram(pe,[{shape:ue,dtype:re,dataId:I}],"float32"),we=this.texData.get(ve.dataId),Me=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(we.texture.texture,we.texShape[0],we.texShape[1]).subarray(0,le);return this.disposeIntermediateTensorInfo(ve),Me}timerAvailable(){return Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(I){const V=this.activeTimers,re=[];let ae=!1;this.programTimersStack==null?(this.programTimersStack=re,ae=!0):this.activeTimers.push(re),this.activeTimers=re,I();const le=NG(this.activeTimers.map(pe=>pe.query)).filter(pe=>pe!=null),he=NG(this.activeTimers.map(pe=>pe.name)).filter(pe=>pe!=null);this.activeTimers=V,ae&&(this.programTimersStack=null);const ue={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const pe=await Promise.all(le);ue.kernelMs=o(pe),ue.getExtraProfileInfo=()=>pe.map((ve,we)=>({name:he[we],ms:ve})).map(ve=>ve.name+": "+ve.ms).join(", ")}else ue.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,ue})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Nk(),endMs:null}}endTimer(I){return Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),I):(I.endMs=Nk(),I)}async getQueryTime(I){if(Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(I);const V=I;return V.endMs-V.startMs}disposeData(I,V=!1){if(this.pendingDisposal.has(I))return!1;if(!this.texData.has(I))return!0;if(V?this.texData.get(I).refCount=0:this.texData.get(I).refCount--,!V&&this.texData.get(I).refCount>0)return!1;if(this.pendingRead.has(I))return this.pendingDisposal.add(I),this.pendingDeletes++,!1;this.releaseGPUData(I);const{complexTensorInfos:re}=this.texData.get(I);return re!=null&&(this.disposeData(re.real.dataId,V),this.disposeData(re.imag.dataId,V)),this.texData.delete(I),!0}releaseGPUData(I){const{texture:V,dtype:re,texShape:ae,usage:le,isPacked:he,slice:ue}=this.texData.get(I),pe=ue&&ue.origDataId||I,ve=this.dataRefCount.get(pe);ve>1?this.dataRefCount.set(pe,ve-1):(this.dataRefCount.delete(pe),V!=null&&(this.numBytesInGPU-=this.computeBytes(ae,re),this.textureManager.releaseTexture(V,ae,le,he)));const we=this.texData.get(I);we.texture=null,we.texShape=null,we.isPacked=!1,we.slice=null}getTexture(I){return this.uploadToGPU(I),this.texData.get(I).texture.texture}getDataInfo(I){return this.texData.get(I)}shouldExecuteOnCPU(I,V=ev){return Cd().getBool("WEBGL_CPU_FORWARD")&&I.every(re=>this.texData.get(re.dataId).texture==null&&F(re.shape)<V)}getGPGPUContext(){return this.gpgpu}where(I){mk("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const V=I.dataSync();return ec(I.shape,V)}packedUnaryOp(I,V,re){const ae=new ew(I.shape,V),le=this.compileAndRun(ae,[I],re);return Ju().makeTensorFromTensorInfo(le)}abs(I){if(this.shouldExecuteOnCPU([I])&&I.dtype!=="complex64"){const ae=ou(this.texData.get(I.dataId).values);return this.makeOutput(I.shape,I.dtype,ae)}if(Cd().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(I,eg,I.dtype);const V=new eP(I.shape,eg),re=this.compileAndRun(V,[I]);return Ju().makeTensorFromTensorInfo(re)}makeTensorInfo(I,V,re){let ae;if(V==="string"&&re!=null&&re.length>0&&j(re[0])){const le=re.map(he=>Nz(he));ae=this.write(le,I,V)}else ae=this.write(re,I,V);return this.texData.get(ae).usage=null,{dataId:ae,shape:I,dtype:V}}makeOutput(I,V,re){return Ju().makeTensorFromTensorInfo(this.makeTensorInfo(I,V,re),this)}unpackTensor(I){const V=new eX(I.shape);return this.runWebGLProgram(V,[I],I.dtype)}packTensor(I){const V=new eJ(I.shape),re=!0;return this.runWebGLProgram(V,[I],I.dtype,null,re)}packedReshape(I,V){const re=[Ev(I.shape),...Eq(I.shape)],ae={dtype:I.dtype,shape:re,dataId:I.dataId},le=[Ev(V),...Eq(V)],he=new ef(le,re),ue=!0,pe=[re],ve=this.runWebGLProgram(he,[ae],I.dtype,pe,ue);return{dataId:ve.dataId,shape:V,dtype:ve.dtype}}decode(I,V){const re=this.texData.get(I),{isPacked:ae,shape:le,dtype:he}=re;if(V!=null){const Le=F(le),Ue=V[0]*V[1]*4;e(Le<=Ue,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const ue=El(le);let pe;ae?pe=new g1(ue):pe=new g0(ue);const ve=!0,we=[V??EC(ue)],Me=this.runWebGLProgram(pe,[{shape:ue,dtype:he,dataId:I}],he,we,ve,V);return{dtype:he,shape:le,dataId:Me.dataId}}runWebGLProgram(I,V,re,ae,le=!1,he){const ue=this.makeTensorInfo(I.outputShape,re),pe=this.texData.get(ue.dataId);if(I.packedOutput&&(pe.isPacked=!0),I.outPackingScheme===E5.DENSE){const Ke=he??EC(I.outputShape);pe.texShape=Ke.map(Ye=>Ye*2)}if(I.outTexUsage!=null&&(pe.usage=I.outTexUsage),F(ue.shape)===0)return pe.values=H(ue.dtype,0),ue;const ve=[],we=V.map(Ke=>{if(Ke.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let Ye=this.texData.get(Ke.dataId);if(Ye.texture==null){if(!I.packedInputs&&F(Ke.shape)<=Cd().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:Ke.shape,texData:null,isUniform:!0,uniformValues:Ye.values};I.packedInputs&&(Ye.isPacked=!0,Ye.shape=Ke.shape)}if(this.uploadToGPU(Ke.dataId),!!Ye.isPacked!=!!I.packedInputs)Ke=Ye.isPacked?this.unpackTensor(Ke):this.packTensor(Ke),ve.push(Ke),Ye=this.texData.get(Ke.dataId);else if(Ye.isPacked&&!EL(Ye.shape,Ke.shape)){const $e=Ke,je=Ke.shape;Ke.shape=Ye.shape,Ke=this.packedReshape(Ke,je),ve.push(Ke),Ye=this.texData.get(Ke.dataId),$e.shape=je}return{shape:Ke.shape,texData:Ye,isUniform:!1}});this.uploadToGPU(ue.dataId);const Me={shape:ue.shape,texData:pe,isUniform:!1},Le=Dj(I,we,Me),Ue=this.getAndSaveBinary(Le,()=>Du(this.gpgpu,I,we,Me)),Ge=this.activeTimers!=null;let ze;Ge&&(ze=this.startTimer()),Cd().get("ENGINE_COMPILE_ONLY")||Dh(this.gpgpu,Ue,we,Me,ae),ve.forEach(Ke=>this.disposeIntermediateTensorInfo(Ke)),Ge&&(ze=this.endTimer(ze),this.activeTimers.push({name:I.constructor.name,query:this.getQueryTime(ze)}));const He=Cd().getNumber("WEBGL_FLUSH_THRESHOLD");if(He>0){const Ke=Nk();Ke-this.lastGlFlushTime>He&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=Ke)}if(!Cd().getBool("WEBGL_LAZILY_UNPACK")&&pe.isPacked&&le===!1){const Ke=this.unpackTensor(ue);return this.disposeIntermediateTensorInfo(ue),Ke}return ue}compileAndRun(I,V,re,ae,le=!1){return re=re||V[0].dtype,this.runWebGLProgram(I,V,re,ae,le)}getAndSaveBinary(I,V){return I in this.binaryCache||(this.binaryCache[I]=V()),this.binaryCache[I]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Cd().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(I=>{this.gpgpu.deleteProgram(this.binaryCache[I].webGLProgram),delete this.binaryCache[I]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=JY(()=>{if(!Cd().get("WEBGL_RENDER_FLOAT32_ENABLED")){const I=Cd().getBool("DEBUG");Cd().set("DEBUG",!1);const V=this.abs(tL(1e-8)).dataSync()[0];if(Cd().set("DEBUG",I),V>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?eW:eR}uploadToGPU(I){const V=this.texData.get(I),{shape:re,dtype:ae,values:le,texture:he,usage:ue,isPacked:pe}=V;if(he!=null)return;const ve=this.activeTimers!=null;let we;ve&&(we=Nk());let Me=V.texShape;if(Me==null&&(Me=Ea(re,pe),V.texShape=Me),le!=null){const Le=El(re);let Ue,Ge=Me[1],ze=Me[0];const He=le instanceof Uint8Array||le instanceof Uint8ClampedArray;(pe||!He)&&([Ge,ze]=Em(Me[0],Me[1])),pe?Ue=new g6(Le,He):Ue=new g5(Le,He);const Ke=He?[ze,Ge]:Me,Ye=this.makeTensorInfo(Ke,ae),$e=this.texData.get(Ye.dataId);He?$e.usage=E6.PIXELS:$e.usage=E6.UPLOAD,$e.texShape=Ke,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(Ye.dataId),Ge,ze,le);const je=[[ze,Ge]],rt=!0,at=this.runWebGLProgram(Ue,[Ye],ae,je,rt),Rt=this.texData.get(at.dataId);V.texShape=Rt.texShape,V.isPacked=Rt.isPacked,V.usage=Rt.usage,Cd().get("ENGINE_COMPILE_ONLY")?this.disposeData(at.dataId):(V.texture=Rt.texture,V.values=null,this.texData.delete(at.dataId)),this.disposeIntermediateTensorInfo(Ye),ve&&(this.uploadWaitMs+=Nk()-we)}else{const Le=this.acquireTexture(Me,ue,ae,pe);V.texture=Le}}convertAndCacheOnCPU(I,V){const re=this.texData.get(I),{dtype:ae}=re;return V!=null&&(re.values=en(V,ae)),re.values}acquireTexture(I,V,re,ae){if(this.numBytesInGPU+=this.computeBytes(I,re),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const le=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+le+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(I,V,ae)}computeBytes(I,V){return I[0]*I[1]*M(V)}checkCompileCompletion(){for(const[,I]of Object.entries(this.binaryCache))this.checkCompletion_(I)}async checkCompileCompletionAsync(){const I=[];if(this.gpgpu.parallelCompilationExtension){for(const[,V]of Object.entries(this.binaryCache))I.push(this.checkCompletionAsync_(V));return Promise.all(I)}else{for(const[,V]of Object.entries(this.binaryCache)){const re=new Promise(ae=>{try{this.checkCompletion_(V),ae(!0)}catch(le){throw le}});I.push(re)}return Promise.all(I)}}async checkCompletionAsync_(I){return this.gpgpu.gl.getProgramParameter(I.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(I):(await dF(),this.checkCompletionAsync_(I))}checkCompletion_(I){if(this.gpgpu.gl.getProgramParameter(I.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(I.webGLProgram)),this.gpgpu.gl.getShaderParameter(I.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(EE(I.source,this.gpgpu.gl.getShaderInfoLog(I.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const I of Object.values(this.binaryCache)){this.gpgpu.buildVao(I.webGLProgram);const{variablesLocations:V,customUniformLocations:re,infLoc:ae,nanLoc:le,outShapeLocation:he,outShapeStridesLocation:ue,outTexShapeLocation:pe}=DY(this.gpgpu,I.program,I.webGLProgram);I.variablesLocations=V,I.customUniformLocations=re,I.infLoc=ae,I.nanLoc=le,I.outShapeLocation=he,I.outShapeStridesLocation=ue,I.outTexShapeLocation=pe}}createTensorFromGPUData(I,V,re){I.channels=I.channels||"RGBA";const{texture:ae,height:le,width:he,channels:ue}=I,pe=Ju().backend;if(!pe.gpgpu.gl.isTexture(ae))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const ve=pe.writeTexture(ae,V,re,le,he,ue);return Ju().makeTensorFromDataId(ve,V,re,pe)}}ea.nextDataId=0;function en(Z,I){if(I==="float32"||I==="complex64")return Z;if(I==="int32"||I==="bool"){const V=I==="int32"?new Int32Array(Z.length):new Uint8Array(Z.length);for(let re=0;re<V.length;++re)V[re]=Math.round(Z[re]);return V}else throw new Error("Unknown dtype "+I)}Jc()&&f0("webgl",()=>new ea,2);const eL="return abs(x);";function eH(Z){const{inputs:I,backend:V}=Z,{x:re}=I;if(V.shouldExecuteOnCPU([re])&&re.dtype!=="complex64"){const le=V.texData.get(re.dataId),he=ou(le.values);return V.makeTensorInfo(re.shape,re.dtype,he)}let ae;return Cd().getBool("WEBGL_PACK_UNARY_OPERATIONS")?ae=new ew(re.shape,eL):ae=new eP(re.shape,eL),V.runWebGLProgram(ae,[re],re.dtype)}const ek={kernelName:CZ,backendName:"webgl",kernelFunc:eH},ez=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class ex{constructor(I,V,re){this.variableNames=["A","B"],this.outputShape=iH(V,re),this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        `+I+`
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const eU=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class eG{constructor(I,V,re,ae=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=iH(V,re);const le=this.outputShape.length;this.enableShapeUniforms=Dr(le);let he="";if(ae)if(le===0||F(this.outputShape)===1)he=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(he=`
          `+Dz(le)+` coords = getOutputCoords();
        `,le===1)this.enableShapeUniforms?he+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:he+=`
            result.y = (coords + 1) >= `+this.outputShape[0]+` ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const ue=em("coords",le);this.enableShapeUniforms?he+=`
            bool nextRowOutOfBounds =
              (`+ue[le-2]+" + 1) >= outShape["+le+` - 2];
            bool nextColOutOfBounds =
              (`+ue[le-1]+" + 1) >= outShape["+le+` - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:he+=`
            bool nextRowOutOfBounds =
              (`+ue[le-2]+" + 1) >= "+this.outputShape[le-2]+`;
            bool nextColOutOfBounds =
              (`+ue[le-1]+" + 1) >= "+this.outputShape[le-1]+`;
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        `+I+`
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        `+he+`

        setOutput(result);
      }
    `}}function eu(Z){const{inputs:I,backend:V}=Z,{x:re}=I;return V.incRef(re.dataId),{dataId:re.dataId,shape:re.shape,dtype:re.dtype}}const eY={kernelName:Cj,backendName:"webgl",kernelFunc:eu};function eM(Z){const{inputs:I,backend:V}=Z,{real:re,imag:ae}=I,le=V.makeTensorInfo(re.shape,"complex64"),he=V.texData.get(le.dataId),ue=eu({inputs:{x:re},backend:V}),pe=eu({inputs:{x:ae},backend:V});return he.complexTensorInfos={real:ue,imag:pe},le}const eh="return (a < 0.) ? b * a : a;",ej=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,er="return (a < 0.) ? b * a : a;",Q0=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Q1(Z){const{inputs:I,backend:V}=Z,{x:re,alpha:ae}=I,le=Cd().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new eG(Q0,re.shape,ae.shape):new ex(er,re.shape,ae.shape);return V.runWebGLProgram(le,[re,ae],"float32")}const Q2={kernelName:mS,backendName:"webgl",kernelFunc:Q1},Q3="if (isnan(x)) return x;";function Q4({opSnippet:Z,packedOpSnippet:I,cpuKernelImpl:V,dtype:re}){return({inputs:ae,backend:le})=>{const{x:he}=ae,ue=le,pe=re||he.dtype;if(ue.shouldExecuteOnCPU([he])&&V!=null){const Me=ue.texData.get(he.dataId),Le=V(Me.values,pe);return ue.makeTensorInfo(he.shape,pe,Le)}const ve=Cd().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&I!=null;let we;return ve?we=new ew(he.shape,I):we=new eP(he.shape,Z),ue.runWebGLProgram(we,[he],pe)}}function Q5({opSnippet:Z,packedOpSnippet:I,checkOutOfBounds:V=!1,supportsComplex:re=!1,cpuKernelImpl:ae,dtype:le}){return({inputs:he,backend:ue})=>{const{a:pe,b:ve}=he,we=ue;if(re&&pe.dtype==="complex64"){const Ge=we.texData.get(pe.dataId),ze=we.texData.get(ve.dataId),[He,Ke]=[[Ge.complexTensorInfos.real,ze.complexTensorInfos.real],[Ge.complexTensorInfos.imag,ze.complexTensorInfos.imag]].map($e=>{const[je,rt]=$e,at={dataId:je.dataId,dtype:je.dtype,shape:pe.shape},Rt={dataId:rt.dataId,dtype:rt.dtype,shape:ve.shape},lt=new ex(Z,pe.shape,ve.shape);return we.runWebGLProgram(lt,[at,Rt],Jb(je.dtype,rt.dtype))}),Ye=eM({inputs:{real:He,imag:Ke},backend:we});return we.disposeIntermediateTensorInfo(He),we.disposeIntermediateTensorInfo(Ke),Ye}const Me=le||Jb(pe.dtype,ve.dtype);if((pe.dtype==="string"||ve.dtype==="string"||we.shouldExecuteOnCPU([pe,ve]))&&ae!=null){const Ge=we.texData.get(pe.dataId).values,ze=we.texData.get(ve.dataId).values,He=pe.dtype==="string"?Ve(Ge):Ge,Ke=pe.dtype==="string"?Ve(ze):ze,[Ye,$e]=ae(pe.shape,ve.shape,He,Ke,Me),je=we.makeTensorInfo($e,Me),rt=we.texData.get(je.dataId);return rt.values=Ye,je}const Le=Cd().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&I!=null;let Ue;return Le?Ue=new eG(I,pe.shape,ve.shape,V):Ue=new ex(Z,pe.shape,ve.shape),we.runWebGLProgram(Ue,[pe,ve],Me)}}function Q6(Z,I=!1){if(Z==="linear")return I?eF:eD;if(Z==="relu")return I?ey:eo;if(Z==="elu")return I?eI:eZ;if(Z==="relu6")return I?eA:ee;if(Z==="prelu")return I?Q0:er;if(Z==="leakyrelu")return I?ej:eh;if(Z==="sigmoid")return I?ep:es;throw new Error("Activation "+Z+" has not been implemented for the WebGL backend.")}const Q7="return a + b;",Q8=Q5({opSnippet:Q7,packedOpSnippet:Q7,supportsComplex:!0,cpuKernelImpl:ob}),Q9={kernelName:Co,backendName:"webgl",kernelFunc:Q8};class QC{constructor(I,V){this.outputShape=[],this.outputShape=I,this.variableNames=V.map((le,he)=>"T"+he);const re=[];this.variableNames.forEach(le=>{re.push("float v"+le+" = get"+le+"AtOutCoords();")});const ae=this.variableNames.map(le=>"v"+le).join(" + ");this.userCode=`
      void main() {
        `+re.join(`
        `)+`

        float result = `+ae+`;
        setOutput(result);
      }
    `}}class Qm{constructor(I,V){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=I,this.variableNames=V.map((le,he)=>"T"+he);const re=[];this.variableNames.forEach(le=>{re.push("vec4 v"+le+" = get"+le+"AtOutCoords();")});const ae=this.variableNames.map(le=>"v"+le).join(" + ");this.userCode=`
      void main() {
        `+re.join(`
        `)+`

        vec4 result = `+ae+`;
        setOutput(result);
      }
    `}}function QN(Z){const{inputs:I,backend:V}=Z,re=I;if(re.length===1)return eu({inputs:{x:re[0]},backend:V});if(re.length>Cd().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const ue=Math.floor(re.length/2),pe=QN({inputs:re.slice(0,ue),backend:V}),ve=QN({inputs:re.slice(ue),backend:V});return QN({inputs:[pe,ve],backend:V})}const ae=re.map(ue=>ue.dtype).reduce((ue,pe)=>Jb(ue,pe)),le=re.map(ue=>ue.shape),he=Cd().getBool("WEBGL_PACK")?new Qm(re[0].shape,le):new QC(re[0].shape,le);return V.runWebGLProgram(he,re,ae)}const QJ={kernelName:Ce,backendName:"webgl",kernelFunc:QN},Qf=ez+`
  return atan(a, b);
`,Qi=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+eU+`
  return result;
`,QO=Q5({opSnippet:Qf,packedOpSnippet:Qi}),QB={kernelName:CQ,backendName:"webgl",kernelFunc:QO};class QS{constructor(I,V,re,ae=!1,le=!1){if(this.variableNames=["x"],V==="avg"&&re)throw new Error("Cannot compute positions for average pool.");const he=I.filterWidth,ue=I.strideHeight,pe=I.strideWidth,ve=I.dilationHeight,we=I.dilationWidth,Me=I.effectiveFilterHeight,Le=I.effectiveFilterWidth,Ue=I.padInfo.top,Ge=I.padInfo.left;this.outputShape=I.outShape;const ze=V==="avg",He="((batch  * "+I.inHeight+" + xR) * "+I.inWidth+" + xC) * "+I.inChannels+" + d",Ke="(xR * "+I.inWidth+" + xC) * "+I.inChannels+" + d";let Ye="0.0";if(ze||(Ye="-1.0 / 1e-20"),re){const lt=">=";this.userCode=`
        const ivec2 strides = ivec2(`+ue+", "+pe+`);
        const ivec2 pads = ivec2(`+Ue+", "+Ge+`);

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < `+Me+`;
              wR += `+ve+`) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= `+I.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+Le+`;
                wC += `+we+`) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= `+I.inWidth+`) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value `+lt+` currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = `+(ae?le?He:Ke:"wR * "+Le+" + wC")+`;
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $e="max";let je=V+"("+V+"("+V+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";V==="avg"&&(je="avgValue / max(count, 1.0)");const rt=Math.floor(he/4)*4,at=he%4,Rt=`
      if (`+ze+`) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = `+$e+`(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(`+ue+", "+pe+`);
      const ivec2 pads = ivec2(`+Ue+", "+Ge+`);
      const float initializationValue = `+Ye+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= `+I.inWidth+`) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(`+Ye+`);
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < `+Me+`;
            wR += `+ve+`) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= `+I.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+rt+`; wC += 4) {
            int xC = xCCorner + wC * `+we+`;

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+we+`, d),
              getValue(batch, xR, xC + 2 * `+we+`, d),
              getValue(batch, xR, xC + 3 * `+we+`, d)
            );

            `+Rt+`
          }

          int xC = xCCorner + `+rt+`;
          if (`+(at===1)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            `+Rt+`
          } else if (`+(at===2)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+we+`, d),
              initializationValue,
              initializationValue
            );

            `+Rt+`
          } else if (`+(at===3)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+we+`, d),
              getValue(batch, xR, xC + 2 * `+we+`, d),
              initializationValue
            );

            `+Rt+`
          }
        }
        setOutput(`+je+`);
      }
    `}}function Qd(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I;D0(ae,"avgPool");const{filterSize:le,strides:he,pad:ue,dimRoundingMode:pe}=re,ve=1;e(Oa(he,ve),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+he+" and dilations '"+ve+"'");const we=OI(ae.shape,le,he,ve,ue,pe);if(we.filterWidth===1&&we.filterHeight===1&&X(we.inShape,we.outShape))return eu({inputs:{x:ae},backend:V});const Me=new QS(we,"avg",!1);return V.runWebGLProgram(Me,[ae],"float32")}const QV={kernelName:Cs,backendName:"webgl",kernelFunc:Qd};class Qb{constructor(I,V,re,ae=!1,le=!1,he=!1,ue=null,pe=!1,ve=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=re,this.enableShapeUniforms=Dr(this.outputShape.length);const we=ae?I[1]:I[2],Me=Math.ceil(we/2),Le=ae?"i * 2, rc.y":"rc.y, i * 2",Ue=le?"rc.z, i * 2":"i * 2, rc.z",Ge=ae?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],ze=le?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let He="",Ke="";ue&&(pe?He=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+ue+`
        }`:ve?He=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+ue+`
        }`:He=`vec4 activation(vec4 x) {
          `+ue+`
        }`,Ke="result = activation(result);");const Ye=he?"result += getBiasAtOutCoords();":"";he&&this.variableNames.push("bias"),pe&&this.variableNames.push("preluActivationWeights"),ve&&this.variableNames.push("leakyreluAlpha");let $e="rc.x",je="rc.x";I[0]<V[0]?$e="imod(rc.x, "+I[0]+")":V[0]<I[0]&&(je="imod(rc.x, "+V[0]+")"),this.userCode=`
      `+He+`
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = `+Me+`.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = `+$e+`;
        int batchB = `+je+`;
        for (int i = 0; i < `+Me+`; i++) {
          vec4 a = getMatrixA(batchA, `+Le+`);
          vec4 b = getMatrixB(batchB, `+Ue+`);

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (`+Ge[0]+" * "+ze[0]+`);
          result += (`+Ge[1]+" * "+ze[1]+`);
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        `+Ye+`

        `+Ke+`

        setOutput(result);
      }
    `}}const QP={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class QE{constructor(I,V,re){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=iH(V,re),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        `+I+`
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const QD="return a * b;";function Qg(Z){const{inputs:I,backend:V}=Z,{a:re,b:ae}=I,le=Jb(re.dtype,ae.dtype);if(re.dtype==="complex64"){const ue=V.texData.get(re.dataId),pe=V.texData.get(ae.dataId),ve=new QE(QP.REAL,re.shape,ae.shape),we=new QE(QP.IMAG,re.shape,ae.shape),Me=[{dataId:ue.complexTensorInfos.real.dataId,dtype:ue.complexTensorInfos.real.dtype,shape:re.shape},{dataId:ue.complexTensorInfos.imag.dataId,dtype:ue.complexTensorInfos.imag.dtype,shape:re.shape},{dataId:pe.complexTensorInfos.real.dataId,dtype:pe.complexTensorInfos.real.dtype,shape:ae.shape},{dataId:pe.complexTensorInfos.imag.dataId,dtype:pe.complexTensorInfos.imag.dtype,shape:ae.shape}],Le=V.runWebGLProgram(ve,Me,"float32"),Ue=V.runWebGLProgram(we,Me,"float32"),Ge=eM({inputs:{real:Le,imag:Ue},backend:V});return V.disposeIntermediateTensorInfo(Le),V.disposeIntermediateTensorInfo(Ue),Ge}if(V.shouldExecuteOnCPU([re,ae])){const ue=V.texData.get(re.dataId),pe=V.texData.get(ae.dataId),[ve,we]=oq(re.shape,ae.shape,ue.values,pe.values,le),Me=V.makeTensorInfo(we,le),Le=V.texData.get(Me.dataId);return Le.values=ve,Me}let he;return Cd().getBool("WEBGL_PACK_BINARY_OPERATIONS")?he=new eG(QD,re.shape,ae.shape):he=new ex(QD,re.shape,ae.shape),V.runWebGLProgram(he,[re,ae],le)}const QZ={kernelName:mm,backendName:"webgl",kernelFunc:Qg};function Qo(Z,I,V){const re=[Ev(Z.shape),...Eq(Z.shape)],ae={dtype:Z.dtype,shape:re,dataId:Z.dataId},le=[Ev(I),...Eq(I)],he=new ef(le,re),ue=!0,pe=[re],ve=V.runWebGLProgram(he,[ae],Z.dtype,pe,ue);return{dataId:ve.dataId,shape:I,dtype:ve.dtype}}function Qe(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{shape:le}=re,he=V,ue=F(ae.shape),pe=l(le,ue),ve=F(pe);e(ue===ve,()=>"The new shape ("+pe+") has "+ve+" elements and the old shape ("+ae.shape+") has "+ue+" elements. The new shape and old shape must have the same number of elements.");const we=he.texData.get(ae.dataId);return we.isPacked&&!EL(ae.shape,pe)&&!(we.texture!==null&&EL(we.shape,pe))?Qo(ae,pe,he):(he.incRef(ae.dataId),{dataId:ae.dataId,shape:pe,dtype:ae.dtype})}const QQ={kernelName:mP,backendName:"webgl",kernelFunc:Qe};class Qs{constructor(I,V){this.variableNames=["x"];const{windowSize:re,batchSize:ae,inSize:le,outSize:he}=I;this.outputShape=[ae,he];const ue=Math.floor(re/4)*4,pe=re%4;let ve="sumValue += dot(values, ones);";if(V!=null){const Me=1/V;ve="sumValue += dot(values * "+(R(Me)?Me.toPrecision(2):Me)+", ones);"}let we="";le%re>0&&(we=`
        if (inIdx < 0 || inIdx >= `+le+`) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+we+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+re+`;

        float sumValue = 0.0;

        for (int i = 0; i < `+ue+`; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+ve+`
        }

        int inIdx = inOffset + `+ue+`;
        if (`+(pe===1)+`) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          `+ve+`
        } else if (`+(pe===2)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          `+ve+`
        } else if (`+(pe===3)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          `+ve+`
        }
        setOutput(sumValue);
      }
    `}}class QF{constructor(I,V){this.variableNames=["x"];const{windowSize:re,batchSize:ae,inSize:le,outSize:he}=I;this.outputShape=[ae,he];let ue="0.0",pe="";V==="prod"?ue="1.0":V==="min"?(ue="1.0 / 1e-20",pe="min"):V==="max"&&(ue="-1.0 / 1e-20",pe="max");let ve=V+"("+V+"("+V+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";V==="sum"?ve="sumValue":V==="prod"?ve="prodValue":V==="all"?ve="allValue":V==="any"&&(ve="anyValue");const we=Math.floor(re/4)*4,Me=re%4;let Le=`
      if (`+(V==="sum")+`) {
        sumValue += dot(values, ones);
      } else if (`+(V==="prod")+`) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = `+pe+`(values, minMaxValue);
        if (`+(V==="min")+" || "+(V==="max")+`) {
          minMaxValue = `+pe+`(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,Ue="vec4";V==="all"?(ue="1.0",Le=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,Ue="bvec4"):V==="any"&&(ue="0.0",Le=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,Ue="bvec4");let Ge="";le%re>0&&(Ge=`
        if (inIdx < 0 || inIdx >= `+le+`) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = `+ue+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+Ge+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+re+`;

        vec4 minMaxValue = vec4(`+ue+`);
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < `+we+`; i += 4) {
          int inIdx = inOffset + i;
          `+Ue+" values = "+Ue+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+Le+`
        }

        int inIdx = inOffset + `+we+`;
        if (`+(Me===1)+`) {
          `+Ue+" values = "+Ue+`(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          `+Le+`
        } else if (`+(Me===2)+`) {
          `+Ue+" values = "+Ue+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          `+Le+`
        } else if (`+(Me===3)+`) {
          `+Ue+" values = "+Ue+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          `+Le+`
        }
        setOutput(`+ve+`);
      }
    `}}function QI(Z){const I=[];for(;I.length===0||I[I.length-1].outSize!==1;){const V=I.length?I[I.length-1].outSize:Z[1],re=dR(V);I.push({inSize:V,windowSize:re,outSize:Math.ceil(V/re)})}return I}function Qy(Z,I,V,re){const ae=QI(Z.shape);let le=Z;for(let he=0;he<ae.length;he++){const{inSize:ue,windowSize:pe,outSize:ve}=ae[he];let we,Me;V==="mean"?we=he===0?new Qs({windowSize:pe,inSize:ue,batchSize:Z.shape[0],outSize:ve},ue):new Qs({windowSize:pe,inSize:ue,batchSize:Z.shape[0],outSize:ve}):we=new QF({windowSize:pe,inSize:ue,batchSize:Z.shape[0],outSize:ve},V),Me=le,le=re.runWebGLProgram(we,[le],I),Me.dataId!==Z.dataId&&re.disposeIntermediateTensorInfo(Me)}return le}class QA{constructor(I,V){this.variableNames=["A"];const re=new Array(I.length);for(let he=0;he<re.length;he++)re[he]=I[V[he]];this.outputShape=re,this.rank=re.length;const ae=Dz(this.rank),le=Qp(V);this.userCode=`
    void main() {
      `+ae+` resRC = getOutputCoords();
      setOutput(getA(`+le+`));
    }
    `}}function Qp(Z){const I=Z.length;if(I>6)throw Error("Transpose for rank "+I+" is not yet supported");const V=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],re=new Array(I);for(let ae=0;ae<Z.length;ae++)re[Z[ae]]=V[ae];return re.join()}class Qw{constructor(I,V){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const re=new Array(I.length);for(let we=0;we<re.length;we++)re[we]=I[V[we]];if(this.outputShape=re,this.rank=re.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");const ae=Dz(this.rank),le=eC("rc",this.rank),he=new Array(this.rank);for(let we=0;we<V.length;we++)he[V[we]]=le[we];const ue="vec2("+he.slice(-2).join()+")",pe="++"+le[this.rank-1]+" < "+re[this.rank-1],ve="getChannel(getA("+he.join()+"), "+ue+")";this.userCode=`
    void main() {
      `+ae+` rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = `+ve+`;
      if(`+pe+`) {
        result[1] = `+ve+`;
      }
      --`+le[this.rank-1]+`;
      if(++`+le[this.rank-2]+" < "+re[this.rank-2]+`) {
        result[2] = `+ve+`;
        if(`+pe+`) {
          result[3] = `+ve+`;
        }
      }
      setOutput(result);
    }
    `}}function QX(Z,I,V){const re=Cd().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qw(Z.shape,I):new QA(Z.shape,I);return V.runWebGLProgram(re,[Z],Z.dtype)}function Qc(Z,I,V,re){const ae=I,le=Z.shape.length,he=n(ae,Z.shape);let ue=he;const pe=tW(ue,le),ve=pe!=null;let we=Z;ve&&(we=QX(Z,pe,re),ue=tK(ue.length,le)),tc("sum",ue,le);const[Me,Le]=tw(we.shape,ue);let Ue=Me;V&&(Ue=tX(Me,he));const Ge=F(Le),ze=F(Z.shape)/Ge,He=Qe({inputs:{x:we},attrs:{shape:[ze,Ge]},backend:re}),Ke=JP(Z.dtype),Ye=Qy(He,Ke,"sum",re),$e=Qe({inputs:{x:Ye},attrs:{shape:Ue},backend:re});return re.disposeIntermediateTensorInfo(He),re.disposeIntermediateTensorInfo(Ye),ve&&re.disposeIntermediateTensorInfo(we),$e}function QW(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{axis:le,keepDims:he}=re;return Qc(ae,le,he,V)}const QR={kernelName:my,backendName:"webgl",kernelFunc:QW};function QK(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{perm:le}=re,he=V,ue=ae.shape.length,pe=new Array(ue);for(let we=0;we<pe.length;we++)pe[we]=ae.shape[le[we]];let ve;if(he.shouldExecuteOnCPU([ae])){const we=he.texData.get(ae.dataId).values,Me=e8(we,ae.shape,ae.dtype,le,pe);ve=he.makeTensorInfo(pe,ae.dtype);const Le=he.texData.get(ve.dataId);Le.values=Me}else ve=QX(ae,le,he);return ve}const QT={kernelName:mK,backendName:"webgl",kernelFunc:QK},Qv=1e3;function Qq({a:Z,b:I,transposeA:V,transposeB:re,backend:ae,bias:le=null,preluActivationWeights:he=null,leakyreluAlpha:ue=0,activation:pe=null}){const ve=Z.shape.length,we=I.shape.length,Me=V?Z.shape[ve-2]:Z.shape[ve-1],Le=re?I.shape[we-1]:I.shape[we-2],Ue=V?Z.shape[ve-1]:Z.shape[ve-2],Ge=re?I.shape[we-2]:I.shape[we-1],ze=Z.shape.slice(0,-2),He=I.shape.slice(0,-2),Ke=F(ze),Ye=F(He),$e=iH(Z.shape.slice(0,-2),I.shape.slice(0,-2)).concat([Ue,Ge]);e(Me===Le,()=>"Error in matMul: inner shapes ("+Me+") and ("+Le+") of Tensors with shapes "+Z.shape+" and "+I.shape+" and transposeA="+V+" and transposeB="+re+" must match.");const je=V?[Ke,Me,Ue]:[Ke,Ue,Me],rt=re?[Ye,Ge,Le]:[Ye,Le,Ge],at=Qe({inputs:{x:Z},backend:ae,attrs:{shape:je}}),Rt=Qe({inputs:{x:I},backend:ae,attrs:{shape:rt}}),lt=[at,Rt],kt=Math.max(Ke,Ye),qt=V?at.shape[1]:at.shape[2],Kt=le!=null,_i=he!=null,ci=pe==="leakyrelu",li=pe!=null?Q6(pe,!0):null,qi=Kt||_i||ci||li!=null;let Ki;if((Ue===1||Ge===1)&&qt>Qv&&qi===!1){let Yi=at,ns=Rt;V&&(Yi=QK({inputs:{x:at},backend:ae,attrs:{perm:[0,2,1]}}),lt.push(Yi)),re&&(ns=QK({inputs:{x:Rt},backend:ae,attrs:{perm:[0,2,1]}}),lt.push(ns));const Gs=Ge!==1,Xs=Ge===1;let $i=Yi;Gs&&($i=Qe({inputs:{x:Yi},backend:ae,attrs:{shape:[kt,qt,1]}}),lt.push($i));const xs=Ge===1?2:1;let hi=ns;Xs&&(hi=Qe({inputs:{x:ns},backend:ae,attrs:{shape:[kt,1,qt]}}),lt.push(hi));const Ri=Qg({inputs:{a:$i,b:hi},backend:ae});Ki=QW({inputs:{x:Ri},backend:ae,attrs:{axis:xs,keepDims:!0}}),lt.push(Ri)}else{const Yi=Jb(Z.dtype,I.dtype),ns=new Qb(je,rt,[kt,Ue,Ge],V,re,Kt,li,_i,ci),Gs=[at,Rt];if(le!=null&&Gs.push(le),_i&&Gs.push(he),ci){const Xs=ae.makeTensorInfo([],"float32",Nn(ue,"float32"));Gs.push(Xs),lt.push(Xs)}Ki=ae.runWebGLProgram(ns,Gs,Yi)}const hs=Qe({inputs:{x:Ki},backend:ae,attrs:{shape:$e}});lt.push(Ki);for(const Yi of lt)ae.disposeIntermediateTensorInfo(Yi);return hs}function Ql(Z){const{inputs:I,backend:V,attrs:re}=Z,{a:ae,b:le}=I,{transposeA:he,transposeB:ue}=re;return Qq({a:ae,b:le,transposeA:he,transposeB:ue,backend:V})}const Qa={kernelName:CF,backendName:"webgl",kernelFunc:Ql},Qn="return float(a != b);",QL=Q5({opSnippet:Qn,cpuKernelImpl:oa,dtype:"bool"});function QH(Z){const{inputs:I,backend:V}=Z,{input:re}=I,ae=V.texData.get(re.dataId);return eu({inputs:{x:ae.complexTensorInfos.real},backend:V})}const Qk="return float(int(x));";function Qz(Z,I){const V=new eP(Z.shape,Qk),re=I.runWebGLProgram(V,[Z],"int32");return{dataId:re.dataId,shape:re.shape,dtype:re.dtype}}function Qx(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{dtype:le}=re;if(le==="complex64"){if(ae.dtype==="complex64")return eu({inputs:{x:ae},backend:V});const he=BQ(ae.shape),ue=Qx({inputs:{x:ae},backend:V,attrs:{dtype:"float32"}}),pe=eM({inputs:{real:ue,imag:he},backend:V});return he.dispose(),V.disposeIntermediateTensorInfo(ue),pe}if(ae.dtype==="complex64"){const he=QH({inputs:{input:ae},backend:V}),ue=Qx({inputs:{x:he},backend:V,attrs:{dtype:le}});return V.disposeIntermediateTensorInfo(he),ue}if(!Y(ae.dtype,le)){const he=eu({inputs:{x:ae},backend:V});return{dataId:he.dataId,shape:he.shape,dtype:le}}if(V.shouldExecuteOnCPU([ae])){const he=V.texData.get(ae.dataId).values,[ue,pe,ve]=og(he,ae.shape,ae.dtype,le);return V.makeTensorInfo(ue,pe,ve)}if(le==="int32")return Qz(ae,V);if(le==="bool"){const he=V.makeTensorInfo([],"bool",H("bool",1)),ue=QL({inputs:{a:ae,b:he},backend:V});return V.disposeIntermediateTensorInfo(he),ue}throw new Error("Error in Cast: failed to cast "+ae.dtype+" to "+le)}const QU={kernelName:CA,backendName:"webgl",kernelFunc:Qx};class QG{constructor(I){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=I,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class Qu{constructor(I){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=I,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function QY(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{clipValueMin:le,clipValueMax:he}=re;let ue;Cd().getBool("WEBGL_PACK_CLIP")?ue=new Qu(ae.shape):ue=new QG(ae.shape);const pe=[[le],[he]];return V.runWebGLProgram(ue,[ae],ae.dtype,pe)}const QM={kernelName:Cp,backendName:"webgl",kernelFunc:QY};class Qh{constructor(I){this.outputShape=[],this.outputShape=dy(I,1),this.variableNames=I.map((he,ue)=>"T"+ue);const V=new Array(I.length-1);V[0]=I[0][1];for(let he=1;he<V.length;he++)V[he]=V[he-1]+I[he][1];const re=["if (yC < "+V[0]+") setOutput(getT0(yR, yC));"];for(let he=1;he<V.length;he++){const ue=V[he-1];re.push("else if (yC < "+V[he]+") setOutput(getT"+he+"(yR, yC-"+ue+"));")}const ae=V.length,le=V[V.length-1];re.push("else setOutput(getT"+ae+"(yR, yC-"+le+"));"),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        `+re.join(`
        `)+`
      }
    `}}class Qj{constructor(I,V){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=dy(I,V);const re=this.outputShape,ae=re.length,le=Dz(ae),he=em("coords",ae),ue=["x","y","z","w","u","v"].slice(0,ae);this.variableNames=I.map((ze,He)=>"T"+He);const pe=new Array(I.length-1);pe[0]=I[0][V];for(let ze=1;ze<pe.length;ze++)pe[ze]=pe[ze-1]+I[ze][V];const ve=ue[V],we=ue.slice(-2),Me=ue.join();let Le="if ("+ve+" < "+pe[0]+`) {
        return getChannel(
            getT0(`+Me+"), vec2("+we.join()+`));
        }`;for(let ze=1;ze<pe.length;ze++){const He=pe[ze-1];Le+=`
        if (`+ve+" < "+pe[ze]+"  && "+ve+" >= "+pe[ze-1]+`) {
          return getChannel(
            getT`+ze+"("+Qr(ue,ve,He)+`),
            vec2(`+Qr(we,ve,He)+`));
        }`}const Ue=pe.length,Ge=pe[pe.length-1];Le+=`
        return getChannel(
          getT`+Ue+"("+Qr(ue,ve,Ge)+`),
          vec2(`+Qr(we,ve,Ge)+"));",this.userCode=`
      float getValue(`+ue.map(ze=>"int "+ze)+`) {
        `+Le+`
      }

      void main() {
        `+le+` coords = getOutputCoords();
        vec4 result = vec4(getValue(`+he+`), 0., 0., 0.);

        `+he[ae-1]+" = "+he[ae-1]+` + 1;
        if (`+he[ae-1]+" < "+re[ae-1]+`) {
          result.g = getValue(`+he+`);
        }

        `+he[ae-2]+" = "+he[ae-2]+` + 1;
        if (`+he[ae-2]+" < "+re[ae-2]+`) {
          result.a = getValue(`+he+`);
        }

        `+he[ae-1]+" = "+he[ae-1]+` - 1;
        if (`+he[ae-2]+" < "+re[ae-2]+` &&
            `+he[ae-1]+" < "+re[ae-1]+`) {
          result.b = getValue(`+he+`);
        }
        setOutput(result);
      }
    `}}function Qr(Z,I,V){const re=Z.indexOf(I);return Z.map((ae,le)=>le===re?ae+" - "+V:ae).join()}function s0(Z){const{inputs:I,backend:V}=Z,{input:re}=I,ae=V.texData.get(re.dataId);return eu({inputs:{x:ae.complexTensorInfos.imag},backend:V})}function s1(Z,I,V){const re=Z[0].dtype;if(re==="complex64"){const Ue=Z.map(Ye=>QH({inputs:{input:Ye},backend:V})),Ge=Z.map(Ye=>s0({inputs:{input:Ye},backend:V})),ze=s1(Ue,I,V),He=s1(Ge,I,V),Ke=eM({inputs:{real:ze,imag:He},backend:V});return Ue.forEach(Ye=>V.disposeIntermediateTensorInfo(Ye)),Ge.forEach(Ye=>V.disposeIntermediateTensorInfo(Ye)),V.disposeIntermediateTensorInfo(ze),V.disposeIntermediateTensorInfo(He),Ke}let ae=V.shouldExecuteOnCPU(Z);if(re==="string"&&(ae=!0),ae){const Ue=Z.map(je=>{const rt=[-1,F(je.shape.slice(I))];return Qe({inputs:{x:je},backend:V,attrs:{shape:rt}})}),Ge=Ue.map(je=>({vals:V.readSync(je.dataId),shape:je.shape})),ze=dy(Ue.map(je=>je.shape),1),He=Ue[0].shape[0]===1,Ke=oo(Ge,ze,re,He),Ye=dy(Z.map(je=>je.shape),I),$e=V.makeTensorInfo(Ye,re,Ke);return Ue.forEach(je=>V.disposeIntermediateTensorInfo(je)),$e}const le=Z.filter(Ue=>F(Ue.shape)>0),he=Cd().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&le[0].shape.length>1;if(le.length===1){const Ue=he?new eP(Z[0].shape,eQ):new ew(Z[0].shape,eQ);return V.runWebGLProgram(Ue,Z,re)}const ue=Cd().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(le.length>ue){const Ue=[];for(let ze=0;ze<le.length;ze+=ue){const He=le.slice(ze,ze+ue);Ue.push(s1(He,I,V))}const Ge=s1(Ue,I,V);for(const ze of Ue)V.disposeIntermediateTensorInfo(ze);return Ge}if(he){const Ue=new Qj(le.map(Ge=>Ge.shape),I);return V.runWebGLProgram(Ue,le,re)}const{tensors2D:pe,outShape:ve}=s2(le,I,V),we=new Qh(pe.map(Ue=>Ue.shape)),Me=V.runWebGLProgram(we,pe,re);pe.forEach(Ue=>V.disposeIntermediateTensorInfo(Ue));const Le=Qe({inputs:{x:Me},attrs:{shape:ve},backend:V});return V.disposeIntermediateTensorInfo(Me),Le}function s2(Z,I,V){const re=dy(Z.map(ae=>ae.shape),I);return{tensors2D:Z.map(ae=>Qe({inputs:{x:ae},attrs:{shape:[-1,F(ae.shape.slice(I))]},backend:V})),outShape:re}}function s3(Z){const{inputs:I,backend:V,attrs:re}=Z,{axis:ae}=re,le=n(ae,I[0].shape)[0],he=I.map(ve=>ve.shape);dI(he,le);const ue=dy(I.map(ve=>ve.shape),le);if(F(ue)===0)return V.makeTensorInfo(ue,I[0].dtype,[]);const pe=I.filter(ve=>F(ve.shape)>0);return pe.length===1?eu({inputs:{x:pe[0]},backend:V}):s1(pe,le,V)}const s4={kernelName:Cc,backendName:"webgl",kernelFunc:s3};class s5{constructor(I,V=!1,re=null,ae=!1,le=!1){this.variableNames=["x","W"],this.outputShape=I.outShape;const he=I.padInfo.top,ue=I.padInfo.left,pe=I.strideHeight,ve=I.strideWidth,we=I.dilationHeight,Me=I.dilationWidth,Le=I.filterHeight,Ue=I.filterWidth,Ge=Math.floor(I.inChannels/4)*4,ze=I.inChannels%4,He=I.dataFormat==="channelsLast",Ke=He?1:2,Ye=He?2:3,$e=He?3:1;let je="",rt="";re&&(ae?je=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+re+`
        }`:le?je=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+re+`
        }`:je=`
          float activation(float x) {
            `+re+`
          }
        `,rt="result = activation(result);");const at=V?"result += getBiasAtOutCoords();":"";V&&this.variableNames.push("bias"),ae&&this.variableNames.push("preluActivationWeights"),le&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+je+`

      const ivec2 strides = ivec2(`+pe+", "+ve+`);
      const ivec2 pads = ivec2(`+he+", "+ue+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[`+$e+`];

        ivec2 xRCCorner =
            ivec2(coords[`+Ke+"], coords["+Ye+`]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+Le+`; wR++) {
          int xR = xRCorner + wR * `+we+`;

          if (xR < 0 || xR >= `+I.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+Ue+`; wC++) {
            int xC = xCCorner + wC * `+Me+`;

            if (xC < 0 || xC >= `+I.inWidth+`) {
              continue;
            }

            for (int d1 = 0; d1 < `+Ge+`; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (`+He+`) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (`+(ze===1)+`) {

              if (`+He+`) {
                dotProd +=
                    getX(batch, xR, xC, `+Ge+`) *
                    getW(wR, wC, `+Ge+`, d2);
              } else {
                dotProd +=
                    getX(batch, `+Ge+`, xR, xC) *
                    getW(wR, wC, `+Ge+`, d2);
              }

            } else if (`+(ze===2)+`) {
              vec2 wValues = vec2(
                getW(wR, wC, `+Ge+`, d2),
                getW(wR, wC, `+Ge+` + 1, d2)
              );

              if (`+He+`) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, `+Ge+`),
                  getX(batch, xR, xC, `+Ge+` + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, `+Ge+`, xR, xC),
                  getX(batch, `+Ge+` + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (`+(ze===3)+`) {
              vec3 wValues = vec3(
                getW(wR, wC, `+Ge+`, d2),
                getW(wR, wC, `+Ge+` + 1, d2),
                getW(wR, wC, `+Ge+` + 2, d2)
              );

              if (`+He+`) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, `+Ge+`),
                  getX(batch, xR, xC, `+Ge+` + 1),
                  getX(batch, xR, xC, `+Ge+` + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, `+Ge+`, xR, xC),
                  getX(batch, `+Ge+` + 1, xR, xC),
                  getX(batch, `+Ge+` + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        `+at+`
        `+rt+`
        setOutput(result);
      }
    `}}class s6{constructor(I,V=!1,re=null,ae=!1,le=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=I.outShape,this.enableShapeUniforms=Dr(this.outputShape.length);const he=I.padInfo.left,ue=I.strideWidth,pe=I.dilationWidth,ve=I.filterHeight,we=I.filterWidth,Me=we;let Le=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let He=0;He<we;He++)Le+=`
           vec4 xTexelC`+He*2+`;
           int xTexelC`+He*2+`Ready;
           vec4 xTexelC`+(He*2+1)+`;
           int xTexelC`+(He*2+1)+`Ready;
           vec4 xC`+He+";";Le+=`
     for (int r = 0; r < `+ve+`; r++) {
      for (int d1 = 0; d1 < `+I.inChannels+`; d1 += 2) {
       `;for(let He=0;He<we;He++)Le+=`
           xTexelC`+He*2+` = vec4(0.0);
           xTexelC`+He*2+`Ready = 0;
           xTexelC`+(He*2+1)+` = vec4(0.0);
           xTexelC`+(He*2+1)+`Ready = 0;
           xC`+He+" = vec4(0.0);";Le+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let He=0;He<(Me+1)/2;He++){const Ke=He*2;if(Le+=`
           xC = xCCorner + `+Ke*pe+`;
           `,ue===1){if(Ke<we&&(he%2===1?(Le+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Ke+`Ready == 0) {
                   xTexelC`+Ke+` = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+Ke+`.zw = vec2(0.0);
                   }
                   xTexelC`+Ke+`Ready = 1;
                 }
               `,pe===1&&Ke>0?Le+=`
                 xC`+Ke+" = vec4(xTexelC"+(Ke-2)+".zw, xTexelC"+Ke+`.xy);
                 `:Le+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC`+Ke+" = vec4(previous.zw, xTexelC"+Ke+`.xy);
                   } else {
                     xC`+Ke+" = vec4(0.0, 0.0, xTexelC"+Ke+`.xy);
                   }
                   `):Le+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC`+Ke+`Ready == 0) {
                   xTexelC`+Ke+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+Ke+`.zw = vec2(0.0);
                   }
                   xTexelC`+Ke+`Ready = 1;
                 }

                 xC`+Ke+" = xTexelC"+Ke+`;
                 `,Ke+1<we)){const Ye=he%2===0?B(pe):pe;pe%2===0&&he%2===1||pe%2!==0&&he%2!==1?(Le+=`
                   xCOffset = xC + imod(pads[1], 2) + `+Ye+`;

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Ke+1)+`Ready == 0) {
                     xTexelC`+(Ke+1)+` = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC`+(Ke+1)+`.zw = vec2(0.0);
                     }
                     xTexelC`+(Ke+1)+`Ready = 1;
                   }
                   `,pe>1?Le+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC`+(Ke+1)+" = vec4(previous.zw, xTexelC"+(Ke+1)+`.xy);
                     } else {
                      xC`+(Ke+1)+" = vec4(0.0, 0.0, xTexelC"+(Ke+1)+`.xy);
                     }
                     `:Le+=`
                     xC`+(Ke+1)+" = vec4(xTexelC"+Ke+".zw, xTexelC"+(Ke+1)+`.xy);
                     `):Ye===1?Le+=`
                     xC`+(Ke+1)+" = xTexelC"+Ke+`;
                     `:Le+=`
                     xCOffset = xC + `+Ye+`;

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Ke+1)+`Ready == 0) {
                       xTexelC`+(Ke+1)+` = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC`+(Ke+1)+`.zw = vec2(0.0);
                       }
                       xTexelC`+(Ke+1)+`Ready = 1;
                     }

                     xC`+(Ke+1)+" = xTexelC"+(Ke+1)+`;
                     `}}else Ke<we&&(he%2===1?(Le+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Ke+`Ready == 0) {
                   xTexelC`+Ke+` = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+Ke+`.zw = vec2(0.0);
                   }
                   xTexelC`+Ke+`Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(Ke+1)+`Ready == 0) {
                   xTexelC`+(Ke+1)+` = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC`+(Ke+1)+`.zw = vec2(0.0);
                   }
                   xTexelC`+(Ke+1)+`Ready = 1;
                 }

                 xC`+Ke+" = vec4(xTexelC"+Ke+".zw, xTexelC"+(Ke+1)+`.zw);
               `,Ke+1<we&&(Le+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC`+(Ke+1)+" = vec4(xTexelC"+(Ke+1)+`.xy, final.xy);
                 `)):(Le+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC`+Ke+`Ready == 0) {
                   xTexelC`+Ke+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+Ke+`.zw = vec2(0.0);
                   }
                   xTexelC`+Ke+`Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Ke+1)+`Ready == 0) {
                   xTexelC`+(Ke+1)+` = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+(Ke+1)+`.zw = vec2(0.);
                   }
                   xTexelC`+(Ke+1)+`Ready = 1;
                 }

                 xC`+Ke+` = vec4(
                   xTexelC`+Ke+".xy, xTexelC"+(Ke+1)+`.xy);
               `,Ke+1<we&&(Le+=`
                   xC`+(Ke+1)+" = vec4(xTexelC"+Ke+".zw, xTexelC"+(Ke+1)+`.zw);
                 `)));Ke<we&&(Le+=`
             wTexel = getW(r, `+Ke+`, d1, d2);
             dotProd += xC`+Ke+`.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < `+I.inChannels+`) {
               dotProd += xC`+Ke+`.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,Ke+1<we&&(Le+=`
               wTexel = getW(r, `+(Ke+1)+`, d1, d2);
               dotProd += xC`+(Ke+1)+`.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < `+I.inChannels+`) {
                 dotProd += xC`+(Ke+1)+`.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}Le+=`
     }
   `,Le+=`
     }
   `,Le+=`
     }
   `;let Ue="",Ge="";re&&(ae?Ue=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           `+re+`
         }`:le?Ue=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           `+re+`
         }`:Ue=`vec4 activation(vec4 x) {
           `+re+`
         }`,Ge="result = activation(result);");const ze=V?"result += getBiasAtOutCoords();":"";V&&this.variableNames.push("bias"),ae&&this.variableNames.push("preluActivationWeights"),le&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       `+Ue+`

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         `+Le+`

         vec4 result = dotProd - vec4(0.000000000000001);
         `+ze+`
         `+Ge+`
         setOutput(result);
       }
     `}}class s7{constructor(I,V){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=I,this.enableShapeUniforms=Dr(this.outputShape.length);const{dataFormat:re}=V,ae=D2(),le=re==="channelsLast",he=le?1:2,ue=le?2:3,pe=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < "+I[2]+" && pos < "+I[1]+") {";let ve="";for(let we=0;we<=1;we++)for(let Me=0;Me<=1;Me++)ve+=`
          blockIndex = rc.z + `+Me+`;
          pos = rc.y + `+we+`;

          `+pe+`
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[`+he+`] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[`+ue+`] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (`+le+`) {
                  innerDims = vec2(d1, ch);
                  result[`+(we*2+Me)+`] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[`+(we*2+Me)+`] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        `+ve+`

        `+ae.output+` = result;
      }
    `}}function s8(Z,I){const V=Z.length;return V>=3?I?[...Z.slice(0,-3),Z[V-3]*Z[V-2],Z[V-1]]:[...Z.slice(0,-3),Z[V-3],Z[V-2]*Z[V-1]]:!I&&V===1&&Z[0]>1?[Z[0],1]:null}function s9({x:Z,filter:I,convInfo:V,backend:re,bias:ae=null,preluActivationWeights:le=null,leakyreluAlpha:he=0,activation:ue=null}){const pe=Z.shape,ve=re.texData.get(Z.dataId),we=V.inChannels,Me=pe[0]*pe[1]*pe[2],Le=V.outChannels,Ue=V.dataFormat==="channelsLast",Ge=!1,ze=!1;let He;const Ke=[];if(le!=null){const Ye=s8(le.shape,Ue);Ye!=null&&(le=Qe({inputs:{x:le},backend:re,attrs:{shape:Ye}}),Ke.push(le))}if(ae!=null){const Ye=s8(ae.shape,Ue);Ye!=null&&(ae=Qe({inputs:{x:ae},backend:re,attrs:{shape:Ye}}),Ke.push(ae))}if(!((Me===1||Le===1)&&we>Qv)&&ve.isPacked&&Ue&&ve.texture!=null&&pe[2]%2!==0&&X(ve.shape.slice(-3),pe.slice(-3))){const Ye=pe[0]*pe[1]*(pe[2]+1),$e={dataId:Z.dataId,shape:[1,Ye,V.inChannels],dtype:Z.dtype},je=ve.shape;ve.shape=ve.shape.slice(),ve.shape[ve.shape.length-2]++,e(EL(ve.shape,$e.shape),()=>"packed reshape "+ve.shape+" to "+$e.shape+" isn't free");const rt=Qe({inputs:{x:I},backend:re,attrs:{shape:[1,V.inChannels,V.outChannels]}});Ke.push(rt);const at=Qq({a:$e,b:rt,backend:re,transposeA:Ge,transposeB:ze,bias:ae,activation:ue,preluActivationWeights:le,leakyreluAlpha:he}),Rt=re.texData.get(at.dataId);e(Rt.isPacked,()=>"batchMatMul result is expected to be packed"),ve.shape=je,Rt.shape=V.outShape,He=eu({inputs:{x:at},backend:re}),He.shape=V.outShape,Ke.push(at)}else{const Ye=V.outHeight*V.outWidth,$e=Qe({inputs:{x:Z},backend:re,attrs:{shape:Ue?[V.batchSize,Ye,V.inChannels]:[V.batchSize,V.inChannels,Ye]}}),je=Qe({inputs:{x:I},backend:re,attrs:{shape:[1,V.inChannels,V.outChannels]}}),rt=Qq({a:Ue?$e:je,b:Ue?je:$e,transposeA:!Ue,transposeB:ze,backend:re,bias:ae,activation:ue,preluActivationWeights:le,leakyreluAlpha:he});He=Qe({inputs:{x:rt},backend:re,attrs:{shape:V.outShape}}),Ke.push($e),Ke.push(je),Ke.push(rt)}for(const Ye of Ke)re.disposeIntermediateTensorInfo(Ye);return He}function sC({x:Z,filter:I,convInfo:V,backend:re,bias:ae=null,preluActivationWeights:le=null,leakyreluAlpha:he=0,activation:ue=null}){const{filterWidth:pe,filterHeight:ve,inChannels:we,outWidth:Me,outHeight:Le,dataFormat:Ue}=V,Ge=Ue==="channelsLast",ze=pe*ve*we,He=Le*Me,Ke=[V.batchSize,ze,He],Ye=!0,$e=!1,je=[];if(le!=null){const Yi=s8(le.shape,Ge);Yi!=null&&(le=Qe({inputs:{x:le},backend:re,attrs:{shape:Yi}}),je.push(le))}if(ae!=null){const Yi=s8(ae.shape,Ge);Yi!=null&&(ae=Qe({inputs:{x:ae},backend:re,attrs:{shape:Yi}}),je.push(ae))}const rt=Qe({inputs:{x:I},backend:re,attrs:{shape:[1,ze,F(I.shape)/ze]}});je.push(rt);const at=new s7(Ke,V),Rt=[Z.shape,[V.padInfo.top,V.padInfo.left],[V.strideHeight,V.strideWidth],[V.dilationHeight,V.dilationWidth],[V.inChannels],[V.filterWidth*V.inChannels],[V.outWidth]],lt=re.runWebGLProgram(at,[Z],"float32",Rt),kt=Qe({inputs:{x:lt},backend:re,attrs:{shape:Ke}});je.push(lt),je.push(kt);const qt=ae!=null,Kt=le!=null,_i=ue==="leakyrelu",ci=ue?Q6(ue,!0):null,li=new Qb(Ge?kt.shape:rt.shape,Ge?rt.shape:kt.shape,Ge?[V.batchSize,He,V.outChannels]:[V.batchSize,V.outChannels,He],Ye,$e,qt,ci,Kt,_i),qi=Ge?[kt,rt]:[rt,kt];if(ae&&qi.push(ae),Kt&&qi.push(le),_i){const Yi=re.makeTensorInfo([],"float32",Nn(he,"float32"));qi.push(Yi),je.push(Yi)}const Ki=re.runWebGLProgram(li,qi,"float32"),hs=Qe({inputs:{x:Ki},backend:re,attrs:{shape:V.outShape}});je.push(Ki);for(const Yi of je)re.disposeIntermediateTensorInfo(Yi);return hs}function sm(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,filter:le}=I,{strides:he,pad:ue,dataFormat:pe,dilations:ve,dimRoundingMode:we}=re,Me=OL(pe),Le=OA(ae.shape,le.shape,he,ve,ue,we,!1,Me);let Ue;if(Le.filterHeight===1&&Le.filterWidth===1&&Le.dilationHeight===1&&Le.dilationWidth===1&&Le.strideHeight===1&&Le.strideWidth===1&&(Le.padInfo.type==="SAME"||Le.padInfo.type==="VALID"))Ue=s9({x:ae,filter:le,convInfo:Le,backend:V});else if(Le.strideWidth<=2&&Me==="channelsLast"&&Cd().getBool("WEBGL_EXP_CONV")){const ze=new s6(Le),He=[[Le.padInfo.top,Le.padInfo.left],[Le.strideHeight,Le.strideWidth],[Le.dilationHeight,Le.dilationWidth],[Le.inHeight,Le.inWidth]];Ue=V.runWebGLProgram(ze,[ae,le],"float32",He)}else if(Cd().getBool("WEBGL_CONV_IM2COL"))Ue=sC({x:ae,filter:le,convInfo:Le,backend:V});else{const ze=new s5(Le);Ue=V.runWebGLProgram(ze,[ae,le],"float32")}const Ge=Qe({inputs:{x:Ue},backend:V,attrs:{shape:Le.outShape}});return V.disposeIntermediateTensorInfo(Ue),Ge}const sN={kernelName:CW,backendName:"webgl",kernelFunc:sm};class sJ{constructor(I){this.variableNames=["dy","W"],this.outputShape=I.inShape;const V=I.filterHeight,re=I.filterWidth,ae=I.strideHeight,le=I.strideWidth,he=I.dataFormat==="channelsLast",ue=V-1-I.padInfo.top,pe=re-1-I.padInfo.left,ve=he?1:2,we=he?2:3,Me=he?3:1;this.userCode=`
      const ivec2 pads = ivec2(`+ue+", "+pe+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[`+Me+`];

        ivec2 dyCorner = ivec2(coords[`+ve+"], coords["+we+`]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+V+`; wR++) {
          float dyR = float(dyRCorner + wR) / `+ae+`.0;

          if (dyR < 0.0 || dyR >= `+I.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = `+V+` - 1 - wR;

          for (int wC = 0; wC < `+re+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+le+`.0;

            if (dyC < 0.0 || dyC >= `+I.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = `+re+` - 1 - wC;

            for (int d2 = 0; d2 < `+I.outChannels+`; d2++) {

              if (`+he+`) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class sf{constructor(I){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=I.inShape,this.enableShapeUniforms=Dr(this.outputShape.length);const V=I.filterHeight,re=I.filterWidth,ae=V-1-I.padInfo.top,le=re-1-I.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(`+ae+", "+le+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < `+V+`; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= `+I.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = `+V+` - 1 - wR;

          for (int wC = 0; wC < `+re+`; wC++) {
            int wCPerm = `+re+` - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < `+I.outWidth+`.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < `+I.outWidth+`.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < `+I.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < `+I.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < `+I.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function si(Z){const{inputs:I,backend:V,attrs:re}=Z,{dy:ae,filter:le}=I,{inputShape:he,strides:ue,pad:pe,dataFormat:ve,dimRoundingMode:we}=re,Me=OL(ve),Le=OA(he,le.shape,ue,1,pe,we,!1,Me);if(Cd().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&Me==="channelsLast"){const Ue=[[Le.strideHeight,Le.strideWidth]],Ge=new sf(Le);return V.runWebGLProgram(Ge,[ae,le],"float32",Ue)}else{const Ue=new sJ(Le);return V.runWebGLProgram(Ue,[ae,le],"float32")}}const sO={kernelName:CK,backendName:"webgl",kernelFunc:si},st=Q3+`
  return cos(x);
`,sB=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  `+eU+`
  return result;
`,sS=Q4({opSnippet:st,packedOpSnippet:sB}),sd={kernelName:CT,backendName:"webgl",kernelFunc:sS};class sV{constructor(I,V,re,ae,le){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[he,ue,pe,ve]=I,[we]=V,[Me,Le]=re;this.outputShape=[we,Me,Le,ve];const Ue=ae==="bilinear"?1:0,[Ge,ze]=[ue-1+".0",pe-1+".0"],[He,Ke,Ye]=Me>1?[""+(ue-1)/(Me-1),"(y2-y1) * height_ratio","y1*"+Ge+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+Ge],[$e,je,rt]=Le>1?[""+(pe-1)/(Le-1),"(x2-x1) * width_ratio","x1*"+ze+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+ze];this.userCode=`
      const float height_ratio = float(`+He+`);
      const float width_ratio = float(`+$e+`);
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= `+he+`) {
          return;
        }

        float height_scale = `+Ke+`;
        float width_scale = `+je+`;

        float in_y = `+Ye+`;
        if( in_y < 0.0 || in_y > `+Ge+` ) {
          setOutput(float(`+le+`));
          return;
        }
        float in_x = `+rt+`;
        if( in_x < 0.0 || in_x > `+ze+` ) {
          setOutput(float(`+le+`));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(`+Ue+` == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const sb=Z=>{const{inputs:I,backend:V,attrs:re}=Z,{image:ae,boxes:le,boxInd:he}=I,{cropSize:ue,method:pe,extrapolationValue:ve}=re,we=new sV(ae.shape,le.shape,ue,pe,ve);return V.runWebGLProgram(we,[ae,le,he],"float32")},sP={kernelName:Cv,backendName:"webgl",kernelFunc:sb};class sE{constructor(I,V,re){this.variableNames=["x"],this.outputShape=[],this.outputShape=I,this.blockSize=V,this.dataFormat=re,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = `+this.getHeightCoordString()+`;
      int w = `+this.getWidthCoordString()+`;
      int d = `+this.getDepthCoordString()+`;

      int in_h = h / `+V+`;
      int offset_h = imod(h, `+V+`);
      int in_w = w / `+V+`;
      int offset_w = imod(w, `+V+`);
      int offset_d = (offset_h * `+V+` + offset_w) *
        `+this.getOutputDepthSize()+`;
      int in_d = d + offset_d;

      float result = `+this.getInputSamplingString()+`;
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function sD(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{blockSize:le,dataFormat:he}=re,ue=ae.shape[0],pe=he==="NHWC"?ae.shape[1]:ae.shape[2],ve=he==="NHWC"?ae.shape[2]:ae.shape[3],we=he==="NHWC"?ae.shape[3]:ae.shape[1],Me=pe*le,Le=ve*le,Ue=we/(le*le),Ge=he==="NHWC"?[ue,Me,Le,Ue]:[ue,Ue,Me,Le],ze=new sE(Ge,le,he);return V.runWebGLProgram(ze,[ae],ae.dtype)}const sg={kernelName:Cq,backendName:"webgl",kernelFunc:sD};class sZ{constructor(I,V=!1,re=null,ae=!1,le=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=I.outShape,this.enableShapeUniforms=Dr(this.outputShape.length);const he=I.filterHeight,ue=I.filterWidth,pe=I.outChannels/I.inChannels;let ve="",we="";re&&(ae?ve=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+re+`
        }`:le?ve=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+re+`
        }`:ve=`
          float activation(float x) {
            `+re+`
          }
        `,we="result = activation(result);");const Me=V?"result += getBiasAtOutCoords();":"";V&&this.variableNames.push("bias"),ae&&this.variableNames.push("preluActivationWeights"),le&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+ve+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+pe+`;
        int q = d2 - d1 * `+pe+`;

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < `+he+`; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < `+ue+`; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        `+Me+`
        `+we+`
        setOutput(result);
      }
    `}}class so{constructor(I,V=!1,re=null,ae=!1,le=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=I.outShape,this.enableShapeUniforms=Dr(this.outputShape.length);const he=I.outChannels/I.inChannels,ue=I.padInfo.left,pe=I.strideWidth,ve=I.dilationWidth,we=I.filterHeight,Me=I.filterWidth,Le=Me;let Ue=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let Ke=0;Ke<Me;Ke++)Ue+=`
          vec4 xTexelC`+Ke*2+`;
          int xTexelC`+Ke*2+`Ready;
          vec4 xTexelC`+(Ke*2+1)+`;
          int xTexelC`+(Ke*2+1)+`Ready;
          vec4 xC`+Ke+";";Ue+=`
    for (int r = 0; r < `+we+`; r++) {
      `;for(let Ke=0;Ke<Me;Ke++)Ue+=`
          xTexelC`+Ke*2+` = vec4(0.0);
          xTexelC`+Ke*2+`Ready = 0;
          xTexelC`+(Ke*2+1)+` = vec4(0.0);
          xTexelC`+(Ke*2+1)+`Ready = 0;
          xC`+Ke+" = vec4(0.0);";Ue+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let Ke=0;Ke<(Le+1)/2;Ke++){const Ye=Ke*2;if(Ue+=`
          xC = xCCorner + `+Ye*ve+`;
          `,pe===1){if(Ye<Me&&(ue%2===1?(Ue+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Ye+`Ready == 0) {
                  xTexelC`+Ye+` = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+Ye+`.zw = vec2(0.0);
                  }
                  xTexelC`+Ye+`Ready = 1;
                }
              `,ve===1&&Ye>0?Ue+=`
                xC`+Ye+" = vec4(xTexelC"+(Ye-2)+".zw, xTexelC"+Ye+`.xy);
                `:Ue+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC`+Ye+" = vec4(previous.zw, xTexelC"+Ye+`.xy);
                  } else {
                    xC`+Ye+" = vec4(0.0, 0.0, xTexelC"+Ye+`.xy);
                  }
                  `):Ue+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC`+Ye+`Ready == 0) {
                  xTexelC`+Ye+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+Ye+`.zw = vec2(0.0);
                  }
                  xTexelC`+Ye+`Ready = 1;
                }

                xC`+Ye+" = xTexelC"+Ye+`;
                `,Ye+1<Me)){const $e=ue%2===0?B(ve):ve;ve%2===0&&ue%2===1||ve%2!==0&&ue%2!==1?(Ue+=`
                  xCOffset = xC + imod(pads[1], 2) + `+$e+`;

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Ye+1)+`Ready == 0) {
                    xTexelC`+(Ye+1)+` = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC`+(Ye+1)+`.zw = vec2(0.0);
                    }
                    xTexelC`+(Ye+1)+`Ready = 1;
                  }
                  `,ve>1?Ue+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC`+(Ye+1)+" = vec4(previous.zw, xTexelC"+(Ye+1)+`.xy);
                    } else {
                     xC`+(Ye+1)+" = vec4(0.0, 0.0, xTexelC"+(Ye+1)+`.xy);
                    }
                    `:Ue+=`
                    xC`+(Ye+1)+" = vec4(xTexelC"+Ye+".zw, xTexelC"+(Ye+1)+`.xy);
                    `):$e===1?Ue+=`
                    xC`+(Ye+1)+" = xTexelC"+Ye+`;
                    `:Ue+=`
                    xCOffset = xC + `+$e+`;

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Ye+1)+`Ready == 0) {
                      xTexelC`+(Ye+1)+` = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC`+(Ye+1)+`.zw = vec2(0.0);
                      }
                      xTexelC`+(Ye+1)+`Ready = 1;
                    }

                    xC`+(Ye+1)+" = xTexelC"+(Ye+1)+`;
                    `}}else Ye<Me&&(ue%2===1?(Ue+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Ye+`Ready == 0) {
                  xTexelC`+Ye+` = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+Ye+`.zw = vec2(0.0);
                  }
                  xTexelC`+Ye+`Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(Ye+1)+`Ready == 0) {
                  xTexelC`+(Ye+1)+` = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC`+(Ye+1)+`.zw = vec2(0.0);
                  }
                  xTexelC`+(Ye+1)+`Ready = 1;
                }

                xC`+Ye+" = vec4(xTexelC"+Ye+".zw, xTexelC"+(Ye+1)+`.zw);
              `,Ye+1<Me&&(Ue+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC`+(Ye+1)+" = vec4(xTexelC"+(Ye+1)+`.xy, final.xy);
                `)):(Ue+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC`+Ye+`Ready == 0) {
                  xTexelC`+Ye+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+Ye+`.zw = vec2(0.0);
                  }
                  xTexelC`+Ye+`Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Ye+1)+`Ready == 0) {
                  xTexelC`+(Ye+1)+` = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+(Ye+1)+`.zw = vec2(0.);
                  }
                  xTexelC`+(Ye+1)+`Ready = 1;
                }

                xC`+Ye+` = vec4(
                  xTexelC`+Ye+".xy, xTexelC"+(Ye+1)+`.xy);
              `,Ye+1<Me&&(Ue+=`
                  xC`+(Ye+1)+" = vec4(xTexelC"+Ye+".zw, xTexelC"+(Ye+1)+`.zw);
                `)));Ye<Me&&(Ue+=`
            wTexel = getW(r, `+Ye+`, d1, q);
            dotProd += xC`+Ye+` * vec4(wTexel.xz, wTexel.xz);
          `,Ye+1<Me&&(Ue+=`
              wTexel = getW(r, `+(Ye+1)+`, d1, q);
              dotProd += xC`+(Ye+1)+` * vec4(wTexel.xz, wTexel.xz);
            `))}Ue+=`
    }
  `,Ue+=`
      }
    `;let Ge="",ze="";re&&(ae?Ge=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+re+`
        }`:le?Ge=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+re+`
        }`:Ge=`vec4 activation(vec4 x) {
          `+re+`
        }`,ze="result = activation(result);");const He=V?"result += getBiasAtOutCoords();":"";V&&this.variableNames.push("bias"),ae&&this.variableNames.push("preluActivationWeights"),le&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+Ge+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+he+`;
        int q = d2 - d1 * `+he+`;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        `+Ue+`

        vec4 result = dotProd - vec4(0.000000000000001);
        `+He+`
        `+ze+`
        setOutput(result);
      }
    `}}function se(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,filter:le}=I,{strides:he,pad:ue,dilations:pe,dimRoundingMode:ve}=re;let we=pe;we==null&&(we=[1,1]),e(Oa(he,we),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+he+" and dilations '"+we+"'");const Me=OA(ae.shape,le.shape,he,we,ue,ve,!0);let Le;Cd().getBool("WEBGL_PACK_DEPTHWISECONV")&&Me.strideWidth<=2&&Me.outChannels/Me.inChannels===1?Le=new so(Me):Le=new sZ(Me);const Ue=[[Me.padInfo.top,Me.padInfo.left],[Me.strideHeight,Me.strideWidth],[Me.dilationHeight,Me.dilationWidth],[Me.inHeight,Me.inWidth]];return V.runWebGLProgram(Le,[ae,le],"float32",Ue)}const sQ={kernelName:Cl,backendName:"webgl",kernelFunc:se};function ss(Z){const{inputs:I,attrs:V,backend:re}=Z,{dim:ae}=V,{input:le}=I,he=le.shape.length,ue=le.shape.slice();let pe=ae;return ae<0&&(e(-(he+1)<=ae,()=>"Axis must be in the interval ["+-(he+1)+", "+he+"]"),pe=he+ae+1),ue.splice(pe,0,1),Qe({inputs:{x:le},backend:re,attrs:{shape:ue}})}const sF={kernelName:Cz,backendName:"webgl",kernelFunc:ss};class sI{constructor(I,V){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=I,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function sy(Z){const{backend:I,attrs:V}=Z,{shape:re,value:ae}=V;let{dtype:le}=V;if(le=le||C2(ae),le==="string"){const he=x(le,F(re));return he.fill(ae),I.makeTensorInfo(re,le,he)}else{const he=new sI(re,ae),ue=[[ae]];return I.runWebGLProgram(he,[],le,ue)}}const sA={kernelName:Cx,backendName:"webgl",kernelFunc:sy},sp="return floor(x);",sw=Q4({opSnippet:sp,packedOpSnippet:sp,cpuKernelImpl:oF}),sX={kernelName:CG,backendName:"webgl",kernelFunc:sw};class sc{constructor(I){this.variableNames=["A"];const V=D2(),[re,ae]=I;this.outputShape=I,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+ae+".0, "+re+`.0);

        vec4 values = `+V.texture2D+`(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class sW{constructor(I){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const V=D2(),[re,ae]=I;this.outputShape=I,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(`+ae+".0, "+re+`.0);
            vec4 values = `+V.texture2D+`(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        `+V.output+` = result;
      }
    `}}const sR={kernelName:ml,backendName:"webgl",kernelFunc:sv};let sK,sT=Cd().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function sv(Z){const{inputs:I,backend:V,attrs:re}=Z;let{pixels:ae}=I;const{numChannels:le}=re,he=typeof HTMLVideoElement<"u"&&ae instanceof HTMLVideoElement,ue=typeof HTMLImageElement<"u"&&ae instanceof HTMLImageElement,[pe,ve]=he?[ae.videoWidth,ae.videoHeight]:[ae.width,ae.height],we=[ve,pe],Me=[ve,pe,le];if(ue||he){const ze=Cd().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(sK==null||ze!==sT)&&(sT=ze,sK=document.createElement("canvas").getContext("2d",{willReadFrequently:sT})),sK.canvas.width=pe,sK.canvas.height=ve,sK.drawImage(ae,0,0,pe,ve),ae=sK.canvas}const Le=V.makeTensorInfo(we,"int32");V.texData.get(Le.dataId).usage=E6.PIXELS,V.gpgpu.uploadPixelDataToTexture(V.getTexture(Le.dataId),ae);const Ue=Cd().getBool("WEBGL_PACK")?new sW(Me):new sc(Me),Ge=V.runWebGLProgram(Ue,[Le],"int32");return V.disposeData(Le.dataId),Ge}function sq(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,filter:le,bias:he,preluActivationWeights:ue}=I,{strides:pe,pad:ve,dataFormat:we,dilations:Me,dimRoundingMode:Le,activation:Ue,leakyreluAlpha:Ge}=re,ze=OL(we),He=OA(ae.shape,le.shape,pe,Me,ve,Le,!1,ze);let Ke;const Ye=[],$e=he!=null,je=ue!=null,rt=Ue==="leakyrelu",at=()=>{const lt=[ae,le],kt=(qt,Kt)=>{if(Kt==="NCHW"&&qt.shape.length===1&&qt.shape[0]!==1){const _i=Qe({inputs:{x:qt},backend:V,attrs:{shape:[qt.shape[0],1,1]}});return Ye.push(_i),_i}return qt};if($e&&lt.push(kt(he,we)),je&&lt.push(kt(ue,we)),rt){const qt=V.makeTensorInfo([],"float32",Nn(Ge,"float32"));lt.push(qt),Ye.push(qt)}return lt};if(He.filterHeight===1&&He.filterWidth===1&&He.dilationHeight===1&&He.dilationWidth===1&&He.strideHeight===1&&He.strideWidth===1&&(He.padInfo.type==="SAME"||He.padInfo.type==="VALID"))Ke=s9({x:ae,filter:le,convInfo:He,backend:V,bias:he,activation:Ue,preluActivationWeights:ue,leakyreluAlpha:Ge});else if(He.strideWidth<=2&&ze==="channelsLast"&&Cd().getBool("WEBGL_EXP_CONV")){const lt=Ue?Q6(Ue,!0):null,kt=new s6(He,$e,lt,je,rt),qt=[[He.padInfo.top,He.padInfo.left],[He.strideHeight,He.strideWidth],[He.dilationHeight,He.dilationWidth],[He.inHeight,He.inWidth]],Kt=at();Ke=V.runWebGLProgram(kt,Kt,"float32",qt)}else if(Cd().getBool("WEBGL_CONV_IM2COL"))Ke=sC({x:ae,filter:le,convInfo:He,backend:V,bias:he,activation:Ue,preluActivationWeights:ue,leakyreluAlpha:Ge});else{const lt=Ue?Q6(Ue,!1):null,kt=new s5(He,$e,lt,je,rt),qt=at();Ke=V.runWebGLProgram(kt,qt,"float32")}const Rt=Qe({inputs:{x:Ke},backend:V,attrs:{shape:He.outShape}});return Ye.push(Ke),Ye.forEach(lt=>V.disposeIntermediateTensorInfo(lt)),Rt}const sl={kernelName:mL,backendName:"webgl",kernelFunc:sq};function sa(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,filter:le,bias:he,preluActivationWeights:ue}=I,{strides:pe,pad:ve,dilations:we,dimRoundingMode:Me,activation:Le,leakyreluAlpha:Ue}=re,Ge=[];let ze=we;ze==null&&(ze=[1,1]),e(Oa(pe,ze),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+pe+" and dilations '"+ze+"'");const He=OA(ae.shape,le.shape,pe,ze,ve,Me,!0),Ke=Cd().getBool("WEBGL_PACK_DEPTHWISECONV")&&He.strideWidth<=2&&He.outChannels/He.inChannels===1,Ye=Le?Q6(Le,Ke):null,$e=[ae,le],je=he!=null,rt=ue!=null,at=Le==="leakyrelu";if(je&&$e.push(he),rt&&$e.push(ue),at){const qt=V.makeTensorInfo([],"float32",Nn(Ue,"float32"));$e.push(qt),Ge.push(qt)}let Rt;Ke?Rt=new so(He,je,Ye,rt,at):Rt=new sZ(He,je,Ye,rt,at);const lt=[[He.padInfo.top,He.padInfo.left],[He.strideHeight,He.strideWidth],[He.dilationHeight,He.dilationWidth],[He.inHeight,He.inWidth]],kt=V.runWebGLProgram(Rt,$e,"float32",lt);return Ge.forEach(qt=>V.disposeIntermediateTensorInfo(qt)),kt}const sn={kernelName:mH,backendName:"webgl",kernelFunc:sa};class sL{constructor(I,V){this.variableNames=["A","indices"],this.outputShape=V,this.rank=V.length;const re=Dz(this.rank),ae=sH(I);this.userCode=`
      void main() {
        `+re+` resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < `+I[2]+`) ? 1.0 : 0.0;
        setOutput(inBounds * getA(`+ae+`));
      }
    `}}function sH(Z,I){const V=["resRC.x","resRC.y","resRC.z","resRC.w"],re=[];for(let ae=0;ae<Z.length;ae++)ae===2?re.push("index"):re.push(""+V[ae]);return re.join()}function sk(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,indices:le}=I,{axis:he,batchDims:ue}=re,pe=n(he,ae.shape)[0];if(Cd().get("DEBUG")){const Ye=V.readSync(le.dataId),$e=ae.shape[pe];for(let je=0;je<Ye.length;++je){const rt=Ye[je];e(rt<=$e-1&&rt>=0,()=>"GatherV2: the index value "+rt+" is not in [0, "+($e-1)+"]")}}const ve=VZ(ae,le,pe,ue),we=F(le.shape),Me=[],Le=Qe({inputs:{x:ae},backend:V,attrs:{shape:[ve.batchSize,ve.outerSize,ve.dimSize,ve.sliceSize]}}),Ue=Qe({inputs:{x:le},backend:V,attrs:{shape:[ve.batchSize,we/ve.batchSize]}});Me.push(Le),Me.push(Ue);const Ge=[ve.batchSize,ve.outerSize,we/ve.batchSize,ve.sliceSize];if(V.shouldExecuteOnCPU([ae,le])||ae.dtype==="string"){const Ye=V.bufferSync(Ue),$e=V.bufferSync(Le),je=oy($e,Ye,Ge);return Me.forEach(rt=>V.disposeIntermediateTensorInfo(rt)),V.makeTensorInfo(ve.outputShape,je.dtype,je.values)}const ze=new sL(Le.shape,Ge),He=V.runWebGLProgram(ze,[Le,Ue],Le.dtype);Me.push(He);const Ke=Qe({inputs:{x:He},backend:V,attrs:{shape:ve.outputShape}});return Me.forEach(Ye=>V.disposeIntermediateTensorInfo(Ye)),Ke}const sz={kernelName:CY,backendName:"webgl",kernelFunc:sk},sx="return float(a >= b);",sU=`
  return vec4(greaterThanEqual(a, b));
`,sG=Q5({opSnippet:sx,packedOpSnippet:sU,dtype:"bool",cpuKernelImpl:ow}),su={kernelName:Ch,backendName:"webgl",kernelFunc:sG},sY="return float(a < b);",sM=`
  return vec4(lessThan(a, b));
`,sh=Q5({opSnippet:sY,packedOpSnippet:sM,cpuKernelImpl:oX,dtype:"bool"}),sj={kernelName:m1,backendName:"webgl",kernelFunc:sh},F0="return float(a <= b);",F1=`
  return vec4(lessThanEqual(a, b));
`,F2=Q5({opSnippet:F0,packedOpSnippet:F1,cpuKernelImpl:oc,dtype:"bool"}),F3={kernelName:m2,backendName:"webgl",kernelFunc:F2},F4="return float(a >= 1.0 && b >= 1.0);",F5=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,F6=Q5({opSnippet:F4,packedOpSnippet:F5,dtype:"bool"}),F7={kernelName:m3,backendName:"webgl",kernelFunc:F6},F8="return float(a >= 1.0 || b >= 1.0);",F9=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,FC=Q5({opSnippet:F8,packedOpSnippet:F9,dtype:"bool"}),Fm={kernelName:m4,backendName:"webgl",kernelFunc:FC};function FN(Z,I,V,re){const ae=F(I),le=F(Z.shape)/ae,he=Qe({inputs:{x:Z},attrs:{shape:[le,ae]},backend:re}),ue=Qy(he,Z.dtype,"max",re),pe=Qe({inputs:{x:ue},attrs:{shape:V},backend:re});return re.disposeIntermediateTensorInfo(he),re.disposeIntermediateTensorInfo(ue),pe}function FJ(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{reductionIndices:le,keepDims:he}=re,ue=ae.shape.length,pe=n(le,ae.shape);let ve=pe;const we=tW(ve,ue),Me=we!=null,Le=V.shouldExecuteOnCPU([ae]);let Ue=ae;if(Me){if(Le){const Ye=V.texData.get(Ue.dataId).values,$e=new Array(ue);for(let at=0;at<$e.length;at++)$e[at]=ae.shape[we[at]];const je=e8(Ye,ae.shape,ae.dtype,we,$e);Ue=V.makeTensorInfo($e,ae.dtype);const rt=V.texData.get(Ue.dataId);rt.values=je}else Ue=QX(ae,we,V);ve=tK(ve.length,ue)}tc("max",ve,ue);const[Ge,ze]=tw(Ue.shape,ve);let He=Ge;he&&(He=tX(Ge,pe));let Ke;if(Le){const Ye=V.texData.get(Ue.dataId).values,$e=oK(Ye,F(ze),He,ae.dtype);Ke=V.makeTensorInfo(He,ae.dtype);const je=V.texData.get(Ke.dataId);je.values=$e}else Ke=FN(Ue,ze,He,V);return Me&&V.disposeIntermediateTensorInfo(Ue),Ke}const Ff={kernelName:m5,backendName:"webgl",kernelFunc:FJ};function Fi(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I;D0(ae,"maxPool");const{filterSize:le,strides:he,pad:ue,dimRoundingMode:pe}=re,ve=1;e(Oa(he,ve),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+he+" and dilations '"+ve+"'");const we=OI(ae.shape,le,he,ve,ue,pe);if(we.filterWidth===1&&we.filterHeight===1&&X(we.inShape,we.outShape))return eu({inputs:{x:ae},backend:V});const Me=new QS(we,"max",!1);return V.runWebGLProgram(Me,[ae],ae.dtype)}const FO={kernelName:m7,backendName:"webgl",kernelFunc:Fi},Ft=ez+`
  return max(a, b);
`,FB=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+eU+`
  return result;
`,FS=Q5({opSnippet:Ft,packedOpSnippet:FB,cpuKernelImpl:oT}),Fd={kernelName:m6,backendName:"webgl",kernelFunc:FS};function FV(Z,I,V,re){const ae=F(I),le=F(Z.shape)/ae,he=Qe({inputs:{x:Z},attrs:{shape:[le,ae]},backend:re}),ue=Qy(he,"float32","mean",re),pe=Qe({inputs:{x:ue},attrs:{shape:V},backend:re});return re.disposeIntermediateTensorInfo(he),re.disposeIntermediateTensorInfo(ue),pe}const Fb={kernelName:m8,backendName:"webgl",kernelFunc:({inputs:Z,attrs:I,backend:V})=>{const{x:re}=Z,{keepDims:ae,axis:le}=I,he=V,ue=re.shape.length,pe=n(le,re.shape);let ve=pe;const we=tW(ve,ue),Me=we!=null,Le=he.shouldExecuteOnCPU([re]),Ue=[];let Ge=re;if(Me){if(Le){const $e=he.texData.get(Ge.dataId).values,je=new Array(ue);for(let Rt=0;Rt<je.length;Rt++)je[Rt]=re.shape[we[Rt]];const rt=e8($e,re.shape,re.dtype,we,je);Ge=he.makeTensorInfo(je,re.dtype);const at=he.texData.get(Ge.dataId);at.values=rt}else Ge=QX(re,we,he);Ue.push(Ge),ve=tK(ve.length,ue)}tc("sum",ve,ue);const[ze,He]=tw(Ge.shape,ve);let Ke=ze;ae&&(Ke=tX(ze,pe));const Ye=FV(Ge,He,Ke,he);for(const $e of Ue)he.disposeIntermediateTensorInfo($e);return Ye}};function FP(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{axis:le,keepDims:he}=re,ue=ae.shape.length,pe=n(le,ae.shape);let ve=pe;const we=tW(ve,ue);let Me=ae;we!=null&&(Me=QK({inputs:{x:ae},backend:V,attrs:{perm:we}}),ve=tK(ve.length,ae.shape.length)),tc("min",ve,ue);const[Le,Ue]=tw(Me.shape,ve),Ge=F(Ue),ze=Qe({inputs:{x:Me},backend:V,attrs:{shape:[-1,Ge]}}),He=Qy(ze,ze.dtype,"min",V);let Ke;if(he){const Ye=tX(Le,pe);Ke=Qe({inputs:{x:He},backend:V,attrs:{shape:Ye}})}else Ke=Qe({inputs:{x:He},backend:V,attrs:{shape:Le}});return V.disposeIntermediateTensorInfo(ze),V.disposeIntermediateTensorInfo(He),we!=null&&V.disposeIntermediateTensorInfo(Me),Ke}const FE={kernelName:m9,backendName:"webgl",kernelFunc:FP},FD=ez+`
  return min(a, b);
`,Fg=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+eU+`
  return result;
`,FZ=Q5({opSnippet:FD,packedOpSnippet:Fg,cpuKernelImpl:ov}),Fo={kernelName:mC,backendName:"webgl",kernelFunc:FZ},Fe=eE+`
  return -x;
`,FQ=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Fs(Z){const{inputs:I,backend:V}=Z,{x:re}=I;if(V.shouldExecuteOnCPU([re])){const le=V.texData.get(re.dataId),[he,ue]=ol(le.values,re.shape,re.dtype);return V.makeTensorInfo(ue,re.dtype,he)}let ae;return Cd().getBool("WEBGL_PACK_UNARY_OPERATIONS")?ae=new ew(re.shape,FQ):ae=new eP(re.shape,Fe),V.runWebGLProgram(ae,[re],re.dtype)}const FF={kernelName:mN,backendName:"webgl",kernelFunc:Fs};function FI(Z){const{inputs:I,backend:V,attrs:re}=Z,{axis:ae}=re;if(I.length===1)return ss({inputs:{input:I[0]},backend:V,attrs:{dim:ae}});const le=I[0].shape,he=I[0].dtype;I.forEach(we=>{Q(le,we.shape,"All tensors passed to stack must have matching shapes"),e(he===we.dtype,()=>"All tensors passed to stack must have matching dtypes")});const ue=[],pe=I.map(we=>{const Me=ss({inputs:{input:we},backend:V,attrs:{dim:ae}});return ue.push(Me),Me}),ve=s3({inputs:pe,backend:V,attrs:{axis:ae}});return ue.forEach(we=>V.disposeIntermediateTensorInfo(we)),ve}const Fy={kernelName:mO,backendName:"webgl",kernelFunc:FI};class FA{constructor(I,V,re){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=V.map((ve,we)=>ve[0]+I[we]+ve[1]);const ae=I.length,le=Dz(ae),he=V.map(ve=>ve[0]).join(","),ue=V.map((ve,we)=>ve[0]+I[we]).join(","),pe=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,ae);if(ae===1){this.userCode=`
        int start = `+he+`;
        int end = `+ue+`;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      `+le+" start = "+le+"("+he+`);
      `+le+" end = "+le+"("+ue+`);

      void main() {
        `+le+` outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          `+le+` coords = outC - start;
          setOutput(getX(`+pe+`));
        }
      }
    `}}class Fp{constructor(I,V,re){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=V.map((ze,He)=>ze[0]+I[He]+ze[1]);const ae=I.length,le=Dz(ae),he=V.map(ze=>ze[0]).join(","),ue=V.map((ze,He)=>ze[0]+I[He]).join(","),pe=em("rc",ae),ve=em("source",ae),we=pe[ae-1]+" < "+this.outputShape[ae-1],Me=ae===1?"source":"vec2("+ve.slice(-2).join()+")",Le=[le+" rc = outputLoc;",pe[ae-1]+` += 1;
       if(`+we+`) {
      `,ae===1?"":`}
       rc = outputLoc;
       `+pe[ae-2]+` += 1;
       if(`+pe[ae-2]+" < "+this.outputShape[ae-2]+") {",ae===1?"":"  "+pe[ae-1]+` += 1;
         if(`+we+") {"],Ue=ae===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let Ge="";for(let ze=0,He=ae===1?2:4;ze<He;ze++)Ge+=`
        `+Le[ze]+`
        if (`+Ue+`) {
          result[`+ze+`] = float(value);
        } else {
          `+le+` source = rc - start;
          result[`+ze+"] = getChannel(getX("+ve.join()+"), "+Me+`);
        }
      `;Ge+=ae===1?"} ":"}}",this.userCode=`
      const `+le+" start = "+le+"("+he+`);
      const `+le+" end = "+le+"("+ue+`);

      void main() {
        `+le+` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        `+Ge+`
        setOutput(result);
      }
    `}}const Fw=Z=>{const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{paddings:le,constantValue:he}=re;if(F(ae.shape)===0){const ve=le.map((we,Me)=>we[0]+ae.shape[Me]+we[1]);return sy({backend:V,attrs:{shape:ve,value:he,dtype:ae.dtype}})}const ue=Cd().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fp(ae.shape,le,he):new FA(ae.shape,le,he),pe=[[he]];return V.runWebGLProgram(ue,[ae],ae.dtype,pe)},FX={kernelName:mt,backendName:"webgl",kernelFunc:Fw},Fc=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,FW=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+eU+`
  return result;
`,FR=Q5({opSnippet:Fc,packedOpSnippet:FW}),FK={kernelName:mB,backendName:"webgl",kernelFunc:FR},FT=Z=>{const{backend:I,attrs:V}=Z,{start:re,stop:ae,step:le,dtype:he}=V,ue=oz(re,ae,le,he);return I.makeTensorInfo([ue.length],he,ue)},Fv={kernelName:md,backendName:"webgl",kernelFunc:FT},Fq=`
if (a == b) {
  return 1.0;
};
return a / b;`,Fl=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Fa=Q5({opSnippet:Fq,packedOpSnippet:Fl,checkOutOfBounds:!0}),Fn={kernelName:CL,backendName:"webgl",kernelFunc:Fa},FL=eE+`
  return (x < 0.0) ? 0.0 : x;
`,FH=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Fk=Q4({opSnippet:FL,packedOpSnippet:FH}),Fz={kernelName:mb,backendName:"webgl",kernelFunc:Fk},Fx=eE+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,FU=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,FG=Q4({opSnippet:Fx,packedOpSnippet:FU}),Fu={kernelName:mg,backendName:"webgl",kernelFunc:FG};class FY{constructor(I,V,re,ae,le){this.variableNames=["A"],this.outputShape=[];const[he,ue,pe,ve]=I;this.outputShape=[he,V,re,ve];const we=[ae&&V>1?ue-1:ue,ae&&re>1?pe-1:pe],Me=[ae&&V>1?V-1:V,ae&&re>1?re-1:re];let Le;le?Le="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":Le="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          `+we[0]/Me[0]+`,
          `+we[1]/Me[1]+`);
      const vec2 inputShapeRC = vec2(`+ue+".0, "+pe+`.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = `+Le+`;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class FM{constructor(I,V,re,ae,le){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[he,ue,pe,ve]=I;this.outputShape=[he,V,re,ve];const we=[ae&&V>1?ue-1:ue,ae&&re>1?pe-1:pe],Me=[ae&&V>1?V-1:V,ae&&re>1?re-1:re];let Le;le?Le="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":Le="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          `+we[0]/Me[0]+`,
          `+we[1]/Me[1]+`,
          `+we[1]/Me[1]+`);
      const vec3 inputShapeRC = vec3(`+ue+".0, "+pe+`.0,
                                     `+pe+`.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = `+Le+`;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < `+(ve-1)+`;
        bool hasNextRow = coords.z < `+(re-1)+`;

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function Fh(Z){const{inputs:I,backend:V,attrs:re}=Z,{images:ae}=I,{alignCorners:le,halfPixelCenters:he,size:ue}=re,[pe,ve]=ue,we=Cd().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new FM(ae.shape,pe,ve,le,he):new FY(ae.shape,pe,ve,le,he);return V.runWebGLProgram(we,[ae],"float32")}const Fj={kernelName:mD,backendName:"webgl",kernelFunc:Fh};class Fr{constructor(I,V){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const re=I[1],ae=I[2];this.outputShape=I;let le="";typeof V=="number"?le="float outputValue = "+V.toFixed(2)+";":le=`
        vec3 fill = vec3(`+V.join(",")+`);
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          `+le+`
          if(coordX >= 0 && coordX < `+ae+" && coordY >= 0 && coordY < "+re+`) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const I0={kernelName:ma,backendName:"webgl",kernelFunc:({inputs:Z,attrs:I,backend:V})=>{const{image:re}=Z,{radians:ae,fillValue:le,center:he}=I,ue=V,pe=new Fr(re.shape,le),[ve,we]=dK(he,re.shape[1],re.shape[2]),Me=[[ve,we,Math.sin(ae),Math.cos(ae)]];return ue.runWebGLProgram(pe,[re],re.dtype,Me)}},I1=Q3+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,I2=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,I3=Q4({opSnippet:I1,packedOpSnippet:I2,cpuKernelImpl:oG}),I4={kernelName:mF,backendName:"webgl",kernelFunc:I3},I5=Q3+`
  return sin(x);
`,I6=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  `+eU+`
  return result;
`,I7=Q4({opSnippet:I5,packedOpSnippet:I6}),I8={kernelName:ms,backendName:"webgl",kernelFunc:I7};class I9{constructor(I){this.variableNames=["source"],this.outputShape=I,this.rank=I.length;const V=Dz(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const re=Im(this.rank);let ae;const le=I.map((he,ue)=>"sourceLoc."+IC[ue]+" = start["+ue+"] + coords."+IC[ue]+";");ae=`
        `+V+` sourceLoc;
        `+V+` coords = getOutputCoords();
        `+le.join(`
`)+`
      `,this.userCode=`
      void main() {
        `+ae+`
        setOutput(getSource(`+re+`));
      }
    `}}const IC=["x","y","z","w","u","v"];function Im(Z){if(Z===1)return"sourceLoc";if(Z<=6)return IC.slice(0,Z).map(I=>"sourceLoc."+I).join(",");throw Error("Slicing for rank "+Z+" is not yet supported")}class IN{constructor(I){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=I,this.rank=I.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const V=Dz(this.rank),re=em("coords",this.rank),ae=em("sourceLoc",this.rank),le=this.rank===1?"sourceLoc":"vec2("+ae.slice(-2).join()+")",he="getChannel(getSource("+ae.join()+"), "+le+")",ue=`
      result.x = `+he+`;
      if (++`+re[this.rank-1]+" < "+I[this.rank-1]+`) {
        ++`+ae[this.rank-1]+`;
        result.y = `+he+`;
        --`+ae[this.rank-1]+`;
      }
    `,pe=this.rank===1?"":`
      --`+re[this.rank-1]+`;
      if (++`+re[this.rank-2]+" < "+I[this.rank-2]+`) {
        ++`+ae[this.rank-2]+`;
        result.z = `+he+`;
        if (++`+re[this.rank-1]+" < "+I[this.rank-1]+`) {
          ++`+ae[this.rank-1]+`;
          result.w = `+he+`;
        }
      }
    `,ve=this.rank<=4?`sourceLoc = coords +
            `+V+"("+I.map((we,Me)=>"start["+Me+"]").join()+");":I.map((we,Me)=>ae[Me]+" = "+re[Me]+" + start["+Me+"];").join(`
`);this.userCode=`
      void main() {
        `+V+` coords = getOutputCoords();
        `+V+` sourceLoc;
        `+ve+`
        vec4 result = vec4(0.);
        `+ue+`
        `+pe+`
        setOutput(result);
      }
    `}}function IJ(Z,I,V,re){const ae=re.texData.get(Z.dataId),le=re.makeTensorInfo(V,Z.dtype),he=re.texData.get(le.dataId);Object.assign(he,ae),he.refCount=1,he.shape=V,he.dtype=Z.dtype;let ue=ON(I,C5(Z.shape));ae.slice&&(ue+=ae.slice.flatOffset),he.slice={flatOffset:ue,origDataId:ae.slice&&ae.slice.origDataId||Z.dataId};const pe=re.dataRefCount.get(he.slice.origDataId)||1;return re.dataRefCount.set(he.slice.origDataId,pe+1),le}function If(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{begin:le,size:he}=re,[ue,pe]=OJ(ae,le,he);if(ir(ae,ue,pe),F(pe)===0)return V.makeTensorInfo(pe,ae.dtype,[]);if(V.shouldExecuteOnCPU([ae])||ae.dtype==="string"){const Me=V.texData.get(ae.dataId),Le=oY(Me.values,ue,pe,ae.shape,ae.dtype);return V.makeTensorInfo(pe,ae.dtype,Le)}const{isPacked:ve}=V.texData.get(ae.dataId),we=Om(ae.shape,ue,pe);if(ve||!we){const Me=Cd().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new IN(pe):new I9(pe),Le=[ue];return V.runWebGLProgram(Me,[ae],ae.dtype,Le)}return V.uploadToGPU(ae.dataId),IJ(ae,ue,pe,V)}const Ii={kernelName:mQ,backendName:"webgl",kernelFunc:If},IO="return sqrt(x);",It=Q4({opSnippet:IO,packedOpSnippet:IO,cpuKernelImpl:or}),IB={kernelName:mI,backendName:"webgl",kernelFunc:It},IS="return x * x;",Id=Q4({opSnippet:IS}),IV={kernelName:mw,backendName:"webgl",kernelFunc:Id};class Ib{constructor(I,V,re){this.variableNames=["x"],this.outputShape=re;const ae=re.length,le=Dz(re.length),he=Dz(re.length);let ue="";if(ae===1)ue="coords * strides + begin";else{let pe=0;ue=re.map((ve,we)=>(pe++,re.length===1?"coords * strides["+we+"] + begin["+we+"]":"coords["+(pe-1)+"] * strides["+we+"] + begin["+we+"]")).join(",")}this.userCode=`
      `+le+" begin = "+le+"("+I+`);
      `+le+" strides = "+le+"("+V+`);

      void main() {
        `+he+` coords = getOutputCoords();
        setOutput(getX(`+ue+`));
      }
    `}}function IP(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{begin:le,end:he,strides:ue,beginMask:pe,endMask:ve,ellipsisMask:we,newAxisMask:Me,shrinkAxisMask:Le}=re,{finalShapeSparse:Ue,finalShape:Ge,isIdentity:ze,sliceDim0:He,isSimpleSlice:Ke,begin:Ye,end:$e,strides:je}=Of(ae.shape,le,he,ue,pe,ve,we,Me,Le);let rt;if(ze)rt=Qe({inputs:{x:ae},backend:V,attrs:{shape:Ge}});else if(He||Ke){e(ae.shape.length>=1,()=>"Input must have rank at least 1, got: "+ae.shape.length);const Rt=O1(Ye,$e,je),lt=If({inputs:{x:ae},backend:V,attrs:{begin:Ye,size:Rt}});rt=Qe({inputs:{x:lt},backend:V,attrs:{shape:Ge}}),V.disposeIntermediateTensorInfo(lt)}else if(V.shouldExecuteOnCPU([ae])){const Rt=V.readSync(ae.dataId),lt=t7(ae.shape,ae.dtype,Rt),kt=e1(Ue,lt,je,Ye);rt=V.makeTensorInfo(Ge,ae.dtype,kt.values)}else{const Rt=new Ib(Ye,je,Ue);rt=V.runWebGLProgram(Rt,[ae],ae.dtype)}const at=Qe({inputs:{x:rt},backend:V,attrs:{shape:Ge}});return V.disposeIntermediateTensorInfo(rt),at}const IE={kernelName:mX,backendName:"webgl",kernelFunc:IP},ID="return a - b;",Ig=Q5({opSnippet:ID,packedOpSnippet:ID,supportsComplex:!0,cpuKernelImpl:e5}),IZ={kernelName:mc,backendName:"webgl",kernelFunc:Ig};class Io{constructor(I,V){this.variableNames=["A"];const re=new Array(I.length);for(let he=0;he<re.length;he++)re[he]=I[he]*V[he];this.outputShape=re,this.rank=re.length;const ae=Dz(this.rank),le=Ie(I);this.userCode=`
      void main() {
        `+ae+` resRC = getOutputCoords();
        setOutput(getA(`+le+`));
      }
    `}}function Ie(Z){const I=Z.length;if(I>5)throw Error("Tile for rank "+I+" is not yet supported");if(I===1)return"imod(resRC, "+Z[0]+")";const V=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],re=[];for(let ae=0;ae<Z.length;ae++)re.push("imod("+V[ae]+", "+Z[ae]+")");return re.join()}function IQ(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{reps:le}=re;if(ae.dtype==="string"||ae.shape.length>5){const ue=V.readSync(ae.dataId),pe=ae.dtype==="string"?ue.map(Me=>Nx(Me)):ue,ve=t7(ae.shape,ae.dtype,pe),we=e6(ve,le);return V.makeTensorInfo(we.shape,we.dtype,we.values)}const he=new Io(ae.shape,le);return V.runWebGLProgram(he,[ae],ae.dtype)}const Is={kernelName:mW,backendName:"webgl",kernelFunc:IQ};class IF{constructor(I,V,re,ae,le,he){this.variableNames=["Image","Transforms"],this.outputShape=he;const ue=re==="nearest"?1:2;let pe;switch(ae){case"constant":pe=1;break;case"reflect":pe=2;break;case"wrap":pe=3;break;case"nearest":pe=4;break;default:pe=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(`+pe+` == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+pe+` == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+pe+` == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < `+I+" && 0 <= coordX && coordX < "+V+`) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(`+le+`);
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(`+le+`);
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(`+V+`));
                float mapY = mapCoord(inY, float(`+I+`));

                if (`+ue+` == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function II(Z){const{inputs:I,backend:V,attrs:re}=Z,{image:ae,transforms:le}=I,{interpolation:he,fillMode:ue,fillValue:pe,outputShape:ve}=re,[we,Me,Le,Ue]=ae.shape,[Ge,ze]=ve??[Me,Le],He=[we,Ge,ze,Ue],Ke=new IF(Me,Le,he,ue,pe,He);return V.runWebGLProgram(Ke,[ae,le],"float32")}const Iy={kernelName:mR,backendName:"webgl",kernelFunc:II};function IA(Z){const{inputs:I,backend:V}=Z,{x:re}=I;if(re.dtype==="complex64"){const ae=QH({inputs:{input:re},backend:V}),le=IA({inputs:{x:ae},backend:V}),he=s0({inputs:{input:re},backend:V}),ue=IA({inputs:{x:he},backend:V}),pe=eM({inputs:{real:le,imag:ue},backend:V});return V.disposeIntermediateTensorInfo(ae),V.disposeIntermediateTensorInfo(le),V.disposeIntermediateTensorInfo(he),V.disposeIntermediateTensorInfo(ue),pe}else return sy({attrs:{shape:re.shape,dtype:re.dtype,value:re.dtype==="string"?"":0},backend:V})}const Ip={kernelName:mv,backendName:"webgl",kernelFunc:IA};function Iw(Z){const{inputs:I,backend:V,attrs:re}=Z,{a:ae,b:le,bias:he,preluActivationWeights:ue}=I,{transposeA:pe,transposeB:ve,activation:we,leakyreluAlpha:Me}=re;return Qq({a:ae,b:le,transposeA:pe,transposeB:ve,backend:V,bias:he,preluActivationWeights:ue,leakyreluAlpha:Me,activation:we})}const IX={kernelName:mn,backendName:"webgl",kernelFunc:Iw},Ic=SQ;class IW extends i{nextDataId(){return IW.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new f(this,Ju())}write(I,V,re){this.firstUse&&(this.firstUse=!1,Cd().get("IS_NODE")&&mk(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const ae={id:this.nextDataId()};return this.data.set(ae,{values:I,dtype:re,refCount:1}),ae}makeTensorInfo(I,V,re){let ae;if(V==="string"&&re!=null&&re.length>0&&j(re[0])){const le=re.map(he=>Nz(he));ae=this.write(le,I,V)}else ae=this.write(re,I,V);return{dataId:ae,shape:I,dtype:V}}refCount(I){return this.data.has(I)?this.data.get(I).refCount:0}incRef(I){const V=this.data.get(I);V.refCount++}decRef(I){if(this.data.has(I)){const V=this.data.get(I);V.refCount--}}move(I,V,re,ae,le){this.data.set(I,{values:V,dtype:ae,refCount:le})}numDataIds(){return this.data.numDataIds()}async read(I){return this.readSync(I)}readSync(I){const{dtype:V,complexTensorInfos:re}=this.data.get(I);if(V==="complex64"){const ae=this.readSync(re.real.dataId),le=this.readSync(re.imag.dataId);return du(ae,le)}return C8(this.data.get(I).values,V)}bufferSync(I){const V=this.readSync(I.dataId);if(I.dtype==="string")try{const re=V.map(ae=>Nx(ae));return t7(I.shape,I.dtype,re)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return t7(I.shape,I.dtype,V)}makeOutput(I,V,re){return Ju().makeTensorFromTensorInfo(this.makeTensorInfo(V,re,I),this)}disposeData(I,V=!1){if(this.data.has(I)){if(this.data.get(I).refCount--,!V&&this.data.get(I).refCount>0)return!1;const{complexTensorInfos:re}=this.data.get(I);re!=null&&(this.disposeData(re.real.dataId,!0),this.disposeData(re.imag.dataId,!0)),this.data.delete(I)}return!0}disposeIntermediateTensorInfo(I){this.disposeData(I.dataId)}async time(I){const V=Nk();return I(),{kernelMs:Nk()-V}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(I){gs([I],"where");const V=this.readSync(I.dataId);return Ic(I.shape,V)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}IW.nextDataId=0,f0("cpu",()=>new IW,1);function IR(Z){const{inputs:I,backend:V}=Z,re=I;gs(I,"addN");const ae=re.map(ue=>V.data.get(ue.dataId).values),le=t7(re[0].shape,re[0].dtype),he=le.values;for(let ue=0;ue<re.length;ue++){const pe=ae[ue];for(let ve=0;ve<he.length;ve++)he[ve]+=pe[ve]}return V.makeTensorInfo(le.shape,le.dtype,le.values)}const IK={kernelName:Ce,backendName:"cpu",kernelFunc:IR},IT=gA((Z,I)=>Math.atan2(Z,I)),Iv=gv(CQ,IT),Iq={kernelName:CQ,backendName:"cpu",kernelFunc:Iv};function Il(Z,I,V,re,ae,le){const he=ae.strideHeight,ue=ae.strideWidth,pe=ae.dilationHeight,ve=ae.dilationWidth,we=ae.effectiveFilterHeight,Me=ae.effectiveFilterWidth,Le=ae.padInfo.top,Ue=ae.padInfo.left,Ge=le==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,ze=t7(ae.outShape,V),He=ze.values,Ke=ae.outShape[1]*ae.outShape[2]*ae.outShape[3],Ye=ae.outShape[2]*ae.outShape[3],$e=ae.outShape[3];for(let je=0;je<ae.batchSize;++je){const rt=je*Ke,at=je*re[0];for(let Rt=0;Rt<ae.inChannels;++Rt)for(let lt=0;lt<ae.outHeight;++lt){const kt=lt*he-Le,qt=Math.max(0,kt),Kt=Math.min(ae.inHeight,we+kt),_i=rt+lt*Ye;for(let ci=0;ci<ae.outWidth;++ci){const li=ci*ue-Ue,qi=Math.max(0,li),Ki=Math.min(ae.inWidth,Me+li);let hs=Ge,Yi=0,ns=0;for(let Xs=qt;Xs<Kt;Xs+=pe){const $i=at+Xs*re[1];for(let xs=qi;xs<Ki;xs+=ve){const hi=$i+xs*re[2],Ri=Z[hi+Rt];le==="max"&&Ri>hs?hs=Ri:le==="avg"&&(Yi+=Ri,ns++)}if(isNaN(hs))break}const Gs=_i+ci*$e+Rt;He[Gs]=le==="avg"?Yi/ns:hs}}}return ze}function Ia(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I;gs(ae,"avgPool");const{filterSize:le,strides:he,pad:ue,dimRoundingMode:pe}=re,ve=1;e(Oa(he,ve),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+he+" and dilations '"+ve+"'");const we=OI(ae.shape,le,he,ve,ue,pe);let Me;if(we.filterWidth===1&&we.filterHeight===1&&X(we.inShape,we.outShape))Me=gX({inputs:{x:ae},backend:V});else{const Le=V.data.get(ae.dataId).values,Ue=C5(ae.shape),Ge=Il(Le,ae.shape,ae.dtype,Ue,we,"avg");Me=V.makeTensorInfo(we.outShape,ae.dtype,Ge.values)}return Me}const In={kernelName:Cs,backendName:"cpu",kernelFunc:Ia};function IL(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{shape:le}=re,he=F(ae.shape),ue=l(le,he),pe=F(ue);e(he===pe,()=>"The new shape ("+ue+") has "+pe+" elements and the old shape ("+ae.shape+") has "+he+" elements. The new shape and old shape must have the same number of elements."),V.incRef(ae.dataId);const ve=V.data.get(ae.dataId);if(ve.complexTensorInfos!=null){const we=ve.complexTensorInfos.real,Me=ve.complexTensorInfos.imag;we.shape=ue,Me.shape=ue}return{dataId:ae.dataId,shape:ue,dtype:ae.dtype}}const IH={kernelName:mP,backendName:"cpu",kernelFunc:IL};function Ik(Z){const{inputs:I,backend:V,attrs:re}=Z,{a:ae,b:le}=I,{transposeA:he,transposeB:ue}=re;gs([ae,le],"matMul");const pe=ae.shape.length,ve=le.shape.length,we=he?ae.shape[pe-2]:ae.shape[pe-1],Me=ue?le.shape[ve-1]:le.shape[ve-2],Le=he?ae.shape[pe-1]:ae.shape[pe-2],Ue=ue?le.shape[ve-2]:le.shape[ve-1],Ge=ae.shape.slice(0,-2),ze=le.shape.slice(0,-2),He=F(Ge),Ke=F(ze),Ye=iH(ae.shape.slice(0,-2),le.shape.slice(0,-2)).concat([Le,Ue]);e(we===Me,()=>"Error in matMul: inner shapes ("+we+") and ("+Me+") of Tensors with shapes "+ae.shape+" and "+le.shape+" and transposeA="+he+" and transposeB="+ue+" must match.");const $e=he?[He,we,Le]:[He,Le,we],je=ue?[Ke,Ue,Me]:[Ke,Me,Ue],rt=IL({inputs:{x:ae},backend:V,attrs:{shape:$e}}),at=IL({inputs:{x:le},backend:V,attrs:{shape:je}}),Rt=he?rt.shape[1]:rt.shape[2],lt=he?rt.shape[2]:rt.shape[1],kt=ue?at.shape[1]:at.shape[2],qt=Math.max(He,Ke),Kt=V.data.get(rt.dataId).values,_i=V.data.get(at.dataId).values,ci=C5(rt.shape),li=C5(at.shape),[qi,Ki,hs]=he?[ci[0],1,ci[1]]:[ci[0],ci[1],1],[Yi,ns,Gs]=ue?[1,li[1],li[0]]:[li[1],1,li[0]],Xs=lt*kt,$i=t7([qt,lt,kt],rt.dtype),xs=$i.values,hi=V.blockSize;for(let Ri=0;Ri<qt;Ri++){const Wi=Ri%He,us=Ri%Ke;for(let Ks=0;Ks<lt;Ks+=hi){const ur=Math.min(Ks+hi,lt);for(let js=0;js<kt;js+=hi){const sr=Math.min(js+hi,kt);for(let cr=0;cr<Rt;cr+=hi){const ln=Math.min(cr+hi,Rt);for(let kr=Ks;kr<ur;kr++)for(let $r=js;$r<sr;$r++){let Rn=0;for(let Ln=cr;Ln<ln;Ln++){const zn=Kt[Wi*qi+kr*Ki+Ln*hs],ra=_i[Ln*Yi+$r*ns+us*Gs];Rn+=zn*ra}xs[Ri*Xs+(kr*kt+$r)]+=Rn}}}}}return V.disposeIntermediateTensorInfo(rt),V.disposeIntermediateTensorInfo(at),V.makeTensorInfo(Ye,$i.dtype,$i.values)}const Iz={kernelName:CF,backendName:"cpu",kernelFunc:Ik},Ix=gU(Cp,(Z,I)=>{const V=I;return Z>V.clipValueMax?V.clipValueMax:Z<V.clipValueMin?V.clipValueMin:Z}),IU={kernelName:Cp,backendName:"cpu",kernelFunc:Ix};function IG(Z){const{inputs:I,backend:V}=Z,{input:re}=I,ae=V.data.get(re.dataId).complexTensorInfos.imag,le=V.data.get(ae.dataId).values;return V.makeTensorInfo(ae.shape,ae.dtype,le)}function Iu(Z){const{inputs:I,backend:V,attrs:re}=Z,{axis:ae}=re,le=n(ae,I[0].shape)[0],he=I.map(ze=>ze.shape);dI(he,le);let ue=dy(I.map(ze=>ze.shape),le);if(F(ue)===0)return V.makeTensorInfo(ue,I[0].dtype,[]);const pe=I.filter(ze=>F(ze.shape)>0);if(pe.length===1)return gX({inputs:{x:pe[0]},backend:V});if(pe[0].dtype==="complex64"){const ze=pe.map(je=>gW({inputs:{input:je},backend:V})),He=pe.map(je=>IG({inputs:{input:je},backend:V})),Ke=Iu({inputs:ze,backend:V,attrs:{axis:le}}),Ye=Iu({inputs:He,backend:V,attrs:{axis:le}}),$e=gp({inputs:{real:Ke,imag:Ye},backend:V});return ze.forEach(je=>V.disposeIntermediateTensorInfo(je)),He.forEach(je=>V.disposeIntermediateTensorInfo(je)),V.disposeIntermediateTensorInfo(Ke),V.disposeIntermediateTensorInfo(Ye),$e}const ve=pe.map(ze=>{const He=[-1,F(ze.shape.slice(le))];return IL({inputs:{x:ze},backend:V,attrs:{shape:He}})}),we=ve.map(ze=>({vals:V.data.get(ze.dataId).values,shape:ze.shape}));ue=dy(ve.map(ze=>ze.shape),1);const Me=ve[0].shape[0]===1,Le=gY(we,ue,I[0].dtype,Me),Ue=dy(pe.map(ze=>ze.shape),le),Ge=V.makeTensorInfo(Ue,I[0].dtype,Le);return ve.forEach(ze=>V.disposeIntermediateTensorInfo(ze)),Ge}const IY={kernelName:Cc,backendName:"cpu",kernelFunc:Iu};function IM(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,filter:le}=I,{strides:he,pad:ue,dataFormat:pe,dilations:ve,dimRoundingMode:we}=re;gs([ae,le],"conv2d");const Me=OL(pe),Le=OA(ae.shape,le.shape,he,ve,ue,we,!1,Me),Ue=Le.filterHeight,Ge=Le.filterWidth,ze=Le.dilationHeight,He=Le.dilationWidth,Ke=Le.padInfo.left,Ye=Le.padInfo.top,$e=Le.dataFormat==="channelsLast",je=new J8(Le.outShape,ae.dtype),rt=C5(ae.shape),at=C5(le.shape),Rt=rt[0],lt=$e?rt[1]:rt[2],kt=$e?rt[2]:1,qt=$e?1:rt[1],Kt=je.strides[0],_i=$e?je.strides[1]:je.strides[2],ci=$e?je.strides[2]:1,li=$e?1:je.strides[1],qi=V.data.get(ae.dataId).values,Ki=V.data.get(le.dataId).values,hs=je.values;for(let Yi=0;Yi<Le.batchSize;++Yi){const ns=Yi*Rt,Gs=Yi*Kt;for(let Xs=0;Xs<Le.outHeight;++Xs){const $i=Gs+Xs*_i,xs=Xs*Le.strideHeight-Ye;for(let hi=0;hi<Ue;++hi){const Ri=xs+hi*ze;if(Ri<0||Ri>=Le.inHeight)continue;const Wi=hi*at[0],us=ns+Ri*lt;for(let Ks=0;Ks<Le.outWidth;++Ks){const ur=$i+Ks*ci,js=Ks*Le.strideWidth-Ke;for(let sr=0;sr<Ge;++sr){const cr=js+sr*He;if(cr<0||cr>=Le.inWidth)continue;const ln=Wi+sr*at[1],kr=us+cr*kt;let $r=ln;for(let Rn=0;Rn<Le.inChannels;++Rn){const Ln=qi[kr+Rn*qt];for(let zn=0;zn<Le.outChannels;++zn)hs[ur+zn*li]+=Ln*Ki[$r+zn];$r+=Le.outChannels}}}}}}return V.makeTensorInfo(je.shape,je.dtype,hs)}const Ih={kernelName:CW,backendName:"cpu",kernelFunc:IM};function Ij(Z){const{inputs:I,backend:V,attrs:re}=Z,{dy:ae,filter:le}=I,{inputShape:he,strides:ue,pad:pe,dataFormat:ve,dimRoundingMode:we}=re;gs([ae,le],"conv2dBackpropInput");const Me=C5(le.shape),Le=C5(ae.shape);let Ue=OL(ve);const Ge=OA(he,le.shape,ue,1,pe,we,!1,Ue),ze=new J8(Ge.inShape,"float32"),He=ze.values,Ke=V.data.get(ae.dataId).values,Ye=V.data.get(le.dataId).values,[$e,je,rt]=Me,{batchSize:at,filterHeight:Rt,filterWidth:lt,inChannels:kt,inHeight:qt,inWidth:Kt,outChannels:_i,outHeight:ci,outWidth:li,strideHeight:qi,strideWidth:Ki}=Ge;Ue=Ge.dataFormat;const hs=Rt-1-Ge.padInfo.top,Yi=lt-1-Ge.padInfo.left,ns=Ue==="channelsLast",Gs=ze.strides[0],Xs=ns?ze.strides[1]:ze.strides[2],$i=ns?ze.strides[2]:1,xs=ns?1:ze.strides[1],hi=Le[0],Ri=ns?Le[1]:Le[2],Wi=ns?Le[2]:1,us=ns?1:Le[1];for(let Ks=0;Ks<at;++Ks)for(let ur=0;ur<kt;++ur)for(let js=0;js<qt;++js){const sr=js-hs,cr=Math.max(0,Math.ceil(sr/qi)),ln=Math.min(ci,(Rt+sr)/qi);for(let kr=0;kr<Kt;++kr){const $r=kr-Yi,Rn=Math.max(0,Math.ceil($r/Ki)),Ln=Math.min(li,(lt+$r)/Ki);let zn=0;for(let aa=cr;aa<ln;++aa){const ps=aa*qi-sr;for(let l0=Rn;l0<Ln;++l0){const Ro=l0*Ki-$r,rx=hi*Ks+Ri*aa+Wi*l0,Ma=$e*(Rt-1-ps)+je*(lt-1-Ro)+rt*ur;for(let pn=0;pn<_i;++pn){const jr=Ke[rx+us*pn],uo=Ye[Ma+pn];zn+=jr*uo}}}const ra=Gs*Ks+Xs*js+$i*kr+xs*ur;He[ra]=zn}}return V.makeTensorInfo(ze.shape,ze.dtype,ze.values)}const Ir={kernelName:CK,backendName:"cpu",kernelFunc:Ij},y0=gU(CT,Z=>Math.cos(Z)),y1={kernelName:CT,backendName:"cpu",kernelFunc:y0};function y2(Z){const{inputs:I,backend:V,attrs:re}=Z,{image:ae,boxes:le,boxInd:he}=I,{cropSize:ue,method:pe,extrapolationValue:ve}=re,[we,Me,Le,Ue]=ae.shape,Ge=le.shape[0],[ze,He]=ue,Ke=t7([Ge,ze,He,Ue],"float32"),Ye=V.data.get(le.dataId).values,$e=V.data.get(he.dataId).values,je=V.data.get(ae.dataId).values,rt=C5(ae.shape),at=C5(Ke.shape);for(let Rt=0;Rt<Ge;Rt++){const lt=Rt*4,kt=Ye[lt],qt=Ye[lt+1],Kt=Ye[lt+2],_i=Ye[lt+3],ci=$e[Rt];if(ci>=we)continue;const li=ze>1?(Kt-kt)*(Me-1)/(ze-1):0,qi=He>1?(_i-qt)*(Le-1)/(He-1):0;for(let Ki=0;Ki<ze;Ki++){const hs=ze>1?kt*(Me-1)+Ki*li:.5*(kt+Kt)*(Me-1);if(hs<0||hs>Me-1){for(let Yi=0;Yi<He;Yi++)for(let ns=0;ns<Ue;ns++){const Gs=ns+Yi*at[2]+Ki*at[1]+Rt*at[0];Ke.values[Gs]=ve}continue}if(pe==="bilinear"){const Yi=Math.floor(hs),ns=Math.ceil(hs),Gs=hs-Yi;for(let Xs=0;Xs<He;Xs++){const $i=He>1?qt*(Le-1)+Xs*qi:.5*(qt+_i)*(Le-1);if($i<0||$i>Le-1){for(let Wi=0;Wi<Ue;Wi++){const us=Wi+Xs*at[2]+Ki*at[1]+Rt*at[0];Ke.values[us]=ve}continue}const xs=Math.floor($i),hi=Math.ceil($i),Ri=$i-xs;for(let Wi=0;Wi<Ue;Wi++){let us=Wi+xs*rt[2]+Yi*rt[1]+ci*rt[0];const Ks=je[us];us=Wi+hi*rt[2]+Yi*rt[1]+ci*rt[0];const ur=je[us];us=Wi+xs*rt[2]+ns*rt[1]+ci*rt[0];const js=je[us];us=Wi+hi*rt[2]+ns*rt[1]+ci*rt[0];const sr=je[us],cr=Ks+(ur-Ks)*Ri,ln=js+(sr-js)*Ri;us=Wi+Xs*at[2]+Ki*at[1]+Rt*at[0],Ke.values[us]=cr+(ln-cr)*Gs}}}else for(let Yi=0;Yi<He;++Yi){const ns=He>1?qt*(Le-1)+Yi*qi:.5*(qt+_i)*(Le-1);if(ns<0||ns>Le-1){for(let $i=0;$i<Ue;$i++){const xs=$i+Yi*at[2]+Ki*at[1]+Rt*at[0];Ke.values[xs]=ve}continue}const Gs=Math.round(ns),Xs=Math.round(hs);for(let $i=0;$i<Ue;$i++){const xs=$i+Gs*rt[2]+Xs*rt[1]+ci*rt[0],hi=$i+Yi*at[2]+Ki*at[1]+Rt*at[0];Ke.values[hi]=je[xs]}}}}return V.makeTensorInfo(Ke.shape,Ke.dtype,Ke.values)}const y3={kernelName:Cv,backendName:"cpu",kernelFunc:y2};function y4(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{blockSize:le,dataFormat:he}=re;e(he==="NHWC",()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+he);const ue=ae.shape[0],pe=ae.shape[1],ve=ae.shape[2],we=ae.shape[3],Me=pe*le,Le=ve*le,Ue=we/(le*le),Ge=V.data.get(ae.dataId).values,ze=new Float32Array(ue*Me*Le*Ue);let He=0;for(let Ke=0;Ke<ue;++Ke)for(let Ye=0;Ye<Me;++Ye){const $e=Math.floor(Ye/le),je=Ye%le;for(let rt=0;rt<Le;++rt){const at=Math.floor(rt/le),Rt=rt%le,lt=(je*le+Rt)*Ue;for(let kt=0;kt<Ue;++kt){const qt=kt+lt+we*(at+ve*($e+pe*Ke));ze[He++]=Ge[qt]}}}return V.makeTensorInfo([ue,Me,Le,Ue],ae.dtype,ze)}const y5={kernelName:Cq,backendName:"cpu",kernelFunc:y4};function y6(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,filter:le}=I,{strides:he,pad:ue,dilations:pe,dimRoundingMode:ve}=re;gs([ae,le],"depthwiseConv2DNative");const we=C5(ae.shape),Me=C5(le.shape);let Le=pe;Le==null&&(Le=[1,1]),e(Oa(he,Le),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+he+" and dilations '"+Le+"'");const Ue=OA(ae.shape,le.shape,he,Le,ue,ve,!0),{filterHeight:Ge,filterWidth:ze,dilationHeight:He,dilationWidth:Ke,padInfo:Ye}=Ue,$e=Ye.left,je=Ye.top,rt=Ue.outChannels/Ue.inChannels,at=new J8(Ue.outShape,ae.dtype),Rt=V.data.get(ae.dataId).values,lt=V.data.get(le.dataId).values,kt=at.values;for(let qt=0;qt<Ue.batchSize;++qt){const Kt=qt*we[0],_i=qt*at.strides[0];for(let ci=0;ci<Ue.outHeight;++ci){const li=_i+ci*at.strides[1],qi=ci*Ue.strideHeight-je;for(let Ki=0;Ki<Ge;++Ki){const hs=qi+Ki*He;if(hs<0||hs>=Ue.inHeight)continue;const Yi=Ki*Me[0],ns=Kt+hs*we[1];for(let Gs=0;Gs<Ue.outWidth;++Gs){const Xs=li+Gs*at.strides[2],$i=Gs*Ue.strideWidth-$e;for(let xs=0;xs<ze;++xs){const hi=$i+xs*Ke;if(hi<0||hi>=Ue.inWidth)continue;const Ri=Yi+xs*Me[1],Wi=ns+hi*Ue.inChannels;let us=Xs,Ks=Ri;for(let ur=0;ur<Ue.inChannels;++ur){const js=Rt[Wi+ur];for(let sr=0;sr<rt;++sr)kt[us+sr]+=js*lt[Ks+sr];us+=rt,Ks+=rt}}}}}}return V.makeTensorInfo(at.shape,at.dtype,at.values)}const y7={kernelName:Cl,backendName:"cpu",kernelFunc:y6};function y8(Z){const{inputs:I,backend:V,attrs:re}=Z,{input:ae}=I,{dim:le}=re,he=ae.shape.length,ue=ae.shape.slice();let pe=le;return le<0&&(e(-(he+1)<=le,()=>"Axis must be in the interval ["+-(he+1)+", "+he+"]"),pe=he+le+1),ue.splice(pe,0,1),IL({inputs:{x:ae},backend:V,attrs:{shape:ue}})}const y9={kernelName:Cz,backendName:"cpu",kernelFunc:y8};function yC(Z){const{backend:I,attrs:V}=Z,{shape:re,value:ae,dtype:le}=V,he=le||C2(ae),ue=x(he,F(re));return yN(ue,ae,he),I.makeTensorInfo(re,he,ue)}const ym={kernelName:Cx,backendName:"cpu",kernelFunc:yC};function yN(Z,I,V){Z.fill(I)}const yJ=gU(Ck,Z=>Z>=0?Z:Math.exp(Z)-1);function yf(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{alpha:le}=re;gs([ae],"leakyRelu");const he=F(ae.shape),ue=V.data.get(ae.dataId).values,pe=H("float32",he);for(let ve=0;ve<ue.length;ve++)pe[ve]=ue[ve]<0?le*ue[ve]:ue[ve];return V.makeTensorInfo(ae.shape,"float32",pe)}const yi=gA((Z,I)=>Z<0?I*Z:Z);function yO(Z){const{inputs:I,backend:V}=Z,{x:re,alpha:ae}=I;gs([re,ae],"prelu");const le=V.data.get(re.dataId).values,he=V.data.get(ae.dataId).values,[ue,pe]=yi(re.shape,ae.shape,le,he,"float32");return V.makeTensorInfo(pe,"float32",ue)}const yt={kernelName:mS,backendName:"cpu",kernelFunc:yO},yB=gU(mb,Z=>Math.max(0,Z)),yS={kernelName:mb,backendName:"cpu",kernelFunc:yB},yd=gU(mg,Z=>Math.min(Math.max(0,Z),6)),yV={kernelName:mg,backendName:"cpu",kernelFunc:yd};function yb(Z,I,V,re,ae){if(V==="linear")return gX({inputs:{x:I},backend:Z});if(V==="relu")return yB({inputs:{x:I},backend:Z});if(V==="elu")return yJ({inputs:{x:I},backend:Z});if(V==="relu6")return yd({inputs:{x:I},backend:Z});if(V==="prelu")return yO({inputs:{x:I,alpha:re},backend:Z});if(V==="leakyrelu")return yf({inputs:{x:I},backend:Z,attrs:{alpha:ae}});if(V==="sigmoid")return ZG({inputs:{x:I},backend:Z});throw new Error("Activation "+V+" has not been implemented for the CPU backend.")}function yP(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,filter:le,bias:he,preluActivationWeights:ue}=I,{strides:pe,pad:ve,dataFormat:we,dilations:Me,dimRoundingMode:Le,activation:Ue,leakyreluAlpha:Ge}=re;let ze=IM({inputs:{x:ae,filter:le},backend:V,attrs:{strides:pe,pad:ve,dataFormat:we,dilations:Me,dimRoundingMode:Le}});if(he){const He=ze;if(we==="NCHW"&&he.shape.length===1&&he.shape[0]!==1){const Ke=IL({inputs:{x:he},backend:V,attrs:{shape:[he.shape[0],1,1]}});ze=gn({inputs:{a:ze,b:Ke},backend:V}),V.disposeIntermediateTensorInfo(Ke)}else ze=gn({inputs:{a:ze,b:he},backend:V});V.disposeIntermediateTensorInfo(He)}if(Ue){const He=ze;if(we==="NCHW"&&Ue==="prelu"&&ue.shape.length===1&&ue.shape[0]!==1){const Ke=IL({inputs:{x:ue},backend:V,attrs:{shape:[ue.shape[0],1,1]}});ze=yb(V,ze,Ue,Ke,Ge),V.disposeIntermediateTensorInfo(Ke)}else ze=yb(V,ze,Ue,ue,Ge);V.disposeIntermediateTensorInfo(He)}return ze}const yE={kernelName:mL,backendName:"cpu",kernelFunc:yP};function yD(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,filter:le,bias:he,preluActivationWeights:ue}=I,{strides:pe,pad:ve,dataFormat:we,dilations:Me,dimRoundingMode:Le,activation:Ue,leakyreluAlpha:Ge}=re;let ze=y6({inputs:{x:ae,filter:le},backend:V,attrs:{strides:pe,pad:ve,dataFormat:we,dilations:Me,dimRoundingMode:Le}});if(he){const He=ze;ze=gn({inputs:{a:ze,b:he},backend:V}),V.disposeIntermediateTensorInfo(He)}if(Ue){const He=ze;ze=yb(V,ze,Ue,ue,Ge),V.disposeIntermediateTensorInfo(He)}return ze}const yg={kernelName:mH,backendName:"cpu",kernelFunc:yD};function yZ(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae,indices:le}=I,{axis:he,batchDims:ue}=re;gs([ae,le],"gatherV2");const pe=n(he,ae.shape)[0],ve=V.data.get(le.dataId).values,we=ae.shape[pe];for(let je=0;je<ve.length;++je){const rt=ve[je];e(rt<=we-1&&rt>=0,()=>"GatherV2: the index value "+rt+" is not in [0, "+(we-1)+"]")}let Me=ue;ue==null&&(Me=0);const Le=F(le.shape),Ue=VZ(ae,le,pe,Me),Ge=IL({inputs:{x:ae},backend:V,attrs:{shape:[Ue.batchSize,Ue.outerSize,Ue.dimSize,Ue.sliceSize]}}),ze=IL({inputs:{x:le},backend:V,attrs:{shape:[Ue.batchSize,Le/Ue.batchSize]}}),He=[Ue.batchSize,Ue.outerSize,Le/Ue.batchSize,Ue.sliceSize],Ke=V.bufferSync(ze),Ye=V.bufferSync(Ge),$e=Z4(Ye,Ke,He);return V.disposeIntermediateTensorInfo(Ge),V.disposeIntermediateTensorInfo(ze),V.makeTensorInfo(Ue.outputShape,$e.dtype,$e.values)}const yo={kernelName:CY,backendName:"cpu",kernelFunc:yZ},ye=gA((Z,I)=>Z&&I),yQ=gv(m3,ye,null,"bool"),ys={kernelName:m3,backendName:"cpu",kernelFunc:yQ},yF=gA((Z,I)=>Z||I),yI=gv(m4,yF,null,"bool"),yy={kernelName:m4,backendName:"cpu",kernelFunc:yI};function yA(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{reductionIndices:le,keepDims:he}=re,ue=V;let pe=ae.shape;const ve=pe.length,we=n(le,pe);let Me=we;const Le=tW(Me,ve);let Ue=ue.data.get(ae.dataId).values;if(Le!=null){const je=new Array(ve);for(let rt=0;rt<je.length;rt++)je[rt]=pe[Le[rt]];Ue=ZF(Ue,pe,ae.dtype,Le,je),Me=tK(Me.length,ve),pe=je}gs(ae,"max"),tc("max",Me,ve);const[Ge,ze]=tw(pe,Me),He=F(ze),Ke=Zt(Ue,He,Ge,ae.dtype),Ye=ue.write(Ke,Ge,ae.dtype);let $e=Ge;return he&&($e=tX(Ge,we)),{dataId:Ye,shape:$e,dtype:ae.dtype}}const yp={kernelName:m5,backendName:"cpu",kernelFunc:yA};function yw(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I;gs(ae,"maxPool");const{filterSize:le,strides:he,pad:ue,dimRoundingMode:pe}=re,ve=1;e(Oa(he,ve),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+he+" and dilations '"+ve+"'");const we=OI(ae.shape,le,he,ve,ue,pe);let Me;if(we.filterWidth===1&&we.filterHeight===1&&X(we.inShape,we.outShape))Me=gX({inputs:{x:ae},backend:V});else{const Le=V.data.get(ae.dataId).values,Ue=C5(ae.shape),Ge=Il(Le,ae.shape,ae.dtype,Ue,we,"max");Me=V.makeTensorInfo(we.outShape,ae.dtype,Ge.values)}return Me}const yX={kernelName:m7,backendName:"cpu",kernelFunc:yw},yc=gA((Z,I)=>Z/I),yW=gv(CL,yc),yR={kernelName:CL,backendName:"cpu",kernelFunc:yW};function yK(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{axis:le,keepDims:he}=re;gs(ae,"sum");let ue;ae.dtype==="bool"?ue=gK({inputs:{x:ae},backend:V,attrs:{dtype:"int32"}}):ue=gX({inputs:{x:ae},backend:V});const pe=ue.shape.length,ve=n(le,ue.shape),we=tW(ve,pe);let Me=ve,Le=ue;we!=null&&(Le=ZI({inputs:{x:ue},backend:V,attrs:{perm:we}}),Me=tK(Me.length,pe)),tc("sum",Me,Le.shape.length);const[Ue,Ge]=tw(Le.shape,Me),ze=Jb(Le.dtype,"int32");let He=gw(V,Ue,ze);const Ke=F(Ge),Ye=V.data.get(He.dataId).values,$e=V.data.get(Le.dataId).values;for(let je=0;je<Ye.length;++je){const rt=je*Ke;let at=0;for(let Rt=0;Rt<Ke;++Rt)at+=$e[rt+Rt];Ye[je]=at}if(he){const je=tX(He.shape,ve),rt=He;He=IL({inputs:{x:He},backend:V,attrs:{shape:je}}),V.disposeIntermediateTensorInfo(rt)}return V.disposeIntermediateTensorInfo(ue),we!=null&&V.disposeIntermediateTensorInfo(Le),He}const yT={kernelName:my,backendName:"cpu",kernelFunc:yK};function yv(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{axis:le,keepDims:he}=re,ue=n(le,ae.shape),pe=tw(ae.shape,ue)[1],ve=F(pe),we=[],Me=V.makeTensorInfo([],"float32",new Float32Array([ve]));we.push(Me);const Le=gK({inputs:{x:ae},backend:V,attrs:{dtype:"float32"}});we.push(Le);const Ue=yW({inputs:{a:Le,b:Me},backend:V});we.push(Ue);const Ge=yK({inputs:{x:Ue},backend:V,attrs:{axis:le,keepDims:he}});return we.forEach(ze=>V.disposeIntermediateTensorInfo(ze)),Ge}const yq={kernelName:m8,backendName:"cpu",kernelFunc:yv};function yl(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{axis:le,keepDims:he}=re;gs(ae,"min");const ue=n(le,ae.shape);let pe=ue;const ve=tW(pe,ae.shape.length);let we=ae;ve!=null&&(we=ZI({inputs:{x:ae},backend:V,attrs:{perm:ve}}),pe=tK(pe.length,ae.shape.length)),tc("min",pe,we.shape.length);const[Me,Le]=tw(we.shape,pe),Ue=F(Le),Ge=CC(F(Me),we.dtype),ze=V.data.get(we.dataId).values;for(let Ke=0;Ke<Ge.length;++Ke){const Ye=Ke*Ue;let $e=ze[Ye];for(let je=0;je<Ue;++je){const rt=ze[Ye+je];(Number.isNaN(rt)||rt<$e)&&($e=rt)}Ge[Ke]=$e}ve!=null&&V.disposeIntermediateTensorInfo(we);const He=V.makeTensorInfo(Me,we.dtype,Ge);if(he){const Ke=tX(Me,ue),Ye=IL({inputs:{x:He},backend:V,attrs:{shape:Ke}});return V.disposeIntermediateTensorInfo(He),Ye}return He}const ya={kernelName:m9,backendName:"cpu",kernelFunc:yl};function yn(Z){const{inputs:I,backend:V,attrs:re}=Z,{axis:ae}=re;if(I.length===1)return y8({inputs:{input:I[0]},backend:V,attrs:{dim:ae}});const le=I[0].shape,he=I[0].dtype;I.forEach(we=>{Q(le,we.shape,"All tensors passed to stack must have matching shapes"),e(he===we.dtype,()=>"All tensors passed to stack must have matching dtypes")});const ue=[],pe=I.map(we=>{const Me=y8({inputs:{input:we},backend:V,attrs:{dim:ae}});return ue.push(Me),Me}),ve=Iu({inputs:pe,backend:V,attrs:{axis:ae}});return ue.forEach(we=>V.disposeIntermediateTensorInfo(we)),ve}const yL={kernelName:mO,backendName:"cpu",kernelFunc:yn};function yH(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{paddings:le,constantValue:he}=re;gs(ae,"pad");const ue=le.map((Ke,Ye)=>Ke[0]+ae.shape[Ye]+Ke[1]),pe=le.map(Ke=>Ke[0]),ve=V.data.get(ae.dataId).values,we=F(ae.shape),Me=ae.shape.length,Le=C5(ae.shape),Ue=F(ue),Ge=ue.length,ze=C5(ue),He=H(ae.dtype,Ue);he!==0&&He.fill(he);for(let Ke=0;Ke<we;Ke++){const Ye=CJ(Ke,Me,Le).map((je,rt)=>je+pe[rt]),$e=CN(Ye,Ge,ze);He[$e]=ve[Ke]}return{dataId:V.write(He,ue,ae.dtype),shape:ue,dtype:ae.dtype}}const yk={kernelName:mt,backendName:"cpu",kernelFunc:yH},yz=gA((Z,I)=>Math.pow(Z,I)),yx=gv(mB,yz),yU={kernelName:mB,backendName:"cpu",kernelFunc:yx};function yG(Z){const{backend:I,attrs:V}=Z,{start:re,stop:ae,dtype:le,step:he}=V,ue=Zk(re,ae,he,le);return I.makeTensorInfo([ue.length],le,ue)}const yu={kernelName:md,backendName:"cpu",kernelFunc:yG};function yY(Z){const{inputs:I,backend:V,attrs:re}=Z,{images:ae}=I,{alignCorners:le,halfPixelCenters:he,size:ue}=re;gs(ae,"resizeBilinear");const pe=C5(ae.shape),[ve,we]=ue,[Me,Le,Ue,Ge]=ae.shape,ze=V.data.get(ae.dataId).values,He=new Float32Array(F([Me,ve,we,Ge])),Ke=[le&&ve>1?Le-1:Le,le&&we>1?Ue-1:Ue],Ye=[le&&ve>1?ve-1:ve,le&&we>1?we-1:we];let $e=0;const je=Ke[0]/Ye[0],rt=Ke[1]/Ye[1];for(let at=0;at<Me;at++)for(let Rt=0;Rt<ve;Rt++){let lt;he?lt=je*(Rt+.5)-.5:lt=je*Rt;const kt=Math.max(0,Math.floor(lt)),qt=lt-kt,Kt=Math.min(Le-1,Math.ceil(lt)),_i=at*pe[0]+kt*pe[1],ci=at*pe[0]+Kt*pe[1];for(let li=0;li<we;li++){let qi;he?qi=rt*(li+.5)-.5:qi=rt*li;const Ki=Math.max(0,Math.floor(qi)),hs=qi-Ki,Yi=Math.min(Ue-1,Math.ceil(qi)),ns=_i+Ki*pe[2],Gs=ci+Ki*pe[2],Xs=_i+Yi*pe[2],$i=ci+Yi*pe[2];for(let xs=0;xs<Ge;xs++){const hi=ze[ns+xs],Ri=ze[Gs+xs],Wi=ze[Xs+xs],us=ze[$i+xs],Ks=hi+(Wi-hi)*hs,ur=Ri+(us-Ri)*hs,js=Ks+(ur-Ks)*qt;He[$e++]=js}}}return V.makeTensorInfo([Me,ve,we,Ge],"float32",He)}const yM={kernelName:mD,backendName:"cpu",kernelFunc:yY},yh={kernelName:ma,backendName:"cpu",kernelFunc:({inputs:Z,attrs:I,backend:V})=>{const{image:re}=Z,{radians:ae,fillValue:le,center:he}=I,ue=V,pe=H(re.dtype,F(re.shape)),[ve,we,Me,Le]=re.shape,[Ue,Ge]=dK(he,we,Me),ze=255,He=Math.sin(ae),Ke=Math.cos(ae),Ye=ue.data.get(re.dataId).values;for(let $e=0;$e<ve;$e++){const je=$e*Me*we*Le;for(let rt=0;rt<we;rt++){const at=rt*(Me*Le);for(let Rt=0;Rt<Me;Rt++){const lt=Rt*Le;for(let kt=0;kt<Le;kt++){const qt=[ve,rt,Rt,kt],Kt=qt[2],_i=qt[1];let ci=(Kt-Ue)*Ke-(_i-Ge)*He,li=(Kt-Ue)*He+(_i-Ge)*Ke;ci=Math.round(ci+Ue),li=Math.round(li+Ge);let qi=le;if(typeof le!="number"&&(kt===3?qi=ze:qi=le[kt]),ci>=0&&ci<Me&&li>=0&&li<we){const hs=li*(Me*Le),Yi=ci*Le,ns=je+hs+Yi+kt;qi=Ye[ns]}const Ki=je+at+lt+kt;pe[Ki]=qi}}}}return{dataId:ue.write(pe,re.shape,re.dtype),shape:re.shape,dtype:re.dtype}}},yj=gU(ms,Z=>Math.sin(Z)),yr={kernelName:ms,backendName:"cpu",kernelFunc:yj},A0={kernelName:mw,backendName:"cpu",kernelFunc:({inputs:Z,backend:I})=>{const{x:V}=Z,re=I;gs(V,"square");const ae=re.data.get(V.dataId).values,le=new Float32Array(ae.length);for(let he=0;he<ae.length;++he){const ue=ae[he];le[he]=ue*ue}return{dataId:re.write(le,V.shape,V.dtype),shape:V.shape,dtype:V.dtype}}};function A1(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{begin:le,end:he,strides:ue,beginMask:pe,endMask:ve,ellipsisMask:we,newAxisMask:Me,shrinkAxisMask:Le}=re;gs(ae,"stridedSlice");const{finalShapeSparse:Ue,finalShape:Ge,isIdentity:ze,sliceDim0:He,isSimpleSlice:Ke,begin:Ye,end:$e,strides:je}=Of(ae.shape,le,he,ue,pe,ve,we,Me,Le);let rt;if(ze)rt=IL({inputs:{x:ae},backend:V,attrs:{shape:Ge}});else if(He||Ke){e(ae.shape.length>=1,()=>"Input must have rank at least 1, got: "+ae.shape.length);const at=O1(Ye,$e,je),Rt=ZM({inputs:{x:ae},backend:V,attrs:{begin:Ye,size:at}});rt=IL({inputs:{x:Rt},backend:V,attrs:{shape:Ge}}),V.disposeIntermediateTensorInfo(Rt)}else{const at=V.bufferSync(ae),Rt=o6(Ue,at,je,Ye);rt=V.makeTensorInfo(Ge,Rt.dtype,Rt.values)}return rt}const A2={kernelName:mX,backendName:"cpu",kernelFunc:A1};function A3(Z){const{inputs:I,backend:V,attrs:re}=Z,{x:ae}=I,{reps:le}=re;gs(ae,"tile");const he=oO(V.bufferSync(ae),le);return V.makeTensorInfo(he.shape,he.dtype,he.values)}const A4={kernelName:mW,backendName:"cpu",kernelFunc:A3};function A5(Z){const{inputs:I,attrs:V,backend:re}=Z,{image:ae,transforms:le}=I,{interpolation:he,fillMode:ue,fillValue:pe,outputShape:ve}=V,[we,Me,Le,Ue]=ae.shape,[Ge,ze]=ve??[Me,Le],He=[we,Ge,ze,Ue],Ke=C5(ae.shape),Ye=Ke[0],$e=Ke[1],je=Ke[2],rt=C5(He),at=rt[0],Rt=rt[1],lt=rt[2],kt=H(ae.dtype,F(He));kt.fill(pe);const qt=re.data.get(ae.dataId).values,Kt=re.data.get(le.dataId).values;for(let _i=0;_i<we;++_i){const ci=le.shape[0]===1?Kt:Kt.subarray(_i*8,_i*8+8);for(let li=0;li<Ge;++li)for(let qi=0;qi<ze;++qi)for(let Ki=0;Ki<Ue;++Ki){let hs;const Yi=ci[6]*qi+ci[7]*li+1;if(Yi===0)continue;const ns=(ci[0]*qi+ci[1]*li+ci[2])/Yi,Gs=(ci[3]*qi+ci[4]*li+ci[5])/Yi,Xs=A7(ns,Le,ue),$i=A7(Gs,Me,ue);switch(he){case"nearest":hs=AJ(qt,Me,Le,Ye,$e,je,_i,$i,Xs,Ki,pe);break;case"bilinear":hs=Af(qt,Me,Le,Ye,$e,je,_i,$i,Xs,Ki,pe);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got "+he)}const xs=_i*at+li*Rt+qi*lt+Ki;kt[xs]=hs}return re.makeTensorInfo(He,ae.dtype,kt)}return{dataId:re.write(kt,He,ae.dtype),shape:ae.shape,dtype:ae.dtype}}const A6={kernelName:mR,backendName:"cpu",kernelFunc:A5};function A7(Z,I,V){switch(V){case"reflect":return A8(Z,I);case"wrap":return A9(Z,I);case"nearest":return Am(Z,I);case"constant":default:return AC(Z)}}function A8(Z,I){let V=Z;if(V<0)if(I<=1)V=0;else{const re=2*I;V<re&&(V=re*Math.trunc(-V/re)+V),V=V<-I?V+re:-V-1}else if(V>I-1)if(I<=1)V=0;else{const re=2*I;V-=re*Math.trunc(V/re),V>=I&&(V=re-V-1)}return t(0,V,I-1)}function A9(Z,I){let V=Z;if(V<0)if(I<=1)V=0;else{const re=I-1;V+=I*(Math.trunc(-V/re)+1)}else if(V>I-1)if(I<=1)V=0;else{const re=I-1;V-=I*Math.trunc(V/re)}return t(0,V,I-1)}function AC(Z,I){return Z}function Am(Z,I){return t(0,Z,I-1)}function AN(Z,I,V,re,ae,le,he,ue,pe,ve,we){const Me=he*re+ue*ae+pe*le+ve;return 0<=ue&&ue<I&&0<=pe&&pe<V?Z[Me]:we}function AJ(Z,I,V,re,ae,le,he,ue,pe,ve,we){const Me=Math.round(ue),Le=Math.round(pe);return AN(Z,I,V,re,ae,le,he,Me,Le,ve,we)}function Af(Z,I,V,re,ae,le,he,ue,pe,ve,we){const Me=Math.floor(ue),Le=Math.floor(pe),Ue=Me+1,Ge=Le+1,ze=(Ge-pe)*AN(Z,I,V,re,ae,le,he,Me,Le,ve,we)+(pe-Le)*AN(Z,I,V,re,ae,le,he,Me,Ge,ve,we),He=(Ge-pe)*AN(Z,I,V,re,ae,le,he,Ue,Le,ve,we)+(pe-Le)*AN(Z,I,V,re,ae,le,he,Ue,Ge,ve,we);return(Ue-ue)*ze+(ue-Me)*He}function Ai(Z){const{inputs:I,backend:V}=Z,{x:re}=I;if(re.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(re.dtype==="complex64"){const ae=gW({inputs:{input:re},backend:V}),le=Ai({inputs:{x:ae},backend:V}),he=IG({inputs:{input:re},backend:V}),ue=Ai({inputs:{x:he},backend:V}),pe=gp({inputs:{real:le,imag:ue},backend:V});return V.disposeIntermediateTensorInfo(ae),V.disposeIntermediateTensorInfo(le),V.disposeIntermediateTensorInfo(he),V.disposeIntermediateTensorInfo(ue),pe}else return yC({backend:V,attrs:{shape:re.shape,value:0,dtype:re.dtype}})}const AO={kernelName:mv,backendName:"cpu",kernelFunc:Ai};function At(Z){const{inputs:I,backend:V,attrs:re}=Z,{a:ae,b:le,bias:he,preluActivationWeights:ue}=I,{transposeA:pe,transposeB:ve,activation:we,leakyreluAlpha:Me}=re;let Le,Ue,Ge;const ze=[];Le=Ik({inputs:{a:ae,b:le},attrs:{transposeA:pe,transposeB:ve},backend:V}),he&&(Ue=gn({inputs:{a:Le,b:he},backend:V}),ze.push(Le),Le=Ue),we&&(Ge=yb(V,Le,we,ue,Me),ze.push(Le),Le=Ge);for(const He of ze)V.disposeIntermediateTensorInfo(He);return Le}const AB={kernelName:mn,backendName:"cpu",kernelFunc:At};mM(ek),mM(Q9),mM(QJ),mM(QB),mM(QV),mM(Qa),mM(QU),mM(QM),mM(s4),mM(sN),mM(sO),mM(sd),mM(sP),mM(sg),mM(sQ),mM(sF),mM(sA),mM(sX),mM(sR),mM(sl),mM(sn),mM(sz),mM(su),mM(eY),mM(sj),mM(F3),mM(F7),mM(Fm),mM(Ff),mM(FO),mM(Fd),mM(Fb),mM(FE),mM(Fo),mM(QZ),mM(FF),mM(Fy),mM(FX),mM(FK),mM(Q2),mM(Fv),mM(Fn),mM(Fz),mM(Fu),mM(QQ),mM(Fj),mM(I0),mM(I4),mM(I8),mM(Ii),mM(IB),mM(IV),mM(IE),mM(IZ),mM(QR),mM(Is),mM(Iy),mM(QT),mM(Ip),mM(IX),mM(gy),mM(gL),mM(IK),mM(Iq),mM(In),mM(Iz),mM(gT),mM(IU),mM(IY),mM(Ih),mM(Ir),mM(y1),mM(y3),mM(y5),mM(y7),mM(y9),mM(ym),mM(Z1),mM(yE),mM(yg),mM(yo),mM(Z8),mM(gc),mM(Zm),mM(Zf),mM(ys),mM(yy),mM(yp),mM(yX),mM(Zd),mM(yq),mM(ya),mM(ZP),mM(ZZ),mM(ZQ),mM(yL),mM(yk),mM(yU),mM(yt),mM(yu),mM(yR),mM(yS),mM(yV),mM(IH),mM(yM),mM(yh),mM(Zu),mM(yr),mM(Zh),mM(o3),mM(A0),mM(A2),mM(oi),mM(yT),mM(A4),mM(A6),mM(Zy),mM(AO),mM(AB);var AS={};(function(p1){var p2=p1;typeof mr<"u"&&(mr.numeric=p2),p2.version="1.2.6",p2.bench=function(Z,I){var V,re,ae,le;for(typeof I>"u"&&(I=15),ae=.5,V=new Date;;){for(ae*=2,le=ae;le>3;le-=4)Z(),Z(),Z(),Z();for(;le>0;)Z(),le--;if(re=new Date,re-V>I)break}for(le=ae;le>3;le-=4)Z(),Z(),Z(),Z();for(;le>0;)Z(),le--;return re=new Date,1e3*(3*ae-1)/(re-V)},p2._myIndexOf=function(Z){var I=this.length,V;for(V=0;V<I;++V)if(this[V]===Z)return V;return-1},p2.myIndexOf=Array.prototype.indexOf?Array.prototype.indexOf:p2._myIndexOf,p2.Function=Function,p2.precision=4,p2.largeArray=50,p2.prettyPrint=function(Z){function I(ae){if(ae===0)return"0";if(isNaN(ae))return"NaN";if(ae<0)return"-"+I(-ae);if(isFinite(ae)){var le=Math.floor(Math.log(ae)/Math.log(10)),he=ae/Math.pow(10,le),ue=he.toPrecision(p2.precision);return parseFloat(ue)===10&&(le++,he=1,ue=he.toPrecision(p2.precision)),parseFloat(ue).toString()+"e"+le.toString()}return"Infinity"}var V=[];function re(ae){var le;if(typeof ae>"u")return V.push(Array(p2.precision+8).join(" ")),!1;if(typeof ae=="string")return V.push('"'+ae+'"'),!1;if(typeof ae=="boolean")return V.push(ae.toString()),!1;if(typeof ae=="number"){var he=I(ae),ue=ae.toPrecision(p2.precision),pe=parseFloat(ae.toString()).toString(),ve=[he,ue,pe,parseFloat(ue).toString(),parseFloat(pe).toString()];for(le=1;le<ve.length;le++)ve[le].length<he.length&&(he=ve[le]);return V.push(Array(p2.precision+8-he.length).join(" ")+he),!1}if(ae===null)return V.push("null"),!1;if(typeof ae=="function"){V.push(ae.toString());var we=!1;for(le in ae)ae.hasOwnProperty(le)&&(we?V.push(`,
`):V.push(`
{`),we=!0,V.push(le),V.push(`: 
`),re(ae[le]));return we&&V.push(`}
`),!0}if(ae instanceof Array){if(ae.length>p2.largeArray)return V.push("...Large Array..."),!0;var we=!1;for(V.push("["),le=0;le<ae.length;le++)le>0&&(V.push(","),we&&V.push(`
 `)),we=re(ae[le]);return V.push("]"),!0}V.push("{");var we=!1;for(le in ae)ae.hasOwnProperty(le)&&(we&&V.push(`,
`),we=!0,V.push(le),V.push(`: 
`),re(ae[le]));return V.push("}"),!0}return re(Z),V.join("")},p2.parseDate=function(Z){function I(V){if(typeof V=="string")return Date.parse(V.replace(/-/g,"/"));if(!(V instanceof Array))throw new Error("parseDate: parameter must be arrays of strings");var re=[],ae;for(ae=0;ae<V.length;ae++)re[ae]=I(V[ae]);return re}return I(Z)},p2.parseFloat=function(Z){function I(V){if(typeof V=="string")return parseFloat(V);if(!(V instanceof Array))throw new Error("parseFloat: parameter must be arrays of strings");var re=[],ae;for(ae=0;ae<V.length;ae++)re[ae]=I(V[ae]);return re}return I(Z)},p2.parseCSV=function(Z){var I=Z.split(`
`),V,re,ae=[],le=/(([^'",]*)|('[^']*')|("[^"]*")),/g,he=/^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/,ue=function(Me){return Me.substr(0,Me.length-1)},pe=0;for(re=0;re<I.length;re++){var ve=(I[re]+",").match(le),we;if(ve.length>0){for(ae[pe]=[],V=0;V<ve.length;V++)we=ue(ve[V]),he.test(we)?ae[pe][V]=parseFloat(we):ae[pe][V]=we;pe++}}return ae},p2.toCSV=function(Z){var I=p2.dim(Z),V,re,ae,le,he;for(ae=I[0],I[1],he=[],V=0;V<ae;V++){for(le=[],re=0;re<ae;re++)le[re]=Z[V][re].toString();he[V]=le.join(", ")}return he.join(`
`)+`
`},p2.getURL=function(Z){var I=new XMLHttpRequest;return I.open("GET",Z,!1),I.send(),I},p2.imageURL=function(Z){function I(He){var Ke=He.length,Ye,$e,je,rt,at,Rt,lt,kt,qt="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Kt="";for(Ye=0;Ye<Ke;Ye+=3)$e=He[Ye],je=He[Ye+1],rt=He[Ye+2],at=$e>>2,Rt=(($e&3)<<4)+(je>>4),lt=((je&15)<<2)+(rt>>6),kt=rt&63,Ye+1>=Ke?lt=kt=64:Ye+2>=Ke&&(kt=64),Kt+=qt.charAt(at)+qt.charAt(Rt)+qt.charAt(lt)+qt.charAt(kt);return Kt}function V(He,Ke,Ye){typeof Ke>"u"&&(Ke=0),typeof Ye>"u"&&(Ye=He.length);var $e=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],je=-1,rt=0;He.length;var at;for(at=Ke;at<Ye;at++)rt=(je^He[at])&255,je=je>>>8^$e[rt];return je^-1}var re=Z[0].length,ae=Z[0][0].length,le,he,ue,pe,ve,we,Me,Le,Ue,Ge,ze=[137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,ae>>24&255,ae>>16&255,ae>>8&255,ae&255,re>>24&255,re>>16&255,re>>8&255,re&255,8,2,0,0,0,-1,-2,-3,-4,-5,-6,-7,-8,73,68,65,84,8,29];for(Ge=V(ze,12,29),ze[29]=Ge>>24&255,ze[30]=Ge>>16&255,ze[31]=Ge>>8&255,ze[32]=Ge&255,le=1,he=0,Me=0;Me<re;Me++){for(Me<re-1?ze.push(0):ze.push(1),ve=3*ae+1+(Me===0)&255,we=3*ae+1+(Me===0)>>8&255,ze.push(ve),ze.push(we),ze.push(~ve&255),ze.push(~we&255),Me===0&&ze.push(0),Le=0;Le<ae;Le++)for(ue=0;ue<3;ue++)ve=Z[ue][Me][Le],ve>255?ve=255:ve<0?ve=0:ve=Math.round(ve),le=(le+ve)%65521,he=(he+le)%65521,ze.push(ve);ze.push(0)}return Ue=(he<<16)+le,ze.push(Ue>>24&255),ze.push(Ue>>16&255),ze.push(Ue>>8&255),ze.push(Ue&255),pe=ze.length-41,ze[33]=pe>>24&255,ze[34]=pe>>16&255,ze[35]=pe>>8&255,ze[36]=pe&255,Ge=V(ze,37),ze.push(Ge>>24&255),ze.push(Ge>>16&255),ze.push(Ge>>8&255),ze.push(Ge&255),ze.push(0),ze.push(0),ze.push(0),ze.push(0),ze.push(73),ze.push(69),ze.push(78),ze.push(68),ze.push(174),ze.push(66),ze.push(96),ze.push(130),"data:image/png;base64,"+I(ze)},p2._dim=function(Z){for(var I=[];typeof Z=="object";)I.push(Z.length),Z=Z[0];return I},p2.dim=function(Z){var I,V;return typeof Z=="object"?(I=Z[0],typeof I=="object"?(V=I[0],typeof V=="object"?p2._dim(Z):[Z.length,I.length]):[Z.length]):[]},p2.mapreduce=function(Z,I){return Function("x","accum","_s","_k",'if(typeof accum === "undefined") accum = '+I+`;
if(typeof x === "number") { var xi = x; `+Z+`; return accum; }
if(typeof _s === "undefined") _s = numeric.dim(x);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i,xi;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) {
        accum = arguments.callee(x[i],accum,_s,_k+1);
    }    return accum;
}
for(i=_n-1;i>=1;i-=2) { 
    xi = x[i];
    `+Z+`;
    xi = x[i-1];
    `+Z+`;
}
if(i === 0) {
    xi = x[i];
    `+Z+`
}
return accum;`)},p2.mapreduce2=function(Z,I){return Function("x",`var n = x.length;
var i,xi;
`+I+`;
for(i=n-1;i!==-1;--i) { 
    xi = x[i];
    `+Z+`;
}
return accum;`)},p2.same=function Z(I,V){var re,ae;if(!(I instanceof Array)||!(V instanceof Array)||(ae=I.length,ae!==V.length))return!1;for(re=0;re<ae;re++)if(I[re]!==V[re])if(typeof I[re]=="object"){if(!Z(I[re],V[re]))return!1}else return!1;return!0},p2.rep=function(Z,I,V){typeof V>"u"&&(V=0);var re=Z[V],ae=Array(re),le;if(V===Z.length-1){for(le=re-2;le>=0;le-=2)ae[le+1]=I,ae[le]=I;return le===-1&&(ae[0]=I),ae}for(le=re-1;le>=0;le--)ae[le]=p2.rep(Z,I,V+1);return ae},p2.dotMMsmall=function(Z,I){var V,re,ae,le,he,ue,pe,ve,we,Me,Le;for(le=Z.length,he=I.length,ue=I[0].length,pe=Array(le),V=le-1;V>=0;V--){for(ve=Array(ue),we=Z[V],ae=ue-1;ae>=0;ae--){for(Me=we[he-1]*I[he-1][ae],re=he-2;re>=1;re-=2)Le=re-1,Me+=we[re]*I[re][ae]+we[Le]*I[Le][ae];re===0&&(Me+=we[0]*I[0][ae]),ve[ae]=Me}pe[V]=ve}return pe},p2._getCol=function(Z,I,V){var re=Z.length,ae;for(ae=re-1;ae>0;--ae)V[ae]=Z[ae][I],--ae,V[ae]=Z[ae][I];ae===0&&(V[0]=Z[0][I])},p2.dotMMbig=function(Z,I){var V=p2._getCol,re=I.length,ae=Array(re),le=Z.length,he=I[0].length,ue=new Array(le),pe,ve=p2.dotVV,we,Me;for(--re,--le,we=le;we!==-1;--we)ue[we]=Array(he);for(--he,we=he;we!==-1;--we)for(V(I,we,ae),Me=le;Me!==-1;--Me)pe=Z[Me],ue[Me][we]=ve(pe,ae);return ue},p2.dotMV=function(Z,I){var V=Z.length;I.length;var re,ae=Array(V),le=p2.dotVV;for(re=V-1;re>=0;re--)ae[re]=le(Z[re],I);return ae},p2.dotVM=function(Z,I){var V,re,ae,le,he,ue,pe;for(ae=Z.length,le=I[0].length,he=Array(le),re=le-1;re>=0;re--){for(ue=Z[ae-1]*I[ae-1][re],V=ae-2;V>=1;V-=2)pe=V-1,ue+=Z[V]*I[V][re]+Z[pe]*I[pe][re];V===0&&(ue+=Z[0]*I[0][re]),he[re]=ue}return he},p2.dotVV=function(Z,I){var V,re=Z.length,ae,le=Z[re-1]*I[re-1];for(V=re-2;V>=1;V-=2)ae=V-1,le+=Z[V]*I[V]+Z[ae]*I[ae];return V===0&&(le+=Z[0]*I[0]),le},p2.dot=function(Z,I){var V=p2.dim;switch(V(Z).length*1e3+V(I).length){case 2002:return I.length<10?p2.dotMMsmall(Z,I):p2.dotMMbig(Z,I);case 2001:return p2.dotMV(Z,I);case 1002:return p2.dotVM(Z,I);case 1001:return p2.dotVV(Z,I);case 1e3:return p2.mulVS(Z,I);case 1:return p2.mulSV(Z,I);case 0:return Z*I;default:throw new Error("numeric.dot only works on vectors and matrices")}},p2.diag=function(Z){var I,V,re,ae=Z.length,le=Array(ae),he;for(I=ae-1;I>=0;I--){for(he=Array(ae),V=I+2,re=ae-1;re>=V;re-=2)he[re]=0,he[re-1]=0;for(re>I&&(he[re]=0),he[I]=Z[I],re=I-1;re>=1;re-=2)he[re]=0,he[re-1]=0;re===0&&(he[0]=0),le[I]=he}return le},p2.getDiag=function(Z){var I=Math.min(Z.length,Z[0].length),V,re=Array(I);for(V=I-1;V>=1;--V)re[V]=Z[V][V],--V,re[V]=Z[V][V];return V===0&&(re[0]=Z[0][0]),re},p2.identity=function(Z){return p2.diag(p2.rep([Z],1))},p2.pointwise=function(Z,I,V){typeof V>"u"&&(V="");var re=[],ae,le=/\[i\]$/,he,ue="",pe=!1;for(ae=0;ae<Z.length;ae++)le.test(Z[ae])?(he=Z[ae].substring(0,Z[ae].length-3),ue=he):he=Z[ae],he==="ret"&&(pe=!0),re.push(he);return re[Z.length]="_s",re[Z.length+1]="_k",re[Z.length+2]='if(typeof _s === "undefined") _s = numeric.dim('+ue+`);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i`+(pe?"":", ret = Array(_n)")+`;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(`+Z.join(",")+`,_s,_k+1);
    return ret;
}
`+V+`
for(i=_n-1;i!==-1;--i) {
    `+I+`
}
return ret;`,Function.apply(null,re)},p2.pointwise2=function(Z,I,V){typeof V>"u"&&(V="");var re=[],ae,le=/\[i\]$/,he,ue="",pe=!1;for(ae=0;ae<Z.length;ae++)le.test(Z[ae])?(he=Z[ae].substring(0,Z[ae].length-3),ue=he):he=Z[ae],he==="ret"&&(pe=!0),re.push(he);return re[Z.length]="var _n = "+ue+`.length;
var i`+(pe?"":", ret = Array(_n)")+`;
`+V+`
for(i=_n-1;i!==-1;--i) {
`+I+`
}
return ret;`,Function.apply(null,re)},p2._biforeach=function Z(I,V,re,ae,le){if(ae===re.length-1){le(I,V);return}var he,ue=re[ae];for(he=ue-1;he>=0;he--)Z(typeof I=="object"?I[he]:I,typeof V=="object"?V[he]:V,re,ae+1,le)},p2._biforeach2=function Z(I,V,re,ae,le){if(ae===re.length-1)return le(I,V);var he,ue=re[ae],pe=Array(ue);for(he=ue-1;he>=0;--he)pe[he]=Z(typeof I=="object"?I[he]:I,typeof V=="object"?V[he]:V,re,ae+1,le);return pe},p2._foreach=function Z(I,V,re,ae){if(re===V.length-1){ae(I);return}var le,he=V[re];for(le=he-1;le>=0;le--)Z(I[le],V,re+1,ae)},p2._foreach2=function Z(I,V,re,ae){if(re===V.length-1)return ae(I);var le,he=V[re],ue=Array(he);for(le=he-1;le>=0;le--)ue[le]=Z(I[le],V,re+1,ae);return ue},p2.ops2={add:"+",sub:"-",mul:"*",div:"/",mod:"%",and:"&&",or:"||",eq:"===",neq:"!==",lt:"<",gt:">",leq:"<=",geq:">=",band:"&",bor:"|",bxor:"^",lshift:"<<",rshift:">>",rrshift:">>>"},p2.opseq={addeq:"+=",subeq:"-=",muleq:"*=",diveq:"/=",modeq:"%=",lshifteq:"<<=",rshifteq:">>=",rrshifteq:">>>=",bandeq:"&=",boreq:"|=",bxoreq:"^="},p2.mathfuns=["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan","isNaN","isFinite"],p2.mathfuns2=["atan2","pow","max","min"],p2.ops1={neg:"-",not:"!",bnot:"~",clone:""},p2.mapreducers={any:["if(xi) return true;","var accum = false;"],all:["if(!xi) return false;","var accum = true;"],sum:["accum += xi;","var accum = 0;"],prod:["accum *= xi;","var accum = 1;"],norm2Squared:["accum += xi*xi;","var accum = 0;"],norminf:["accum = max(accum,abs(xi));","var accum = 0, max = Math.max, abs = Math.abs;"],norm1:["accum += abs(xi)","var accum = 0, abs = Math.abs;"],sup:["accum = max(accum,xi);","var accum = -Infinity, max = Math.max;"],inf:["accum = min(accum,xi);","var accum = Infinity, min = Math.min;"]},function(){var Z,I;for(Z=0;Z<p2.mathfuns2.length;++Z)I=p2.mathfuns2[Z],p2.ops2[I]=I;for(Z in p2.ops2)if(p2.ops2.hasOwnProperty(Z)){I=p2.ops2[Z];var V,re,ae="";p2.myIndexOf.call(p2.mathfuns2,Z)!==-1?(ae="var "+I+" = Math."+I+`;
`,V=function(le,he,ue){return le+" = "+I+"("+he+","+ue+")"},re=function(le,he){return le+" = "+I+"("+le+","+he+")"}):(V=function(le,he,ue){return le+" = "+he+" "+I+" "+ue},p2.opseq.hasOwnProperty(Z+"eq")?re=function(le,he){return le+" "+I+"= "+he}:re=function(le,he){return le+" = "+le+" "+I+" "+he}),p2[Z+"VV"]=p2.pointwise2(["x[i]","y[i]"],V("ret[i]","x[i]","y[i]"),ae),p2[Z+"SV"]=p2.pointwise2(["x","y[i]"],V("ret[i]","x","y[i]"),ae),p2[Z+"VS"]=p2.pointwise2(["x[i]","y"],V("ret[i]","x[i]","y"),ae),p2[Z]=Function(`var n = arguments.length, i, x = arguments[0], y;
var VV = numeric.`+Z+"VV, VS = numeric."+Z+"VS, SV = numeric."+Z+`SV;
var dim = numeric.dim;
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof x === "object") {
      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);
      else x = numeric._biforeach2(x,y,dim(x),0,VS);
  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);
  else `+re("x","y")+`
}
return x;
`),p2[I]=p2[Z],p2[Z+"eqV"]=p2.pointwise2(["ret[i]","x[i]"],re("ret[i]","x[i]"),ae),p2[Z+"eqS"]=p2.pointwise2(["ret[i]","x"],re("ret[i]","x"),ae),p2[Z+"eq"]=Function(`var n = arguments.length, i, x = arguments[0], y;
var V = numeric.`+Z+"eqV, S = numeric."+Z+`eqS
var s = numeric.dim(x);
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);
  else numeric._biforeach(x,y,s,0,S);
}
return x;
`)}for(Z=0;Z<p2.mathfuns2.length;++Z)I=p2.mathfuns2[Z],delete p2.ops2[I];for(Z=0;Z<p2.mathfuns.length;++Z)I=p2.mathfuns[Z],p2.ops1[I]=I;for(Z in p2.ops1)p2.ops1.hasOwnProperty(Z)&&(ae="",I=p2.ops1[Z],p2.myIndexOf.call(p2.mathfuns,Z)!==-1&&Math.hasOwnProperty(I)&&(ae="var "+I+" = Math."+I+`;
`),p2[Z+"eqV"]=p2.pointwise2(["ret[i]"],"ret[i] = "+I+"(ret[i]);",ae),p2[Z+"eq"]=Function("x",'if(typeof x !== "object") return '+I+`x
var i;
var V = numeric.`+Z+`eqV;
var s = numeric.dim(x);
numeric._foreach(x,s,0,V);
return x;
`),p2[Z+"V"]=p2.pointwise2(["x[i]"],"ret[i] = "+I+"(x[i]);",ae),p2[Z]=Function("x",'if(typeof x !== "object") return '+I+`(x)
var i;
var V = numeric.`+Z+`V;
var s = numeric.dim(x);
return numeric._foreach2(x,s,0,V);
`));for(Z=0;Z<p2.mathfuns.length;++Z)I=p2.mathfuns[Z],delete p2.ops1[I];for(Z in p2.mapreducers)p2.mapreducers.hasOwnProperty(Z)&&(I=p2.mapreducers[Z],p2[Z+"V"]=p2.mapreduce2(I[0],I[1]),p2[Z]=Function("x","s","k",I[1]+`if(typeof x !== "object") {    xi = x;
`+I[0]+`;
    return accum;
}if(typeof s === "undefined") s = numeric.dim(x);
if(typeof k === "undefined") k = 0;
if(k === s.length-1) return numeric.`+Z+`V(x);
var xi;
var n = x.length, i;
for(i=n-1;i!==-1;--i) {
   xi = arguments.callee(x[i]);
`+I[0]+`;
}
return accum;
`))}(),p2.truncVV=p2.pointwise(["x[i]","y[i]"],"ret[i] = round(x[i]/y[i])*y[i];","var round = Math.round;"),p2.truncVS=p2.pointwise(["x[i]","y"],"ret[i] = round(x[i]/y)*y;","var round = Math.round;"),p2.truncSV=p2.pointwise(["x","y[i]"],"ret[i] = round(x/y[i])*y[i];","var round = Math.round;"),p2.trunc=function(Z,I){return typeof Z=="object"?typeof I=="object"?p2.truncVV(Z,I):p2.truncVS(Z,I):typeof I=="object"?p2.truncSV(Z,I):Math.round(Z/I)*I},p2.inv=function(Ge){var I=p2.dim(Ge),V=Math.abs,re=I[0],ae=I[1],le=p2.clone(Ge),he,ue,pe=p2.identity(re),ve,we,Me,Le,Ue,Ge;for(Le=0;Le<ae;++Le){var ze=-1,He=-1;for(Me=Le;Me!==re;++Me)Ue=V(le[Me][Le]),Ue>He&&(ze=Me,He=Ue);for(ue=le[ze],le[ze]=le[Le],le[Le]=ue,we=pe[ze],pe[ze]=pe[Le],pe[Le]=we,Ge=ue[Le],Ue=Le;Ue!==ae;++Ue)ue[Ue]/=Ge;for(Ue=ae-1;Ue!==-1;--Ue)we[Ue]/=Ge;for(Me=re-1;Me!==-1;--Me)if(Me!==Le){for(he=le[Me],ve=pe[Me],Ge=he[Le],Ue=Le+1;Ue!==ae;++Ue)he[Ue]-=ue[Ue]*Ge;for(Ue=ae-1;Ue>0;--Ue)ve[Ue]-=we[Ue]*Ge,--Ue,ve[Ue]-=we[Ue]*Ge;Ue===0&&(ve[0]-=we[0]*Ge)}}return pe},p2.det=function(Z){var I=p2.dim(Z);if(I.length!==2||I[0]!==I[1])throw new Error("numeric: det() only works on square matrices");var V=I[0],re=1,ae,le,he,ue=p2.clone(Z),pe,ve,we,Me,Le;for(le=0;le<V-1;le++){for(he=le,ae=le+1;ae<V;ae++)Math.abs(ue[ae][le])>Math.abs(ue[he][le])&&(he=ae);for(he!==le&&(Me=ue[he],ue[he]=ue[le],ue[le]=Me,re*=-1),pe=ue[le],ae=le+1;ae<V;ae++){for(ve=ue[ae],we=ve[le]/pe[le],he=le+1;he<V-1;he+=2)Le=he+1,ve[he]-=pe[he]*we,ve[Le]-=pe[Le]*we;he!==V&&(ve[he]-=pe[he]*we)}if(pe[le]===0)return 0;re*=pe[le]}return re*ue[le][le]},p2.transpose=function(Z){var I,V,re=Z.length,ae=Z[0].length,le=Array(ae),he,ue,pe;for(V=0;V<ae;V++)le[V]=Array(re);for(I=re-1;I>=1;I-=2){for(ue=Z[I],he=Z[I-1],V=ae-1;V>=1;--V)pe=le[V],pe[I]=ue[V],pe[I-1]=he[V],--V,pe=le[V],pe[I]=ue[V],pe[I-1]=he[V];V===0&&(pe=le[0],pe[I]=ue[0],pe[I-1]=he[0])}if(I===0){for(he=Z[0],V=ae-1;V>=1;--V)le[V][0]=he[V],--V,le[V][0]=he[V];V===0&&(le[0][0]=he[0])}return le},p2.negtranspose=function(Z){var I,V,re=Z.length,ae=Z[0].length,le=Array(ae),he,ue,pe;for(V=0;V<ae;V++)le[V]=Array(re);for(I=re-1;I>=1;I-=2){for(ue=Z[I],he=Z[I-1],V=ae-1;V>=1;--V)pe=le[V],pe[I]=-ue[V],pe[I-1]=-he[V],--V,pe=le[V],pe[I]=-ue[V],pe[I-1]=-he[V];V===0&&(pe=le[0],pe[I]=-ue[0],pe[I-1]=-he[0])}if(I===0){for(he=Z[0],V=ae-1;V>=1;--V)le[V][0]=-he[V],--V,le[V][0]=-he[V];V===0&&(le[0][0]=-he[0])}return le},p2._random=function Z(I,V){var re,ae=I[V],le=Array(ae),he;if(V===I.length-1){for(he=Math.random,re=ae-1;re>=1;re-=2)le[re]=he(),le[re-1]=he();return re===0&&(le[0]=he()),le}for(re=ae-1;re>=0;re--)le[re]=Z(I,V+1);return le},p2.random=function(Z){return p2._random(Z,0)},p2.norm2=function(Z){return Math.sqrt(p2.norm2Squared(Z))},p2.linspace=function(Z,I,V){if(typeof V>"u"&&(V=Math.max(Math.round(I-Z)+1,1)),V<2)return V===1?[Z]:[];var re,ae=Array(V);for(V--,re=V;re>=0;re--)ae[re]=(re*I+(V-re)*Z)/V;return ae},p2.getBlock=function(Z,I,V){var re=p2.dim(Z);function ae(le,he){var ue,pe=I[he],ve=V[he]-pe,we=Array(ve);if(he===re.length-1){for(ue=ve;ue>=0;ue--)we[ue]=le[ue+pe];return we}for(ue=ve;ue>=0;ue--)we[ue]=ae(le[ue+pe],he+1);return we}return ae(Z,0)},p2.setBlock=function(Z,I,V,re){var ae=p2.dim(Z);function le(he,ue,pe){var ve,we=I[pe],Me=V[pe]-we;if(pe===ae.length-1)for(ve=Me;ve>=0;ve--)he[ve+we]=ue[ve];for(ve=Me;ve>=0;ve--)le(he[ve+we],ue[ve],pe+1)}return le(Z,re,0),Z},p2.getRange=function(Z,I,V){var re=I.length,ae=V.length,le,he,ue=Array(re),pe,ve;for(le=re-1;le!==-1;--le)for(ue[le]=Array(ae),pe=ue[le],ve=Z[I[le]],he=ae-1;he!==-1;--he)pe[he]=ve[V[he]];return ue},p2.blockMatrix=function(Z){var I=p2.dim(Z);if(I.length<4)return p2.blockMatrix([Z]);var V=I[0],re=I[1],ae,le,he,ue,pe;for(ae=0,le=0,he=0;he<V;++he)ae+=Z[he][0].length;for(ue=0;ue<re;++ue)le+=Z[0][ue][0].length;var ve=Array(ae);for(he=0;he<ae;++he)ve[he]=Array(le);var we=0,Me,Le,Ue,Ge,ze;for(he=0;he<V;++he){for(Me=le,ue=re-1;ue!==-1;--ue)for(pe=Z[he][ue],Me-=pe[0].length,Ue=pe.length-1;Ue!==-1;--Ue)for(ze=pe[Ue],Le=ve[we+Ue],Ge=ze.length-1;Ge!==-1;--Ge)Le[Me+Ge]=ze[Ge];we+=Z[he][0].length}return ve},p2.tensor=function(Z,I){if(typeof Z=="number"||typeof I=="number")return p2.mul(Z,I);var V=p2.dim(Z),re=p2.dim(I);if(V.length!==1||re.length!==1)throw new Error("numeric: tensor product is only defined for vectors");var ae=V[0],le=re[0],he=Array(ae),ue,pe,ve,we;for(pe=ae-1;pe>=0;pe--){for(ue=Array(le),we=Z[pe],ve=le-1;ve>=3;--ve)ue[ve]=we*I[ve],--ve,ue[ve]=we*I[ve],--ve,ue[ve]=we*I[ve],--ve,ue[ve]=we*I[ve];for(;ve>=0;)ue[ve]=we*I[ve],--ve;he[pe]=ue}return he},p2.T=function(Z,I){this.x=Z,this.y=I},p2.t=function(Z,I){return new p2.T(Z,I)},p2.Tbinop=function(Z,I,V,re,ae){if(p2.indexOf,typeof ae!="string"){var le;ae="";for(le in p2)p2.hasOwnProperty(le)&&(Z.indexOf(le)>=0||I.indexOf(le)>=0||V.indexOf(le)>=0||re.indexOf(le)>=0)&&le.length>1&&(ae+="var "+le+" = numeric."+le+`;
`)}return Function(["y"],`var x = this;
if(!(y instanceof numeric.T)) { y = new numeric.T(y); }
`+ae+`
if(x.y) {  if(y.y) {    return new numeric.T(`+re+`);
  }
  return new numeric.T(`+V+`);
}
if(y.y) {
  return new numeric.T(`+I+`);
}
return new numeric.T(`+Z+`);
`)},p2.T.prototype.add=p2.Tbinop("add(x.x,y.x)","add(x.x,y.x),y.y","add(x.x,y.x),x.y","add(x.x,y.x),add(x.y,y.y)"),p2.T.prototype.sub=p2.Tbinop("sub(x.x,y.x)","sub(x.x,y.x),neg(y.y)","sub(x.x,y.x),x.y","sub(x.x,y.x),sub(x.y,y.y)"),p2.T.prototype.mul=p2.Tbinop("mul(x.x,y.x)","mul(x.x,y.x),mul(x.x,y.y)","mul(x.x,y.x),mul(x.y,y.x)","sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))"),p2.T.prototype.reciprocal=function(){var Z=p2.mul,I=p2.div;if(this.y){var V=p2.add(Z(this.x,this.x),Z(this.y,this.y));return new p2.T(I(this.x,V),I(p2.neg(this.y),V))}return new T(I(1,this.x))},p2.T.prototype.div=function(Z){if(Z instanceof p2.T||(Z=new p2.T(Z)),Z.y)return this.mul(Z.reciprocal());var I=p2.div;return this.y?new p2.T(I(this.x,Z.x),I(this.y,Z.x)):new p2.T(I(this.x,Z.x))},p2.T.prototype.dot=p2.Tbinop("dot(x.x,y.x)","dot(x.x,y.x),dot(x.x,y.y)","dot(x.x,y.x),dot(x.y,y.x)","sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))"),p2.T.prototype.transpose=function(){var Z=p2.transpose,I=this.x,V=this.y;return V?new p2.T(Z(I),Z(V)):new p2.T(Z(I))},p2.T.prototype.transjugate=function(){var Z=p2.transpose,I=this.x,V=this.y;return V?new p2.T(Z(I),p2.negtranspose(V)):new p2.T(Z(I))},p2.Tunop=function(Z,I,V){return typeof V!="string"&&(V=""),Function(`var x = this;
`+V+`
if(x.y) {  `+I+`;
}
`+Z+`;
`)},p2.T.prototype.exp=p2.Tunop("return new numeric.T(ex)","return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))","var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;"),p2.T.prototype.conj=p2.Tunop("return new numeric.T(x.x);","return new numeric.T(x.x,numeric.neg(x.y));"),p2.T.prototype.neg=p2.Tunop("return new numeric.T(neg(x.x));","return new numeric.T(neg(x.x),neg(x.y));","var neg = numeric.neg;"),p2.T.prototype.sin=p2.Tunop("return new numeric.T(numeric.sin(x.x))","return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));"),p2.T.prototype.cos=p2.Tunop("return new numeric.T(numeric.cos(x.x))","return x.exp().add(x.neg().exp()).div(2);"),p2.T.prototype.abs=p2.Tunop("return new numeric.T(numeric.abs(x.x));","return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));","var mul = numeric.mul;"),p2.T.prototype.log=p2.Tunop("return new numeric.T(numeric.log(x.x));",`var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();
return new numeric.T(numeric.log(r.x),theta.x);`),p2.T.prototype.norm2=p2.Tunop("return numeric.norm2(x.x);",`var f = numeric.norm2Squared;
return Math.sqrt(f(x.x)+f(x.y));`),p2.T.prototype.inv=function(){var Z=this;if(typeof Z.y>"u")return new p2.T(p2.inv(Z.x));var I=Z.x.length,Ge,ze,He,V=p2.identity(I),re=p2.rep([I,I],0),ae=p2.clone(Z.x),le=p2.clone(Z.y),he,ue,pe,ve,we,Me,Le,Ue,Ge,ze,He,Ke,Ye,$e,je,rt,at,Rt;for(Ge=0;Ge<I;Ge++){for($e=ae[Ge][Ge],je=le[Ge][Ge],Ke=$e*$e+je*je,He=Ge,ze=Ge+1;ze<I;ze++)$e=ae[ze][Ge],je=le[ze][Ge],Ye=$e*$e+je*je,Ye>Ke&&(He=ze,Ke=Ye);for(He!==Ge&&(Rt=ae[Ge],ae[Ge]=ae[He],ae[He]=Rt,Rt=le[Ge],le[Ge]=le[He],le[He]=Rt,Rt=V[Ge],V[Ge]=V[He],V[He]=Rt,Rt=re[Ge],re[Ge]=re[He],re[He]=Rt),he=ae[Ge],ue=le[Ge],we=V[Ge],Me=re[Ge],$e=he[Ge],je=ue[Ge],ze=Ge+1;ze<I;ze++)rt=he[ze],at=ue[ze],he[ze]=(rt*$e+at*je)/Ke,ue[ze]=(at*$e-rt*je)/Ke;for(ze=0;ze<I;ze++)rt=we[ze],at=Me[ze],we[ze]=(rt*$e+at*je)/Ke,Me[ze]=(at*$e-rt*je)/Ke;for(ze=Ge+1;ze<I;ze++){for(pe=ae[ze],ve=le[ze],Le=V[ze],Ue=re[ze],$e=pe[Ge],je=ve[Ge],He=Ge+1;He<I;He++)rt=he[He],at=ue[He],pe[He]-=rt*$e-at*je,ve[He]-=at*$e+rt*je;for(He=0;He<I;He++)rt=we[He],at=Me[He],Le[He]-=rt*$e-at*je,Ue[He]-=at*$e+rt*je}}for(Ge=I-1;Ge>0;Ge--)for(we=V[Ge],Me=re[Ge],ze=Ge-1;ze>=0;ze--)for(Le=V[ze],Ue=re[ze],$e=ae[ze][Ge],je=le[ze][Ge],He=I-1;He>=0;He--)rt=we[He],at=Me[He],Le[He]-=$e*rt-je*at,Ue[He]-=$e*at+je*rt;return new p2.T(V,re)},p2.T.prototype.get=function(Z){var I=this.x,V=this.y,re=0,ae,le=Z.length;if(V){for(;re<le;)ae=Z[re],I=I[ae],V=V[ae],re++;return new p2.T(I,V)}for(;re<le;)ae=Z[re],I=I[ae],re++;return new p2.T(I)},p2.T.prototype.set=function(Z,I){var V=this.x,re=this.y,ae=0,le,he=Z.length,ue=I.x,pe=I.y;if(he===0)return pe?this.y=pe:re&&(this.y=void 0),this.x=V,this;if(pe){for(re||(re=p2.rep(p2.dim(V),0),this.y=re);ae<he-1;)le=Z[ae],V=V[le],re=re[le],ae++;return le=Z[ae],V[le]=ue,re[le]=pe,this}if(re){for(;ae<he-1;)le=Z[ae],V=V[le],re=re[le],ae++;return le=Z[ae],V[le]=ue,ue instanceof Array?re[le]=p2.rep(p2.dim(ue),0):re[le]=0,this}for(;ae<he-1;)le=Z[ae],V=V[le],ae++;return le=Z[ae],V[le]=ue,this},p2.T.prototype.getRows=function(Z,I){var V=I-Z+1,re,ae=Array(V),le,he=this.x,ue=this.y;for(re=Z;re<=I;re++)ae[re-Z]=he[re];if(ue){for(le=Array(V),re=Z;re<=I;re++)le[re-Z]=ue[re];return new p2.T(ae,le)}return new p2.T(ae)},p2.T.prototype.setRows=function(Z,I,V){var re,ae=this.x,le=this.y,he=V.x,ue=V.y;for(re=Z;re<=I;re++)ae[re]=he[re-Z];if(ue)for(le||(le=p2.rep(p2.dim(ae),0),this.y=le),re=Z;re<=I;re++)le[re]=ue[re-Z];else if(le)for(re=Z;re<=I;re++)le[re]=p2.rep([he[re-Z].length],0);return this},p2.T.prototype.getRow=function(Z){var I=this.x,V=this.y;return V?new p2.T(I[Z],V[Z]):new p2.T(I[Z])},p2.T.prototype.setRow=function(Z,I){var V=this.x,re=this.y,ae=I.x,le=I.y;return V[Z]=ae,le?(re||(re=p2.rep(p2.dim(V),0),this.y=re),re[Z]=le):re&&(re=p2.rep([ae.length],0)),this},p2.T.prototype.getBlock=function(Z,I){var V=this.x,re=this.y,ae=p2.getBlock;return re?new p2.T(ae(V,Z,I),ae(re,Z,I)):new p2.T(ae(V,Z,I))},p2.T.prototype.setBlock=function(Z,I,V){V instanceof p2.T||(V=new p2.T(V));var re=this.x,ae=this.y,le=p2.setBlock,he=V.x,ue=V.y;if(ue)return ae||(this.y=p2.rep(p2.dim(this),0),ae=this.y),le(re,Z,I,he),le(ae,Z,I,ue),this;le(re,Z,I,he),ae&&le(ae,Z,I,p2.rep(p2.dim(he),0))},p2.T.rep=function(Z,I){var V=p2.T;I instanceof V||(I=new V(I));var re=I.x,ae=I.y,le=p2.rep;return ae?new V(le(Z,re),le(Z,ae)):new V(le(Z,re))},p2.T.diag=function(Z){Z instanceof p2.T||(Z=new p2.T(Z));var I=Z.x,V=Z.y,re=p2.diag;return V?new p2.T(re(I),re(V)):new p2.T(re(I))},p2.T.eig=function(){if(this.y)throw new Error("eig: not implemented for complex matrices.");return p2.eig(this.x)},p2.T.identity=function(Z){return new p2.T(p2.identity(Z))},p2.T.prototype.getDiag=function(){var Z=p2,I=this.x,V=this.y;return V?new Z.T(Z.getDiag(I),Z.getDiag(V)):new Z.T(Z.getDiag(I))},p2.house=function(Z){var I=p2.clone(Z),V=Z[0]>=0?1:-1,re=V*p2.norm2(Z);I[0]+=re;var ae=p2.norm2(I);if(ae===0)throw new Error("eig: internal error");return p2.div(I,ae)},p2.toUpperHessenberg=function(Z){var I=p2.dim(Z);if(I.length!==2||I[0]!==I[1])throw new Error("numeric: toUpperHessenberg() only works on square matrices");var V=I[0],re,ae,le,he,ue,pe=p2.clone(Z),ve,we,Me,Le,Ue=p2.identity(V),Ge;for(ae=0;ae<V-2;ae++){for(he=Array(V-ae-1),re=ae+1;re<V;re++)he[re-ae-1]=pe[re][ae];if(p2.norm2(he)>0){for(ue=p2.house(he),ve=p2.getBlock(pe,[ae+1,ae],[V-1,V-1]),we=p2.tensor(ue,p2.dot(ue,ve)),re=ae+1;re<V;re++)for(Me=pe[re],Le=we[re-ae-1],le=ae;le<V;le++)Me[le]-=2*Le[le-ae];for(ve=p2.getBlock(pe,[0,ae+1],[V-1,V-1]),we=p2.tensor(p2.dot(ve,ue),ue),re=0;re<V;re++)for(Me=pe[re],Le=we[re],le=ae+1;le<V;le++)Me[le]-=2*Le[le-ae-1];for(ve=Array(V-ae-1),re=ae+1;re<V;re++)ve[re-ae-1]=Ue[re];for(we=p2.tensor(ue,p2.dot(ue,ve)),re=ae+1;re<V;re++)for(Ge=Ue[re],Le=we[re-ae-1],le=0;le<V;le++)Ge[le]-=2*Le[le]}}return{H:pe,Q:Ue}},p2.epsilon=2220446049250313e-31,p2.QRFrancis=function(Z,I){typeof I>"u"&&(I=1e4),Z=p2.clone(Z),p2.clone(Z);var V=p2.dim(Z),re=V[0],ae,le,he,ue,pe,ve,we,Me,Le,Ue=p2.identity(re),Ge,ze,He,Ke,Ye,$e,je,rt,at;if(re<3)return{Q:Ue,B:[[0,re-1]]};var Rt=p2.epsilon;for(at=0;at<I;at++){for(je=0;je<re-1;je++)if(Math.abs(Z[je+1][je])<Rt*(Math.abs(Z[je][je])+Math.abs(Z[je+1][je+1]))){var lt=p2.QRFrancis(p2.getBlock(Z,[0,0],[je,je]),I),kt=p2.QRFrancis(p2.getBlock(Z,[je+1,je+1],[re-1,re-1]),I);for(He=Array(je+1),$e=0;$e<=je;$e++)He[$e]=Ue[$e];for(Ke=p2.dot(lt.Q,He),$e=0;$e<=je;$e++)Ue[$e]=Ke[$e];for(He=Array(re-je-1),$e=je+1;$e<re;$e++)He[$e-je-1]=Ue[$e];for(Ke=p2.dot(kt.Q,He),$e=je+1;$e<re;$e++)Ue[$e]=Ke[$e-je-1];return{Q:Ue,B:lt.B.concat(p2.add(kt.B,je+1))}}if(he=Z[re-2][re-2],ue=Z[re-2][re-1],pe=Z[re-1][re-2],ve=Z[re-1][re-1],Me=he+ve,we=he*ve-ue*pe,Le=p2.getBlock(Z,[0,0],[2,2]),Me*Me>=4*we){var qt,Kt;qt=.5*(Me+Math.sqrt(Me*Me-4*we)),Kt=.5*(Me-Math.sqrt(Me*Me-4*we)),Le=p2.add(p2.sub(p2.dot(Le,Le),p2.mul(Le,qt+Kt)),p2.diag(p2.rep([3],qt*Kt)))}else Le=p2.add(p2.sub(p2.dot(Le,Le),p2.mul(Le,Me)),p2.diag(p2.rep([3],we)));for(ae=[Le[0][0],Le[1][0],Le[2][0]],le=p2.house(ae),He=[Z[0],Z[1],Z[2]],Ke=p2.tensor(le,p2.dot(le,He)),$e=0;$e<3;$e++)for(ze=Z[$e],Ye=Ke[$e],rt=0;rt<re;rt++)ze[rt]-=2*Ye[rt];for(He=p2.getBlock(Z,[0,0],[re-1,2]),Ke=p2.tensor(p2.dot(He,le),le),$e=0;$e<re;$e++)for(ze=Z[$e],Ye=Ke[$e],rt=0;rt<3;rt++)ze[rt]-=2*Ye[rt];for(He=[Ue[0],Ue[1],Ue[2]],Ke=p2.tensor(le,p2.dot(le,He)),$e=0;$e<3;$e++)for(Ge=Ue[$e],Ye=Ke[$e],rt=0;rt<re;rt++)Ge[rt]-=2*Ye[rt];var _i;for(je=0;je<re-2;je++){for(rt=je;rt<=je+1;rt++)if(Math.abs(Z[rt+1][rt])<Rt*(Math.abs(Z[rt][rt])+Math.abs(Z[rt+1][rt+1]))){var lt=p2.QRFrancis(p2.getBlock(Z,[0,0],[rt,rt]),I),kt=p2.QRFrancis(p2.getBlock(Z,[rt+1,rt+1],[re-1,re-1]),I);for(He=Array(rt+1),$e=0;$e<=rt;$e++)He[$e]=Ue[$e];for(Ke=p2.dot(lt.Q,He),$e=0;$e<=rt;$e++)Ue[$e]=Ke[$e];for(He=Array(re-rt-1),$e=rt+1;$e<re;$e++)He[$e-rt-1]=Ue[$e];for(Ke=p2.dot(kt.Q,He),$e=rt+1;$e<re;$e++)Ue[$e]=Ke[$e-rt-1];return{Q:Ue,B:lt.B.concat(p2.add(kt.B,rt+1))}}for(_i=Math.min(re-1,je+3),ae=Array(_i-je),$e=je+1;$e<=_i;$e++)ae[$e-je-1]=Z[$e][je];for(le=p2.house(ae),He=p2.getBlock(Z,[je+1,je],[_i,re-1]),Ke=p2.tensor(le,p2.dot(le,He)),$e=je+1;$e<=_i;$e++)for(ze=Z[$e],Ye=Ke[$e-je-1],rt=je;rt<re;rt++)ze[rt]-=2*Ye[rt-je];for(He=p2.getBlock(Z,[0,je+1],[re-1,_i]),Ke=p2.tensor(p2.dot(He,le),le),$e=0;$e<re;$e++)for(ze=Z[$e],Ye=Ke[$e],rt=je+1;rt<=_i;rt++)ze[rt]-=2*Ye[rt-je-1];for(He=Array(_i-je),$e=je+1;$e<=_i;$e++)He[$e-je-1]=Ue[$e];for(Ke=p2.tensor(le,p2.dot(le,He)),$e=je+1;$e<=_i;$e++)for(Ge=Ue[$e],Ye=Ke[$e-je-1],rt=0;rt<re;rt++)Ge[rt]-=2*Ye[rt]}}throw new Error("numeric: eigenvalue iteration does not converge -- increase maxiter?")},p2.eig=function(Z,I){var V=p2.toUpperHessenberg(Z),re=p2.QRFrancis(V.H,I),ae=p2.T,_i=Z.length,le,he,ue=re.B,pe=p2.dot(re.Q,p2.dot(V.H,p2.transpose(re.Q))),ve=new ae(p2.dot(re.Q,V.Q)),we,Me=ue.length,Le,Ue,Ge,ze,He,Ke,Ye,$e,je,rt,at,Rt,lt,kt,qt=Math.sqrt;for(he=0;he<Me;he++)if(le=ue[he][0],le!==ue[he][1]){if(Le=le+1,Ue=pe[le][le],Ge=pe[le][Le],ze=pe[Le][le],He=pe[Le][Le],Ge===0&&ze===0)continue;Ke=-Ue-He,Ye=Ue*He-Ge*ze,$e=Ke*Ke-4*Ye,$e>=0?(Ke<0?je=-.5*(Ke-qt($e)):je=-.5*(Ke+qt($e)),lt=(Ue-je)*(Ue-je)+Ge*Ge,kt=ze*ze+(He-je)*(He-je),lt>kt?(lt=qt(lt),at=(Ue-je)/lt,Rt=Ge/lt):(kt=qt(kt),at=ze/kt,Rt=(He-je)/kt),we=new ae([[Rt,-at],[at,Rt]]),ve.setRows(le,Le,we.dot(ve.getRows(le,Le)))):(je=-.5*Ke,rt=.5*qt(-$e),lt=(Ue-je)*(Ue-je)+Ge*Ge,kt=ze*ze+(He-je)*(He-je),lt>kt?(lt=qt(lt+rt*rt),at=(Ue-je)/lt,Rt=Ge/lt,je=0,rt/=lt):(kt=qt(kt+rt*rt),at=ze/kt,Rt=(He-je)/kt,je=rt/kt,rt=0),we=new ae([[Rt,-at],[at,Rt]],[[je,rt],[rt,-je]]),ve.setRows(le,Le,we.dot(ve.getRows(le,Le))))}var Kt=ve.dot(Z).dot(ve.transjugate()),_i=Z.length,ci=p2.T.identity(_i);for(Le=0;Le<_i;Le++)if(Le>0)for(he=Le-1;he>=0;he--){var li=Kt.get([he,he]),qi=Kt.get([Le,Le]);if(p2.neq(li.x,qi.x)||p2.neq(li.y,qi.y))je=Kt.getRow(he).getBlock([he],[Le-1]),rt=ci.getRow(Le).getBlock([he],[Le-1]),ci.set([Le,he],Kt.get([he,Le]).neg().sub(je.dot(rt)).div(li.sub(qi)));else{ci.setRow(Le,ci.getRow(he));continue}}for(Le=0;Le<_i;Le++)je=ci.getRow(Le),ci.setRow(Le,je.div(je.norm2()));return ci=ci.transpose(),ci=ve.transjugate().dot(ci),{lambda:Kt.getDiag(),E:ci}},p2.ccsSparse=function(Z){var I=Z.length,he,V,re,ae,le=[];for(re=I-1;re!==-1;--re){V=Z[re];for(ae in V){for(ae=parseInt(ae);ae>=le.length;)le[le.length]=0;V[ae]!==0&&le[ae]++}}var he=le.length,ue=Array(he+1);for(ue[0]=0,re=0;re<he;++re)ue[re+1]=ue[re]+le[re];var pe=Array(ue[he]),ve=Array(ue[he]);for(re=I-1;re!==-1;--re){V=Z[re];for(ae in V)V[ae]!==0&&(le[ae]--,pe[ue[ae]+le[ae]]=re,ve[ue[ae]+le[ae]]=V[ae])}return[ue,pe,ve]},p2.ccsFull=function(Z){var I=Z[0],V=Z[1],re=Z[2],ae=p2.ccsDim(Z),le=ae[0],he=ae[1],ue,pe,ve,we,Me=p2.rep([le,he],0);for(ue=0;ue<he;ue++)for(ve=I[ue],we=I[ue+1],pe=ve;pe<we;++pe)Me[V[pe]][ue]=re[pe];return Me},p2.ccsTSolve=function(Z,I,V,re,ae){var le=Z[0],he=Z[1],ue=Z[2],pe=le.length-1,ve=Math.max,we=0;typeof re>"u"&&(V=p2.rep([pe],0)),typeof re>"u"&&(re=p2.linspace(0,V.length-1)),typeof ae>"u"&&(ae=[]);function Me($e){var je;if(V[$e]===0){for(V[$e]=1,je=le[$e];je<le[$e+1];++je)Me(he[je]);ae[we]=$e,++we}}var Le,Ue,Ge,ze,He,Ke,Ye;for(Le=re.length-1;Le!==-1;--Le)Me(re[Le]);for(ae.length=we,Le=ae.length-1;Le!==-1;--Le)V[ae[Le]]=0;for(Le=re.length-1;Le!==-1;--Le)Ue=re[Le],V[Ue]=I[Ue];for(Le=ae.length-1;Le!==-1;--Le){for(Ue=ae[Le],Ge=le[Ue],ze=ve(le[Ue+1],Ge),He=Ge;He!==ze;++He)if(he[He]===Ue){V[Ue]/=ue[He];break}for(Ye=V[Ue],He=Ge;He!==ze;++He)Ke=he[He],Ke!==Ue&&(V[Ke]-=Ye*ue[He])}return V},p2.ccsDFS=function(Z){this.k=Array(Z),this.k1=Array(Z),this.j=Array(Z)},p2.ccsDFS.prototype.dfs=function(Z,I,V,re,ae,le){var he=0,ue,pe=ae.length,ve=this.k,we=this.k1,Me=this.j,Le,Ue;if(re[Z]===0)for(re[Z]=1,Me[0]=Z,ve[0]=Le=I[Z],we[0]=Ue=I[Z+1];;)if(Le>=Ue){if(ae[pe]=Me[he],he===0)return;++pe,--he,Le=ve[he],Ue=we[he]}else ue=le[V[Le]],re[ue]===0?(re[ue]=1,ve[he]=Le,++he,Me[he]=ue,Le=I[ue],we[he]=Ue=I[ue+1]):++Le},p2.ccsLPSolve=function(Z,I,V,re,ae,le,he){var ue=Z[0],pe=Z[1],ve=Z[2];ue.length-1;var we=I[0],Me=I[1],Le=I[2],Ue,Ge,ze,He,Ke,Ye,$e,je,rt;for(Ge=we[ae],ze=we[ae+1],re.length=0,Ue=Ge;Ue<ze;++Ue)he.dfs(le[Me[Ue]],ue,pe,V,re,le);for(Ue=re.length-1;Ue!==-1;--Ue)V[re[Ue]]=0;for(Ue=Ge;Ue!==ze;++Ue)He=le[Me[Ue]],V[He]=Le[Ue];for(Ue=re.length-1;Ue!==-1;--Ue){for(He=re[Ue],Ke=ue[He],Ye=ue[He+1],$e=Ke;$e<Ye;++$e)if(le[pe[$e]]===He){V[He]/=ve[$e];break}for(rt=V[He],$e=Ke;$e<Ye;++$e)je=le[pe[$e]],je!==He&&(V[je]-=rt*ve[$e])}return V},p2.ccsLUP1=function(Z,I){var V=Z[0].length-1,re=[p2.rep([V+1],0),[],[]],ae=[p2.rep([V+1],0),[],[]],le=re[0],he=re[1],ue=re[2],pe=ae[0],ve=ae[1],we=ae[2],Me=p2.rep([V],0),Le=p2.rep([V],0),Ue,Ge,ze,He,Ke,Ye,$e,je=p2.ccsLPSolve,rt=Math.abs,at=p2.linspace(0,V-1),Rt=p2.linspace(0,V-1),lt=new p2.ccsDFS(V);for(typeof I>"u"&&(I=1),Ue=0;Ue<V;++Ue){for(je(re,Z,Me,Le,Ue,Rt,lt),He=-1,Ke=-1,Ge=Le.length-1;Ge!==-1;--Ge)ze=Le[Ge],!(ze<=Ue)&&(Ye=rt(Me[ze]),Ye>He&&(Ke=ze,He=Ye));for(rt(Me[Ue])<I*He&&(Ge=at[Ue],He=at[Ke],at[Ue]=He,Rt[He]=Ue,at[Ke]=Ge,Rt[Ge]=Ke,He=Me[Ue],Me[Ue]=Me[Ke],Me[Ke]=He),He=le[Ue],Ke=pe[Ue],$e=Me[Ue],he[He]=at[Ue],ue[He]=1,++He,Ge=Le.length-1;Ge!==-1;--Ge)ze=Le[Ge],Ye=Me[ze],Le[Ge]=0,Me[ze]=0,ze<=Ue?(ve[Ke]=ze,we[Ke]=Ye,++Ke):(he[He]=at[ze],ue[He]=Ye/$e,++He);le[Ue+1]=He,pe[Ue+1]=Ke}for(Ge=he.length-1;Ge!==-1;--Ge)he[Ge]=Rt[he[Ge]];return{L:re,U:ae,P:at,Pinv:Rt}},p2.ccsDFS0=function(Z){this.k=Array(Z),this.k1=Array(Z),this.j=Array(Z)},p2.ccsDFS0.prototype.dfs=function(Z,I,V,re,ae,le,he){var ue=0,pe,ve=ae.length,we=this.k,Me=this.k1,Le=this.j,Ue,Ge;if(re[Z]===0)for(re[Z]=1,Le[0]=Z,we[0]=Ue=I[le[Z]],Me[0]=Ge=I[le[Z]+1];;){if(isNaN(Ue))throw new Error("Ow!");if(Ue>=Ge){if(ae[ve]=le[Le[ue]],ue===0)return;++ve,--ue,Ue=we[ue],Ge=Me[ue]}else pe=V[Ue],re[pe]===0?(re[pe]=1,we[ue]=Ue,++ue,Le[ue]=pe,pe=le[pe],Ue=I[pe],Me[ue]=Ge=I[pe+1]):++Ue}},p2.ccsLPSolve0=function(Z,I,V,re,ae,le,he,ue){var pe=Z[0],ve=Z[1],we=Z[2];pe.length-1;var Me=I[0],Le=I[1],Ue=I[2],Ge,ze,He,Ke,Ye,$e,je,rt,at;for(ze=Me[ae],He=Me[ae+1],re.length=0,Ge=ze;Ge<He;++Ge)ue.dfs(Le[Ge],pe,ve,V,re,le,he);for(Ge=re.length-1;Ge!==-1;--Ge)Ke=re[Ge],V[he[Ke]]=0;for(Ge=ze;Ge!==He;++Ge)Ke=Le[Ge],V[Ke]=Ue[Ge];for(Ge=re.length-1;Ge!==-1;--Ge){for(Ke=re[Ge],rt=he[Ke],Ye=pe[Ke],$e=pe[Ke+1],je=Ye;je<$e;++je)if(ve[je]===rt){V[rt]/=we[je];break}for(at=V[rt],je=Ye;je<$e;++je)V[ve[je]]-=at*we[je];V[rt]=at}},p2.ccsLUP0=function(Z,I){var V=Z[0].length-1,re=[p2.rep([V+1],0),[],[]],ae=[p2.rep([V+1],0),[],[]],le=re[0],he=re[1],ue=re[2],pe=ae[0],ve=ae[1],we=ae[2],Me=p2.rep([V],0),Le=p2.rep([V],0),Ue,Ge,ze,He,Ke,Ye,$e,je=p2.ccsLPSolve0,rt=Math.abs,at=p2.linspace(0,V-1),Rt=p2.linspace(0,V-1),lt=new p2.ccsDFS0(V);for(typeof I>"u"&&(I=1),Ue=0;Ue<V;++Ue){for(je(re,Z,Me,Le,Ue,Rt,at,lt),He=-1,Ke=-1,Ge=Le.length-1;Ge!==-1;--Ge)ze=Le[Ge],!(ze<=Ue)&&(Ye=rt(Me[at[ze]]),Ye>He&&(Ke=ze,He=Ye));for(rt(Me[at[Ue]])<I*He&&(Ge=at[Ue],He=at[Ke],at[Ue]=He,Rt[He]=Ue,at[Ke]=Ge,Rt[Ge]=Ke),He=le[Ue],Ke=pe[Ue],$e=Me[at[Ue]],he[He]=at[Ue],ue[He]=1,++He,Ge=Le.length-1;Ge!==-1;--Ge)ze=Le[Ge],Ye=Me[at[ze]],Le[Ge]=0,Me[at[ze]]=0,ze<=Ue?(ve[Ke]=ze,we[Ke]=Ye,++Ke):(he[He]=at[ze],ue[He]=Ye/$e,++He);le[Ue+1]=He,pe[Ue+1]=Ke}for(Ge=he.length-1;Ge!==-1;--Ge)he[Ge]=Rt[he[Ge]];return{L:re,U:ae,P:at,Pinv:Rt}},p2.ccsLUP=p2.ccsLUP0,p2.ccsDim=function(Z){return[p2.sup(Z[1])+1,Z[0].length-1]},p2.ccsGetBlock=function(Z,I,V){var re=p2.ccsDim(Z),ae=re[0],le=re[1];typeof I>"u"?I=p2.linspace(0,ae-1):typeof I=="number"&&(I=[I]),typeof V>"u"?V=p2.linspace(0,le-1):typeof V=="number"&&(V=[V]);var he,ue=I.length,pe,ve=V.length,we,Me,Le,Ue=p2.rep([le],0),Ge=[],ze=[],He=[Ue,Ge,ze],Ke=Z[0],Ye=Z[1],$e=Z[2],je=p2.rep([ae],0),rt=0,at=p2.rep([ae],0);for(pe=0;pe<ve;++pe){Me=V[pe];var Rt=Ke[Me],lt=Ke[Me+1];for(he=Rt;he<lt;++he)we=Ye[he],at[we]=1,je[we]=$e[he];for(he=0;he<ue;++he)Le=I[he],at[Le]&&(Ge[rt]=he,ze[rt]=je[I[he]],++rt);for(he=Rt;he<lt;++he)we=Ye[he],at[we]=0;Ue[pe+1]=rt}return He},p2.ccsDot=function(Z,I){var V=Z[0],re=Z[1],ae=Z[2],le=I[0],he=I[1],ue=I[2],pe=p2.ccsDim(Z),ve=p2.ccsDim(I),we=pe[0];pe[1];var Me=ve[1],Le=p2.rep([we],0),Ue=p2.rep([we],0),Ge=Array(we),ze=p2.rep([Me],0),He=[],Ke=[],Ye=[ze,He,Ke],$e,je,rt,at,Rt,lt,kt,qt,Kt,_i,ci;for(rt=0;rt!==Me;++rt){for(at=le[rt],Rt=le[rt+1],Kt=0,je=at;je<Rt;++je)for(_i=he[je],ci=ue[je],lt=V[_i],kt=V[_i+1],$e=lt;$e<kt;++$e)qt=re[$e],Ue[qt]===0&&(Ge[Kt]=qt,Ue[qt]=1,Kt=Kt+1),Le[qt]=Le[qt]+ae[$e]*ci;for(at=ze[rt],Rt=at+Kt,ze[rt+1]=Rt,je=Kt-1;je!==-1;--je)ci=at+je,$e=Ge[je],He[ci]=$e,Ke[ci]=Le[$e],Ue[$e]=0,Le[$e]=0;ze[rt+1]=ze[rt]+Kt}return Ye},p2.ccsLUPSolve=function(Z,I){var V=Z.L,re=Z.U;Z.P;var ae=I[0],le=!1;typeof ae!="object"&&(I=[[0,I.length],p2.linspace(0,I.length-1),I],ae=I[0],le=!0);var he=I[1],ue=I[2],pe=V[0].length-1,ve=ae.length-1,we=p2.rep([pe],0),Me=Array(pe),Le=p2.rep([pe],0),Ue=Array(pe),Ge=p2.rep([ve+1],0),ze=[],He=[],Ke=p2.ccsTSolve,Ye,$e,je,rt,at,Rt,lt=0;for(Ye=0;Ye<ve;++Ye){for(at=0,je=ae[Ye],rt=ae[Ye+1],$e=je;$e<rt;++$e)Rt=Z.Pinv[he[$e]],Ue[at]=Rt,Le[Rt]=ue[$e],++at;for(Ue.length=at,Ke(V,Le,we,Ue,Me),$e=Ue.length-1;$e!==-1;--$e)Le[Ue[$e]]=0;if(Ke(re,we,Le,Me,Ue),le)return Le;for($e=Me.length-1;$e!==-1;--$e)we[Me[$e]]=0;for($e=Ue.length-1;$e!==-1;--$e)Rt=Ue[$e],ze[lt]=Rt,He[lt]=Le[Rt],Le[Rt]=0,++lt;Ge[Ye+1]=lt}return[Ge,ze,He]},p2.ccsbinop=function(Z,I){return typeof I>"u"&&(I=""),Function("X","Y",`var Xi = X[0], Xj = X[1], Xv = X[2];
var Yi = Y[0], Yj = Y[1], Yv = Y[2];
var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;
var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];
var x = numeric.rep([m],0),y = numeric.rep([m],0);
var xk,yk,zk;
var i,j,j0,j1,k,p=0;
`+I+`for(i=0;i<n;++i) {
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Xj[j];
    x[k] = 1;
    Zj[p] = k;
    ++p;
  }
  j0 = Yi[i]; j1 = Yi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Yj[j];
    y[k] = Yv[j];
    if(x[k] === 0) {
      Zj[p] = k;
      ++p;
    }
  }
  Zi[i+1] = p;
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];
  j0 = Zi[i]; j1 = Zi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Zj[j];
    xk = x[k];
    yk = y[k];
`+Z+`
    Zv[j] = zk;
  }
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;
  j0 = Yi[i]; j1 = Yi[i+1];
  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;
}
return [Zi,Zj,Zv];`)},function(){var p9,pC,pm,pN;for(p9 in p2.ops2)isFinite(eval("1"+p2.ops2[p9]+"0"))?pC="[Y[0],Y[1],numeric."+p9+"(X,Y[2])]":pC="NaN",isFinite(eval("0"+p2.ops2[p9]+"1"))?pm="[X[0],X[1],numeric."+p9+"(X[2],Y)]":pm="NaN",isFinite(eval("1"+p2.ops2[p9]+"0"))&&isFinite(eval("0"+p2.ops2[p9]+"1"))?pN="numeric.ccs"+p9+"MM(X,Y)":pN="NaN",p2["ccs"+p9+"MM"]=p2.ccsbinop("zk = xk "+p2.ops2[p9]+"yk;"),p2["ccs"+p9]=Function("X","Y",'if(typeof X === "number") return '+pC+`;
if(typeof Y === "number") return `+pm+`;
return `+pN+`;
`)}(),p2.ccsScatter=function Z(I){var V=I[0],re=I[1],ae=I[2],le=p2.sup(re)+1,he=V.length,ue=p2.rep([le],0),pe=Array(he),ve=Array(he),we=p2.rep([le],0),Me;for(Me=0;Me<he;++Me)we[re[Me]]++;for(Me=0;Me<le;++Me)ue[Me+1]=ue[Me]+we[Me];var Le=ue.slice(0),Ue,Ge;for(Me=0;Me<he;++Me)Ge=re[Me],Ue=Le[Ge],pe[Ue]=V[Me],ve[Ue]=ae[Me],Le[Ge]=Le[Ge]+1;return[ue,pe,ve]},p2.ccsGather=function Z(I){var V=I[0],re=I[1],ae=I[2],le=V.length-1,he=re.length,ue=Array(he),pe=Array(he),ve=Array(he),we,Me,Le,Ue,Ge;for(Ge=0,we=0;we<le;++we)for(Le=V[we],Ue=V[we+1],Me=Le;Me!==Ue;++Me)pe[Ge]=we,ue[Ge]=re[Me],ve[Ge]=ae[Me],++Ge;return[ue,pe,ve]},p2.sdim=function Z(I,V,re){if(typeof V>"u"&&(V=[]),typeof I!="object")return V;typeof re>"u"&&(re=0),re in V||(V[re]=0),I.length>V[re]&&(V[re]=I.length);var ae;for(ae in I)I.hasOwnProperty(ae)&&Z(I[ae],V,re+1);return V},p2.sclone=function Z(I,V,re){typeof V>"u"&&(V=0),typeof re>"u"&&(re=p2.sdim(I).length);var ae,le=Array(I.length);if(V===re-1){for(ae in I)I.hasOwnProperty(ae)&&(le[ae]=I[ae]);return le}for(ae in I)I.hasOwnProperty(ae)&&(le[ae]=Z(I[ae],V+1,re));return le},p2.sdiag=function Z(I){var V=I.length,re,ae=Array(V),le;for(re=V-1;re>=1;re-=2)le=re-1,ae[re]=[],ae[re][re]=I[re],ae[le]=[],ae[le][le]=I[le];return re===0&&(ae[0]=[],ae[0][0]=I[re]),ae},p2.sidentity=function Z(I){return p2.sdiag(p2.rep([I],1))},p2.stranspose=function Z(I){var V=[];I.length;var re,ae,le;for(re in I)if(I.hasOwnProperty(re)){le=I[re];for(ae in le)le.hasOwnProperty(ae)&&(typeof V[ae]!="object"&&(V[ae]=[]),V[ae][re]=le[ae])}return V},p2.sLUP=function Z(I,V){throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.")},p2.sdotMM=function Z(I,V){var re=I.length;V.length;var ae=p2.stranspose(V),le=ae.length,he,ue,pe,ve,we,Me,Le=Array(re),Ue;for(pe=re-1;pe>=0;pe--){for(Ue=[],he=I[pe],we=le-1;we>=0;we--){Me=0,ue=ae[we];for(ve in he)he.hasOwnProperty(ve)&&ve in ue&&(Me+=he[ve]*ue[ve]);Me&&(Ue[we]=Me)}Le[pe]=Ue}return Le},p2.sdotMV=function Z(I,V){var re=I.length,ae,le,he,ue=Array(re),pe;for(le=re-1;le>=0;le--){ae=I[le],pe=0;for(he in ae)ae.hasOwnProperty(he)&&V[he]&&(pe+=ae[he]*V[he]);pe&&(ue[le]=pe)}return ue},p2.sdotVM=function Z(I,V){var re,ae,le,he,ue=[];for(re in I)if(I.hasOwnProperty(re)){le=V[re],he=I[re];for(ae in le)le.hasOwnProperty(ae)&&(ue[ae]||(ue[ae]=0),ue[ae]+=he*le[ae])}return ue},p2.sdotVV=function Z(I,V){var re,ae=0;for(re in I)I[re]&&V[re]&&(ae+=I[re]*V[re]);return ae},p2.sdot=function Z(I,V){var re=p2.sdim(I).length,ae=p2.sdim(V).length,le=re*1e3+ae;switch(le){case 0:return I*V;case 1001:return p2.sdotVV(I,V);case 2001:return p2.sdotMV(I,V);case 1002:return p2.sdotVM(I,V);case 2002:return p2.sdotMM(I,V);default:throw new Error("numeric.sdot not implemented for tensors of order "+re+" and "+ae)}},p2.sscatter=function Z(I){var V=I[0].length,re,ae,le,he=I.length,ue=[],pe;for(ae=V-1;ae>=0;--ae)if(I[he-1][ae]){for(pe=ue,le=0;le<he-2;le++)re=I[le][ae],pe[re]||(pe[re]=[]),pe=pe[re];pe[I[le][ae]]=I[le+1][ae]}return ue},p2.sgather=function Z(I,V,re){typeof V>"u"&&(V=[]),typeof re>"u"&&(re=[]);var ae,le,he;ae=re.length;for(le in I)if(I.hasOwnProperty(le))if(re[ae]=parseInt(le),he=I[le],typeof he=="number"){if(he){if(V.length===0)for(le=ae+1;le>=0;--le)V[le]=[];for(le=ae;le>=0;--le)V[le].push(re[le]);V[ae+1].push(he)}}else Z(he,V,re);return re.length>ae&&re.pop(),V},p2.cLU=function Z(I){var V=I[0],re=I[1],ae=I[2],kt=V.length,le=0,he,ue,pe,ve,we,Me;for(he=0;he<kt;he++)V[he]>le&&(le=V[he]);le++;var Le=Array(le),Ue=Array(le),Ge=p2.rep([le],1/0),ze=p2.rep([le],-1/0),$e,je,He;for(pe=0;pe<kt;pe++)he=V[pe],ue=re[pe],ue<Ge[he]&&(Ge[he]=ue),ue>ze[he]&&(ze[he]=ue);for(he=0;he<le-1;he++)ze[he]>ze[he+1]&&(ze[he+1]=ze[he]);for(he=le-1;he>=1;he--)Ge[he]<Ge[he-1]&&(Ge[he-1]=Ge[he]);var Ke=0,Ye=0;for(he=0;he<le;he++)Ue[he]=p2.rep([ze[he]-Ge[he]+1],0),Le[he]=p2.rep([he-Ge[he]],0),Ke+=he-Ge[he]+1,Ye+=ze[he]-he+1;for(pe=0;pe<kt;pe++)he=V[pe],Ue[he][re[pe]-Ge[he]]=ae[pe];for(he=0;he<le-1;he++)for(ve=he-Ge[he],$e=Ue[he],ue=he+1;Ge[ue]<=he&&ue<le;ue++)if(we=he-Ge[ue],Me=ze[he]-he,je=Ue[ue],He=je[we]/$e[ve],He){for(pe=1;pe<=Me;pe++)je[pe+we]-=He*$e[pe+ve];Le[ue][he-Ge[ue]]=He}var $e=[],je=[],rt=[],at=[],Rt=[],lt=[],kt,qt,Kt;for(kt=0,qt=0,he=0;he<le;he++){for(ve=Ge[he],we=ze[he],Kt=Ue[he],ue=he;ue<=we;ue++)Kt[ue-ve]&&($e[kt]=he,je[kt]=ue,rt[kt]=Kt[ue-ve],kt++);for(Kt=Le[he],ue=ve;ue<he;ue++)Kt[ue-ve]&&(at[qt]=he,Rt[qt]=ue,lt[qt]=Kt[ue-ve],qt++);at[qt]=he,Rt[qt]=he,lt[qt]=1,qt++}return{U:[$e,je,rt],L:[at,Rt,lt]}},p2.cLUsolve=function Z(I,V){var re=I.L,ae=I.U,le=p2.clone(V),he=re[0],ue=re[1],pe=re[2],ve=ae[0],we=ae[1],Me=ae[2],Le=ve.length;he.length;var Ue=le.length,Ge,ze;for(ze=0,Ge=0;Ge<Ue;Ge++){for(;ue[ze]<Ge;)le[Ge]-=pe[ze]*le[ue[ze]],ze++;ze++}for(ze=Le-1,Ge=Ue-1;Ge>=0;Ge--){for(;we[ze]>Ge;)le[Ge]-=Me[ze]*le[we[ze]],ze--;le[Ge]/=Me[ze],ze--}return le},p2.cgrid=function Z(I,V){typeof I=="number"&&(I=[I,I]);var re=p2.rep(I,-1),ae,le,he;if(typeof V!="function")switch(V){case"L":V=function(ue,pe){return ue>=I[0]/2||pe<I[1]/2};break;default:V=function(ue,pe){return!0};break}for(he=0,ae=1;ae<I[0]-1;ae++)for(le=1;le<I[1]-1;le++)V(ae,le)&&(re[ae][le]=he,he++);return re},p2.cdelsq=function Z(I){var V=[[-1,0],[0,-1],[0,1],[1,0]],re=p2.dim(I),ae=re[0],le=re[1],he,ue,pe,ve,we,Me=[],Le=[],Ue=[];for(he=1;he<ae-1;he++)for(ue=1;ue<le-1;ue++)if(!(I[he][ue]<0)){for(pe=0;pe<4;pe++)ve=he+V[pe][0],we=ue+V[pe][1],!(I[ve][we]<0)&&(Me.push(I[he][ue]),Le.push(I[ve][we]),Ue.push(-1));Me.push(I[he][ue]),Le.push(I[he][ue]),Ue.push(4)}return[Me,Le,Ue]},p2.cdotMV=function Z(I,V){var re,ae=I[0],le=I[1],he=I[2],ue,pe=ae.length,ve;for(ve=0,ue=0;ue<pe;ue++)ae[ue]>ve&&(ve=ae[ue]);for(ve++,re=p2.rep([ve],0),ue=0;ue<pe;ue++)re[ae[ue]]+=he[ue]*V[le[ue]];return re},p2.Spline=function Z(I,V,re,ae,le){this.x=I,this.yl=V,this.yr=re,this.kl=ae,this.kr=le},p2.Spline.prototype._at=function Z(pe,V){var re=this.x,ae=this.yl,le=this.yr,he=this.kl,ue=this.kr,pe,ve,we,Me,Le=p2.add,Ue=p2.sub,Ge=p2.mul;ve=Ue(Ge(he[V],re[V+1]-re[V]),Ue(le[V+1],ae[V])),we=Le(Ge(ue[V+1],re[V]-re[V+1]),Ue(le[V+1],ae[V])),Me=(pe-re[V])/(re[V+1]-re[V]);var ze=Me*(1-Me);return Le(Le(Le(Ge(1-Me,ae[V]),Ge(Me,le[V+1])),Ge(ve,ze*(1-Me))),Ge(we,ze*Me))},p2.Spline.prototype.at=function Z(I){if(typeof I=="number"){var V=this.x,ue=V.length,re,ae,le,he=Math.floor;for(re=0,ae=ue-1;ae-re>1;)le=he((re+ae)/2),V[le]<=I?re=le:ae=le;return this._at(I,re)}var ue=I.length,pe,ve=Array(ue);for(pe=ue-1;pe!==-1;--pe)ve[pe]=this.at(I[pe]);return ve},p2.Spline.prototype.diff=function Z(){var I=this.x,V=this.yl,re=this.yr,ae=this.kl,le=this.kr,he=V.length,ue,pe,ve,we=ae,Me=le,Le=Array(he),Ue=Array(he),Ge=p2.add,ze=p2.mul,He=p2.div,Ke=p2.sub;for(ue=he-1;ue!==-1;--ue)pe=I[ue+1]-I[ue],ve=Ke(re[ue+1],V[ue]),Le[ue]=He(Ge(ze(ve,6),ze(ae[ue],-4*pe),ze(le[ue+1],-2*pe)),pe*pe),Ue[ue+1]=He(Ge(ze(ve,-6),ze(ae[ue],2*pe),ze(le[ue+1],4*pe)),pe*pe);return new p2.Spline(I,we,Me,Le,Ue)},p2.Spline.prototype.roots=function Z(){function I(ns){return ns*ns}var He=[],V=this.x,re=this.yl,ae=this.yr,le=this.kl,he=this.kr;typeof re[0]=="number"&&(re=[re],ae=[ae],le=[le],he=[he]);var ue=re.length,pe=V.length-1,ve,we,Me,Le,Ue,Ge,ze,He=Array(ue),Ke,Ye,$e,je,rt,at,Rt,lt,kt,qt,Kt,_i,ci,li,qi,Ki,hs=Math.sqrt;for(ve=0;ve!==ue;++ve){for(Le=re[ve],Ue=ae[ve],Ge=le[ve],ze=he[ve],Ke=[],we=0;we!==pe;we++){for(we>0&&Ue[we]*Le[we]<0&&Ke.push(V[we]),kt=V[we+1]-V[we],V[we],je=Le[we],rt=Ue[we+1],Ye=Ge[we]/kt,$e=ze[we+1]/kt,lt=I(Ye-$e+3*(je-rt))+12*$e*je,at=$e+3*je+2*Ye-3*rt,Rt=3*($e+Ye+2*(je-rt)),lt<=0?(Kt=at/Rt,Kt>V[we]&&Kt<V[we+1]?qt=[V[we],Kt,V[we+1]]:qt=[V[we],V[we+1]]):(Kt=(at-hs(lt))/Rt,_i=(at+hs(lt))/Rt,qt=[V[we]],Kt>V[we]&&Kt<V[we+1]&&qt.push(Kt),_i>V[we]&&_i<V[we+1]&&qt.push(_i),qt.push(V[we+1])),li=qt[0],Kt=this._at(li,we),Me=0;Me<qt.length-1;Me++){if(qi=qt[Me+1],_i=this._at(qi,we),Kt===0){Ke.push(li),li=qi,Kt=_i;continue}if(_i===0||Kt*_i>0){li=qi,Kt=_i;continue}for(var Yi=0;Ki=(Kt*qi-_i*li)/(Kt-_i),!(Ki<=li||Ki>=qi);)if(ci=this._at(Ki,we),ci*_i>0)qi=Ki,_i=ci,Yi===-1&&(Kt*=.5),Yi=-1;else if(ci*Kt>0)li=Ki,Kt=ci,Yi===1&&(_i*=.5),Yi=1;else break;Ke.push(Ki),li=qt[Me+1],Kt=this._at(li,we)}_i===0&&Ke.push(qi)}He[ve]=Ke}return typeof this.yl[0]=="number"?He[0]:He},p2.spline=function Z(I,V,re,ae){var le=I.length,he=[],ue=[],pe=[],ve,we=p2.sub,Me=p2.mul,Le=p2.add;for(ve=le-2;ve>=0;ve--)ue[ve]=I[ve+1]-I[ve],pe[ve]=we(V[ve+1],V[ve]);(typeof re=="string"||typeof ae=="string")&&(re=ae="periodic");var Ue=[[],[],[]];switch(typeof re){case"undefined":he[0]=Me(3/(ue[0]*ue[0]),pe[0]),Ue[0].push(0,0),Ue[1].push(0,1),Ue[2].push(2/ue[0],1/ue[0]);break;case"string":he[0]=Le(Me(3/(ue[le-2]*ue[le-2]),pe[le-2]),Me(3/(ue[0]*ue[0]),pe[0])),Ue[0].push(0,0,0),Ue[1].push(le-2,0,1),Ue[2].push(1/ue[le-2],2/ue[le-2]+2/ue[0],1/ue[0]);break;default:he[0]=re,Ue[0].push(0),Ue[1].push(0),Ue[2].push(1);break}for(ve=1;ve<le-1;ve++)he[ve]=Le(Me(3/(ue[ve-1]*ue[ve-1]),pe[ve-1]),Me(3/(ue[ve]*ue[ve]),pe[ve])),Ue[0].push(ve,ve,ve),Ue[1].push(ve-1,ve,ve+1),Ue[2].push(1/ue[ve-1],2/ue[ve-1]+2/ue[ve],1/ue[ve]);switch(typeof ae){case"undefined":he[le-1]=Me(3/(ue[le-2]*ue[le-2]),pe[le-2]),Ue[0].push(le-1,le-1),Ue[1].push(le-2,le-1),Ue[2].push(1/ue[le-2],2/ue[le-2]);break;case"string":Ue[1][Ue[1].length-1]=0;break;default:he[le-1]=ae,Ue[0].push(le-1),Ue[1].push(le-1),Ue[2].push(1);break}typeof he[0]!="number"?he=p2.transpose(he):he=[he];var Ge=Array(he.length);if(typeof re=="string")for(ve=Ge.length-1;ve!==-1;--ve)Ge[ve]=p2.ccsLUPSolve(p2.ccsLUP(p2.ccsScatter(Ue)),he[ve]),Ge[ve][le-1]=Ge[ve][0];else for(ve=Ge.length-1;ve!==-1;--ve)Ge[ve]=p2.cLUsolve(p2.cLU(Ue),he[ve]);return typeof V[0]=="number"?Ge=Ge[0]:Ge=p2.transpose(Ge),new p2.Spline(I,V,V,Ge,Ge)},p2.fftpow2=function Z(I,V){var re=I.length;if(re!==1){var ae=Math.cos,le=Math.sin,he,ue,pe=Array(re/2),ve=Array(re/2),we=Array(re/2),Me=Array(re/2);for(ue=re/2,he=re-1;he!==-1;--he)--ue,we[ue]=I[he],Me[ue]=V[he],--he,pe[ue]=I[he],ve[ue]=V[he];Z(pe,ve),Z(we,Me),ue=re/2;var Le,Ue=-6.283185307179586/re,Ge,ze;for(he=re-1;he!==-1;--he)--ue,ue===-1&&(ue=re/2-1),Le=Ue*he,Ge=ae(Le),ze=le(Le),I[he]=pe[ue]+Ge*we[ue]-ze*Me[ue],V[he]=ve[ue]+Ge*Me[ue]+ze*we[ue]}},p2._ifftpow2=function Z(I,V){var re=I.length;if(re!==1){var ae=Math.cos,le=Math.sin,he,ue,pe=Array(re/2),ve=Array(re/2),we=Array(re/2),Me=Array(re/2);for(ue=re/2,he=re-1;he!==-1;--he)--ue,we[ue]=I[he],Me[ue]=V[he],--he,pe[ue]=I[he],ve[ue]=V[he];Z(pe,ve),Z(we,Me),ue=re/2;var Le,Ue=6.283185307179586/re,Ge,ze;for(he=re-1;he!==-1;--he)--ue,ue===-1&&(ue=re/2-1),Le=Ue*he,Ge=ae(Le),ze=le(Le),I[he]=pe[ue]+Ge*we[ue]-ze*Me[ue],V[he]=ve[ue]+Ge*Me[ue]+ze*we[ue]}},p2.ifftpow2=function Z(I,V){p2._ifftpow2(I,V),p2.diveq(I,I.length),p2.diveq(V,V.length)},p2.convpow2=function Z(I,V,re,ae){p2.fftpow2(I,V),p2.fftpow2(re,ae);var le,he=I.length,ue,pe,ve,we;for(le=he-1;le!==-1;--le)ue=I[le],ve=V[le],pe=re[le],we=ae[le],I[le]=ue*pe-ve*we,V[le]=ue*we+ve*pe;p2.ifftpow2(I,V)},p2.T.prototype.fft=function Z(){var I=this.x,V=this.y,re=I.length,ae=Math.log,le=ae(2),he=Math.ceil(ae(2*re-1)/le),ue=Math.pow(2,he),pe=p2.rep([ue],0),ve=p2.rep([ue],0),we=Math.cos,Me=Math.sin,Le,Ue=-3.141592653589793/re,Ge,ze=p2.rep([ue],0),He=p2.rep([ue],0);for(Le=0;Le<re;Le++)ze[Le]=I[Le];if(typeof V<"u")for(Le=0;Le<re;Le++)He[Le]=V[Le];for(pe[0]=1,Le=1;Le<=ue/2;Le++)Ge=Ue*Le*Le,pe[Le]=we(Ge),ve[Le]=Me(Ge),pe[ue-Le]=we(Ge),ve[ue-Le]=Me(Ge);var Ke=new p2.T(ze,He),Ye=new p2.T(pe,ve);return Ke=Ke.mul(Ye),p2.convpow2(Ke.x,Ke.y,p2.clone(Ye.x),p2.neg(Ye.y)),Ke=Ke.mul(Ye),Ke.x.length=re,Ke.y.length=re,Ke},p2.T.prototype.ifft=function Z(){var I=this.x,V=this.y,re=I.length,ae=Math.log,le=ae(2),he=Math.ceil(ae(2*re-1)/le),ue=Math.pow(2,he),pe=p2.rep([ue],0),ve=p2.rep([ue],0),we=Math.cos,Me=Math.sin,Le,Ue=3.141592653589793/re,Ge,ze=p2.rep([ue],0),He=p2.rep([ue],0);for(Le=0;Le<re;Le++)ze[Le]=I[Le];if(typeof V<"u")for(Le=0;Le<re;Le++)He[Le]=V[Le];for(pe[0]=1,Le=1;Le<=ue/2;Le++)Ge=Ue*Le*Le,pe[Le]=we(Ge),ve[Le]=Me(Ge),pe[ue-Le]=we(Ge),ve[ue-Le]=Me(Ge);var Ke=new p2.T(ze,He),Ye=new p2.T(pe,ve);return Ke=Ke.mul(Ye),p2.convpow2(Ke.x,Ke.y,p2.clone(Ye.x),p2.neg(Ye.y)),Ke=Ke.mul(Ye),Ke.x.length=re,Ke.y.length=re,Ke.div(re)},p2.gradient=function Z(I,V){var re=V.length,ae=I(V);if(isNaN(ae))throw new Error("gradient: f(x) is a NaN!");var Me=Math.max,le,he=p2.clone(V),ue,pe,ve=Array(re);p2.div,p2.sub;var we,Me=Math.max,Le=.001,Ue=Math.abs,Ge=Math.min,ze,He,Ke,Ye=0,$e,je,rt;for(le=0;le<re;le++)for(var at=Me(1e-6*ae,1e-8);;){if(++Ye,Ye>20)throw new Error("Numerical gradient fails");if(he[le]=V[le]+at,ue=I(he),he[le]=V[le]-at,pe=I(he),he[le]=V[le],isNaN(ue)||isNaN(pe)){at/=16;continue}if(ve[le]=(ue-pe)/(2*at),ze=V[le]-at,He=V[le],Ke=V[le]+at,$e=(ue-ae)/at,je=(ae-pe)/at,rt=Me(Ue(ve[le]),Ue(ae),Ue(ue),Ue(pe),Ue(ze),Ue(He),Ue(Ke),1e-8),we=Ge(Me(Ue($e-ve[le]),Ue(je-ve[le]),Ue($e-je))/rt,at/rt),we>Le)at/=16;else break}return ve},p2.uncmin=function Z(I,V,re,ae,le,he,ue){var pe=p2.gradient;typeof ue>"u"&&(ue={}),typeof re>"u"&&(re=1e-8),typeof ae>"u"&&(ae=function(Xs){return pe(I,Xs)}),typeof le>"u"&&(le=1e3),V=p2.clone(V);var ve=V.length,we=I(V),Me,Le;if(isNaN(we))throw new Error("uncmin: f(x0) is a NaN!");var Ue=Math.max,Ge=p2.norm2;re=Ue(re,p2.epsilon);var ze,He,Ke,Ye=ue.Hinv||p2.identity(ve),$e=p2.dot;p2.inv;var je=p2.sub,rt=p2.add,at=p2.tensor,Rt=p2.div,lt=p2.mul,kt=p2.all,qt=p2.isFinite,Kt=p2.neg,_i=0,ci,li,qi,Ki,hs,Yi,ns,Gs="";for(He=ae(V);_i<le;){if(typeof he=="function"&&he(_i,V,we,He,Ye)){Gs="Callback returned true";break}if(!kt(qt(He))){Gs="Gradient has Infinity or NaN";break}if(ze=Kt($e(Ye,He)),!kt(qt(ze))){Gs="Search direction has Infinity or NaN";break}if(ns=Ge(ze),ns<re){Gs="Newton step smaller than tol";break}for(Yi=1,Le=$e(He,ze),li=V;_i<le&&!(Yi*ns<re);){if(ci=lt(ze,Yi),li=rt(V,ci),Me=I(li),Me-we>=.1*Yi*Le||isNaN(Me)){Yi*=.5,++_i;continue}break}if(Yi*ns<re){Gs="Line search step size smaller than tol";break}if(_i===le){Gs="maxit reached during line search";break}Ke=ae(li),qi=je(Ke,He),hs=$e(qi,ci),Ki=$e(Ye,qi),Ye=je(rt(Ye,lt((hs+$e(qi,Ki))/(hs*hs),at(ci,ci))),Rt(rt(at(Ki,ci),at(ci,Ki)),hs)),V=li,we=Me,He=Ke,++_i}return{solution:V,f:we,gradient:He,invHessian:Ye,iterations:_i,message:Gs}},p2.Dopri=function Z(I,V,re,ae,le,he,ue){this.x=I,this.y=V,this.f=re,this.ymid=ae,this.iterations=le,this.events=ue,this.message=he},p2.Dopri.prototype._at=function Z(ze,V){function re(lt){return lt*lt}var ae=this,le=ae.x,he=ae.y,ue=ae.f,pe=ae.ymid;le.length;var ve,we,Me,Le,Ue,Ge,ze,He,Ke=.5,Ye=p2.add,$e=p2.mul,je=p2.sub,rt,at,Rt;return ve=le[V],we=le[V+1],Le=he[V],Ue=he[V+1],He=we-ve,Me=ve+Ke*He,Ge=pe[V],rt=je(ue[V],$e(Le,1/(ve-Me)+2/(ve-we))),at=je(ue[V+1],$e(Ue,1/(we-Me)+2/(we-ve))),Rt=[re(ze-we)*(ze-Me)/re(ve-we)/(ve-Me),re(ze-ve)*re(ze-we)/re(ve-Me)/re(we-Me),re(ze-ve)*(ze-Me)/re(we-ve)/(we-Me),(ze-ve)*re(ze-we)*(ze-Me)/re(ve-we)/(ve-Me),(ze-we)*re(ze-ve)*(ze-Me)/re(ve-we)/(we-Me)],Ye(Ye(Ye(Ye($e(Le,Rt[0]),$e(Ge,Rt[1])),$e(Ue,Rt[2])),$e(rt,Rt[3])),$e(at,Rt[4]))},p2.Dopri.prototype.at=function Z(I){var V,re,ae,le=Math.floor;if(typeof I!="number"){var he=I.length,ue=Array(he);for(V=he-1;V!==-1;--V)ue[V]=this.at(I[V]);return ue}var pe=this.x;for(V=0,re=pe.length-1;re-V>1;)ae=le(.5*(V+re)),pe[ae]<=I?V=ae:re=ae;return this._at(I,V)},p2.dopri=function Z(I,V,re,ae,le,he,ue){typeof le>"u"&&(le=1e-6),typeof he>"u"&&(he=1e3);var pe=[I],ve=[re],we=[ae(I,re)],Me,Le,Ue,Ge,ze,He,Ke=[],Ye=1/5,$e=[3/40,9/40],je=[44/45,-56/15,32/9],rt=[19372/6561,-25360/2187,64448/6561,-212/729],at=[9017/3168,-355/33,46732/5247,49/176,-5103/18656],Rt=[35/384,0,500/1113,125/192,-2187/6784,11/84],lt=[.5*6025192743/30085553152,0,.5*51252292925/65400821598,.5*-2691868925/45128329728,.5*187940372067/1594534317056,.5*-1776094331/19743644256,.5*11237099/235043384],kt=[1/5,3/10,4/5,8/9,1,1],qt=[-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40],Kt=0,_i,ci,li=(V-I)/10,qi=0,Ki=p2.add,hs=p2.mul,Yi,ns,Gs=Math.min,Xs=Math.abs,$i=p2.norminf,xs=Math.pow,hi=p2.any,Ri=p2.lt,Wi=p2.and;p2.sub;var us,Ks,ur,js=new p2.Dopri(pe,ve,we,Ke,-1,"");for(typeof ue=="function"&&(us=ue(I,re));I<V&&qi<he;){if(++qi,I+li>V&&(li=V-I),Me=ae(I+kt[0]*li,Ki(re,hs(Ye*li,we[Kt]))),Le=ae(I+kt[1]*li,Ki(Ki(re,hs($e[0]*li,we[Kt])),hs($e[1]*li,Me))),Ue=ae(I+kt[2]*li,Ki(Ki(Ki(re,hs(je[0]*li,we[Kt])),hs(je[1]*li,Me)),hs(je[2]*li,Le))),Ge=ae(I+kt[3]*li,Ki(Ki(Ki(Ki(re,hs(rt[0]*li,we[Kt])),hs(rt[1]*li,Me)),hs(rt[2]*li,Le)),hs(rt[3]*li,Ue))),ze=ae(I+kt[4]*li,Ki(Ki(Ki(Ki(Ki(re,hs(at[0]*li,we[Kt])),hs(at[1]*li,Me)),hs(at[2]*li,Le)),hs(at[3]*li,Ue)),hs(at[4]*li,Ge))),Yi=Ki(Ki(Ki(Ki(Ki(re,hs(we[Kt],li*Rt[0])),hs(Le,li*Rt[2])),hs(Ue,li*Rt[3])),hs(Ge,li*Rt[4])),hs(ze,li*Rt[5])),He=ae(I+li,Yi),_i=Ki(Ki(Ki(Ki(Ki(hs(we[Kt],li*qt[0]),hs(Le,li*qt[2])),hs(Ue,li*qt[3])),hs(Ge,li*qt[4])),hs(ze,li*qt[5])),hs(He,li*qt[6])),typeof _i=="number"?ns=Xs(_i):ns=$i(_i),ns>le){if(li=.2*li*xs(le/ns,.25),I+li===I){js.msg="Step size became too small";break}continue}if(Ke[Kt]=Ki(Ki(Ki(Ki(Ki(Ki(re,hs(we[Kt],li*lt[0])),hs(Le,li*lt[2])),hs(Ue,li*lt[3])),hs(Ge,li*lt[4])),hs(ze,li*lt[5])),hs(He,li*lt[6])),++Kt,pe[Kt]=I+li,ve[Kt]=Yi,we[Kt]=He,typeof ue=="function"){var sr,cr=I,ln=I+.5*li,kr;if(Ks=ue(ln,Ke[Kt-1]),ur=Wi(Ri(us,0),Ri(0,Ks)),hi(ur)||(cr=ln,ln=I+li,us=Ks,Ks=ue(ln,Yi),ur=Wi(Ri(us,0),Ri(0,Ks))),hi(ur)){for(var $r,Rn,Ln=0,zn=1,ra=1;;){if(typeof us=="number")kr=(ra*Ks*cr-zn*us*ln)/(ra*Ks-zn*us);else for(kr=ln,ci=us.length-1;ci!==-1;--ci)us[ci]<0&&Ks[ci]>0&&(kr=Gs(kr,(ra*Ks[ci]*cr-zn*us[ci]*ln)/(ra*Ks[ci]-zn*us[ci])));if(kr<=cr||kr>=ln)break;sr=js._at(kr,Kt-1),Rn=ue(kr,sr),$r=Wi(Ri(us,0),Ri(0,Rn)),hi($r)?(ln=kr,Ks=Rn,ur=$r,ra=1,Ln===-1?zn*=.5:zn=1,Ln=-1):(cr=kr,us=Rn,zn=1,Ln===1?ra*=.5:ra=1,Ln=1)}return Yi=js._at(.5*(I+kr),Kt-1),js.f[Kt]=ae(kr,sr),js.x[Kt]=kr,js.y[Kt]=sr,js.ymid[Kt-1]=Yi,js.events=ur,js.iterations=qi,js}}I+=li,re=Yi,us=Ks,li=Gs(.8*li*xs(le/ns,.25),4*li)}return js.iterations=qi,js},p2.LU=function(Z,I){I=I||!1;var V=Math.abs,re,ae,le,he,ue,pe,ve,we,Me,Le=Z.length,Ue=Le-1,Ge=new Array(Le);for(I||(Z=p2.clone(Z)),le=0;le<Le;++le){for(ve=le,pe=Z[le],Me=V(pe[le]),ae=le+1;ae<Le;++ae)he=V(Z[ae][le]),Me<he&&(Me=he,ve=ae);for(Ge[le]=ve,ve!=le&&(Z[le]=Z[ve],Z[ve]=pe,pe=Z[le]),ue=pe[le],re=le+1;re<Le;++re)Z[re][le]/=ue;for(re=le+1;re<Le;++re){for(we=Z[re],ae=le+1;ae<Ue;++ae)we[ae]-=we[le]*pe[ae],++ae,we[ae]-=we[le]*pe[ae];ae===Ue&&(we[ae]-=we[le]*pe[ae])}}return{LU:Z,P:Ge}},p2.LUsolve=function Z(I,V){var re,ae,le=I.LU,he=le.length,ue=p2.clone(V),pe=I.P,ve,we,Me;for(re=he-1;re!==-1;--re)ue[re]=V[re];for(re=0;re<he;++re)for(ve=pe[re],pe[re]!==re&&(Me=ue[re],ue[re]=ue[ve],ue[ve]=Me),we=le[re],ae=0;ae<re;++ae)ue[re]-=ue[ae]*we[ae];for(re=he-1;re>=0;--re){for(we=le[re],ae=re+1;ae<he;++ae)ue[re]-=ue[ae]*we[ae];ue[re]/=we[re]}return ue},p2.solve=function Z(I,V,re){return p2.LUsolve(p2.LU(I,re),V)},p2.echelonize=function Z(I){var V=p2.dim(I),re=V[0],ae=V[1],le=p2.identity(re),he=Array(re),ue,pe,ve,we,Me,Le,Ue,Ge,ze=Math.abs,He=p2.diveq;for(I=p2.clone(I),ue=0;ue<re;++ue){for(ve=0,Me=I[ue],Le=le[ue],pe=1;pe<ae;++pe)ze(Me[ve])<ze(Me[pe])&&(ve=pe);for(he[ue]=ve,He(Le,Me[ve]),He(Me,Me[ve]),pe=0;pe<re;++pe)if(pe!==ue){for(Ue=I[pe],Ge=Ue[ve],we=ae-1;we!==-1;--we)Ue[we]-=Me[we]*Ge;for(Ue=le[pe],we=re-1;we!==-1;--we)Ue[we]-=Le[we]*Ge}}return{I:le,A:I,P:he}},p2.__solveLP=function Z(I,V,re,ae,le,he,ue){var pe=p2.sum;p2.log;var ve=p2.mul,we=p2.sub,Me=p2.dot,Le=p2.div,Ue=p2.add,Ge=I.length,ze=re.length,He,Ke=!1,Ye=0,$e=1;p2.transpose(V),p2.svd;var je=p2.transpose;p2.leq;var rt=Math.sqrt,at=Math.abs;p2.muleq,p2.norminf,p2.any;var Rt=Math.min,lt=p2.all,kt=p2.gt,qt=Array(Ge),Kt=Array(ze);p2.rep([ze],1);var _i,ci=p2.solve,li=we(re,Me(V,he)),qi,Ki=Me(I,I),hs;for(qi=Ye;qi<le;++qi){var Yi,ns;for(Yi=ze-1;Yi!==-1;--Yi)Kt[Yi]=Le(V[Yi],li[Yi]);var Gs=je(Kt);for(Yi=Ge-1;Yi!==-1;--Yi)qt[Yi]=pe(Gs[Yi]);$e=.25*at(Ki/Me(I,qt));var Xs=100*rt(Ki/Me(qt,qt));for((!isFinite($e)||$e>Xs)&&($e=Xs),hs=Ue(I,ve($e,qt)),_i=Me(Gs,Kt),Yi=Ge-1;Yi!==-1;--Yi)_i[Yi][Yi]+=1;ns=ci(_i,Le(hs,$e),!0);var $i=Le(li,Me(V,ns)),xs=1;for(Yi=ze-1;Yi!==-1;--Yi)$i[Yi]<0&&(xs=Rt(xs,-.999*$i[Yi]));if(He=we(he,ve(ns,xs)),li=we(re,Me(V,He)),!lt(kt(li,0)))return{solution:he,message:"",iterations:qi};if(he=He,$e<ae)return{solution:He,message:"",iterations:qi};if(ue){var hi=Me(I,hs),Ri=Me(V,hs);for(Ke=!0,Yi=ze-1;Yi!==-1;--Yi)if(hi*Ri[Yi]<0){Ke=!1;break}}else he[Ge-1]>=0?Ke=!1:Ke=!0;if(Ke)return{solution:He,message:"Unbounded",iterations:qi}}return{solution:he,message:"maximum iteration count exceeded",iterations:qi}},p2._solveLP=function Z(I,V,re,ae,le){var he=I.length,ue=re.length,Ge;p2.sum,p2.log,p2.mul;var pe=p2.sub,ve=p2.dot;p2.div,p2.add;var we=p2.rep([he],0).concat([1]),Me=p2.rep([ue,1],-1),Le=p2.blockMatrix([[V,Me]]),Ue=re,Ge=p2.rep([he],0).concat(Math.max(0,p2.sup(p2.neg(re)))+1),ze=p2.__solveLP(we,Le,Ue,ae,le,Ge,!1),He=p2.clone(ze.solution);He.length=he;var Ke=p2.inf(pe(re,ve(V,He)));if(Ke<0)return{solution:NaN,message:"Infeasible",iterations:ze.iterations};var Ye=p2.__solveLP(I,V,re,ae,le-ze.iterations,He,!0);return Ye.iterations+=ze.iterations,Ye},p2.solveLP=function Z(I,V,re,ae,le,he,ue){if(typeof ue>"u"&&(ue=1e3),typeof he>"u"&&(he=p2.epsilon),typeof ae>"u")return p2._solveLP(I,V,re,he,ue);var pe=ae.length,ve=ae[0].length,we=V.length,Me=p2.echelonize(ae),Le=p2.rep([ve],0),Ue=Me.P,Ge=[],ze;for(ze=Ue.length-1;ze!==-1;--ze)Le[Ue[ze]]=1;for(ze=ve-1;ze!==-1;--ze)Le[ze]===0&&Ge.push(ze);var He=p2.getRange,Ke=p2.linspace(0,pe-1),Ye=p2.linspace(0,we-1),$e=He(ae,Ke,Ge),je=He(V,Ye,Ue),rt=He(V,Ye,Ge),at=p2.dot,Rt=p2.sub,lt=at(je,Me.I),kt=Rt(rt,at(lt,$e)),qt=Rt(re,at(lt,le)),Kt=Array(Ue.length),_i=Array(Ge.length);for(ze=Ue.length-1;ze!==-1;--ze)Kt[ze]=I[Ue[ze]];for(ze=Ge.length-1;ze!==-1;--ze)_i[ze]=I[Ge[ze]];var ci=Rt(_i,at(Kt,at(Me.I,$e))),li=p2._solveLP(ci,kt,qt,he,ue),qi=li.solution;if(qi!==qi)return li;var Ki=at(Me.I,Rt(le,at($e,qi))),hs=Array(I.length);for(ze=Ue.length-1;ze!==-1;--ze)hs[Ue[ze]]=Ki[ze];for(ze=Ge.length-1;ze!==-1;--ze)hs[Ge[ze]]=qi[ze];return{solution:hs,message:li.message,iterations:li.iterations}},p2.MPStoLP=function Z(I){I instanceof String&&I.split(`
`);var V=0,re=["Initial state","NAME","ROWS","COLUMNS","RHS","BOUNDS","ENDATA"],ae=I.length,le,he,ue,pe=0,ve={},we=[],Me=0,Le={},Ue=0,Ge,ze=[],He=[],Ke=[];function Ye(Rt){throw new Error("MPStoLP: "+Rt+`
Line `+le+": "+I[le]+`
Current state: `+re[V]+`
`)}for(le=0;le<ae;++le){ue=I[le];var $e=ue.match(/\S*/g),je=[];for(he=0;he<$e.length;++he)$e[he]!==""&&je.push($e[he]);if(je.length!==0){for(he=0;he<re.length&&ue.substr(0,re[he].length)!==re[he];++he);if(he<re.length){if(V=he,he===1&&(Ge=je[1]),he===6)return{name:Ge,c:ze,A:p2.transpose(He),b:Ke,rows:ve,vars:Le};continue}switch(V){case 0:case 1:Ye("Unexpected line");case 2:switch(je[0]){case"N":pe===0?pe=je[1]:Ye("Two or more N rows");break;case"L":ve[je[1]]=Me,we[Me]=1,Ke[Me]=0,++Me;break;case"G":ve[je[1]]=Me,we[Me]=-1,Ke[Me]=0,++Me;break;case"E":ve[je[1]]=Me,we[Me]=0,Ke[Me]=0,++Me;break;default:Ye("Parse error "+p2.prettyPrint(je))}break;case 3:Le.hasOwnProperty(je[0])||(Le[je[0]]=Ue,ze[Ue]=0,He[Ue]=p2.rep([Me],0),++Ue);var rt=Le[je[0]];for(he=1;he<je.length;he+=2){if(je[he]===pe){ze[rt]=parseFloat(je[he+1]);continue}var at=ve[je[he]];He[rt][at]=(we[at]<0?-1:1)*parseFloat(je[he+1])}break;case 4:for(he=1;he<je.length;he+=2)Ke[ve[je[he]]]=(we[ve[je[he]]]<0?-1:1)*parseFloat(je[he+1]);break;case 5:break;case 6:Ye("Internal error")}}}Ye("Reached end of file without ENDATA")},p2.seedrandom={pow:Math.pow,random:Math.random},function(Z,I,V,re,ae,le,he){I.seedrandom=function(Me,Le){var Ue=[],Ge;return Me=ve(pe(Le?[Me,Z]:arguments.length?Me:[new Date().getTime(),Z,window],3),Ue),Ge=new ue(Ue),ve(Ge.S,Z),I.random=function(){for(var ze=Ge.g(re),He=he,Ke=0;ze<ae;)ze=(ze+Ke)*V,He*=V,Ke=Ge.g(1);for(;ze>=le;)ze/=2,He/=2,Ke>>>=1;return(ze+Ke)/He},Me};function ue(Me){var Le,Ue,Ge=this,ze=Me.length,He=0,Ke=Ge.i=Ge.j=Ge.m=0;for(Ge.S=[],Ge.c=[],ze||(Me=[ze++]);He<V;)Ge.S[He]=He++;for(He=0;He<V;He++)Le=Ge.S[He],Ke=we(Ke+Le+Me[He%ze]),Ue=Ge.S[Ke],Ge.S[He]=Ue,Ge.S[Ke]=Le;Ge.g=function(Ye){var $e=Ge.S,je=we(Ge.i+1),rt=$e[je],at=we(Ge.j+rt),Rt=$e[at];$e[je]=Rt,$e[at]=rt;for(var lt=$e[we(rt+Rt)];--Ye;)je=we(je+1),rt=$e[je],at=we(at+rt),Rt=$e[at],$e[je]=Rt,$e[at]=rt,lt=lt*V+$e[we(rt+Rt)];return Ge.i=je,Ge.j=at,lt},Ge.g(V)}function pe(Me,Le,Ue,Ge,ze){if(Ue=[],ze=typeof Me,Le&&ze=="object"){for(Ge in Me)if(Ge.indexOf("S")<5)try{Ue.push(pe(Me[Ge],Le-1))}catch{}}return Ue.length?Ue:Me+(ze!="string"?"\0":"")}function ve(Me,Le,Ue,Ge){for(Me+="",Ue=0,Ge=0;Ge<Me.length;Ge++)Le[we(Ge)]=we((Ue^=Le[we(Ge)]*19)+Me.charCodeAt(Ge));Me="";for(Ge in Le)Me+=String.fromCharCode(Le[Ge]);return Me}function we(Me){return Me&V-1}he=I.pow(V,re),ae=I.pow(2,ae),le=ae*2,ve(I.random(),Z)}([],p2.seedrandom,256,6,52),function(Z){function I(pe){if(typeof pe!="object")return pe;var ve=[],we,Me=pe.length;for(we=0;we<Me;we++)ve[we+1]=I(pe[we]);return ve}function V(pe){if(typeof pe!="object")return pe;var ve=[],we,Me=pe.length;for(we=1;we<Me;we++)ve[we-1]=V(pe[we]);return ve}function re(pe,ve,we){var Me,Le,Ue,Ge,ze;for(Ue=1;Ue<=we;Ue=Ue+1){for(pe[Ue][Ue]=1/pe[Ue][Ue],ze=-pe[Ue][Ue],Me=1;Me<Ue;Me=Me+1)pe[Me][Ue]=ze*pe[Me][Ue];if(Ge=Ue+1,we<Ge)break;for(Le=Ge;Le<=we;Le=Le+1)for(ze=pe[Ue][Le],pe[Ue][Le]=0,Me=1;Me<=Ue;Me=Me+1)pe[Me][Le]=pe[Me][Le]+ze*pe[Me][Ue]}}function ae(pe,ve,we,Me){var Le,Ue,Ge,ze;for(Ue=1;Ue<=we;Ue=Ue+1){for(ze=0,Le=1;Le<Ue;Le=Le+1)ze=ze+pe[Le][Ue]*Me[Le];Me[Ue]=(Me[Ue]-ze)/pe[Ue][Ue]}for(Ge=1;Ge<=we;Ge=Ge+1)for(Ue=we+1-Ge,Me[Ue]=Me[Ue]/pe[Ue][Ue],ze=-Me[Ue],Le=1;Le<Ue;Le=Le+1)Me[Le]=Me[Le]+ze*pe[Le][Ue]}function le(pe,ve,we,Me){var Le,Ue,Ge,ze,He,Ke;for(Ue=1;Ue<=we;Ue=Ue+1){if(Me[1]=Ue,Ke=0,Ge=Ue-1,Ge<1){if(Ke=pe[Ue][Ue]-Ke,Ke<=0)break;pe[Ue][Ue]=Math.sqrt(Ke)}else{for(ze=1;ze<=Ge;ze=ze+1){for(He=pe[ze][Ue],Le=1;Le<ze;Le=Le+1)He=He-pe[Le][Ue]*pe[Le][ze];He=He/pe[ze][ze],pe[ze][Ue]=He,Ke=Ke+He*He}if(Ke=pe[Ue][Ue]-Ke,Ke<=0)break;pe[Ue][Ue]=Math.sqrt(Ke)}Me[1]=0}}function he(pe,ve,we,Me,Le,Ue,Ge,ze,He,Ke,Ye,$e,je,rt,at,Rt){var lt,kt,qt,Kt,_i,ci,li,qi,Ki,hs,Yi,ns,Gs,Xs,$i,xs,hi,Ri,Wi,us,Ks,ur,js,sr,cr,ln,kr;Gs=Math.min(Me,Ke),qt=2*Me+Gs*(Gs+5)/2+2*Ke+1,sr=1e-60;do sr=sr+sr,cr=1+.1*sr,ln=1+.2*sr;while(cr<=1||ln<=1);for(lt=1;lt<=Me;lt=lt+1)at[lt]=ve[lt];for(lt=Me+1;lt<=qt;lt=lt+1)at[lt]=0;for(lt=1;lt<=Ke;lt=lt+1)$e[lt]=0;if(_i=[],Rt[1]===0){if(le(pe,we,Me,_i),_i[1]!==0){Rt[1]=2;return}ae(pe,we,Me,ve),re(pe,we,Me)}else{for(kt=1;kt<=Me;kt=kt+1)for(Le[kt]=0,lt=1;lt<=kt;lt=lt+1)Le[kt]=Le[kt]+pe[lt][kt]*ve[lt];for(kt=1;kt<=Me;kt=kt+1)for(ve[kt]=0,lt=kt;lt<=Me;lt=lt+1)ve[kt]=ve[kt]+pe[kt][lt]*Le[lt]}for(Ue[1]=0,kt=1;kt<=Me;kt=kt+1)for(Le[kt]=ve[kt],Ue[1]=Ue[1]+at[kt]*Le[kt],at[kt]=0,lt=kt+1;lt<=Me;lt=lt+1)pe[lt][kt]=0;for(Ue[1]=-Ue[1]/2,Rt[1]=0,li=Me,qi=li+Me,Yi=qi+Gs,Ki=Yi+Gs+1,hs=Ki+Gs*(Gs+1)/2,Xs=hs+Ke,lt=1;lt<=Ke;lt=lt+1){for(xs=0,kt=1;kt<=Me;kt=kt+1)xs=xs+Ge[kt][lt]*Ge[kt][lt];at[Xs+lt]=Math.sqrt(xs)}je=0,rt[1]=0,rt[2]=0;function $r(){for(rt[1]=rt[1]+1,qt=hs,lt=1;lt<=Ke;lt=lt+1){for(qt=qt+1,xs=-ze[lt],kt=1;kt<=Me;kt=kt+1)xs=xs+Ge[kt][lt]*Le[kt];if(Math.abs(xs)<sr&&(xs=0),lt>Ye)at[qt]=xs;else if(at[qt]=-Math.abs(xs),xs>0){for(kt=1;kt<=Me;kt=kt+1)Ge[kt][lt]=-Ge[kt][lt];ze[lt]=-ze[lt]}}for(lt=1;lt<=je;lt=lt+1)at[hs+$e[lt]]=0;for(ns=0,$i=0,lt=1;lt<=Ke;lt=lt+1)at[hs+lt]<$i*at[Xs+lt]&&(ns=lt,$i=at[hs+lt]/at[Xs+lt]);return ns===0?999:0}function Rn(){for(lt=1;lt<=Me;lt=lt+1){for(xs=0,kt=1;kt<=Me;kt=kt+1)xs=xs+pe[kt][lt]*Ge[kt][ns];at[lt]=xs}for(Kt=li,lt=1;lt<=Me;lt=lt+1)at[Kt+lt]=0;for(kt=je+1;kt<=Me;kt=kt+1)for(lt=1;lt<=Me;lt=lt+1)at[Kt+lt]=at[Kt+lt]+pe[lt][kt]*at[kt];for(ur=!0,lt=je;lt>=1;lt=lt-1){for(xs=at[lt],qt=Ki+lt*(lt+3)/2,Kt=qt-lt,kt=lt+1;kt<=je;kt=kt+1)xs=xs-at[qt]*at[qi+kt],qt=qt+kt;if(xs=xs/at[Kt],at[qi+lt]=xs,$e[lt]<Ye||xs<0)break;ur=!1,ci=lt}if(!ur)for(hi=at[Yi+ci]/at[qi+ci],lt=1;lt<=je&&!($e[lt]<Ye||at[qi+lt]<0);lt=lt+1)$i=at[Yi+lt]/at[qi+lt],$i<hi&&(hi=$i,ci=lt);for(xs=0,lt=li+1;lt<=li+Me;lt=lt+1)xs=xs+at[lt]*at[lt];if(Math.abs(xs)<=sr){if(ur)return Rt[1]=1,999;for(lt=1;lt<=je;lt=lt+1)at[Yi+lt]=at[Yi+lt]-hi*at[qi+lt];return at[Yi+je+1]=at[Yi+je+1]+hi,700}else{for(xs=0,lt=1;lt<=Me;lt=lt+1)xs=xs+at[li+lt]*Ge[lt][ns];for(Ri=-at[hs+ns]/xs,js=!0,ur||hi<Ri&&(Ri=hi,js=!1),lt=1;lt<=Me;lt=lt+1)Le[lt]=Le[lt]+Ri*at[li+lt],Math.abs(Le[lt])<sr&&(Le[lt]=0);for(Ue[1]=Ue[1]+Ri*xs*(Ri/2+at[Yi+je+1]),lt=1;lt<=je;lt=lt+1)at[Yi+lt]=at[Yi+lt]-Ri*at[qi+lt];if(at[Yi+je+1]=at[Yi+je+1]+Ri,js){for(je=je+1,$e[je]=ns,qt=Ki+(je-1)*je/2+1,lt=1;lt<=je-1;lt=lt+1)at[qt]=at[lt],qt=qt+1;if(je===Me)at[qt]=at[Me];else{for(lt=Me;lt>=je+1&&!(at[lt]===0||(Wi=Math.max(Math.abs(at[lt-1]),Math.abs(at[lt])),us=Math.min(Math.abs(at[lt-1]),Math.abs(at[lt])),at[lt-1]>=0?$i=Math.abs(Wi*Math.sqrt(1+us*us/(Wi*Wi))):$i=-Math.abs(Wi*Math.sqrt(1+us*us/(Wi*Wi))),Wi=at[lt-1]/$i,us=at[lt]/$i,Wi===1));lt=lt-1)if(Wi===0)for(at[lt-1]=us*$i,kt=1;kt<=Me;kt=kt+1)$i=pe[kt][lt-1],pe[kt][lt-1]=pe[kt][lt],pe[kt][lt]=$i;else for(at[lt-1]=$i,Ks=us/(1+Wi),kt=1;kt<=Me;kt=kt+1)$i=Wi*pe[kt][lt-1]+us*pe[kt][lt],pe[kt][lt]=Ks*(pe[kt][lt-1]+$i)-pe[kt][lt],pe[kt][lt-1]=$i;at[qt]=at[je]}}else{for(xs=-ze[ns],kt=1;kt<=Me;kt=kt+1)xs=xs+Le[kt]*Ge[kt][ns];if(ns>Ye)at[hs+ns]=xs;else if(at[hs+ns]=-Math.abs(xs),xs>0){for(kt=1;kt<=Me;kt=kt+1)Ge[kt][ns]=-Ge[kt][ns];ze[ns]=-ze[ns]}return 700}}return 0}function Ln(){if(qt=Ki+ci*(ci+1)/2+1,Kt=qt+ci,at[Kt]===0||(Wi=Math.max(Math.abs(at[Kt-1]),Math.abs(at[Kt])),us=Math.min(Math.abs(at[Kt-1]),Math.abs(at[Kt])),at[Kt-1]>=0?$i=Math.abs(Wi*Math.sqrt(1+us*us/(Wi*Wi))):$i=-Math.abs(Wi*Math.sqrt(1+us*us/(Wi*Wi))),Wi=at[Kt-1]/$i,us=at[Kt]/$i,Wi===1))return 798;if(Wi===0){for(lt=ci+1;lt<=je;lt=lt+1)$i=at[Kt-1],at[Kt-1]=at[Kt],at[Kt]=$i,Kt=Kt+lt;for(lt=1;lt<=Me;lt=lt+1)$i=pe[lt][ci],pe[lt][ci]=pe[lt][ci+1],pe[lt][ci+1]=$i}else{for(Ks=us/(1+Wi),lt=ci+1;lt<=je;lt=lt+1)$i=Wi*at[Kt-1]+us*at[Kt],at[Kt]=Ks*(at[Kt-1]+$i)-at[Kt],at[Kt-1]=$i,Kt=Kt+lt;for(lt=1;lt<=Me;lt=lt+1)$i=Wi*pe[lt][ci]+us*pe[lt][ci+1],pe[lt][ci+1]=Ks*(pe[lt][ci]+$i)-pe[lt][ci+1],pe[lt][ci]=$i}return 0}function zn(){for(Kt=qt-ci,lt=1;lt<=ci;lt=lt+1)at[Kt]=at[qt],qt=qt+1,Kt=Kt+1;return at[Yi+ci]=at[Yi+ci+1],$e[ci]=$e[ci+1],ci=ci+1,ci<je?797:0}function ra(){return at[Yi+je]=at[Yi+je+1],at[Yi+je+1]=0,$e[je]=0,je=je-1,rt[2]=rt[2]+1,0}for(kr=0;;){if(kr=$r(),kr===999)return;for(;kr=Rn(),kr!==0;){if(kr===999)return;if(kr===700)if(ci===je)ra();else{for(;Ln(),kr=zn(),kr===797;);ra()}}}}function ue(pe,ve,we,Me,Le,Ue){pe=I(pe),ve=I(ve),we=I(we);var Ge,ze,He,Ke,Ye,$e=[],je=[],rt=[],at=[],Rt=[],lt;if(Le=Le||0,Ue=Ue?I(Ue):[void 0,0],Me=Me?I(Me):[],ze=pe.length-1,He=we[1].length-1,!Me)for(Ge=1;Ge<=He;Ge=Ge+1)Me[Ge]=0;for(Ge=1;Ge<=He;Ge=Ge+1)je[Ge]=0;for(Ke=0,Ye=Math.min(ze,He),Ge=1;Ge<=ze;Ge=Ge+1)rt[Ge]=0;for($e[1]=0,Ge=1;Ge<=2*ze+Ye*(Ye+5)/2+2*He+1;Ge=Ge+1)at[Ge]=0;for(Ge=1;Ge<=2;Ge=Ge+1)Rt[Ge]=0;return he(pe,ve,ze,ze,rt,$e,we,Me,ze,He,Le,je,Ke,Rt,at,Ue),lt="",Ue[1]===1&&(lt="constraints are inconsistent, no solution!"),Ue[1]===2&&(lt="matrix D in quadratic function is not positive definite!"),{solution:V(rt),value:V($e),unconstrained_solution:V(ve),iterations:V(Rt),iact:V(je),message:lt}}Z.solveQP=ue}(p2),p2.svd=function Z(I){var V,re=p2.epsilon,ae=1e-64/re,le=50,he=0,ue=0,pe=0,ve=0,we=0,Me=p2.clone(I),Le=Me.length,Ue=Me[0].length;if(Le<Ue)throw"Need more rows than columns";var Ge=new Array(Ue),ze=new Array(Ue);for(ue=0;ue<Ue;ue++)Ge[ue]=ze[ue]=0;var He=p2.rep([Ue,Ue],0);function Ke(_i,ci){return _i=Math.abs(_i),ci=Math.abs(ci),_i>ci?_i*Math.sqrt(1+ci*ci/_i/_i):ci==0?_i:ci*Math.sqrt(1+_i*_i/ci/ci)}var Ye=0,$e=0,je=0,rt=0,at=0,Rt=0,lt=0;for(ue=0;ue<Ue;ue++){for(Ge[ue]=$e,lt=0,we=ue+1,pe=ue;pe<Le;pe++)lt+=Me[pe][ue]*Me[pe][ue];if(lt<=ae)$e=0;else for(Ye=Me[ue][ue],$e=Math.sqrt(lt),Ye>=0&&($e=-$e),je=Ye*$e-lt,Me[ue][ue]=Ye-$e,pe=we;pe<Ue;pe++){for(lt=0,ve=ue;ve<Le;ve++)lt+=Me[ve][ue]*Me[ve][pe];for(Ye=lt/je,ve=ue;ve<Le;ve++)Me[ve][pe]+=Ye*Me[ve][ue]}for(ze[ue]=$e,lt=0,pe=we;pe<Ue;pe++)lt=lt+Me[ue][pe]*Me[ue][pe];if(lt<=ae)$e=0;else{for(Ye=Me[ue][ue+1],$e=Math.sqrt(lt),Ye>=0&&($e=-$e),je=Ye*$e-lt,Me[ue][ue+1]=Ye-$e,pe=we;pe<Ue;pe++)Ge[pe]=Me[ue][pe]/je;for(pe=we;pe<Le;pe++){for(lt=0,ve=we;ve<Ue;ve++)lt+=Me[pe][ve]*Me[ue][ve];for(ve=we;ve<Ue;ve++)Me[pe][ve]+=lt*Ge[ve]}}at=Math.abs(ze[ue])+Math.abs(Ge[ue]),at>rt&&(rt=at)}for(ue=Ue-1;ue!=-1;ue+=-1){if($e!=0){for(je=$e*Me[ue][ue+1],pe=we;pe<Ue;pe++)He[pe][ue]=Me[ue][pe]/je;for(pe=we;pe<Ue;pe++){for(lt=0,ve=we;ve<Ue;ve++)lt+=Me[ue][ve]*He[ve][pe];for(ve=we;ve<Ue;ve++)He[ve][pe]+=lt*He[ve][ue]}}for(pe=we;pe<Ue;pe++)He[ue][pe]=0,He[pe][ue]=0;He[ue][ue]=1,$e=Ge[ue],we=ue}for(ue=Ue-1;ue!=-1;ue+=-1){for(we=ue+1,$e=ze[ue],pe=we;pe<Ue;pe++)Me[ue][pe]=0;if($e!=0){for(je=Me[ue][ue]*$e,pe=we;pe<Ue;pe++){for(lt=0,ve=we;ve<Le;ve++)lt+=Me[ve][ue]*Me[ve][pe];for(Ye=lt/je,ve=ue;ve<Le;ve++)Me[ve][pe]+=Ye*Me[ve][ue]}for(pe=ue;pe<Le;pe++)Me[pe][ue]=Me[pe][ue]/$e}else for(pe=ue;pe<Le;pe++)Me[pe][ue]=0;Me[ue][ue]+=1}for(re=re*rt,ve=Ue-1;ve!=-1;ve+=-1)for(var kt=0;kt<le;kt++){var qt=!1;for(we=ve;we!=-1;we+=-1){if(Math.abs(Ge[we])<=re){qt=!0;break}if(Math.abs(ze[we-1])<=re)break}if(!qt){he=0,lt=1;var Kt=we-1;for(ue=we;ue<ve+1&&(Ye=lt*Ge[ue],Ge[ue]=he*Ge[ue],!(Math.abs(Ye)<=re));ue++)for($e=ze[ue],je=Ke(Ye,$e),ze[ue]=je,he=$e/je,lt=-Ye/je,pe=0;pe<Le;pe++)at=Me[pe][Kt],Rt=Me[pe][ue],Me[pe][Kt]=at*he+Rt*lt,Me[pe][ue]=-at*lt+Rt*he}if(Rt=ze[ve],we==ve){if(Rt<0)for(ze[ve]=-Rt,pe=0;pe<Ue;pe++)He[pe][ve]=-He[pe][ve];break}if(kt>=le-1)throw"Error: no convergence.";for(rt=ze[we],at=ze[ve-1],$e=Ge[ve-1],je=Ge[ve],Ye=((at-Rt)*(at+Rt)+($e-je)*($e+je))/(2*je*at),$e=Ke(Ye,1),Ye<0?Ye=((rt-Rt)*(rt+Rt)+je*(at/(Ye-$e)-je))/rt:Ye=((rt-Rt)*(rt+Rt)+je*(at/(Ye+$e)-je))/rt,he=1,lt=1,ue=we+1;ue<ve+1;ue++){for($e=Ge[ue],at=ze[ue],je=lt*$e,$e=he*$e,Rt=Ke(Ye,je),Ge[ue-1]=Rt,he=Ye/Rt,lt=je/Rt,Ye=rt*he+$e*lt,$e=-rt*lt+$e*he,je=at*lt,at=at*he,pe=0;pe<Ue;pe++)rt=He[pe][ue-1],Rt=He[pe][ue],He[pe][ue-1]=rt*he+Rt*lt,He[pe][ue]=-rt*lt+Rt*he;for(Rt=Ke(Ye,je),ze[ue-1]=Rt,he=Ye/Rt,lt=je/Rt,Ye=he*$e+lt*at,rt=-lt*$e+he*at,pe=0;pe<Le;pe++)at=Me[pe][ue-1],Rt=Me[pe][ue],Me[pe][ue-1]=at*he+Rt*lt,Me[pe][ue]=-at*lt+Rt*he}Ge[we]=0,Ge[ve]=Ye,ze[ve]=rt}for(ue=0;ue<ze.length;ue++)ze[ue]<re&&(ze[ue]=0);for(ue=0;ue<Ue;ue++)for(pe=ue-1;pe>=0;pe--)if(ze[pe]<ze[ue]){for(he=ze[pe],ze[pe]=ze[ue],ze[ue]=he,ve=0;ve<Me.length;ve++)V=Me[ve][ue],Me[ve][ue]=Me[ve][pe],Me[ve][pe]=V;for(ve=0;ve<He.length;ve++)V=He[ve][ue],He[ve][ue]=He[ve][pe],He[ve][pe]=V;ue=pe}return{U:Me,S:ze,V:He}}})(AS);class Ad{constructor(){this.bodyTracks=[],this.poseFilters=[],this.angle=.08333333333333333*Math.PI,this.ratio=1.7777777777777777,this.near=1,this.poseScore=.6,this.alignScore=.9,this.alignVisibility=.9,this.skipCount=2,this.skipMax=2}async process(I,V){var re,ae;if(this.bodyTracks.length<1&&this.skipCount<this.skipMax)return this.skipCount++,[];this.skipCount=0;const le=JY(()=>{const Le=ip(iU(I,3),"float32"),Ue=BS(OP(Le,255*.5),1);return B0(Ue,0)}),[he,ue]=[le.shape[1],le.shape[2]];if(this.bodyTracks.length===0){const Le=await((re=this.bodyDetector)==null?void 0:re.process(le))||[];this.bodyTracks=Le.map(Ue=>({center:Ue.points[0],top:Ue.points[1]})),this.bodyTracks.forEach(()=>this.poseFilters.push(new Vz))}const pe=this.bodyTracks.length>0?((ae=this.poseDetector)==null?void 0:ae.process(le,this.bodyTracks))||[]:[];pe.forEach((Le,Ue)=>{var Ge;if(V!==void 0){const ze=ue/he,He=Le.top[0]-Le.center[0],Ke=(Le.top[1]-Le.center[1])/ze,Ye=Math.sqrt(He*He+Ke*Ke)*2*(1+ze)*.5;pe[Ue]=this.poseFilters[Ue].filter(Le,V,1/Ye)}(Ge=this.poseAligner)==null||Ge.alignPoints(pe[Ue].keypoints)}),le.dispose();let ve=[],we=[],Me=[];for(let Le=0;Le<this.bodyTracks.length;Le++){const Ue={center:[this.bodyTracks[Le].center[0]*ue,this.bodyTracks[Le].center[1]*he],top:[this.bodyTracks[Le].top[0]*ue,this.bodyTracks[Le].top[1]*he]};let Ge={center:[pe[Le].center[0]*ue,pe[Le].center[1]*he],top:[pe[Le].top[0]*ue,pe[Le].top[1]*he]};const ze=[Ue,Ge].map(He=>{const{center:Ke,top:Ye}=He,$e=[Ye[0]-Ke[0],Ye[1]-Ke[1]],je=Math.sqrt($e[0]*$e[0]+$e[1]*$e[1]);return[[Ke[0]-je,Ke[1]-je],[Ke[0]+je,Ke[1]+je]]});VU(ze[0],ze[1])>.5&&pe[Le].score>this.poseScore&&(ve.push({center:[...pe[Le].center],top:[...pe[Le].top]}),we.push(this.poseFilters[Le]),Me.push(pe[Le]))}return this.bodyTracks=ve,this.poseFilters=we,Me}setCamera(I,V,re=1){var ae;this.angle=I,this.ratio=V,this.near=re,(ae=this.poseAligner)==null||ae.setCamera(I,V,re)}async init(I,V="./",re=!1,ae=!1,le="webgl"){const he=await VM(I,V,re),ue=new he.ParseLoader(V);if(re||(await ue.remove("pose.wasm"),await ue.remove("poseutils.wasm")),!await ue.loadDict(["pose.wasm","poseutils.wasm"])||!await ue.load("pose.wasm")||!ue.parse())return;Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),JG(),await Jj(le);const pe={weightUrlConverter:async Le=>Le,fetchFunc:async Le=>{const Ue=new Blob([ue.file(Le)]);return fetch(URL.createObjectURL(Ue))}},ve=await Ph("bodymodel.def",pe),we=await Ph("posemodel.def",pe);if(this.bodyDetector=new VT(ve),this.poseDetector=new Vq(we,ae),!await ue.load("poseutils.wasm"))return;const Me=await Vh({wasmBinary:ue.data()});ue.delete(),Me.PoseAligner.prototype.alignPoints=function(Le){const Ue=new Me.VectorFloat,Ge=new Me.VectorFloat,ze=new Me.VectorFloat,He=new Me.VectorFloat;Le.forEach(Ye=>{Ue.push_back(Ye.pixel[0]),Ue.push_back(Ye.pixel[1]),Ue.push_back(Ye.pixel[2]),Ge.push_back(Ye.metric[0]),Ge.push_back(Ye.metric[1]),Ge.push_back(Ye.metric[2]),ze.push_back(Ye.score),He.push_back(Ye.visibility)});const Ke=this.align(Ue,Ge,ze,He);Le.forEach((Ye,$e)=>{Ye.metric=[Ke.get($e*3),Ke.get($e*3+1),Ke.get($e*3+2)]}),Ue.delete(),Ge.delete(),ze.delete(),He.delete(),Ke.delete()},this.poseModule=Me,this.poseAligner=new this.poseModule.PoseAligner,this.poseAligner.setThresh(this.alignScore,this.alignVisibility)}reset(){var I;this.bodyTracks=[],this.poseFilters=[],this.skipCount=this.skipMax,(I=this.poseDetector)==null||I.reset()}async prepare(){var I,V;Cd().set("ENGINE_COMPILE_ONLY",!0),await((I=this.bodyDetector)==null?void 0:I.prepare()),await((V=this.poseDetector)==null?void 0:V.prepare());const re=f1();re instanceof ea&&(re.checkCompileCompletion(),re.getUniformLocations()),Cd().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var I,V,re;this.reset(),(I=this.bodyDetector)==null||I.dispose(),delete this.bodyDetector,(V=this.poseDetector)==null||V.dispose(),delete this.poseDetector,(re=this.poseAligner)==null||re.delete(),delete this.poseAligner}}function AV(Z,I){const V=2*Math.tan(.5*I.angle),re=I.ratio*V,ae=Z.map(pe=>({pixel:[(pe.pixel[0]-.5)*re,(pe.pixel[1]-.5)*V],world:pe.world})),le=[];ae.forEach(pe=>le.push([0,1,-pe.pixel[1],pe.world[1]-pe.pixel[1]*pe.world[2]],[-1,0,pe.pixel[0],pe.pixel[0]*pe.world[2]-pe.world[0]]));const{V:he}=AS.svd(le),ue=he[3][3];return[he[0][3]/ue,he[1][3]/ue,he[2][3]/ue]}var Ab=Object.defineProperty,AP=Object.getOwnPropertySymbols,AE=Object.prototype.hasOwnProperty,AD=Object.prototype.propertyIsEnumerable,Ag=(Z,I,V)=>I in Z?Ab(Z,I,{enumerable:!0,configurable:!0,writable:!0,value:V}):Z[I]=V,AZ=(Z,I)=>{for(var V in I||(I={}))AE.call(I,V)&&Ag(Z,V,I[V]);if(AP)for(var V of AP(I))AD.call(I,V)&&Ag(Z,V,I[V]);return Z};class Ao{constructor(I){this.model=I,this.facesMax=3,this.iouThresh=.3,this.scoreThresh=.5,this.keypointCount=6,this.model=I,this.modelSize=I.inputs[0].shape?{width:I.inputs[0].shape[2],height:I.inputs[0].shape[1]}:{width:128,height:128},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchors=Sg(this.anchorsData),this.size=SD([this.modelSize.width,this.modelSize.height])}async process(I,V){let re={x:0,y:0};const[ae,le,he]=JY(()=>{const ze={width:I.shape[2],height:I.shape[1]},He=ze.width/ze.height;let Ke=AZ({},ze),Ye={x:0,y:0};He>this.modelRatio?(Ke.height=ze.width/this.modelRatio,Ye.y=Math.floor((Ke.height-ze.height)*.5),re.y=Ye.y/Ke.height):He<this.modelRatio&&(Ke.width=ze.height*this.modelRatio,Ye.x=Math.floor((Ke.width-ze.width)*.5),re.x=Ye.x/Ke.width);const $e=BA(I,[[0,0],[Ye.y,Ye.y],[Ye.x,Ye.x],[0,0]],0),je=dQ.resizeBilinear($e,[this.modelSize.height,this.modelSize.width]),rt=OS(OD(je,2),-1),at=SB(this.model.execute(rt,"objects")),Rt=t0(at,[0,0],[-1,1]),lt=SB(Oj(Rt)),kt=this.decodeBoxes(at,this.anchors,this.size);return[at,kt,lt]}),ue=await dQ.nonMaxSuppressionAsync(le,he,this.facesMax,this.iouThresh,this.scoreThresh),pe=await ue.data();ue.dispose();const ve=[];for(let ze=0;ze<pe.length;ze++){const He=pe[ze];ve.push({box:t0(le,[He,0],[1,-1]),score:t0(he,He,1),anchorI:He,points:V?t0(ae,[He,5],[1,-1]):void 0})}const we=await Promise.all(ve.map(async ze=>{var He,Ke;const Ye=await ze.box.data(),$e=await ze.score.data(),je=await((He=ze.points)==null?void 0:He.data());return ze.box.dispose(),ze.score.dispose(),(Ke=ze.points)==null||Ke.dispose(),{box:Ye,score:$e[0],anchorI:ze.anchorI,points:je}})),Me={width:1-2*re.x,height:1-2*re.y};re.x/=Me.width,re.y/=Me.height;const Le=this.modelSize.width*Me.width,Ue=this.modelSize.height*Me.height,Ge=[];for(let ze=0;ze<we.length;ze++){const He=we[ze].box,Ke=this.anchorsData[we[ze].anchorI],Ye=we[ze].points,$e=[];for(let je=0;je<this.keypointCount&&Ye;je++)$e.push({x:(Ye[je*2+0]+Ke[0])/Le-re.x,y:(Ye[je*2+1]+Ke[1])/Ue-re.y});Ge.push({box:[[He[0]/Le-re.x,He[1]/Ue-re.y],[He[2]/Le-re.x,He[3]/Ue-re.y]],score:we[ze].score,keypoints:Ye&&$e})}return ae.dispose(),le.dispose(),he.dispose(),Ge}decodeBoxes(I,V,re){const ae=t0(I,[0,1],[-1,2]),le=OS(ae,V),he=t0(I,[0,3],[-1,2]),ue=OP(he,2),pe=BS(le,ue),ve=OS(le,ue);return tN([pe,ve],1)}buildAnchors(I){const V=[8,16],re=[2,6],ae=[];for(let le=0;le<V.length;le++){const he=V[le],ue=Math.floor((I.height+he-1)/he),pe=Math.floor((I.width+he-1)/he),ve=re[le];for(let we=0;we<ue;we++){const Me=he*(we+.5);for(let Le=0;Le<pe;Le++){const Ue=he*(Le+.5);for(let Ge=0;Ge<ve;Ge++)ae.push([Ue,Me])}}}return ae}async prepare(){const{width:I,height:V}=this.modelSize,re=BQ([1,V,I,3]),ae=this.model.execute(re,"objects");await ae.data(),re.dispose(),ae.dispose()}dispose(){this.model.dispose(),this.anchors.dispose()}}var Ae=(Z=>(Z[Z.EyeR=0]="EyeR",Z[Z.EyeL=1]="EyeL",Z[Z.Nose=2]="Nose",Z[Z.Mouth=3]="Mouth",Z[Z.EarR=4]="EarR",Z[Z.EarL=5]="EarL",Z))(Ae||{});class AQ{constructor(I){this.model=I,this.boxFactor=1.5,this.symmetryPoints=[13,168],this.modelSize=I.inputs[0].shape?{width:I.inputs[0].shape[2],height:I.inputs[0].shape[1]}:{width:192,height:192},this.modelHighP=this.model.outputs.length===7}process(I,V){const re=V.map(ue=>{const{box:pe,symmetry:ve}=ue,we=.5*(this.boxFactor-1),Me={x:we*(pe[1][0]-pe[0][0]),y:we*(pe[1][1]-pe[0][1])};return{box:[[pe[0][0]-Me.x,pe[0][1]-Me.y],[pe[1][0]+Me.x,pe[1][1]+Me.y]],symmetry:ve}}),[ae,le]=[I.shape[1],I.shape[2]],{modelSize:he}=this;return re.map(ue=>{const{box:pe,symmetry:ve}=ue,we=Math.atan2((ve[1].x-ve[0].x)*le,(ve[0].y-ve[1].y)*ae),Me=[.5*(pe[0][0]+pe[1][0]),.5*(pe[0][1]+pe[1][1])],Le={width:pe[1][0]-pe[0][0],height:pe[1][1]-pe[0][1]},Ue=[pe[0][1]*ae,pe[0][0]*le,pe[1][1]*ae,pe[1][0]*le],Ge=this.rotatedRect(I,Ue,we,he),ze=this.modelHighP?["output_mesh_identity","output_faceflag","output_lips","Identity_1:0","Identity_5:0","Identity_2:0","Identity_6:0"]:["output_mesh","output_faceflag"],[He,Ke,Ye,$e,je,rt,at]=this.model.execute(Ge,ze),Rt=He.dataSync(),lt=Ke.dataSync()[0];let kt=[];for(let ns=0;ns<Rt.length/3;ns++)kt.push([Rt[ns*3+0],Rt[ns*3+1],Rt[ns*3+2]]);if(Ye){const ns=Ye.dataSync();AF(kt,ns,Ay)}if($e&&je){const ns=$e.dataSync(),Gs=je.dataSync();AF(kt,ns,AA),AF(kt,Gs,Ap)}if(rt&&at){const ns=rt.dataSync(),Gs=at.dataSync(),Xs=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173].map(xs=>kt[xs]),$i=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398].map(xs=>kt[xs]);for(let xs=0;xs<ns.length/2;xs++){const hi=[ns[xs*2+0],ns[xs*2+1]];kt.push([hi[0],hi[1],AI(hi,Xs)])}for(let xs=0;xs<Gs.length/2;xs++){const hi=[Gs[xs*2+0],Gs[xs*2+1]];kt.push([hi[0],hi[1],AI(hi,$i)])}}const qt=[Le.width*le/he.width,Le.height*ae/he.height],Kt=kt.map(ns=>[(ns[0]-he.width/2)*qt[0],(ns[1]-he.height/2)*qt[1],ns[2]*qt[0]]),_i=Math.sin(we),ci=Math.cos(we),li=Kt.map(ns=>[(ns[0]*ci-ns[1]*_i)/le+Me[0],(ns[0]*_i+ns[1]*ci)/ae+Me[1],ns[2]/le]),qi=li.map(ns=>ns[0]),Ki=li.map(ns=>ns[1]),hs=[Math.min(...qi),Math.min(...Ki)],Yi=[Math.max(...qi),Math.max(...Ki)];return Ge.dispose(),He.dispose(),Ke.dispose(),Ye?.dispose(),$e?.dispose(),je?.dispose(),rt?.dispose(),at?.dispose(),{keypoints:li,score:lt,box:[[hs[0],hs[1]],[Yi[0],Yi[1]]]}})}rotatedRect(I,V,re,ae){const[le,he]=[V[2]-V[0],V[3]-V[1]],[ue,pe]=[(V[2]+V[0])*.5,(V[3]+V[1])*.5],[ve,we]=[le/ae.height,he/ae.width],[Me,Le]=[Math.cos(re),Math.sin(re)],Ue=[Me*we,-Le*ve,(-Me*he+Le*le)*.5+pe,Le*we,Me*ve,(-Le*he-Me*le)*.5+ue,0,0];return dQ.transform(I,[Ue],"bilinear","constant",0,[ae.height,ae.width])}async prepare(){const{width:I,height:V}=this.modelSize,re=BQ([1,V,I,3]),ae=this.model.execute(re);await Promise.all(ae.map(async le=>{await le.data(),le.dispose()})),re.dispose()}dispose(){this.model.dispose()}}function As(Z,I){return Z.keypoints.forEach(V=>{V[0]*=I,V[1]*=I,V[2]*=I}),Z.box[0][0]*=I,Z.box[0][1]*=I,Z.box[1][0]*=I,Z.box[1][1]*=I,Z}function AF(Z,I,V){for(let re=0;re<V.length;re++)Z[V[re]][0]=I[re*2+0],Z[V[re]][1]=I[re*2+1]}function AI(Z,I){let V=0,re=Number.MAX_VALUE;for(let ae=0;ae<I.length;ae++){const le=[I[ae][0]-Z[0],I[ae][1]-Z[1]],he=le[0]*le[0]+le[1]*le[1];he<re&&(re=he,V=ae)}return I[V][2]}const Ay=[61,146,91,181,84,17,314,405,321,375,291,185,40,39,37,0,267,269,270,409,78,95,88,178,87,14,317,402,318,324,308,191,80,81,82,13,312,311,310,415,76,77,90,180,85,16,315,404,320,307,306,184,74,73,72,11,302,303,304,408,62,96,89,179,86,15,316,403,319,325,292,183,42,41,38,12,268,271,272,407],AA=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173,130,25,110,24,23,22,26,112,243,247,30,29,27,28,56,190,226,31,228,229,230,231,232,233,244,113,225,224,223,222,221,189,35,124,46,53,52,65,143,111,117,118,119,120,121,128,245,156,70,63,105,66,107,55,193],Ap=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398,359,255,339,254,253,252,256,341,463,467,260,259,257,258,286,414,446,261,448,449,450,451,452,453,464,342,445,444,443,442,441,413,265,353,276,283,282,295,372,340,346,347,348,349,350,357,465,383,300,293,334,296,336,285,417];var Aw=Object.defineProperty,AX=Object.getOwnPropertySymbols,Ac=Object.prototype.hasOwnProperty,AW=Object.prototype.propertyIsEnumerable,AR=(Z,I,V)=>I in Z?Aw(Z,I,{enumerable:!0,configurable:!0,writable:!0,value:V}):Z[I]=V,AK=(Z,I)=>{for(var V in I||(I={}))Ac.call(I,V)&&AR(Z,V,I[V]);if(AX)for(var V of AX(I))AW.call(I,V)&&AR(Z,V,I[V]);return Z};class AT{constructor(I,V=!1){this.model=I,this.modelSize=I.inputs[0].shape?{width:I.inputs[0].shape[2],height:I.inputs[0].shape[1]}:{width:256,height:256},this.modelRatio=this.modelSize.width/this.modelSize.height,V&&(this.maskFilter=new Vv(this.modelSize))}process(I,V){var re,ae;const{modelSize:le}=this,he=I.shape[2]/I.shape[1],ue=this.modelRatio/he,pe={width:V[1][0]-V[0][0],height:V[1][1]-V[0][1]},ve={x:(V[1][0]+V[0][0])*.5,y:(V[1][1]+V[0][1])*.5};pe.width/pe.height>ue?pe.height=pe.width/ue:pe.width=pe.height*ue;const we=[ve.y-pe.height*.5,ve.x-pe.width*.5,ve.y+pe.height*.5,ve.x+pe.width*.5],Me=dQ.cropAndResize(I,[we],[0],[le.height,le.width]),Le=(re=this.model)==null?void 0:re.execute(Me),Ue=t0(Le,[0,0,0,1],-1),Ge=SB(Ue),ze=((ae=this.maskFilter)==null?void 0:ae.process(Ge))||Ge,He=OD(ze,255),Ke=new Uint8Array(He.dataSync());return Me.dispose(),Le.dispose(),Ue.dispose(),Ge.dispose(),He.dispose(),{buffer:Ke,size:AK({},this.modelSize),box:[[we[1],we[0]],[we[3],we[2]]]}}resize(I){if(this.modelSize.width===I.width&&this.modelSize.height===I.height)return;const{model:V}=this,re=[Math.round(I.height/16),Math.round(I.width/16)];V.weights["StatefulPartitionedCall/model/up_sampling2d/mul"][0]=SD([re[0]*2,re[1]*2],"int32"),V.weights["StatefulPartitionedCall/model/up_sampling2d_1/mul"][0]=SD([re[0]*4,re[1]*4],"int32"),V.weights["StatefulPartitionedCall/model/up_sampling2d_2/mul"][0]=SD([re[0]*8,re[1]*8],"int32"),V.weights["StatefulPartitionedCall/model/segment/stack/1"][0]=SD([re[0]*16],"int32"),V.weights["StatefulPartitionedCall/model/segment/stack/2"][0]=SD([re[1]*16],"int32");const ae=V.executor;ae._inputs[0].attrParams.shape.value[1]=re[0]*16,ae._inputs[0].attrParams.shape.value[2]=re[1]*16;const le=V.executor.graph.nodes,he=(ue,pe)=>{const ve=le["StatefulPartitionedCall/model/"+ue].attrParams;ve.kernelSize.value[1]=pe[0],ve.kernelSize.value[2]=pe[1],ve.strides.value[1]=pe[0],ve.strides.value[2]=pe[1]};he("average_pooling2d/AvgPool",[re[0]*4,re[1]*4]),he("average_pooling2d_1/AvgPool",[re[0],re[1]]),he("average_pooling2d_2/AvgPool",[re[0],re[1]]),he("average_pooling2d_3/AvgPool",[re[0],re[1]]),he("average_pooling2d_4/AvgPool",[re[0],re[1]]),he("average_pooling2d_5/AvgPool",[re[0],re[1]]),he("average_pooling2d_6/AvgPool",[re[0],re[1]]),he("average_pooling2d_7/AvgPool",[re[0]*2,re[1]*2]),he("average_pooling2d_8/AvgPool",[re[0]*4,re[1]*4]),he("average_pooling2d_9/AvgPool",[re[0]*8,re[1]*8]),this.modelSize=I,this.modelRatio=I.width/I.height}size(){return this.modelSize}reset(){var I;(I=this.maskFilter)==null||I.reset()}async prepare(){var I;const{width:V,height:re}=this.modelSize,ae=BQ([1,re,V,3]),le=this.model.execute(ae),he=t0(le,[0,0,0,1],-1),ue=SB(he);await(((I=this.maskFilter)==null?void 0:I.process(ue))||ue).data(),ae.dispose(),le.dispose(),he.dispose(),ue.dispose()}dispose(){var I;this.model.dispose(),(I=this.maskFilter)==null||I.dispose(),delete this.maskFilter}}var Av=(()=>{var Z=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(I={}){var V=I,re,ae;V.ready=new Promise((_t,vt)=>{re=_t,ae=vt});var le=Object.assign({},V),he=!0,ue="";function pe(_t){return V.locateFile?V.locateFile(_t,ue):ue+_t}typeof document<"u"&&document.currentScript&&(ue=document.currentScript.src),Z&&(ue=Z),ue.startsWith("blob:")?ue="":ue=ue.substr(0,ue.replace(/[?#].*/,"").lastIndexOf("/")+1),V.print||console.log.bind(console);var ve=V.printErr||console.error.bind(console);Object.assign(V,le),le=null,V.arguments&&V.arguments,V.thisProgram&&V.thisProgram,V.quit&&V.quit;var we;V.wasmBinary&&(we=V.wasmBinary);var Me,Le=!1,Ue,Ge,ze,He,Ke,Ye,$e,je;function rt(){var _t=Me.buffer;V.HEAP8=Ue=new Int8Array(_t),V.HEAP16=ze=new Int16Array(_t),V.HEAPU8=Ge=new Uint8Array(_t),V.HEAPU16=He=new Uint16Array(_t),V.HEAP32=Ke=new Int32Array(_t),V.HEAPU32=Ye=new Uint32Array(_t),V.HEAPF32=$e=new Float32Array(_t),V.HEAPF64=je=new Float64Array(_t)}var at=[],Rt=[],lt=[];function kt(){if(V.preRun)for(typeof V.preRun=="function"&&(V.preRun=[V.preRun]);V.preRun.length;)_i(V.preRun.shift());Ks(at)}function qt(){Ks(Rt)}function Kt(){if(V.postRun)for(typeof V.postRun=="function"&&(V.postRun=[V.postRun]);V.postRun.length;)li(V.postRun.shift());Ks(lt)}function _i(_t){at.unshift(_t)}function ci(_t){Rt.unshift(_t)}function li(_t){lt.unshift(_t)}var qi=0,Ki=null;function hs(_t){var vt;qi++,(vt=V.monitorRunDependencies)==null||vt.call(V,qi)}function Yi(_t){var vt;if(qi--,(vt=V.monitorRunDependencies)==null||vt.call(V,qi),qi==0&&Ki){var Ut=Ki;Ki=null,Ut()}}function ns(_t){var vt;(vt=V.onAbort)==null||vt.call(V,_t),_t="Aborted("+_t+")",ve(_t),Le=!0,_t+=". Build with -sASSERTIONS for more info.";var Ut=new WebAssembly.RuntimeError(_t);throw ae(Ut),Ut}var Gs="data:application/octet-stream;base64,",Xs=_t=>_t.startsWith(Gs),$i;$i="faceutils.wasm",Xs($i)||($i=pe($i));function xs(_t){if(_t==$i&&we)return new Uint8Array(we);throw"both async and sync fetching of the wasm failed"}function hi(_t){return!we&&he&&typeof fetch=="function"?fetch(_t,{credentials:"same-origin"}).then(vt=>{if(!vt.ok)throw"failed to load wasm binary file at '"+_t+"'";return vt.arrayBuffer()}).catch(()=>xs(_t)):Promise.resolve().then(()=>xs(_t))}function Ri(_t,vt,Ut){return hi(_t).then(jt=>WebAssembly.instantiate(jt,vt)).then(Ut,jt=>{ve("failed to asynchronously prepare wasm: "+jt),ns(jt)})}function Wi(_t,vt,Ut,jt){return!_t&&typeof WebAssembly.instantiateStreaming=="function"&&!Xs(vt)&&typeof fetch=="function"?fetch(vt,{credentials:"same-origin"}).then(ni=>{var ri=WebAssembly.instantiateStreaming(ni,Ut);return ri.then(jt,function(Li){return ve("wasm streaming compile failed: "+Li),ve("falling back to ArrayBuffer instantiation"),Ri(vt,Ut,jt)})}):Ri(vt,Ut,jt)}function us(){var _t={a:zs};function vt(jt,ni){return a0=jt.exports,Me=a0.y,rt(),_o=a0.C,ci(a0.z),Yi(),a0}hs();function Ut(jt){vt(jt.instance)}if(V.instantiateWasm)try{return V.instantiateWasm(_t,vt)}catch(jt){ve("Module.instantiateWasm callback failed with error: "+jt),ae(jt)}return Wi(we,$i,_t,Ut).catch(ae),{}}var Ks=_t=>{for(;_t.length>0;)_t.shift()(V)};V.noExitRuntime;class ur{constructor(vt){this.excPtr=vt,this.ptr=vt-24}set_type(vt){Ye[this.ptr+4>>2]=vt}get_type(){return Ye[this.ptr+4>>2]}set_destructor(vt){Ye[this.ptr+8>>2]=vt}get_destructor(){return Ye[this.ptr+8>>2]}set_caught(vt){vt=vt?1:0,Ue[this.ptr+12]=vt}get_caught(){return Ue[this.ptr+12]!=0}set_rethrown(vt){vt=vt?1:0,Ue[this.ptr+13]=vt}get_rethrown(){return Ue[this.ptr+13]!=0}init(vt,Ut){this.set_adjusted_ptr(0),this.set_type(vt),this.set_destructor(Ut)}set_adjusted_ptr(vt){Ye[this.ptr+16>>2]=vt}get_adjusted_ptr(){return Ye[this.ptr+16>>2]}get_exception_ptr(){var vt=ct(this.get_type());if(vt)return Ye[this.excPtr>>2];var Ut=this.get_adjusted_ptr();return Ut!==0?Ut:this.excPtr}}var js=0,sr=(_t,vt,Ut)=>{var jt=new ur(_t);throw jt.init(vt,Ut),js=_t,js},cr={},ln=_t=>{for(;_t.length;){var vt=_t.pop(),Ut=_t.pop();Ut(vt)}};function kr(_t){return this.fromWireType(Ye[_t>>2])}var $r={},Rn={},Ln={},zn,ra=_t=>{throw new zn(_t)},aa=(_t,vt,Ut)=>{_t.forEach(function(zi){Ln[zi]=vt});function jt(zi){var Rs=Ut(zi);Rs.length!==_t.length&&ra("Mismatched type converter count");for(var as=0;as<_t.length;++as)c0(_t[as],Rs[as])}var ni=new Array(vt.length),ri=[],Li=0;vt.forEach((zi,Rs)=>{Rn.hasOwnProperty(zi)?ni[Rs]=Rn[zi]:(ri.push(zi),$r.hasOwnProperty(zi)||($r[zi]=[]),$r[zi].push(()=>{ni[Rs]=Rn[zi],++Li,Li===ri.length&&jt(ni)}))}),ri.length===0&&jt(ni)},ps=_t=>{var vt=cr[_t];delete cr[_t];var Ut=vt.elements,jt=Ut.length,ni=Ut.map(zi=>zi.getterReturnType).concat(Ut.map(zi=>zi.setterArgumentType)),ri=vt.rawConstructor,Li=vt.rawDestructor;aa([_t],ni,zi=>(Ut.forEach((Rs,as)=>{var Ms=zi[as],an=Rs.getter,cn=Rs.getterContext,Mn=zi[as+jt],wn=Rs.setter,xr=Rs.setterContext;Rs.read=nt=>Ms.fromWireType(an(cn,nt)),Rs.write=(nt,Gr)=>{var _s=[];wn(xr,nt,Mn.toWireType(_s,Gr)),ln(_s)}}),[{name:vt.name,fromWireType:Rs=>{for(var as=new Array(jt),Ms=0;Ms<jt;++Ms)as[Ms]=Ut[Ms].read(Rs);return Li(Rs),as},toWireType:(Rs,as)=>{if(jt!==as.length)throw new TypeError("Incorrect number of tuple elements for "+vt.name+": expected="+jt+", actual="+as.length);for(var Ms=ri(),an=0;an<jt;++an)Ut[an].write(Ms,as[an]);return Rs!==null&&Rs.push(Li,Ms),Ms},argPackAdvance:U0,readValueFromPointer:kr,destructorFunction:Li}]))},l0={},Ro=_t=>{var vt=l0[_t];delete l0[_t];var Ut=vt.rawConstructor,jt=vt.rawDestructor,ni=vt.fields,ri=ni.map(Li=>Li.getterReturnType).concat(ni.map(Li=>Li.setterArgumentType));aa([_t],ri,Li=>{var zi={};return ni.forEach((Rs,as)=>{var Ms=Rs.fieldName,an=Li[as],cn=Rs.getter,Mn=Rs.getterContext,wn=Li[as+ni.length],xr=Rs.setter,nt=Rs.setterContext;zi[Ms]={read:Gr=>an.fromWireType(cn(Mn,Gr)),write:(Gr,_s)=>{var Yt=[];xr(nt,Gr,wn.toWireType(Yt,_s)),ln(Yt)}}}),[{name:vt.name,fromWireType:Rs=>{var as={};for(var Ms in zi)as[Ms]=zi[Ms].read(Rs);return jt(Rs),as},toWireType:(Rs,as)=>{for(var Ms in zi)if(!(Ms in as))throw new TypeError('Missing field: "'+Ms+'"');var an=Ut();for(Ms in zi)zi[Ms].write(an,as[Ms]);return Rs!==null&&Rs.push(jt,an),an},argPackAdvance:U0,readValueFromPointer:kr,destructorFunction:jt}]})},rx=(_t,vt,Ut,jt,ni)=>{},Ma=()=>{for(var _t=new Array(256),vt=0;vt<256;++vt)_t[vt]=String.fromCharCode(vt);pn=_t},pn,jr=_t=>{for(var vt="",Ut=_t;Ge[Ut];)vt+=pn[Ge[Ut++]];return vt},uo,hn=_t=>{throw new uo(_t)};function Wo(_t,vt,Ut={}){var jt=vt.name;if(_t||hn('type "'+jt+'" must have a positive integer typeid pointer'),Rn.hasOwnProperty(_t)){if(Ut.ignoreDuplicateRegistrations)return;hn("Cannot register type '"+jt+"' twice")}if(Rn[_t]=vt,delete Ln[_t],$r.hasOwnProperty(_t)){var ni=$r[_t];delete $r[_t],ni.forEach(ri=>ri())}}function c0(_t,vt,Ut={}){if(!("argPackAdvance"in vt))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Wo(_t,vt,Ut)}var U0=8,U2=(_t,vt,Ut,jt)=>{vt=jr(vt),c0(_t,{name:vt,fromWireType:function(ni){return!!ni},toWireType:function(ni,ri){return ri?Ut:jt},argPackAdvance:U0,readValueFromPointer:function(ni){return this.fromWireType(Ge[ni])},destructorFunction:null})},kh=_t=>({count:_t.count,deleteScheduled:_t.deleteScheduled,preservePointerOnDelete:_t.preservePointerOnDelete,ptr:_t.ptr,ptrType:_t.ptrType,smartPtr:_t.smartPtr,smartPtrType:_t.smartPtrType}),$x=_t=>{function vt(Ut){return Ut.$$.ptrType.registeredClass.name}hn(vt(_t)+" instance already deleted")},Tl=!1,Mi=_t=>{},Uh=_t=>{_t.smartPtr?_t.smartPtrType.rawDestructor(_t.smartPtr):_t.ptrType.registeredClass.rawDestructor(_t.ptr)},Gn=_t=>{_t.count.value-=1;var vt=_t.count.value===0;vt&&Uh(_t)},u0=(_t,vt,Ut)=>{if(vt===Ut)return _t;if(Ut.baseClass===void 0)return null;var jt=u0(_t,vt,Ut.baseClass);return jt===null?null:Ut.downcast(jt)},wa={},Ho=()=>Object.keys(vi).length,px=()=>{var _t=[];for(var vt in vi)vi.hasOwnProperty(vt)&&_t.push(vi[vt]);return _t},Y0=[],$l=()=>{for(;Y0.length;){var _t=Y0.pop();_t.$$.deleteScheduled=!1,_t.delete()}},wr,rl=_t=>{wr=_t,Y0.length&&wr&&wr($l)},Tr=()=>{V.getInheritedInstanceCount=Ho,V.getLiveInheritedInstances=px,V.flushPendingDeletes=$l,V.setDelayFunction=rl},vi={},r2=(_t,vt)=>{for(vt===void 0&&hn("ptr should not be undefined");_t.baseClass;)vt=_t.upcast(vt),_t=_t.baseClass;return vt},vc=(_t,vt)=>(vt=r2(_t,vt),vi[vt]),j0=(_t,vt)=>{(!vt.ptrType||!vt.ptr)&&ra("makeClassHandle requires ptr and ptrType");var Ut=!!vt.smartPtrType,jt=!!vt.smartPtr;return Ut!==jt&&ra("Both smartPtrType and smartPtr must be specified"),vt.count={value:1},io(Object.create(_t,{$$:{value:vt,writable:!0}}))};function Rc(_t){var vt=this.getPointee(_t);if(!vt)return this.destructor(_t),null;var Ut=vc(this.registeredClass,vt);if(Ut!==void 0){if(Ut.$$.count.value===0)return Ut.$$.ptr=vt,Ut.$$.smartPtr=_t,Ut.clone();var jt=Ut.clone();return this.destructor(_t),jt}function ni(){return this.isSmartPointer?j0(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:vt,smartPtrType:this,smartPtr:_t}):j0(this.registeredClass.instancePrototype,{ptrType:this,ptr:_t})}var ri=this.registeredClass.getActualType(vt),Li=wa[ri];if(!Li)return ni.call(this);var zi;this.isConst?zi=Li.constPointerType:zi=Li.pointerType;var Rs=u0(vt,this.registeredClass,zi.registeredClass);return Rs===null?ni.call(this):this.isSmartPointer?j0(zi.registeredClass.instancePrototype,{ptrType:zi,ptr:Rs,smartPtrType:this,smartPtr:_t}):j0(zi.registeredClass.instancePrototype,{ptrType:zi,ptr:Rs})}var io=_t=>typeof FinalizationRegistry>"u"?(io=vt=>vt,_t):(Tl=new FinalizationRegistry(vt=>{Gn(vt.$$)}),io=vt=>{var Ut=vt.$$,jt=!!Ut.smartPtr;if(jt){var ni={$$:Ut};Tl.register(vt,ni,vt)}return vt},Mi=vt=>Tl.unregister(vt),io(_t)),G2=()=>{Object.assign(Wn.prototype,{isAliasOf(_t){if(!(this instanceof Wn)||!(_t instanceof Wn))return!1;var vt=this.$$.ptrType.registeredClass,Ut=this.$$.ptr;_t.$$=_t.$$;for(var jt=_t.$$.ptrType.registeredClass,ni=_t.$$.ptr;vt.baseClass;)Ut=vt.upcast(Ut),vt=vt.baseClass;for(;jt.baseClass;)ni=jt.upcast(ni),jt=jt.baseClass;return vt===jt&&Ut===ni},clone(){if(this.$$.ptr||$x(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var _t=io(Object.create(Object.getPrototypeOf(this),{$$:{value:kh(this.$$)}}));return _t.$$.count.value+=1,_t.$$.deleteScheduled=!1,_t},delete(){this.$$.ptr||$x(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&hn("Object already scheduled for deletion"),Mi(this),Gn(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||$x(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&hn("Object already scheduled for deletion"),Y0.push(this),Y0.length===1&&wr&&wr($l),this.$$.deleteScheduled=!0,this}})};function Wn(){}var _x=(_t,vt)=>Object.defineProperty(vt,"name",{value:_t}),z2=(_t,vt,Ut)=>{if(_t[vt].overloadTable===void 0){var jt=_t[vt];_t[vt]=function(...ni){return _t[vt].overloadTable.hasOwnProperty(ni.length)||hn("Function '"+Ut+"' called with an invalid number of arguments ("+ni.length+") - expects one of ("+_t[vt].overloadTable+")!"),_t[vt].overloadTable[ni.length].apply(this,ni)},_t[vt].overloadTable=[],_t[vt].overloadTable[jt.argCount]=jt}},Mc=(_t,vt,Ut)=>{V.hasOwnProperty(_t)?((Ut===void 0||V[_t].overloadTable!==void 0&&V[_t].overloadTable[Ut]!==void 0)&&hn("Cannot register public name '"+_t+"' twice"),z2(V,_t,_t),V.hasOwnProperty(Ut)&&hn("Cannot register multiple overloads of a function with the same number of arguments ("+Ut+")!"),V[_t].overloadTable[Ut]=vt):(V[_t]=vt,Ut!==void 0&&(V[_t].numArguments=Ut))},wc=48,Xa=57,n2=_t=>{if(_t===void 0)return"_unknown";_t=_t.replace(/[^a-zA-Z0-9_]/g,"$");var vt=_t.charCodeAt(0);return vt>=wc&&vt<=Xa?"_"+_t:_t};function W2(_t,vt,Ut,jt,ni,ri,Li,zi){this.name=_t,this.constructor=vt,this.instancePrototype=Ut,this.rawDestructor=jt,this.baseClass=ni,this.getActualType=ri,this.upcast=Li,this.downcast=zi,this.pureVirtualFunctions=[]}var Gx=(_t,vt,Ut)=>{for(;vt!==Ut;)vt.upcast||hn("Expected null or instance of "+Ut.name+", got an instance of "+vt.name),_t=vt.upcast(_t),vt=vt.baseClass;return _t};function Lc(_t,vt){if(vt===null)return this.isReference&&hn("null is not a valid "+this.name),0;vt.$$||hn('Cannot pass "'+Y2(vt)+'" as a '+this.name),vt.$$.ptr||hn("Cannot pass deleted object as a pointer of type "+this.name);var Ut=vt.$$.ptrType.registeredClass,jt=Gx(vt.$$.ptr,Ut,this.registeredClass);return jt}function Gh(_t,vt){var Ut;if(vt===null)return this.isReference&&hn("null is not a valid "+this.name),this.isSmartPointer?(Ut=this.rawConstructor(),_t!==null&&_t.push(this.rawDestructor,Ut),Ut):0;(!vt||!vt.$$)&&hn('Cannot pass "'+Y2(vt)+'" as a '+this.name),vt.$$.ptr||hn("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&vt.$$.ptrType.isConst&&hn("Cannot convert argument of type "+(vt.$$.smartPtrType?vt.$$.smartPtrType.name:vt.$$.ptrType.name)+" to parameter type "+this.name);var jt=vt.$$.ptrType.registeredClass;if(Ut=Gx(vt.$$.ptr,jt,this.registeredClass),this.isSmartPointer)switch(vt.$$.smartPtr===void 0&&hn("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:vt.$$.smartPtrType===this?Ut=vt.$$.smartPtr:hn("Cannot convert argument of type "+(vt.$$.smartPtrType?vt.$$.smartPtrType.name:vt.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:Ut=vt.$$.smartPtr;break;case 2:if(vt.$$.smartPtrType===this)Ut=vt.$$.smartPtr;else{var ni=vt.clone();Ut=this.rawShare(Ut,h2.toHandle(()=>ni.delete())),_t!==null&&_t.push(this.rawDestructor,Ut)}break;default:hn("Unsupporting sharing policy")}return Ut}function vl(_t,vt){if(vt===null)return this.isReference&&hn("null is not a valid "+this.name),0;vt.$$||hn('Cannot pass "'+Y2(vt)+'" as a '+this.name),vt.$$.ptr||hn("Cannot pass deleted object as a pointer of type "+this.name),vt.$$.ptrType.isConst&&hn("Cannot convert argument of type "+vt.$$.ptrType.name+" to parameter type "+this.name);var Ut=vt.$$.ptrType.registeredClass,jt=Gx(vt.$$.ptr,Ut,this.registeredClass);return jt}var zx=()=>{Object.assign(po.prototype,{getPointee(_t){return this.rawGetPointee&&(_t=this.rawGetPointee(_t)),_t},destructor(_t){var vt;(vt=this.rawDestructor)==null||vt.call(this,_t)},argPackAdvance:U0,readValueFromPointer:kr,fromWireType:Rc})};function po(_t,vt,Ut,jt,ni,ri,Li,zi,Rs,as,Ms){this.name=_t,this.registeredClass=vt,this.isReference=Ut,this.isConst=jt,this.isSmartPointer=ni,this.pointeeType=ri,this.sharingPolicy=Li,this.rawGetPointee=zi,this.rawConstructor=Rs,this.rawShare=as,this.rawDestructor=Ms,!ni&&vt.baseClass===void 0?jt?(this.toWireType=Lc,this.destructorFunction=null):(this.toWireType=vl,this.destructorFunction=null):this.toWireType=Gh}var Gi=(_t,vt,Ut)=>{V.hasOwnProperty(_t)||ra("Replacing nonexistent public symbol"),V[_t].overloadTable!==void 0&&Ut!==void 0?V[_t].overloadTable[Ut]=vt:(V[_t]=vt,V[_t].argCount=Ut)},va=(_t,vt,Ut)=>{var jt=V["dynCall_"+_t];return jt(vt,...Ut)},Rl=[],_o,X2=_t=>{var vt=Rl[_t];return vt||(_t>=Rl.length&&(Rl.length=_t+1),Rl[_t]=vt=_o.get(_t)),vt},n0=(_t,vt,Ut=[])=>{if(_t.includes("j"))return va(_t,vt,Ut);var jt=X2(vt)(...Ut);return jt},kc=(_t,vt)=>(...Ut)=>n0(_t,vt,Ut),_0=(_t,vt)=>{_t=jr(_t);function Ut(){return _t.includes("j")?kc(_t,vt):X2(vt)}var jt=Ut();return typeof jt!="function"&&hn("unknown function pointer with signature "+_t+": "+vt),jt},To=(_t,vt)=>{var Ut=_x(vt,function(jt){this.name=vt,this.message=jt;var ni=new Error(jt).stack;ni!==void 0&&(this.stack=this.toString()+`
`+ni.replace(/^Error(:[^\n]*)?\n/,""))});return Ut.prototype=Object.create(_t.prototype),Ut.prototype.constructor=Ut,Ut.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},Ut},Xo,K2=_t=>{var vt=Lt(_t),Ut=jr(vt);return z0(vt),Ut},ha=(_t,vt)=>{var Ut=[],jt={};function ni(ri){if(!jt[ri]&&!Rn[ri]){if(Ln[ri]){Ln[ri].forEach(ni);return}Ut.push(ri),jt[ri]=!0}}throw vt.forEach(ni),new Xo(_t+": "+Ut.map(K2).join([", "]))},nl=(_t,vt,Ut,jt,ni,ri,Li,zi,Rs,as,Ms,an,cn)=>{Ms=jr(Ms),ri=_0(ni,ri),zi&&(zi=_0(Li,zi)),as&&(as=_0(Rs,as)),cn=_0(an,cn);var Mn=n2(Ms);Mc(Mn,function(){ha("Cannot construct "+Ms+" due to unbound types",[jt])}),aa([_t,vt,Ut],jt?[jt]:[],wn=>{var xr;wn=wn[0];var nt,Gr;jt?(nt=wn.registeredClass,Gr=nt.instancePrototype):Gr=Wn.prototype;var _s=_x(Ms,function(...rh){if(Object.getPrototypeOf(this)!==Yt)throw new uo("Use 'new' to construct "+Ms);if(Us.constructor_body===void 0)throw new uo(Ms+" has no accessible constructor");var Tu=Us.constructor_body[rh.length];if(Tu===void 0)throw new uo("Tried to invoke ctor of "+Ms+" with invalid number of parameters ("+rh.length+") - expected ("+Object.keys(Us.constructor_body).toString()+") parameters instead!");return Tu.apply(this,rh)}),Yt=Object.create(Gr,{constructor:{value:_s}});_s.prototype=Yt;var Us=new W2(Ms,_s,Yt,cn,nt,ri,zi,as);Us.baseClass&&((xr=Us.baseClass).__derivedClasses!=null||(xr.__derivedClasses=[]),Us.baseClass.__derivedClasses.push(Us));var pi=new po(Ms,Us,!0,!1,!1),Rx=new po(Ms+"*",Us,!1,!1,!1),Mx=new po(Ms+" const*",Us,!1,!0,!1);return wa[_t]={pointerType:Rx,constPointerType:Mx},Gi(Mn,_s),[pi,Rx,Mx]})},nx=(_t,vt)=>{for(var Ut=[],jt=0;jt<_t;jt++)Ut.push(Ye[vt+jt*4>>2]);return Ut};function zh(_t){for(var vt=1;vt<_t.length;++vt)if(_t[vt]!==null&&_t[vt].destructorFunction===void 0)return!0;return!1}function Ko(_t,vt,Ut,jt,ni,ri){var Li=vt.length;Li<2&&hn("argTypes array size mismatch! Must at least get return value and 'this' types!");var zi=vt[1]!==null&&Ut!==null,Rs=zh(vt),as=vt[0].name!=="void",Ms=Li-2,an=new Array(Ms),cn=[],Mn=[],wn=function(...xr){xr.length!==Ms&&hn("function "+_t+" called with "+xr.length+" arguments, expected "+Ms),Mn.length=0;var nt;cn.length=zi?2:1,cn[0]=ni,zi&&(nt=vt[1].toWireType(Mn,this),cn[1]=nt);for(var Gr=0;Gr<Ms;++Gr)an[Gr]=vt[Gr+2].toWireType(Mn,xr[Gr]),cn.push(an[Gr]);var _s=jt(...cn);function Yt(Us){if(Rs)ln(Mn);else for(var pi=zi?1:2;pi<vt.length;pi++){var Rx=pi===1?nt:an[pi-2];vt[pi].destructorFunction!==null&&vt[pi].destructorFunction(Rx)}if(as)return vt[0].fromWireType(Us)}return Yt(_s)};return _x(_t,wn)}var Uc=(_t,vt,Ut,jt,ni,ri)=>{var Li=nx(vt,Ut);ni=_0(jt,ni),aa([],[_t],zi=>{zi=zi[0];var Rs="constructor "+zi.name;if(zi.registeredClass.constructor_body===void 0&&(zi.registeredClass.constructor_body=[]),zi.registeredClass.constructor_body[vt-1]!==void 0)throw new uo("Cannot register multiple constructors with identical number of parameters ("+(vt-1)+") for class '"+zi.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return zi.registeredClass.constructor_body[vt-1]=()=>{ha("Cannot construct "+zi.name+" due to unbound types",Li)},aa([],Li,as=>(as.splice(1,0,null),zi.registeredClass.constructor_body[vt-1]=Ko(Rs,as,null,ni,ri),[])),[]})},rr=_t=>{_t=_t.trim();const vt=_t.indexOf("(");return vt!==-1?_t.substr(0,vt):_t},Gc=(_t,vt,Ut,jt,ni,ri,Li,zi,Rs)=>{var as=nx(Ut,jt);vt=jr(vt),vt=rr(vt),ri=_0(ni,ri),aa([],[_t],Ms=>{Ms=Ms[0];var an=Ms.name+"."+vt;vt.startsWith("@@")&&(vt=Symbol[vt.substring(2)]),zi&&Ms.registeredClass.pureVirtualFunctions.push(vt);function cn(){ha("Cannot call "+an+" due to unbound types",as)}var Mn=Ms.registeredClass.instancePrototype,wn=Mn[vt];return wn===void 0||wn.overloadTable===void 0&&wn.className!==Ms.name&&wn.argCount===Ut-2?(cn.argCount=Ut-2,cn.className=Ms.name,Mn[vt]=cn):(z2(Mn,vt,an),Mn[vt].overloadTable[Ut-2]=cn),aa([],as,xr=>{var nt=Ko(an,xr,Ms,ri,Li);return Mn[vt].overloadTable===void 0?(nt.argCount=Ut-2,Mn[vt]=nt):Mn[vt].overloadTable[Ut-2]=nt,[]}),[]})},a2=(_t,vt,Ut)=>(_t instanceof Object||hn(Ut+' with invalid "this": '+_t),_t instanceof vt.registeredClass.constructor||hn(Ut+' incompatible with "this" of type '+_t.constructor.name),_t.$$.ptr||hn("cannot call emscripten binding method "+Ut+" on deleted object"),Gx(_t.$$.ptr,_t.$$.ptrType.registeredClass,vt.registeredClass)),T0=(_t,vt,Ut,jt,ni,ri,Li,zi,Rs,as)=>{vt=jr(vt),ni=_0(jt,ni),aa([],[_t],Ms=>{Ms=Ms[0];var an=Ms.name+"."+vt,cn={get(){ha("Cannot access "+an+" due to unbound types",[Ut,Li])},enumerable:!0,configurable:!0};return Rs?cn.set=()=>ha("Cannot access "+an+" due to unbound types",[Ut,Li]):cn.set=Mn=>hn(an+" is a read-only property"),Object.defineProperty(Ms.registeredClass.instancePrototype,vt,cn),aa([],Rs?[Ut,Li]:[Ut],Mn=>{var wn=Mn[0],xr={get(){var Gr=a2(this,Ms,an+" getter");return wn.fromWireType(ni(ri,Gr))},enumerable:!0};if(Rs){Rs=_0(zi,Rs);var nt=Mn[1];xr.set=function(Gr){var _s=a2(this,Ms,an+" setter"),Yt=[];Rs(as,_s,nt.toWireType(Yt,Gr)),ln(Yt)}}return Object.defineProperty(Ms.registeredClass.instancePrototype,vt,xr),[]}),[]})},x2=[],ui=[],l2=_t=>{_t>9&&--ui[_t+1]===0&&(ui[_t]=void 0,x2.push(_t))},Uo=()=>ui.length/2-5-x2.length,al=()=>{ui.push(0,1,void 0,1,null,1,!0,1,!1,1),V.count_emval_handles=Uo},h2={toValue:_t=>(_t||hn("Cannot use deleted val. handle = "+_t),ui[_t]),toHandle:_t=>{switch(_t){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const vt=x2.pop()||ui.length;return ui[vt]=_t,ui[vt+1]=1,vt}}}},za={name:"emscripten::val",fromWireType:_t=>{var vt=h2.toValue(_t);return l2(_t),vt},toWireType:(_t,vt)=>h2.toHandle(vt),argPackAdvance:U0,readValueFromPointer:kr,destructorFunction:null},v0=_t=>c0(_t,za),Y2=_t=>{if(_t===null)return"null";var vt=typeof _t;return vt==="object"||vt==="array"||vt==="function"?_t.toString():""+_t},xl=(_t,vt)=>{switch(vt){case 4:return function(Ut){return this.fromWireType($e[Ut>>2])};case 8:return function(Ut){return this.fromWireType(je[Ut>>3])};default:throw new TypeError("invalid float width ("+vt+"): "+_t)}},Yo=(_t,vt,Ut)=>{vt=jr(vt),c0(_t,{name:vt,fromWireType:jt=>jt,toWireType:(jt,ni)=>ni,argPackAdvance:U0,readValueFromPointer:xl(vt,Ut),destructorFunction:null})},jo=(_t,vt,Ut)=>{switch(vt){case 1:return Ut?jt=>Ue[jt]:jt=>Ge[jt];case 2:return Ut?jt=>ze[jt>>1]:jt=>He[jt>>1];case 4:return Ut?jt=>Ke[jt>>2]:jt=>Ye[jt>>2];default:throw new TypeError("invalid integer width ("+vt+"): "+_t)}},zc=(_t,vt,Ut,jt,ni)=>{vt=jr(vt);var ri=Ms=>Ms;if(jt===0){var Li=32-8*Ut;ri=Ms=>Ms<<Li>>>Li}var zi=vt.includes("unsigned"),Rs=(Ms,an)=>{},as;zi?as=function(Ms,an){return Rs(an,this.name),an>>>0}:as=function(Ms,an){return Rs(an,this.name),an},c0(_t,{name:vt,fromWireType:ri,toWireType:as,argPackAdvance:U0,readValueFromPointer:jo(vt,Ut,jt!==0),destructorFunction:null})},Wc=(_t,vt,Ut)=>{var jt=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],ni=jt[vt];function ri(Li){var zi=Ye[Li>>2],Rs=Ye[Li+4>>2];return new ni(Ue.buffer,Rs,zi)}Ut=jr(Ut),c0(_t,{name:Ut,fromWireType:ri,argPackAdvance:U0,readValueFromPointer:ri},{ignoreDuplicateRegistrations:!0})},Wh=(_t,vt,Ut,jt)=>{if(!(jt>0))return 0;for(var ni=Ut,ri=Ut+jt-1,Li=0;Li<_t.length;++Li){var zi=_t.charCodeAt(Li);if(zi>=55296&&zi<=57343){var Rs=_t.charCodeAt(++Li);zi=65536+((zi&1023)<<10)|Rs&1023}if(zi<=127){if(Ut>=ri)break;vt[Ut++]=zi}else if(zi<=2047){if(Ut+1>=ri)break;vt[Ut++]=192|zi>>6,vt[Ut++]=128|zi&63}else if(zi<=65535){if(Ut+2>=ri)break;vt[Ut++]=224|zi>>12,vt[Ut++]=128|zi>>6&63,vt[Ut++]=128|zi&63}else{if(Ut+3>=ri)break;vt[Ut++]=240|zi>>18,vt[Ut++]=128|zi>>12&63,vt[Ut++]=128|zi>>6&63,vt[Ut++]=128|zi&63}}return vt[Ut]=0,Ut-ni},c2=(_t,vt,Ut)=>Wh(_t,Ge,vt,Ut),u2=_t=>{for(var vt=0,Ut=0;Ut<_t.length;++Ut){var jt=_t.charCodeAt(Ut);jt<=127?vt++:jt<=2047?vt+=2:jt>=55296&&jt<=57343?(vt+=4,++Ut):vt+=3}return vt},Mo=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Hc=(_t,vt,Ut)=>{for(var jt=vt+Ut,ni=vt;_t[ni]&&!(ni>=jt);)++ni;if(ni-vt>16&&_t.buffer&&Mo)return Mo.decode(_t.subarray(vt,ni));for(var ri="";vt<ni;){var Li=_t[vt++];if(!(Li&128)){ri+=String.fromCharCode(Li);continue}var zi=_t[vt++]&63;if((Li&224)==192){ri+=String.fromCharCode((Li&31)<<6|zi);continue}var Rs=_t[vt++]&63;if((Li&240)==224?Li=(Li&15)<<12|zi<<6|Rs:Li=(Li&7)<<18|zi<<12|Rs<<6|_t[vt++]&63,Li<65536)ri+=String.fromCharCode(Li);else{var as=Li-65536;ri+=String.fromCharCode(55296|as>>10,56320|as&1023)}}return ri},Hh=(_t,vt)=>_t?Hc(Ge,_t,vt):"",_2=(_t,vt)=>{vt=jr(vt);var Ut=vt==="std::string";c0(_t,{name:vt,fromWireType(jt){var ni=Ye[jt>>2],ri=jt+4,Li;if(Ut)for(var zi=ri,Rs=0;Rs<=ni;++Rs){var as=ri+Rs;if(Rs==ni||Ge[as]==0){var Ms=as-zi,an=Hh(zi,Ms);Li===void 0?Li=an:(Li+=String.fromCharCode(0),Li+=an),zi=as+1}}else{for(var cn=new Array(ni),Rs=0;Rs<ni;++Rs)cn[Rs]=String.fromCharCode(Ge[ri+Rs]);Li=cn.join("")}return z0(jt),Li},toWireType(jt,ni){ni instanceof ArrayBuffer&&(ni=new Uint8Array(ni));var ri,Li=typeof ni=="string";Li||ni instanceof Uint8Array||ni instanceof Uint8ClampedArray||ni instanceof Int8Array||hn("Cannot pass non-string to std::string"),Ut&&Li?ri=u2(ni):ri=ni.length;var zi=q0(4+ri+1),Rs=zi+4;if(Ye[zi>>2]=ri,Ut&&Li)c2(ni,Rs,ri+1);else if(Li)for(var as=0;as<ri;++as){var Ms=ni.charCodeAt(as);Ms>255&&(z0(Rs),hn("String has UTF-16 code units that do not fit in 8 bits")),Ge[Rs+as]=Ms}else for(var as=0;as<ri;++as)Ge[Rs+as]=ni[as];return jt!==null&&jt.push(z0,zi),zi},argPackAdvance:U0,readValueFromPointer:kr,destructorFunction(jt){z0(jt)}})},G0=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Ml=(_t,vt)=>{for(var Ut=_t,jt=Ut>>1,ni=jt+vt/2;!(jt>=ni)&&He[jt];)++jt;if(Ut=jt<<1,Ut-_t>32&&G0)return G0.decode(Ge.subarray(_t,Ut));for(var ri="",Li=0;!(Li>=vt/2);++Li){var zi=ze[_t+Li*2>>1];if(zi==0)break;ri+=String.fromCharCode(zi)}return ri},wl=(_t,vt,Ut)=>{if(Ut!=null||(Ut=2147483647),Ut<2)return 0;Ut-=2;for(var jt=vt,ni=Ut<_t.length*2?Ut/2:_t.length,ri=0;ri<ni;++ri){var Li=_t.charCodeAt(ri);ze[vt>>1]=Li,vt+=2}return ze[vt>>1]=0,vt-jt},j2=_t=>_t.length*2,La=(_t,vt)=>{for(var Ut=0,jt="";!(Ut>=vt/4);){var ni=Ke[_t+Ut*4>>2];if(ni==0)break;if(++Ut,ni>=65536){var ri=ni-65536;jt+=String.fromCharCode(55296|ri>>10,56320|ri&1023)}else jt+=String.fromCharCode(ni)}return jt},Xh=(_t,vt,Ut)=>{if(Ut!=null||(Ut=2147483647),Ut<4)return 0;for(var jt=vt,ni=jt+Ut-4,ri=0;ri<_t.length;++ri){var Li=_t.charCodeAt(ri);if(Li>=55296&&Li<=57343){var zi=_t.charCodeAt(++ri);Li=65536+((Li&1023)<<10)|zi&1023}if(Ke[vt>>2]=Li,vt+=4,vt+4>ni)break}return Ke[vt>>2]=0,vt-jt},q2=_t=>{for(var vt=0,Ut=0;Ut<_t.length;++Ut){var jt=_t.charCodeAt(Ut);jt>=55296&&jt<=57343&&++Ut,vt+=4}return vt},T2=(_t,vt,Ut)=>{Ut=jr(Ut);var jt,ni,ri,Li;vt===2?(jt=Ml,ni=wl,Li=j2,ri=zi=>He[zi>>1]):vt===4&&(jt=La,ni=Xh,Li=q2,ri=zi=>Ye[zi>>2]),c0(_t,{name:Ut,fromWireType:zi=>{for(var Rs=Ye[zi>>2],as,Ms=zi+4,an=0;an<=Rs;++an){var cn=zi+4+an*vt;if(an==Rs||ri(cn)==0){var Mn=cn-Ms,wn=jt(Ms,Mn);as===void 0?as=wn:(as+=String.fromCharCode(0),as+=wn),Ms=cn+vt}}return z0(zi),as},toWireType:(zi,Rs)=>{typeof Rs!="string"&&hn("Cannot pass non-string to C++ string type "+Ut);var as=Li(Rs),Ms=q0(4+as+vt);return Ye[Ms>>2]=as/vt,ni(Rs,Ms+4,as+vt),zi!==null&&zi.push(z0,Ms),Ms},argPackAdvance:U0,readValueFromPointer:kr,destructorFunction(zi){z0(zi)}})},Ll=(_t,vt,Ut,jt,ni,ri)=>{cr[_t]={name:jr(vt),rawConstructor:_0(Ut,jt),rawDestructor:_0(ni,ri),elements:[]}},Tx=(_t,vt,Ut,jt,ni,ri,Li,zi,Rs)=>{cr[_t].elements.push({getterReturnType:vt,getter:_0(Ut,jt),getterContext:ni,setterArgumentType:ri,setter:_0(Li,zi),setterContext:Rs})},$2=(_t,vt,Ut,jt,ni,ri)=>{l0[_t]={name:jr(vt),rawConstructor:_0(Ut,jt),rawDestructor:_0(ni,ri),fields:[]}},Kh=(_t,vt,Ut,jt,ni,ri,Li,zi,Rs,as)=>{l0[_t].fields.push({fieldName:jr(vt),getterReturnType:Ut,getter:_0(jt,ni),getterContext:ri,setterArgumentType:Li,setter:_0(zi,Rs),setterContext:as})},kl=(_t,vt)=>{vt=jr(vt),c0(_t,{isVoid:!0,name:vt,argPackAdvance:0,fromWireType:()=>{},toWireType:(Ut,jt)=>{}})},Xc=(_t,vt)=>{var Ut=Rn[_t];return Ut===void 0&&hn(vt+" has unknown type "+K2(_t)),Ut},Ul=(_t,vt)=>{_t=Xc(_t,"_emval_take_value");var Ut=_t.readValueFromPointer(vt);return h2.toHandle(Ut)},Yh=()=>{ns("")},Kc=(_t,vt,Ut)=>Ge.copyWithin(_t,vt,vt+Ut),ro=()=>2147483648,vx=_t=>{var vt=Me.buffer,Ut=(_t-vt.byteLength+65535)/65536;try{return Me.grow(Ut),rt(),1}catch{}},v2=_t=>{var vt=Ge.length;_t>>>=0;var Ut=ro();if(_t>Ut)return!1;for(var jt=(Rs,as)=>Rs+(as-Rs%as)%as,ni=1;ni<=4;ni*=2){var ri=vt*(1+.2/ni);ri=Math.min(ri,_t+100663296);var Li=Math.min(Ut,jt(Math.max(_t,ri),65536)),zi=vx(Li);if(zi)return!0}return!1};zn=V.InternalError=class extends Error{constructor(_t){super(_t),this.name="InternalError"}},Ma(),uo=V.BindingError=class extends Error{constructor(_t){super(_t),this.name="BindingError"}},G2(),Tr(),zx(),Xo=V.UnboundTypeError=To(Error,"UnboundTypeError"),al();var zs={b:sr,h:ps,x:Ro,q:rx,v:U2,l:nl,g:Uc,c:Gc,f:T0,u:v0,n:Yo,e:zc,a:Wc,m:_2,j:T2,i:Ll,d:Tx,o:$2,k:Kh,w:kl,p:Ul,r:Yh,t:Kc,s:v2},a0=us(),z0=_t=>(z0=a0.A)(_t),q0=_t=>(q0=a0.B)(_t),Lt=_t=>(Lt=a0.D)(_t),ct=_t=>(ct=a0.E)(_t),ai;Ki=function _t(){ai||ki(),ai||(Ki=_t)};function ki(){if(qi>0||(kt(),qi>0))return;function _t(){ai||(ai=!0,V.calledRun=!0,!Le&&(qt(),re(V),V.onRuntimeInitialized&&V.onRuntimeInitialized(),Kt()))}V.setStatus?(V.setStatus("Running..."),setTimeout(function(){setTimeout(function(){V.setStatus("")},1),_t()},1)):_t()}if(V.preInit)for(typeof V.preInit=="function"&&(V.preInit=[V.preInit]);V.preInit.length>0;)V.preInit.pop()();return ki(),I.ready}})();class Aq{constructor(){this.faceTracks=[],this.faceFilters=[],this.meshScore=.9,this.maskSize=256}async process(I,V){var re,ae,le,he,ue;const pe=JY(()=>{const Ge=ip(iU(I,3),"float32"),ze=OD(Ge,1/255);return B0(ze,0)});let ve=[];this.faceTracks.length===0&&(ve=await((re=this.faceDetector)==null?void 0:re.process(pe,!0))||[],ve.forEach(Ge=>{if(!Ge.keypoints)return;const{box:ze}=Ge,He=.5*.3*(Ge.box[1][1]-Ge.box[0][1]);this.faceTracks.push({box:[[ze[0][0],ze[0][1]-He],[ze[1][0],ze[1][1]+He]],symmetry:[Ge.keypoints[Ae.Mouth],Ge.keypoints[Ae.Nose]]}),this.faceFilters.push(new this.faceModule.FaceFilter({minCutOff:1,minCutOffD:2,beta:30},{minCutOff:1,minCutOffD:2,beta:30},1))}),(ae=this.bodySegmenter)==null||ae.reset());const we=this.faceTracks.length>0?((le=this.meshDetector)==null?void 0:le.process(pe,this.faceTracks))||[]:[],Me=[],Le=[],Ue=[];for(let Ge=0;Ge<this.faceTracks.length;Ge++){const ze=we[Ge],{box:He}=ze,Ke=[ze.keypoints[((he=this.meshDetector)==null?void 0:he.symmetryPoints[0])||0],ze.keypoints[((ue=this.meshDetector)==null?void 0:ue.symmetryPoints[1])||0]];if(VU(this.faceTracks[Ge].box,He)>.5&&ze.score>this.meshScore){if(Ue.push(ze),Me.push({box:He,symmetry:[{x:Ke[0][0],y:Ke[0][1]},{x:Ke[1][0],y:Ke[1][1]}]}),V===void 0)continue;const[Ye,$e]=[pe.shape[1],pe.shape[2]],[je,rt]=[He[1][0]-He[0][0],He[1][1]-He[0][1]],at=(je+rt*$e/Ye)*.5;this.faceFilters[Ge].smoothFilter(ze,V,1/at),ze.keypoints=this.faceFilters[Ge].smoothPixel(),ze.box=this.faceFilters[Ge].smoothBox();const{bodySegmenter:Rt,maskExt:lt}=this;if(Rt){const kt=Rt.size(),qt=$e/Ye,Kt=kt.width/kt.height/qt,_i=Kt<1?{width:Kt,height:1}:{width:1,height:1/Kt},ci=[.5*(He[0][0]+He[1][0]),.5*(He[0][1]+He[1][1])],li=lt?[[He[0][0]-je*lt,He[0][1]-rt*lt],[He[1][0]+je*lt,He[1][1]+rt*lt]]:[[ci[0]-.5*_i.width,ci[1]-.5*_i.height],[ci[0]+.5*_i.width,ci[1]+.5*_i.height]];li[0][0]<0&&(li[1][0]-=li[0][0],li[0][0]=0),li[0][1]<0&&(li[1][1]-=li[0][1],li[0][1]=0),li[1][0]>1&&(li[0][0]-=li[1][0]-1,li[1][0]=1),li[1][1]>1&&(li[0][1]-=li[1][1]-1,li[1][1]=1),li[0][0]<0&&(li[0][0]*=.5,li[1][0]-=li[0][0]),li[0][1]<0&&(li[0][1]*=.5,li[1][1]-=li[0][1]),ze.mask=Rt.process(pe,li)}Le.push(this.faceFilters[Ge])}else this.faceFilters[Ge].delete()}return pe.dispose(),this.faceTracks=Me,this.faceFilters=Le,Ue}align(I){var V;const re=new this.faceModule.VectorFloat;return I.flat().forEach(ae=>re.push_back(ae)),(V=this.faceAligner)==null||V.align(re),re.delete(),this.alignTransform()}alignTransform(){if(!this.faceAligner)return;const I=this.faceAligner.rotation,V=this.faceAligner.translation,re=this.faceAligner.scale,ae=this.faceAligner.shapeScale;return{rotation:[I[0],I[1],I[2],I[3]],translation:[V[0],V[1],V[2]],scale:re,shapeScale:[ae[0],ae[1],ae[2]]}}metricPoints(){if(!this.faceAligner)return;let I=[];const V=this.faceAligner.metricPoints();for(let re=0;re<V.size();re+=3)I.push([V.get(re+0),V.get(re+1),V.get(re+2)]);return V.delete(),I}referencePoints(){if(!this.faceAligner)return;let I=[];const V=this.faceAligner.referencePoints();for(let re=0;re<V.size();re+=3)I.push([V.get(re+0),V.get(re+1),V.get(re+2)]);return V.delete(),I}backprojPoints(){if(!this.faceAligner)return;let I=[];const V=this.faceAligner.backprojPoints();for(let re=0;re<V.size();re+=3)I.push([V.get(re+0),V.get(re+1),V.get(re+2)]);return V.delete(),I}setCamera(I,V,re){var ae;if((ae=this.faceAligner)==null||ae.setCamera(I,V,re),this.bodySegmenter&&!this.maskExt){const le=this.maskSize/16,[he,ue]=V>1?[le,Math.round(le/V)]:[Math.round(le*V),le];this.bodySegmenter.resize({width:he*16,height:ue*16})}}async init(I,V="./",re=!1,ae=!1,le=!1,he,ue=256,pe="webgl"){const ve=await VM(I,V,re),we=new ve.ParseLoader(V),[Me,Le]=ae?["faceext.wasm","meshextmodel.def"]:["face.wasm","meshmodel.def"],Ue=[Me,"faceutils.wasm"];if(le&&Ue.push("mask.wasm"),!re)for(const $e of Ue)await we.remove($e);if(!await we.loadDict(Ue)||!await we.load(Me)||!we.parse())return;Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),JG(),await Jj(pe);const Ge={weightUrlConverter:async $e=>$e,fetchFunc:async $e=>{const je=new Blob([we.file($e)]);return fetch(URL.createObjectURL(je))}},ze=await Ph("facemodel.def",Ge),He=await Ph(Le,Ge),Ke=le&&await we.load("mask.wasm")&&we.parse()&&await Ph("maskmodel.def",Ge);if(this.faceDetector=new Ao(ze),this.meshDetector=new AQ(He),Ke&&(this.bodySegmenter=new AT(Ke,typeof le=="object"&&le.smooth),this.bodySegmenter.resize({width:ue,height:ue}),this.maskSize=this.bodySegmenter.size().width,this.maskExt=he),!await we.load("faceutils.wasm"))return;const Ye=await Av({wasmBinary:we.data()});we.delete(),Ye.FaceFilter.prototype.smoothFilter=function($e,je){const rt=new Ye.VectorFloat,at=new Ye.VectorFloat;$e.keypoints.flat().forEach(Rt=>rt.push_back(Rt)),$e.box.flat().forEach(Rt=>at.push_back(Rt)),this.filter(rt,at,$e.score,je,1),rt.delete(),at.delete()},Ye.FaceFilter.prototype.smoothPixel=function(){let $e=[];const je=this.pixel();for(let rt=0;rt<je.size();rt+=3)$e.push([je.get(rt+0),je.get(rt+1),je.get(rt+2)]);return je.delete(),$e},Ye.FaceFilter.prototype.smoothBox=function(){const $e=this.box(),je=[[$e[0],$e[1]],[$e[2],$e[3]]];return $e.delete(),je},this.faceModule=Ye,this.faceAligner=new this.faceModule.FaceAligner}reset(){var I;this.faceFilters.forEach(V=>V.delete()),this.faceFilters=[],this.faceTracks=[],(I=this.bodySegmenter)==null||I.reset()}async prepare(){var I,V,re;Cd().set("ENGINE_COMPILE_ONLY",!0),await((I=this.faceDetector)==null?void 0:I.prepare()),await((V=this.meshDetector)==null?void 0:V.prepare()),await((re=this.bodySegmenter)==null?void 0:re.prepare());const ae=f1();ae instanceof ea&&(ae.checkCompileCompletion(),ae.getUniformLocations()),Cd().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var I,V,re,ae;this.reset(),(I=this.faceDetector)==null||I.dispose(),(V=this.meshDetector)==null||V.dispose(),(re=this.bodySegmenter)==null||re.dispose(),(ae=this.faceAligner)==null||ae.delete()}}var Al=Object.defineProperty,Aa=Object.getOwnPropertySymbols,An=Object.prototype.hasOwnProperty,AL=Object.prototype.propertyIsEnumerable,AH=(Z,I,V)=>I in Z?Al(Z,I,{enumerable:!0,configurable:!0,writable:!0,value:V}):Z[I]=V,Ak=(Z,I)=>{for(var V in I||(I={}))An.call(I,V)&&AH(Z,V,I[V]);if(Aa)for(var V of Aa(I))AL.call(I,V)&&AH(Z,V,I[V]);return Z};class Az{constructor(I){this.model=I,this.handsMax=1,this.iouThresh=.3,this.scoreThresh=.45,this.model=I,this.modelSize=I.inputs[0].shape?{width:I.inputs[0].shape[2],height:I.inputs[0].shape[1]}:{width:192,height:192},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=SD(this.anchorsData.map(V=>V.x)),this.anchorsY=SD(this.anchorsData.map(V=>V.y))}async process(I){let V={x:0,y:0};const[re,ae]=JY(()=>{const ve={width:I.shape[2],height:I.shape[1]},we=ve.width/ve.height;let Me=Ak({},ve),Le={x:0,y:0};we>this.modelRatio?(Me.height=I.shape[2]/this.modelRatio,Le.y=Math.floor((Me.height-I.shape[1])*.5),V.y=Le.y/Me.height):we<this.modelRatio&&(Me.width=I.shape[1]*this.modelRatio,Le.x=Math.floor((Me.width-I.shape[2])*.5),V.x=Le.x/Me.width);const Ue=BA(I,[[0,0],[Le.y,Le.y],[Le.x,Le.x],[0,0]],0),Ge=dQ.resizeBilinear(Ue,[this.modelSize.height,this.modelSize.width]),ze=this.model.execute(Ge,"palm"),He=SB(t0(ze,[0,0,1],[1,-1,-1])),Ke=SB(t0(ze,[0,0,0],[1,-1,1])),Ye=Oj(tC(Ke,-100,100));return[this.decodeBoxes(He,[this.anchorsX,this.anchorsY],this.modelSize),Ye]}),le=await re.data(),he=await ae.data();let ue=[];for(let ve=0;ve<he.length;ve++){if(he[ve]<this.scoreThresh)continue;const we=le[ve*18+2]-le[ve*18+0],Me=le[ve*18+3]-le[ve*18+1];we<0||Me<0||ue.push({box:[[le[ve*18+0],le[ve*18+1]],[le[ve*18+2],le[ve*18+3]]],points:[[le[ve*18+4],le[ve*18+5]],[le[ve*18+6],le[ve*18+7]],[le[ve*18+8],le[ve*18+9]],[le[ve*18+10],le[ve*18+11]],[le[ve*18+12],le[ve*18+13]],[le[ve*18+14],le[ve*18+15]],[le[ve*18+16],le[ve*18+17]]],score:he[ve]})}if(re.dispose(),ae.dispose(),ue.length<1)return[];if(ue.length>1){const ve=Sg(ue.map(Ge=>[Ge.box[0][1],Ge.box[0][0],Ge.box[1][1],Ge.box[1][0]])),we=SD(ue.map(Ge=>Ge.score)),Me=await dQ.nonMaxSuppressionAsync(ve,we,this.handsMax,this.iouThresh,this.scoreThresh),Le=await Me.data();Me.dispose();const Ue=[];for(let Ge=0;Ge<Le.length;Ge++)Ue.push(ue[Le[Ge]]);ue=Ue}if(ue.length<1)return[];const pe={width:1-2*V.x,height:1-2*V.y};return ue.map(ve=>({points:ve.points.map(we=>[(we[0]-V.x)/pe.width,(we[1]-V.y)/pe.height]),box:ve.box.map(we=>[(we[0]-V.x)/pe.width,(we[1]-V.y)/pe.height]),score:ve.score}))}decodeBoxes(I,V,re){let ae=SB(t0(I,[0,0],[-1,1])),le=SB(t0(I,[0,1],[-1,1])),he=SB(t0(I,[0,2],[-1,1])),ue=SB(t0(I,[0,3],[-1,1]));ae=OS(OP(ae,re.width),V[0]),le=OS(OP(le,re.height),V[1]),he=OP(he,re.width*2),ue=OP(ue,re.height*2);const pe=Oz(BS(ae,he),[2016,1]),ve=Oz(BS(le,ue),[2016,1]),we=Oz(OS(ae,he),[2016,1]),Me=Oz(OS(le,ue),[2016,1]);let Le=tN([pe,ve,we,Me],1);for(let Ue=0;Ue<7;Ue++){let Ge=SB(t0(I,[0,4+Ue*2],[-1,1])),ze=SB(t0(I,[0,4+Ue*2+1],[-1,1]));Ge=Oz(OS(OP(Ge,re.width),V[0]),[2016,1]),ze=Oz(OS(OP(ze,re.height),V[1]),[2016,1]),Le=tN([Le,Ge,ze],1)}return Le}buildAnchors(I){const V=[8,16,16,16],re=[];let ae=0;for(;ae<4;){let le=0,he=ae;for(;he<V.length&&V[he]===V[ae];)le+=2,he++;const ue=V[ae],pe=Math.ceil(I.height/ue),ve=Math.ceil(I.width/ue);for(let we=0;we<pe;++we)for(let Me=0;Me<ve;++Me)for(let Le=0;Le<le;++Le)re.push({x:(Me+.5)/ve,y:(we+.5)/pe});ae=he}return re}async prepare(){const{width:I,height:V}=this.modelSize,re=BQ([1,V,I,3]),ae=this.model.execute(re,"palm");await ae.data(),re.dispose(),ae.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}var Ax;(Z=>(Z.add=(I,V)=>[I[0]+V[0],I[1]+V[1],I[2]+V[2]],Z.sub=(I,V)=>[I[0]-V[0],I[1]-V[1],I[2]-V[2]],Z.cross=(I,V)=>[I[1]*V[2]-I[2]*V[1],I[2]*V[0]-I[0]*V[2],I[0]*V[1]-I[1]*V[0]],Z.lerp=(I,V,re)=>[I[0]+(V[0]-I[0])*re,I[1]+(V[1]-I[1])*re,I[2]+(V[2]-I[2])*re],Z.scale=(I,V)=>[I[0]*V,I[1]*V,I[2]*V],Z.negate=I=>[-I[0],-I[1],-I[2]],Z.normalize=I=>(0,Z.scale)(I,1/(0,Z.length)(I)),Z.normalizeToLen=(I,V)=>(0,Z.scale)(I,V/(0,Z.length)(I)),Z.dot=(I,V)=>I[0]*V[0]+I[1]*V[1]+I[2]*V[2],Z.lengthSqr=I=>I[0]**2+I[1]**2+I[2]**2,Z.length=I=>Math.sqrt(I[0]**2+I[1]**2+I[2]**2)))(Ax||(Ax={}));class AU{constructor(I,V=!0){this.model=I,this.wrist=V,this.localMaxSize={width:256,height:256},this.circlePoints=[],this.colorWeights=[.5,1,.8],this.colorThresh=.05,this.edgeThresh=.003,this.edgeStop=.01,this.model=I,this.modelSize=I.inputs[0].shape?{width:I.inputs[0].shape[2],height:I.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.buildCircle(31)}process(I,V){const[re,ae]=[I.shape[1],I.shape[2]],{modelSize:le,modelRatio:he,localMaxSize:ue}=this;return V.map(pe=>{const ve=[pe.start[0]*ae,pe.start[1]*re],we=[pe.end[0]*ae,pe.end[1]*re];let[Me,Le]=[we[0]-ve[0],ve[1]-we[1]];const Ue=Math.sqrt(Me**2+Le**2);Me/=Ue,Le/=Ue;const Ge=Math.atan2(Me,Le),ze=[.5*(pe.box[0][0]+pe.box[1][0])*ae,.5*(pe.box[0][1]+pe.box[1][1])*re];let He=.5*(pe.box[1][0]-pe.box[0][0])*ae,Ke=.5*(pe.box[1][1]-pe.box[0][1])*re;const Ye=He/Ke/he;Ye>1?He*=Ye:Ke/=Ye;const $e=[ze[1]-Ke,ze[0]-He,ze[1]+Ke,ze[0]+He],je=JY(()=>this.rotatedRect(I,$e,Ge,!1,le)),rt=["Identity_2:0","Identity_1:0","Identity:0","Identity_3:0"],[at,Rt,lt,kt]=this.model.execute(je,rt),qt=at.dataSync(),Kt=kt.dataSync(),_i=Rt.dataSync()[0],ci=2*lt.dataSync()[0]-1;let li=[];for(let hi=0;hi<21;hi++)li.push([qt[3*hi+0]/le.width,qt[3*hi+1]/le.height,qt[3*hi+2]/le.width/.4]);const qi=[li[0][0],li[0][1]];let Ki=qi[0],hs=qi[1];Ki=(Ki-.5)*2*He,hs=(hs-.5)*2*Ke,qi[0]=Ki*Le-hs*Me+ze[0],qi[1]=Ki*Me+hs*Le+ze[1];const Yi=[qi[1]-Ke,qi[0]-He,qi[1]+Ke,qi[0]+He],ns=this.wrist?JY(()=>this.rotatedRect(I,Yi,Ge,!0,ue)):void 0;let Gs=[],Xs=[];const $i=ns?JY(()=>{const hi=SB(ns,[0]),Ri=iX(hi,[[.299,-.14713,.615],[.587,-.28886,-.51499],[.114,.436,-.10001]]),Wi=[[[[-.25],[-.25],[-.25]],[[0],[0],[0]],[[.25],[.25],[.25]]],[[[-.5],[-.5],[-.5]],[[0],[0],[0]],[[.5],[.5],[.5]]],[[[-.25],[-.25],[-.25]],[[0],[0],[0]],[[.25],[.25],[.25]]]],us=[[[[-.25],[-.25],[-.25]],[[-.5],[-.5],[-.5]],[[-.25],[-.25],[-.25]]],[[[0],[0],[0]],[[0],[0],[0]],[[0],[0],[0]]],[[[.25],[.25],[.25]],[[.5],[.5],[.5]],[[.25],[.25],[.25]]]],Ks=tg(Ri,Wi,1,"same"),ur=tg(Ri,us,1,"same"),js=tG(tx(Ks),2,!0),sr=tG(tx(ur),2,!0),cr=tG(OD(Ks,ur),2,!0),ln=OS(js,sr),kr=tk(OS(tx(BS(js,sr)),OD(tx(cr),4))),$r=OD(OS(ln,kr),.5);let Rn=tf([BS($r,sr),cr],2);Rn=OP(Rn,tj(Rn,2,!0));let Ln=kr;if(this.backend&&this.localMaxProg){const hn=this.backend.compileAndRun(this.localMaxProg,[Ln,Rn]);Ln=Ju().makeTensorFromTensorInfo(hn)}const zn=OD(OU(Ri,4,4,"valid"),this.colorWeights),ra=zn.shape,aa=[ra[0]/2,ra[1]/2],ps=Oz(zn,[ra[0],ra[1],1,3]),l0=Sf(zn,[aa[0]-3,aa[1]-4,0],[7,9,3]),Ro=tl(tj(BS(ps,Oz(l0,[-1,3])),3,!1),2,!0),rx=Sf(zn,[aa[0]-4,8,0],[2,8,3]),Ma=Sf(zn,[aa[0]-4,ra[1]-16,0],[2,8,3]),pn=OM([Oz(rx,[-1,3]),Oz(Ma,[-1,3])],0),jr=tl(tj(BS(ps,pn),3,!1),2,!0),uo=BR(BP(Bf(Ro,jr),Bf(Ro,[this.colorThresh])),9,"max","same");return{yuv:Ri,rgb:hi,edgeVal:Ln,edgeXY:Rn,fg:uo}}):void 0,xs=$i?JY(()=>{const hi=BD($i.edgeVal,4,4,"valid");let Ri=OU($i.edgeXY,4,4,"valid");Ri=OP(Ri,tj(Ri,2,!0));const Wi=hi.dataSync(),us=Ri.dataSync(),Ks=$i.fg.dataSync(),ur=this.circlePoints.map($r=>this.evaluateLine([64/2,64/2],$r,Wi,us,Ks));let js=0,sr=0,cr=-1;for(let $r=0;$r<ur.length;$r++){const Rn=ur[$r].strengthL;for(let Ln=$r;Ln<$r+12&&Ln<ur.length;Ln++){const zn=Rn+ur[Ln].strengthR;zn>=cr&&(cr=zn,js=$r,sr=Ln)}}Gs.push([...this.circlePoints[Math.round(.5*(js+sr))]]);const ln=ur[js].anchorsL.map($r=>[$r[0],$r[1]]),kr=ur[sr].anchorsR.map($r=>[$r[0],$r[1]]);Gs.push(...ln),Gs.push(...kr),Xs.push(this.fitLine(ln)),Xs.push(this.fitLine(kr))}):void 0;return je.dispose(),at.dispose(),kt.dispose(),Rt.dispose(),lt.dispose(),ns?.dispose(),$i?.yuv.dispose(),$i?.rgb.dispose(),$i?.edgeVal.dispose(),$i?.edgeXY.dispose(),{points:li,metricData:Kt,score:_i,handedness:ci,radiusX:He,radiusY:Ke,angle:Ge,anchors:Gs,lines:Xs,center:ze,wristCenter:qi,wristDebug:xs}}).map((pe,ve)=>{const{points:we,metricData:Me,score:Le,handedness:Ue,radiusX:Ge,radiusY:ze,angle:He,anchors:Ke,lines:Ye,center:$e,wristCenter:je,wristDebug:rt}=pe,at=we.map((Kt,_i)=>({pixel:Kt,metric:[Me[3*_i+0],Me[3*_i+1],Me[3*_i+2]]}));at.forEach(Kt=>{Kt.pixel[0]=(Kt.pixel[0]-.5)*2*Ge,Kt.pixel[1]=(Kt.pixel[1]-.5)*2*ze,Kt.pixel[2]*=2*Ge});const Rt=Math.sin(He),lt=Math.cos(He);at.forEach(Kt=>{const _i=Kt.pixel[0],ci=Kt.pixel[1];Kt.pixel[0]=(_i*lt-ci*Rt+$e[0])/ae,Kt.pixel[1]=(_i*Rt+ci*lt+$e[1])/re,Kt.pixel[2]/=ae;const li=Kt.metric[0],qi=Kt.metric[1];Kt.metric[0]=li*lt-qi*Rt,Kt.metric[1]=li*Rt+qi*lt});const kt=this.circlePoints.map(Kt=>[Kt[0]/64,Kt[1]/64]);Ke.forEach(Kt=>{Kt[0]=(Kt[0]+.5)/64,Kt[1]=(Kt[1]+.5)/64}),Ke.forEach(Kt=>{const _i=(Kt[0]-.5)*2*Ge,ci=(Kt[1]-.5)*2*ze;Kt[0]=(_i*lt-ci*Rt+je[0])/ae,Kt[1]=(_i*Rt+ci*lt+je[1])/re}),Ye.forEach(Kt=>{Kt.point[0]=(Kt.point[0]+.5)/64,Kt.point[1]=(Kt.point[1]+.5)/64});const qt=this.normalizeLines(Ye[0],Ye[1],[.5,.5]);return qt.forEach(Kt=>{const _i=(Kt.point[0]-.5)*2*Ge,ci=(Kt.point[1]-.5)*2*ze;Kt.point[0]=(_i*lt-ci*Rt+je[0])/ae,Kt.point[1]=(_i*Rt+ci*lt+je[1])/re;const li=Kt.vector[0],qi=Kt.vector[1];Kt.vector[0]=li*lt-qi*Rt,Kt.vector[1]=li*Rt+qi*lt}),{keypoints:at,score:Le,handedness:Ue,wrist:{lines:qt},debug:{box:V[ve],anchors:Ke,circle:kt,tensors:rt}}})}evaluateLine(I,V,re,ae,le){const he=[V[0]-I[0],V[1]-I[1]],ue=this.buildLine(he[0],he[1]).slice(0,24),pe=ue.map($e=>[$e[1],-$e[0]]),ve=Math.sqrt(he[0]**2+he[1]**2);he[0]/=ve,he[1]/=ve;const we=[he[1],-he[0]];ue.forEach($e=>{$e[0]+=I[0],$e[1]+=I[1]});let Me=[],Le=[];const Ue=new Array(16).fill(0),Ge=new Array(16).fill(0);for(let $e=6;$e<ue.length;$e++){const je=ue[$e];let rt=2,at=[0,0],Rt=-1,lt=-1,kt=[0,0];for(rt=2;rt<16;rt++){at=[je[0]+pe[rt][0],je[1]+pe[rt][1]];const qt=at[1]*64+at[0];if(le[qt]<.5)break;if(re[qt]<this.edgeThresh)continue;const Kt=ae[2*qt],_i=ae[2*qt+1];if(!(Math.abs(Kt*we[0]+_i*we[1])<.95)){if(re[qt]>this.edgeStop){lt=rt,kt=at,Rt=re[qt];break}re[qt]>Rt&&(lt=rt,kt=at,Rt=re[qt])}}for(lt<16&&lt>3&&(Me.push([...kt,lt]),Ue[lt]++),rt=2,Rt=-1,lt=-1,kt=[0,0],rt=2;rt<16;rt++){at=[je[0]-pe[rt][0],je[1]-pe[rt][1]];const qt=at[1]*64+at[0];if(le[qt]<.5)break;if(re[qt]<this.edgeThresh)continue;const Kt=ae[2*qt],_i=ae[2*qt+1];if(!(Math.abs(Kt*we[0]+_i*we[1])<.95)){if(re[qt]>this.edgeStop){lt=rt,kt=at,Rt=re[qt];break}re[qt]>Rt&&(lt=rt,kt=at,Rt=re[qt])}}lt<16&&lt>3&&(Le.push([...kt,lt]),Ge[lt]++)}let ze=0,He=0,Ke=0,Ye=0;for(let $e=1;$e<16;$e++){const je=.5*Ue[$e-1]+Ue[$e]+.5*Ue[$e+1],rt=.5*Ge[$e-1]+Ge[$e]+.5*Ge[$e+1];je>ze&&(ze=je,Ke=$e),rt>He&&(He=rt,Ye=$e)}return Me=Me.filter($e=>Math.abs($e[2]-Ke)<=1),Le=Le.filter($e=>Math.abs($e[2]-Ye)<=1),{anchorsL:Me,anchorsR:Le,strengthL:ze,strengthR:He}}fitLine(I){const V=I.reduce((ue,pe)=>[ue[0]+pe[0],ue[1]+pe[1]],[0,0]);V[0]/=I.length,V[1]/=I.length;const re=I.reduce((ue,pe)=>{const ve=[pe[0]-V[0],pe[1]-V[1]];return[ue[0]+ve[0]**2-ve[1]**2,ue[1]+2*ve[0]*ve[1]]},[0,0]),ae=Math.sqrt(re[0]**2+re[1]**2),le=[Math.sqrt(.5*(ae+re[0])),Math.sqrt(.5*(ae-re[0]))],he=Math.sqrt(le[0]**2+le[1]**2);return le[0]/=he,le[1]/=he,re[1]<0&&(le[0]=-le[0]),{point:V,vector:le}}normalizeLines(I,V,re){const ae=at=>[at[0]/at[2],at[1]/at[2],1],le=[...I.point,1],he=[...V.point,1],ue=[...I.vector,0],pe=[...V.vector,0],ve=Ax.lerp(ue,pe,.5),we=[ve[1],-ve[0],0],Me=Ax.cross(le,Ax.add(le,ue)),Le=Ax.cross(he,Ax.add(he,pe)),Ue=Ax.cross(le,Ax.add(le,we)),Ge=ae(Ax.cross(Ue,Le)),ze=Ax.lerp(le,Ge,.5),He=[...re,1],Ke=Ax.add(ze,Ax.scale(ve,Ax.dot(ve,Ax.sub(He,ze)))),Ye=Ax.add(Ke,Ax.scale(ve,.15)),$e=Ax.cross(Ye,Ax.add(Ye,we)),je=ae(Ax.cross(Me,$e)),rt=ae(Ax.cross(Le,$e));return[{point:[je[0],je[1]],vector:I.vector},{point:[rt[0],rt[1]],vector:V.vector},{point:Ye,vector:ve}]}buildLine(I,V){let[re,ae]=[Math.abs(I),Math.abs(V)],le=!1;re<ae&&([re,ae]=[ae,re],le=!0);let he=[],ue=0,pe=0,ve=2*ae,we=ve-re;for(;ue<re-2;ue++)he.push([ue,pe]),we+=ve,we>=0&&(pe++,we-=2*re);return le&&(he=he.map(Me=>[Me[1],Me[0]])),I<0&&he.forEach(Me=>{Me[0]*=-1}),V<0&&he.forEach(Me=>{Me[1]*=-1}),he}buildCircle(I){let V=I,re=0,ae=3-2*I;for(;re<V;)this.circlePoints.push([V,re]),re++,ae>0?(V--,ae=ae+4*(re-V)+10):ae=ae+4*re+6;re--;for(let le=re;le>=0;le--){const he=this.circlePoints[le];this.circlePoints.push([he[1],he[0]])}for(let le=2*re;le>=0;le--){const he=this.circlePoints[le];this.circlePoints.push([-he[0],he[1]])}this.circlePoints.forEach(le=>{le[0]+=32,le[1]+=32})}rotatedRect(I,V,re,ae,le){const[he,ue]=[V[2]-V[0],V[3]-V[1]],[pe,ve]=[(V[2]+V[0])*.5,(V[3]+V[1])*.5],[we,Me]=[he/le.height,ue/le.width],[Le,Ue]=[Math.cos(re),Math.sin(re)],Ge=[Le*Me,-Ue*we,(-Le*ue+Ue*he)*.5+ve,Ue*Me,Le*we,(-Ue*ue-Le*he)*.5+pe,0,0];return dQ.transform(I,[Ge],"bilinear",ae?"reflect":"constant",0,[le.height,le.width])}async prepare(){const{width:I,height:V}=this.modelSize,re=BQ([1,V,I,3]),ae=this.model.execute(re);if(await Promise.all(ae.map(async le=>{await le.data(),le.dispose()})),re.dispose(),Jr()==="webgl"){const{width:le,height:he}=this.localMaxSize;this.backend=f1(),this.localMaxProg={variableNames:["val","dir"],outputShape:[he,le,1],userCode:`
                    void main() {
                        ivec3 c = getOutputCoords();
                        float dx = getDir(c[0], c[1], 0);
                        float dy = getDir(c[0], c[1], 1);
                        vec2 d = vec2(dx, dy) / max(abs(dx), abs(dy));
                        vec2 cf = vec2(c[1], c[0]);
                        float v0 = getVal(round(cf.y - 2.0 * d.y),
                                          round(cf.x - 2.0 * d.x), 0);
                        float v1 = getVal(round(cf.y - d.y),
                                          round(cf.x - d.x), 0);
                        float v2 = getVal(round(cf.y), round(cf.x), 0);
                        float v3 = getVal(round(cf.x + d.y),
                                          round(cf.x + d.x), 0);
                        float v4 = getVal(round(cf.y + 2.0 * d.y),
                                          round(cf.x + 2.0 * d.x), 0);
                        float vmax = max(max(v0, v1), max(v3, v4));
                        setOutput(v2 >= vmax ? v2 : 0.0);
                    }
            `};const ue=BQ([he,le,1]),pe=this.backend.compileAndRun(this.localMaxProg,[ue,ue]),ve=Ju().makeTensorFromTensorInfo(pe);ue.dispose(),ve.dispose()}}async dispose(){var I;(I=this.model)==null||I.dispose()}}class AG{constructor(){this.freq=30,this.pixelParams={minCutOff:2,minCutOffD:4,beta:50},this.metricParams={minCutOff:.1,minCutOffD:1,beta:20},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(I,V,re=1){if(this.time>=V)return I;if(this.time!==0&&(this.freq=1/(V-this.time)),this.time=V,!this.raw||!this.smooth||!this.der)return this.raw=this.clonePose(I),this.smooth=this.clonePose(I),this.der={keypoints:I.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0]})),score:0,handedness:.5,wrist:{lines:I.wrist.lines.map(()=>({point:[0,0],vector:[0,0]}))}},this.clonePose(this.smooth);const ae=[...this.smooth.keypoints[0].pixel];this.filterKeypoints(I.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,re);const le=[...this.smooth.keypoints[0].pixel],{raw:he,smooth:ue,der:pe}=this;for(let we=0;we<I.wrist.lines.length;we++){const Me=I.wrist.lines[we],Le=he.wrist.lines[we],Ue=pe.wrist.lines[we],Ge=ue.wrist.lines[we];if(isNaN(Ge.point[0])||isNaN(Ge.point[0])||isNaN(Ge.vector[0])||isNaN(Ge.vector[0])){Ge.point=[...Me.point],Ge.vector=[...Me.vector];continue}if(isNaN(Me.point[0])||isNaN(Me.point[0])||isNaN(Me.vector[0])||isNaN(Me.vector[0])){Ge.point[0]+=le[0]-ae[0],Ge.point[1]+=le[1]-ae[1];continue}this.filterCoord2D(Me.point,Le.point,Ue.point,Ge.point,re,{minCutOff:.5,minCutOffD:4,beta:75}),this.filterCoord2D(Me.vector,Le.vector,Ue.vector,Ge.vector,re,{minCutOff:.1,minCutOffD:.5,beta:10});const ze=Math.sqrt(Ge.vector[0]**2+Ge.vector[1]**2);Ge.vector[0]/=ze,Ge.vector[1]/=ze}const ve=this.alpha(this.scoreCutOff);return this.smooth.score=this.smooth.score+ve*(I.score-this.smooth.score),this.smooth.debug=I.debug&&{box:{box:[[...I.debug.box.box[0]],[...I.debug.box.box[1]]],points:I.debug.box.points.map(we=>[...we]),start:[...I.debug.box.start],end:[...I.debug.box.end]},circle:I.debug.circle,anchors:I.debug.anchors,tensors:I.debug.tensors},this.clonePose(this.smooth)}filterKeypoints(I,V,re,ae,le){for(let he=0;he<I.length;he++)this.filterCoord3D(I[he].pixel,V[he].pixel,re[he].pixel,ae[he].pixel,le,this.pixelParams),this.filterCoord3D(I[he].metric,V[he].metric,re[he].metric,ae[he].metric,le,this.metricParams)}filterCoord3D(I,V,re,ae,le,he){const ue=[(I[0]-ae[0])*le*this.freq,(I[1]-ae[1])*le*this.freq,(I[2]-ae[2])*le*this.freq],pe=this.alpha(he.minCutOffD);re[0]=re[0]+pe*(ue[0]-re[0]),re[1]=re[1]+pe*(ue[1]-re[1]),re[2]=re[2]+pe*(ue[2]-re[2]);const ve=[this.alpha(he.minCutOff+he.beta*Math.abs(re[0])),this.alpha(he.minCutOff+he.beta*Math.abs(re[1])),this.alpha(he.minCutOff+he.beta*Math.abs(re[2]))];ae[0]=ae[0]+ve[0]*(I[0]-ae[0]),ae[1]=ae[1]+ve[1]*(I[1]-ae[1]),ae[2]=ae[2]+ve[2]*(I[2]-ae[2]),V[0]=I[0],V[1]=I[1],V[2]=I[2]}filterCoord2D(I,V,re,ae,le,he){const ue=[(I[0]-ae[0])*le*this.freq,(I[1]-ae[1])*le*this.freq],pe=this.alpha(he.minCutOffD);re[0]=re[0]+pe*(ue[0]-re[0]),re[1]=re[1]+pe*(ue[1]-re[1]);const ve=[this.alpha(he.minCutOff+he.beta*Math.abs(re[0])),this.alpha(he.minCutOff+he.beta*Math.abs(re[1]))];ae[0]=ae[0]+ve[0]*(I[0]-ae[0]),ae[1]=ae[1]+ve[1]*(I[1]-ae[1]),V[0]=I[0],V[1]=I[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(I){return 1/(1+this.freq/(2*Math.PI*I))}clonePose(I){return{keypoints:I.keypoints.map(V=>({pixel:[...V.pixel],metric:[...V.metric]})),score:I.score,handedness:I.handedness,wrist:{lines:I.wrist.lines.map(V=>({point:[...V.point],vector:[...V.vector]}))},debug:I.debug&&{box:{box:[[...I.debug.box.box[0]],[...I.debug.box.box[1]]],points:I.debug.box.points.map(V=>[...V]),start:[...I.debug.box.start],end:[...I.debug.box.end]},circle:I.debug.circle.map(V=>[...V]),anchors:I.debug.anchors.map(V=>[...V]),tensors:I.debug.tensors}}}}class Au{constructor(){this.handTracks=[],this.handFilters=[],this.angle=.05555555555555555*Math.PI,this.ratio=1.7777777777777777,this.near=1,this.handScore=.55}async process(I,V){var re,ae;const le=JY(()=>{const Ge=ip(iU(I,3),"float32"),ze=OP(Ge,255);return B0(ze,0)}),[he,ue]=[le.shape[1],le.shape[2]],pe=(Ge,ze)=>{const He=[Ge[0]*ue,Ge[1]*he],Ke=[ze[0]*ue,ze[1]*he];let[Ye,$e]=[Ke[0]-He[0],He[1]-Ke[1]];const je=Math.sqrt(Ye**2+$e**2);return Ye/=je,$e/=je,[Ye,$e]},ve=(Ge,ze,He,Ke,Ye,$e)=>{const je=[.5*(Ge[0][0]+Ge[1][0])*ue,.5*(Ge[0][1]+Ge[1][1])*he],rt={width:(Ge[1][0]-Ge[0][0])*ue,height:(Ge[1][1]-Ge[0][1])*he},[at,Rt]=pe(ze,He),lt=[Ye*rt.width,$e*rt.height];je[0]+=lt[0]*Rt-lt[1]*at,je[1]+=lt[0]*at+lt[1]*Rt,je[0]/=ue,je[1]/=he;const kt=.5*Ke*Math.max(rt.width,rt.height);let qt=kt/ue,Kt=kt/he;return[[je[0]-qt,je[1]-Kt],[je[0]+qt,je[1]+Kt]]};if(this.handTracks.length===0){const Ge=await((re=this.palmDetector)==null?void 0:re.process(le))||[];this.handTracks=Ge.map(ze=>({box:ve(ze.box,ze.points[0],ze.points[2],2.6,0,-.5),points:ze.points,start:ze.points[0],end:ze.points[2]})),this.handTracks.forEach(()=>this.handFilters.push(new AG))}const we=this.handTracks.length>0?((ae=this.handDetector)==null?void 0:ae.process(le,this.handTracks))||[]:[];we.forEach((Ge,ze)=>{if(V===void 0)return;const He=ue/he,Ke=this.handTracks[ze].box[1][0]-this.handTracks[ze].box[0][0],Ye=(this.handTracks[ze].box[1][1]-this.handTracks[ze].box[0][1])/He,$e=Math.sqrt(Ke*Ke+Ye*Ye)*(1+He);we[ze]=this.handFilters[ze].filter(Ge,V,1/$e)}),le.dispose();const Me=[],Le=[],Ue=[];for(let Ge=0;Ge<we.length;Ge++){const ze=we[Ge],{keypoints:He,score:Ke}=ze;if(Ke<this.handScore)continue;const Ye=[He[0].pixel[0],He[0].pixel[1]],$e=[He[5].pixel[0],He[5].pixel[1]],je=[He[10].pixel[0],He[10].pixel[1]],rt=[He[14].pixel[0],He[14].pixel[1]],at=[.25*$e[0]+.5*je[0]+.25*rt[0],.25*$e[1]+.5*je[1]+.25*rt[1]],[Rt,lt]=pe(Ye,at),[kt,qt]=[-Rt,lt],Kt=[...He.slice(0,4),...He.slice(5,7),...He.slice(9,11),...He.slice(13,15),...He.slice(17,19)].map(Gs=>[Gs.pixel[0],Gs.pixel[1]]),_i=[[10,10],[-10,-10]];for(let Gs=0;Gs<Kt.length;Gs++)_i[0][0]=Math.min(_i[0][0],Kt[Gs][0]),_i[0][1]=Math.min(_i[0][1],Kt[Gs][1]),_i[1][0]=Math.max(_i[1][0],Kt[Gs][0]),_i[1][1]=Math.max(_i[1][1],Kt[Gs][1]);const ci=[(_i[0][0]+_i[1][0])*.5,(_i[0][1]+_i[1][1])*.5],li=[[10,10],[-10,-10]];for(let Gs=0;Gs<Kt.length;Gs++){const Xs=[(Kt[Gs][0]-ci[0])*ue,(Kt[Gs][1]-ci[1])*he],$i=[qt*Xs[0]-kt*Xs[1],kt*Xs[0]+qt*Xs[1]];li[0][0]=Math.min(li[0][0],$i[0]),li[0][1]=Math.min(li[0][1],$i[1]),li[1][0]=Math.max(li[1][0],$i[0]),li[1][1]=Math.max(li[1][1],$i[1])}const qi=[(li[0][0]+li[1][0])*.5,(li[0][1]+li[1][1])*.5],Ki=[(lt*qi[0]-Rt*qi[1])/ue+ci[0],(Rt*qi[0]+lt*qi[1])/he+ci[1]],hs=.5*(li[1][0]-li[0][0])/ue,Yi=.5*(li[1][1]-li[0][1])/he,ns=ve([[Ki[0]-hs,ci[1]-Yi],[Ki[0]+hs,ci[1]+Yi]],Ye,at,2,0,-.1);VU(ns,this.handTracks[Ge].box)<.5||(this.align(we[Ge].keypoints),Me.push({box:ns,start:Ye,end:at,points:[]}),Le.push(this.handFilters[Ge]),Ue.push(we[Ge]))}return this.handTracks=Me,this.handFilters=Le,Ue}align(I){const V=2*Math.tan(.5*this.angle),re=this.ratio*V,ae=I.map(ve=>{const we=[(ve.pixel[0]-.5)*re,(ve.pixel[1]-.5)*V],Me=[...ve.metric];return{pixel:we,world:Me}}),le=[];ae.forEach(ve=>{le.push([0,1,-ve.pixel[1],ve.world[1]-ve.pixel[1]*ve.world[2]],[-1,0,ve.pixel[0],ve.pixel[0]*ve.world[2]-ve.world[0]])});const{V:he}=AS.svd(le),ue=he[3][3],pe=[he[0][3]/ue,he[1][3]/ue,he[2][3]/ue];I.forEach(ve=>{ve.metric[0]+=pe[0],ve.metric[1]+=pe[1],ve.metric[2]+=pe[2]}),I.forEach(ve=>{const we=[(ve.pixel[0]-.5)*re,(ve.pixel[1]-.5)*V],Me=ve.metric;Me[0]=we[0]*Me[2],Me[1]=we[1]*Me[2],ve.metric[1]=-ve.metric[1],ve.metric[2]=-ve.metric[2]})}setCamera(I,V,re=1){this.angle=I,this.ratio=V,this.near=re}async init(I,V="./",re=!1,ae="webgl"){const le=await VM(I,V,re),he=new le.ParseLoader(V);if(re||await he.remove("hand.wasm"),!await he.loadDict(["hand.wasm"])||!await he.load("hand.wasm")||!he.parse())return;Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),JG(),await Jj(ae);const ue={weightUrlConverter:async we=>we,fetchFunc:async we=>{const Me=new Blob([he.file(we)]);return fetch(URL.createObjectURL(Me))}},pe=await Ph("palmmodel.def",ue),ve=await Ph("handmodel.def",ue);this.palmDetector=new Az(pe),this.handDetector=new AU(ve)}reset(){this.handTracks=[],this.handFilters=[]}async prepare(){var I,V;Cd().set("ENGINE_COMPILE_ONLY",!0),await((I=this.palmDetector)==null?void 0:I.prepare()),await((V=this.handDetector)==null?void 0:V.prepare());const re=f1();re instanceof ea&&(re.checkCompileCompletion(),re.getUniformLocations()),Cd().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var I;this.reset(),(I=this.palmDetector)==null||I.dispose()}}class AY{async process(I,V){var re;const ae=JY(()=>{const he=ip(iU(I,3),"float32"),ue=OD(he,1/255);return B0(ue,0)}),le=(re=this.segmenter)==null?void 0:re.process(ae,[[0,0],[1,1]]);return ae.dispose(),le?[le]:[]}async init(I,V="./",re=!1,ae=!1,le=!1,he="webgl"){const ue=await VM(I,V,re),pe=new ue.ParseLoader(V),[ve,we]=le?["masksm.wasm","maskmodelsm.def"]:["mask.wasm","maskmodel.def"];if(re||await pe.remove(ve),!await pe.loadDict([ve])||!await pe.load(ve)||!pe.parse())return;Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),JG(),await Jj(he);const Me=await Ph(we,{weightUrlConverter:async Le=>Le,fetchFunc:async Le=>{const Ue=new Blob([pe.file(Le)]);return fetch(URL.createObjectURL(Ue))}});this.segmenter=new AT(Me,ae)}reset(){var I;(I=this.segmenter)==null||I.reset()}async prepare(){var I;Cd().set("ENGINE_COMPILE_ONLY",!0),await((I=this.segmenter)==null?void 0:I.prepare());const V=f1();V instanceof ea&&(V.checkCompileCompletion(),V.getUniformLocations()),Cd().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var I;(I=this.segmenter)==null||I.dispose(),delete this.segmenter}}const AM={lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyebrowUpper:[156,70,63,105,66,107,55],rightEyebrowLower:[124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyebrowUpper:[383,300,293,334,296,336,285],leftEyebrowLower:[353,276,283,282,295],leftEyeIris:[468,469,470,471,472]},Ah=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255],Aj=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]],Ar=[[0,-.03406405,.05979506],[0,-.01126867,.07475604],[0,-.02089025,.06058267],[-.00463928,.00955356,.06633583],[0,-.00463172,.0758658],[0,.00365668,.0724287],[0,.02473254,.05788627],[-.04253081,.02577645,.03279702],[0,.04019041,.05284765],[0,.04885978,.05385259],[0,.08261777,.04481537],[0,-.03706812,.05864923],[0,-.03918302,.05569429],[0,-.03994437,.05219482],[0,-.04542401,.05404753],[0,-.04745578,.05529456],[0,-.05019568,.05601447],[0,-.05365124,.0553544],[0,-.06149625,.05071371],[0,-.01501096,.07112196],[-.00416106,-.0146645,.06447657],[-.0708796,.05434801,99621e-8],[-.02628638,.02035898,.03848121],[-.03198363,.01985814,.03796952],[-.03775151,.02039402,.03646194],[-.04465819,.02422949,.03155169],[-.02164288,.02189867,.03851822],[-.03208229,.03223925,.04115823],[-.02673803,.03205336,.04092203],[-.03745193,.03165285,.03972409],[-.04161018,.03059068,.03719554],[-.05062005,.01934418,.02776093],[-.02266659,-.07425769,.04389811],[-.04445859,.0266399,.03173422],[-.0721453,.02263009,7315e-7],[-.05799793,.02349546,.02204059],[-.02844939,-.00720869,.0443313],[-.00711452,-.03329356,.05877044],[-.00606033,-.03924563,.05444922],[-.01431615,-.03500954,.05496188],[-.0191491,-.03803147,.05028929],[-.01131043,-.03973938,.05189647],[-.01563548,-.04082763,.04842262],[-.02650112,-.05003649,.04188482],[-.00427049,-.01094135,.07360528],[-.00496396,-.0047566,.07440358],[-.05253307,.03881582,.0336316],[-.01718698,.00974608,.04558359],[-.01608635,-.00942517,.05814193],[-.01651267,-.00610869,.05581319],[-.04765501,-.00701555,.03534632],[-.00478306,.00295764,.07101013],[-.03734964,.04508229,.04550455],[-.04588603,.04302036,.04048485],[-.06279331,.06615427,.01425851],[-.01220941,.04142164,.05106035],[-.02193489,.03100317,.04000575],[-.03102642,-.04352985,.04095904],[-.06719682,-.04788644,-.01745402],[-.01193824,-.01306796,.05737746],[-.00729766,-.01593713,.05833207],[-.02456206,-.04342622,.04283883],[-.02204823,-.04304509,.04162498],[-.04985894,.0480246,.03751978],[-.01592294,-.0125771,.05456949],[-.02644548,.04524653,.0492156],[-.02760292,.0510097,.05015991],[-.03523964,.08005974,.03729165],[-.05599763,.05715469,.0272426],[-.03063932,.06566143,.04529982],[-.05720968,.04254583,.02830853],[-.06374393,.04785589,.01591692],[-.00672728,-.03688017,.05737803],[-.0126256,-.03787692,.05417778],[-.01732553,-.03952768,.05000578],[-.01043625,-.01464974,.05662455],[-.02321234,-.0432907,.04258155],[-.02056846,-.04477672,.04520882],[-.02153084,-.04276323,.04038092],[-.00946874,-.0103525,.06512274],[-.01469132,-.04036351,.04604907],[-.0102434,-.03989852,.04926693],[-.00533422,-.03993222,.05138201],[-.0076972,-.06095395,.04985882],[-.00699606,-.05291851,.05448303],[-.00669687,-.0494977,.05509611],[-.00630947,-.04695102,.0544937],[-.00583218,-.04517983,.05339869],[-.0153717,-.04423207,.04745469],[-.016156,-.04475943,.04813631],[-.01729053,-.0461868,.04854462],[-.01838624,-.04828747,.04823736],[-.0236825,-.03106238,.04868095],[-.07542244,-.01049282,-.02431321],[0,-.01724004,.0660139],[-.01826614,-.04399532,.0439902],[-.01929558,-.04411831,.04497051],[-.00597442,-.02013687,.05866456],[-.01405627,-.01714197,.05241086],[-.00662449,-.01819322,.05863759],[-.02342339,.00572221,.04294303],[-.03327324,.00104862,.0411386],[-.01726175,-.00919166,.05273354],[-.05133204,.07485601,.02660443],[-.04538641,.06319907,.03683425],[-.03986562,.05109486,.04466315],[-.02169681,-.05440434,.04455873],[-.01395634,.05011962,.05316032],[-.016195,.06599216,.04921107],[-.01891399,.08236376,.04274999],[-.04195832,.02235205,.03375099],[-.05733342,.01411738,.02431726],[-.01859888,.02355756,.03843182],[-.04988612,.03074653,.03083858],[-.01303263,.01416452,.04831091],[-.01305757,-.0067278,.06415959],[-.0646517,.00937119,.01689873],[-.05258659,.00945811,.02974312],[-.04432338,.00722095,.03522615],[-.03300681,.0086164,.03872784],[-.02430178,.01131491,.04039035],[-.01820731,.01467953,.04224124],[-.00563221,.02307693,.05566789],[-.06338145,-.00529279,.01881175],[-.05587698,.03208071,.0268784],[-.00242624,-.01462858,.07071491],[-.01611251,.00339325,.0489542],[-.07743095,.02364999,-.02005167],[-.01391142,.01851047,.04448999],[-.01785794,-.00978285,.0485047],[-.04670959,.0266446,.03084075],[-.0133397,-.00283762,.06097047],[-.07270896,-.02890916,-.02252455],[-.01856432,.02585245,.03757904],[-.00923388,73075e-8,.06671944],[-.05000589,-.06135128,.01892522],[-.05085276,-.0717859,.0071471],[-.07159291,-.0081182,-72044e-8],[-.05843051,-.05248023,.0092409],[-.06847258,.03662916,.00724696],[-.02412942,-.08258854,.04119211],[-.00179909,-.01689865,.06573301],[-.02103655,-.00163946,.04566119],[-.06407571,.02236021,.01560843],[-.03670075,.02360153,.0363523],[-.03177186,.02294264,.03775705],[-.02196121,-.04598323,.04479785],[-.06234883,-.0194443,.01663542],[-.01292924,-.09295921,.04094062],[-.03210651,-.08533278,.02802],[-.04068926,-.07993109,.01925118],[0,.06545389,.05027312],[0,-.09403378,.0426449],[-.02724032,.02315802,.03777151],[-.0228846,.0239889,.03697603],[-.01998311,.02496546,.03689148],[-.0613004,.03399261,.02038516],[-.0228846,.02886503,.03775031],[-.02724032,.02961809,.03871767],[-.03177186,.02964135,.03876973],[-.03670075,.02927713,.03724325],[-.04018389,.02857356,.03482983],[-.07555811,.04106811,-.00991916],[-.04018389,.02483694,.03440898],[0,-.02521946,.05932265],[-.01776217,-.02683947,.05213116],[-.01222237,-.01182445,.05952464],[-.00731493,-.02536684,.05815343],[0,.03271026,.05236015],[-.04135272,-.06996639,.02671969],[-.03311811,-.07660816,.03382962],[-.01313701,-.08639995,.04702454],[-.05940524,-.06223629,-.00631469],[-.01998311,.02743837,.0374403],[-.00901447,.01236991,.05754256],[0,-.08765243,.04891439],[-.02308977,-.08974197,.03609069],[-.06954154,-.02439843,-.00131163],[-.01098819,-.04458788,.05120726],[-.01181124,-.04579997,.05189563],[-.01255818,-.04787901,.0523705],[-.01325085,-.05106508,.05205009],[-.01546388,-.05819392,.04757892],[-.01953754,-.04183893,.04431712],[-.02117802,-.04137093,.04555095],[-.02285339,-.04051196,.04582437],[-.0285016,-.03665721,.04484993],[-.05278538,-.02238942,.02861224],[-.00946709,.01907627,.0519678],[-.01314173,.03104912,.04231405],[-.0178,.02859999,.03881555],[-.0184511,-.0409888,.04247263],[-.05436186,-.04030482,.02109851],[-.00766444,.0318213,.04861453],[-.01938616,-.06614411,.04521083],[0,.01059412,.06774605],[-.00516573,.01583571,.06148363],[0,.01728368,.0631675],[-.01246815,.00230296,.05681035],[0,-.07942194,.05181172],[0,-.069915,.05153477],[-.00997827,-.06930922,.04979575],[-.03288807,-.05382515,.03795751],[-.02311631,-.01566238,.04590084],[-.0268025,-.06111567,.04096151],[-.03832928,-.01537327,.04137731],[-.0296186,-.02274216,.04440943],[-.04386901,-.02683286,.03643886],[-.01217295,-.07834466,.04969285],[-.01542374,-.00136843,.05201008],[-.03878377,-.06041764,.03311078],[-.03084037,-.06809843,.03814194],[-.03747321,-.04503546,.03726452],[-.06094129,-.03205992,.01473481],[-.04588995,-.04728726,.0298322],[-.06583231,-.03941269,70267e-8],[-.0349258,-.03195821,.04130198],[-.01255543,.0080234,.05307551],[-.01126122,-.00933603,.06538785],[-.01443109,-.01142775,.05905127],[-.00923043,-.00529043,.07003423],[-.01755386,.03529116,.04327697],[-.02632589,.03713828,.0436463],[-.03388062,.03721975,.04309029],[-.04075766,.03675412,.04076063],[-.0462291,.0347469,.03646322],[-.05171755,.02535752,.02670867],[-.0729733,.00763172,-48769e-8],[-.04706828,.01651,.03109532],[-.04071712,.01476821,.03476944],[-.03269817,.01470658,.03731945],[-.02527572,.0161731,.03865444],[-.01970894,.01858504,.03961782],[-.01579543,.0209794,.04084997],[-.07664182,.00673132,-.02435867],[-.01397041,-.0134014,.05630378],[-.00884838,.00658739,.06233231],[-.00767097,-.00968036,.07077932],[-.00460213,-.01334107,.06787448],[-.00748618,-.01067995,.06798303],[-.01236408,-.01585569,.05480489],[-.00387306,-.01409991,.06957705],[-.00319925,-.01607932,.06508676],[-.01639633,.02556297,.03863737],[-.01255645,.02467143,.042038],[-.01031362,.02382662,.04615849],[-.04253081,.02772296,.03315305],[-.0453,.0291,.03339685],[.00463928,.00955356,.06633583],[.04253081,.02577645,.03279702],[.00416106,-.0146645,.06447657],[.0708796,.05434801,99621e-8],[.02628638,.02035898,.03848121],[.03198363,.01985814,.03796952],[.03775151,.02039402,.03646194],[.04465819,.02422949,.03155169],[.02164288,.02189867,.03851822],[.03208229,.03223925,.04115823],[.02673803,.03205336,.04092203],[.03745193,.03165285,.03972409],[.04161018,.03059068,.03719554],[.05062005,.01934418,.02776093],[.02266659,-.07425769,.04389811],[.04445859,.0266399,.03173422],[.0721453,.02263009,7315e-7],[.05799793,.02349546,.02204059],[.02844939,-.00720869,.0443313],[.00711452,-.03329356,.05877044],[.00606033,-.03924563,.05444922],[.01431615,-.03500954,.05496188],[.0191491,-.03803147,.05028929],[.01131043,-.03973938,.05189647],[.01563548,-.04082763,.04842262],[.02650112,-.05003649,.04188482],[.00427049,-.01094135,.07360528],[.00496396,-.0047566,.07440358],[.05253307,.03881582,.0336316],[.01718698,.00974608,.04558359],[.01608635,-.00942517,.05814193],[.01651267,-.00610869,.05581319],[.04765501,-.00701555,.03534632],[.00478306,.00295764,.07101013],[.03734964,.04508229,.04550455],[.04588603,.04302036,.04048485],[.06279331,.06615427,.01425851],[.01220941,.04142164,.05106035],[.02193489,.03100317,.04000575],[.03102642,-.04352985,.04095904],[.06719682,-.04788644,-.01745402],[.01193824,-.01306796,.05737746],[.00729766,-.01593713,.05833207],[.02456206,-.04342622,.04283883],[.02204823,-.04304509,.04162498],[.04985894,.0480246,.03751978],[.01592294,-.0125771,.05456949],[.02644548,.04524653,.0492156],[.02760292,.0510097,.05015991],[.03523964,.08005974,.03729165],[.05599763,.05715469,.0272426],[.03063932,.06566143,.04529982],[.05720968,.04254583,.02830853],[.06374393,.04785589,.01591692],[.00672728,-.03688017,.05737803],[.0126256,-.03787692,.05417778],[.01732553,-.03952768,.05000578],[.01043625,-.01464974,.05662455],[.02321234,-.0432907,.04258155],[.02056846,-.04477672,.04520882],[.02153084,-.04276323,.04038092],[.00946874,-.0103525,.06512274],[.01469132,-.04036351,.04604907],[.0102434,-.03989852,.04926693],[.00533422,-.03993222,.05138201],[.0076972,-.06095395,.04985882],[.00699606,-.05291851,.05448303],[.00669687,-.0494977,.05509611],[.00630947,-.04695102,.0544937],[.00583218,-.04517983,.05339869],[.0153717,-.04423207,.04745469],[.016156,-.04475943,.04813631],[.01729053,-.0461868,.04854462],[.01838624,-.04828747,.04823736],[.0236825,-.03106238,.04868095],[.07542244,-.01049282,-.02431321],[.01826614,-.04399532,.0439902],[.01929558,-.04411831,.04497051],[.00597442,-.02013687,.05866456],[.01405627,-.01714197,.05241086],[.00662449,-.01819322,.05863759],[.02342339,.00572221,.04294303],[.03327324,.00104862,.0411386],[.01726175,-.00919166,.05273354],[.05133204,.07485601,.02660443],[.04538641,.06319907,.03683425],[.03986562,.05109486,.04466315],[.02169681,-.05440434,.04455873],[.01395634,.05011962,.05316032],[.016195,.06599216,.04921107],[.01891399,.08236376,.04274999],[.04195832,.02235205,.03375099],[.05733342,.01411738,.02431726],[.01859888,.02355756,.03843182],[.04988612,.03074653,.03083858],[.01303263,.01416452,.04831091],[.01305757,-.0067278,.06415959],[.0646517,.00937119,.01689873],[.05258659,.00945811,.02974312],[.04432338,.00722095,.03522615],[.03300681,.0086164,.03872784],[.02430178,.01131491,.04039035],[.01820731,.01467953,.04224124],[.00563221,.02307693,.05566789],[.06338145,-.00529279,.01881175],[.05587698,.03208071,.0268784],[.00242624,-.01462858,.07071491],[.01611251,.00339325,.0489542],[.07743095,.02364999,-.02005167],[.01391142,.01851047,.04448999],[.01785794,-.00978285,.0485047],[.04670959,.0266446,.03084075],[.0133397,-.00283762,.06097047],[.07270896,-.02890916,-.02252455],[.01856432,.02585245,.03757904],[.00923388,73075e-8,.06671944],[.05000589,-.06135128,.01892522],[.05085276,-.0717859,.0071471],[.07159291,-.0081182,-72044e-8],[.05843051,-.05248023,.0092409],[.06847258,.03662916,.00724696],[.02412942,-.08258854,.04119211],[.00179909,-.01689865,.06573301],[.02103655,-.00163946,.04566119],[.06407571,.02236021,.01560843],[.03670075,.02360153,.0363523],[.03177186,.02294264,.03775705],[.02196121,-.04598323,.04479785],[.06234883,-.0194443,.01663542],[.01292924,-.09295921,.04094062],[.03210651,-.08533278,.02802],[.04068926,-.07993109,.01925118],[.02724032,.02315802,.03777151],[.0228846,.0239889,.03697603],[.01998311,.02496546,.03689148],[.0613004,.03399261,.02038516],[.0228846,.02886503,.03775031],[.02724032,.02961809,.03871767],[.03177186,.02964135,.03876973],[.03670075,.02927713,.03724325],[.04018389,.02857356,.03482983],[.07555811,.04106811,-.00991916],[.04018389,.02483694,.03440898],[.01776217,-.02683947,.05213116],[.01222237,-.01182445,.05952464],[.00731493,-.02536684,.05815343],[.04135272,-.06996639,.02671969],[.03311811,-.07660816,.03382962],[.01313701,-.08639995,.04702454],[.05940524,-.06223629,-.00631469],[.01998311,.02743837,.0374403],[.00901447,.01236991,.05754256],[.02308977,-.08974197,.03609069],[.06954154,-.02439843,-.00131163],[.01098819,-.04458788,.05120726],[.01181124,-.04579997,.05189563],[.01255818,-.04787901,.0523705],[.01325085,-.05106508,.05205009],[.01546388,-.05819392,.04757892],[.01953754,-.04183893,.04431712],[.02117802,-.04137093,.04555095],[.02285339,-.04051196,.04582437],[.0285016,-.03665721,.04484993],[.05278538,-.02238942,.02861224],[.00946709,.01907627,.0519678],[.01314173,.03104912,.04231405],[.0178,.02859999,.03881555],[.0184511,-.0409888,.04247263],[.05436186,-.04030482,.02109851],[.00766444,.0318213,.04861453],[.01938616,-.06614411,.04521083],[.00516573,.01583571,.06148363],[.01246815,.00230296,.05681035],[.00997827,-.06930922,.04979575],[.03288807,-.05382515,.03795751],[.02311631,-.01566238,.04590084],[.0268025,-.06111567,.04096151],[.03832928,-.01537327,.04137731],[.0296186,-.02274216,.04440943],[.04386901,-.02683286,.03643886],[.01217295,-.07834466,.04969285],[.01542374,-.00136843,.05201008],[.03878377,-.06041764,.03311078],[.03084037,-.06809843,.03814194],[.03747321,-.04503546,.03726452],[.06094129,-.03205992,.01473481],[.04588995,-.04728726,.0298322],[.06583231,-.03941269,70267e-8],[.0349258,-.03195821,.04130198],[.01255543,.0080234,.05307551],[.01126122,-.00933603,.06538785],[.01443109,-.01142775,.05905127],[.00923043,-.00529043,.07003423],[.01755386,.03529116,.04327697],[.02632589,.03713828,.0436463],[.03388062,.03721975,.04309029],[.04075766,.03675412,.04076063],[.0462291,.0347469,.03646322],[.05171755,.02535752,.02670867],[.0729733,.00763172,-48769e-8],[.04706828,.01651,.03109532],[.04071712,.01476821,.03476944],[.03269817,.01470658,.03731945],[.02527572,.0161731,.03865444],[.01970894,.01858504,.03961782],[.01579543,.0209794,.04084997],[.07664182,.00673132,-.02435867],[.01397041,-.0134014,.05630378],[.00884838,.00658739,.06233231],[.00767097,-.00968036,.07077932],[.00460213,-.01334107,.06787448],[.00748618,-.01067995,.06798303],[.01236408,-.01585569,.05480489],[.00387306,-.01409991,.06957705],[.00319925,-.01607932,.06508676],[.01639633,.02556297,.03863737],[.01255645,.02467143,.042038],[.01031362,.02382662,.04615849],[.04253081,.02772296,.03315305],[.0453,.0291,.03339685]];class p0{constructor(){this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.meancolor",this.canvas.hidden=!0,this.canvas.width=1,this.canvas.height=1,this.context=this.canvas.getContext("2d",{alpha:!1,desynchronized:!0})}mean(I){if(!this.context)return;this.context.drawImage(I,0,0,1,1);const V=this.context.getImageData(0,0,1,1);return[V.data[0],V.data[1],V.data[2]]}brightness(I){const V=this.mean(I);return V?(.2989*V[0]+.587*V[1]+.1141*V[2])/255:void 0}dispose(){this.context=null,this.canvas&&document.removeChild(this.canvas),delete this.canvas}}},924:function(Z,I,V){"use strict";var re=V(210),ae=V(559),le=ae(re("String.prototype.indexOf"));Z.exports=function(ue,pe){var ve=re(ue,!!pe);return typeof ve=="function"&&le(ue,".prototype.")>-1?ae(ve):ve}},559:function(Z,I,V){"use strict";var re=V(612),ae=V(210),le=V(771),he=V(453),ue=ae("%Function.prototype.apply%"),pe=ae("%Function.prototype.call%"),ve=ae("%Reflect.apply%",!0)||re.call(pe,ue),we=V(429),Me=ae("%Math.max%");Z.exports=function(Ge){if(typeof Ge!="function")throw new he("a function is required");var ze=ve(re,pe,arguments);return le(ze,1+Me(0,Ge.length-(arguments.length-1)),!0)};var Le=function(){return ve(re,ue,arguments)};we?we(Z.exports,"apply",{value:Le}):Z.exports.apply=Le},296:function(Z,I,V){"use strict";var re=V(429),ae=V(464),le=V(453),he=V(275);Z.exports=function(pe,ve,we){if(!pe||typeof pe!="object"&&typeof pe!="function")throw new le("`obj` must be an object or a function`");if(typeof ve!="string"&&typeof ve!="symbol")throw new le("`property` must be a string or a symbol`");if(arguments.length>3&&typeof arguments[3]!="boolean"&&arguments[3]!==null)throw new le("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&typeof arguments[4]!="boolean"&&arguments[4]!==null)throw new le("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&typeof arguments[5]!="boolean"&&arguments[5]!==null)throw new le("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&typeof arguments[6]!="boolean")throw new le("`loose`, if provided, must be a boolean");var Me=arguments.length>3?arguments[3]:null,Le=arguments.length>4?arguments[4]:null,Ue=arguments.length>5?arguments[5]:null,Ge=arguments.length>6?arguments[6]:!1,ze=!!he&&he(pe,ve);if(re)re(pe,ve,{configurable:Ue===null&&ze?ze.configurable:!Ue,enumerable:Me===null&&ze?ze.enumerable:!Me,value:we,writable:Le===null&&ze?ze.writable:!Le});else if(Ge||!Me&&!Le&&!Ue)pe[ve]=we;else throw new ae("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")}},429:function(Z,I,V){"use strict";var re=V(210),ae=re("%Object.defineProperty%",!0)||!1;if(ae)try{ae({},"a",{value:1})}catch{ae=!1}Z.exports=ae},981:function(Z){"use strict";Z.exports=EvalError},648:function(Z){"use strict";Z.exports=Error},726:function(Z){"use strict";Z.exports=RangeError},712:function(Z){"use strict";Z.exports=ReferenceError},464:function(Z){"use strict";Z.exports=SyntaxError},453:function(Z){"use strict";Z.exports=TypeError},915:function(Z){"use strict";Z.exports=URIError},187:function(Z){"use strict";var I=typeof Reflect=="object"?Reflect:null,V=I&&typeof I.apply=="function"?I.apply:function(at,Rt,lt){return Function.prototype.apply.call(at,Rt,lt)},re;I&&typeof I.ownKeys=="function"?re=I.ownKeys:Object.getOwnPropertySymbols?re=function(at){return Object.getOwnPropertyNames(at).concat(Object.getOwnPropertySymbols(at))}:re=function(at){return Object.getOwnPropertyNames(at)};function ae(rt){console&&console.warn&&console.warn(rt)}var le=Number.isNaN||function(at){return at!==at};function he(){he.init.call(this)}Z.exports=he,Z.exports.once=Ye,he.EventEmitter=he,he.prototype._events=void 0,he.prototype._eventsCount=0,he.prototype._maxListeners=void 0;var ue=10;function pe(rt){if(typeof rt!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof rt)}Object.defineProperty(he,"defaultMaxListeners",{enumerable:!0,get:function(){return ue},set:function(rt){if(typeof rt!="number"||rt<0||le(rt))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+rt+".");ue=rt}}),he.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},he.prototype.setMaxListeners=function(at){if(typeof at!="number"||at<0||le(at))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+at+".");return this._maxListeners=at,this};function ve(rt){return rt._maxListeners===void 0?he.defaultMaxListeners:rt._maxListeners}he.prototype.getMaxListeners=function(){return ve(this)},he.prototype.emit=function(at){for(var Rt=[],lt=1;lt<arguments.length;lt++)Rt.push(arguments[lt]);var kt=at==="error",qt=this._events;if(qt!==void 0)kt=kt&&qt.error===void 0;else if(!kt)return!1;if(kt){var Kt;if(Rt.length>0&&(Kt=Rt[0]),Kt instanceof Error)throw Kt;var _i=new Error("Unhandled error."+(Kt?" ("+Kt.message+")":""));throw _i.context=Kt,_i}var ci=qt[at];if(ci===void 0)return!1;if(typeof ci=="function")V(ci,this,Rt);else for(var li=ci.length,qi=ze(ci,li),lt=0;lt<li;++lt)V(qi[lt],this,Rt);return!0};function we(rt,at,Rt,lt){var kt,qt,Kt;if(pe(Rt),qt=rt._events,qt===void 0?(qt=rt._events=Object.create(null),rt._eventsCount=0):(qt.newListener!==void 0&&(rt.emit("newListener",at,Rt.listener?Rt.listener:Rt),qt=rt._events),Kt=qt[at]),Kt===void 0)Kt=qt[at]=Rt,++rt._eventsCount;else if(typeof Kt=="function"?Kt=qt[at]=lt?[Rt,Kt]:[Kt,Rt]:lt?Kt.unshift(Rt):Kt.push(Rt),kt=ve(rt),kt>0&&Kt.length>kt&&!Kt.warned){Kt.warned=!0;var _i=new Error("Possible EventEmitter memory leak detected. "+Kt.length+" "+String(at)+" listeners added. Use emitter.setMaxListeners() to increase limit");_i.name="MaxListenersExceededWarning",_i.emitter=rt,_i.type=at,_i.count=Kt.length,ae(_i)}return rt}he.prototype.addListener=function(at,Rt){return we(this,at,Rt,!1)},he.prototype.on=he.prototype.addListener,he.prototype.prependListener=function(at,Rt){return we(this,at,Rt,!0)};function Me(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function Le(rt,at,Rt){var lt={fired:!1,wrapFn:void 0,target:rt,type:at,listener:Rt},kt=Me.bind(lt);return kt.listener=Rt,lt.wrapFn=kt,kt}he.prototype.once=function(at,Rt){return pe(Rt),this.on(at,Le(this,at,Rt)),this},he.prototype.prependOnceListener=function(at,Rt){return pe(Rt),this.prependListener(at,Le(this,at,Rt)),this},he.prototype.removeListener=function(at,Rt){var lt,kt,qt,Kt,_i;if(pe(Rt),kt=this._events,kt===void 0)return this;if(lt=kt[at],lt===void 0)return this;if(lt===Rt||lt.listener===Rt)--this._eventsCount===0?this._events=Object.create(null):(delete kt[at],kt.removeListener&&this.emit("removeListener",at,lt.listener||Rt));else if(typeof lt!="function"){for(qt=-1,Kt=lt.length-1;Kt>=0;Kt--)if(lt[Kt]===Rt||lt[Kt].listener===Rt){_i=lt[Kt].listener,qt=Kt;break}if(qt<0)return this;qt===0?lt.shift():He(lt,qt),lt.length===1&&(kt[at]=lt[0]),kt.removeListener!==void 0&&this.emit("removeListener",at,_i||Rt)}return this},he.prototype.off=he.prototype.removeListener,he.prototype.removeAllListeners=function(at){var Rt,lt,kt;if(lt=this._events,lt===void 0)return this;if(lt.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):lt[at]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete lt[at]),this;if(arguments.length===0){var qt=Object.keys(lt),Kt;for(kt=0;kt<qt.length;++kt)Kt=qt[kt],Kt!=="removeListener"&&this.removeAllListeners(Kt);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(Rt=lt[at],typeof Rt=="function")this.removeListener(at,Rt);else if(Rt!==void 0)for(kt=Rt.length-1;kt>=0;kt--)this.removeListener(at,Rt[kt]);return this};function Ue(rt,at,Rt){var lt=rt._events;if(lt===void 0)return[];var kt=lt[at];return kt===void 0?[]:typeof kt=="function"?Rt?[kt.listener||kt]:[kt]:Rt?Ke(kt):ze(kt,kt.length)}he.prototype.listeners=function(at){return Ue(this,at,!0)},he.prototype.rawListeners=function(at){return Ue(this,at,!1)},he.listenerCount=function(rt,at){return typeof rt.listenerCount=="function"?rt.listenerCount(at):Ge.call(rt,at)},he.prototype.listenerCount=Ge;function Ge(rt){var at=this._events;if(at!==void 0){var Rt=at[rt];if(typeof Rt=="function")return 1;if(Rt!==void 0)return Rt.length}return 0}he.prototype.eventNames=function(){return this._eventsCount>0?re(this._events):[]};function ze(rt,at){for(var Rt=new Array(at),lt=0;lt<at;++lt)Rt[lt]=rt[lt];return Rt}function He(rt,at){for(;at+1<rt.length;at++)rt[at]=rt[at+1];rt.pop()}function Ke(rt){for(var at=new Array(rt.length),Rt=0;Rt<at.length;++Rt)at[Rt]=rt[Rt].listener||rt[Rt];return at}function Ye(rt,at){return new Promise(function(Rt,lt){function kt(Kt){rt.removeListener(at,qt),lt(Kt)}function qt(){typeof rt.removeListener=="function"&&rt.removeListener("error",kt),Rt([].slice.call(arguments))}je(rt,at,qt,{once:!0}),at!=="error"&&$e(rt,kt,{once:!0})})}function $e(rt,at,Rt){typeof rt.on=="function"&&je(rt,"error",at,Rt)}function je(rt,at,Rt,lt){if(typeof rt.on=="function")lt.once?rt.once(at,Rt):rt.on(at,Rt);else if(typeof rt.addEventListener=="function")rt.addEventListener(at,function kt(qt){lt.once&&rt.removeEventListener(at,kt),Rt(qt)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof rt)}},29:function(Z,I,V){"use strict";var re=V(320),ae=Object.prototype.toString,le=Object.prototype.hasOwnProperty,he=function(Me,Le,Ue){for(var Ge=0,ze=Me.length;Ge<ze;Ge++)le.call(Me,Ge)&&(Ue==null?Le(Me[Ge],Ge,Me):Le.call(Ue,Me[Ge],Ge,Me))},ue=function(Me,Le,Ue){for(var Ge=0,ze=Me.length;Ge<ze;Ge++)Ue==null?Le(Me.charAt(Ge),Ge,Me):Le.call(Ue,Me.charAt(Ge),Ge,Me)},pe=function(Me,Le,Ue){for(var Ge in Me)le.call(Me,Ge)&&(Ue==null?Le(Me[Ge],Ge,Me):Le.call(Ue,Me[Ge],Ge,Me))},ve=function(Me,Le,Ue){if(!re(Le))throw new TypeError("iterator must be a function");var Ge;arguments.length>=3&&(Ge=Ue),ae.call(Me)==="[object Array]"?he(Me,Le,Ge):typeof Me=="string"?ue(Me,Le,Ge):pe(Me,Le,Ge)};Z.exports=ve},92:function(Z){"use strict";var I="Function.prototype.bind called on incompatible ",V=Object.prototype.toString,re=Math.max,ae="[object Function]",le=function(ve,we){for(var Me=[],Le=0;Le<ve.length;Le+=1)Me[Le]=ve[Le];for(var Ue=0;Ue<we.length;Ue+=1)Me[Ue+ve.length]=we[Ue];return Me},he=function(ve,we){for(var Me=[],Le=we||0,Ue=0;Le<ve.length;Le+=1,Ue+=1)Me[Ue]=ve[Le];return Me},ue=function(pe,ve){for(var we="",Me=0;Me<pe.length;Me+=1)we+=pe[Me],Me+1<pe.length&&(we+=ve);return we};Z.exports=function(ve){var we=this;if(typeof we!="function"||V.apply(we)!==ae)throw new TypeError(I+we);for(var Me=he(arguments,1),Le,Ue=function(){if(this instanceof Le){var Ye=we.apply(this,le(Me,arguments));return Object(Ye)===Ye?Ye:this}return we.apply(ve,le(Me,arguments))},Ge=re(0,we.length-Me.length),ze=[],He=0;He<Ge;He++)ze[He]="$"+He;if(Le=Function("binder","return function ("+ue(ze,",")+"){ return binder.apply(this,arguments); }")(Ue),we.prototype){var Ke=function(){};Ke.prototype=we.prototype,Le.prototype=new Ke,Ke.prototype=null}return Le}},612:function(Z,I,V){"use strict";var re=V(92);Z.exports=Function.prototype.bind||re},210:function(Z,I,V){"use strict";var re,ae=V(648),le=V(981),he=V(726),ue=V(712),pe=V(464),ve=V(453),we=V(915),Me=Function,Le=function(Gs){try{return Me('"use strict"; return ('+Gs+").constructor;")()}catch{}},Ue=Object.getOwnPropertyDescriptor;if(Ue)try{Ue({},"")}catch{Ue=null}var Ge=function(){throw new ve},ze=Ue?function(){try{return arguments.callee,Ge}catch{try{return Ue(arguments,"callee").get}catch{return Ge}}}():Ge,He=V(405)(),Ke=V(185)(),Ye=Object.getPrototypeOf||(Ke?function(Gs){return Gs.__proto__}:null),$e={},je=typeof Uint8Array>"u"||!Ye?re:Ye(Uint8Array),rt={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?re:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?re:ArrayBuffer,"%ArrayIteratorPrototype%":He&&Ye?Ye([][Symbol.iterator]()):re,"%AsyncFromSyncIteratorPrototype%":re,"%AsyncFunction%":$e,"%AsyncGenerator%":$e,"%AsyncGeneratorFunction%":$e,"%AsyncIteratorPrototype%":$e,"%Atomics%":typeof Atomics>"u"?re:Atomics,"%BigInt%":typeof BigInt>"u"?re:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?re:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?re:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?re:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":ae,"%eval%":eval,"%EvalError%":le,"%Float32Array%":typeof Float32Array>"u"?re:Float32Array,"%Float64Array%":typeof Float64Array>"u"?re:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?re:FinalizationRegistry,"%Function%":Me,"%GeneratorFunction%":$e,"%Int8Array%":typeof Int8Array>"u"?re:Int8Array,"%Int16Array%":typeof Int16Array>"u"?re:Int16Array,"%Int32Array%":typeof Int32Array>"u"?re:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":He&&Ye?Ye(Ye([][Symbol.iterator]())):re,"%JSON%":typeof JSON=="object"?JSON:re,"%Map%":typeof Map>"u"?re:Map,"%MapIteratorPrototype%":typeof Map>"u"||!He||!Ye?re:Ye(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?re:Promise,"%Proxy%":typeof Proxy>"u"?re:Proxy,"%RangeError%":he,"%ReferenceError%":ue,"%Reflect%":typeof Reflect>"u"?re:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?re:Set,"%SetIteratorPrototype%":typeof Set>"u"||!He||!Ye?re:Ye(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?re:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":He&&Ye?Ye(""[Symbol.iterator]()):re,"%Symbol%":He?Symbol:re,"%SyntaxError%":pe,"%ThrowTypeError%":ze,"%TypedArray%":je,"%TypeError%":ve,"%Uint8Array%":typeof Uint8Array>"u"?re:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?re:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?re:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?re:Uint32Array,"%URIError%":we,"%WeakMap%":typeof WeakMap>"u"?re:WeakMap,"%WeakRef%":typeof WeakRef>"u"?re:WeakRef,"%WeakSet%":typeof WeakSet>"u"?re:WeakSet};if(Ye)try{null.error}catch(Gs){var at=Ye(Ye(Gs));rt["%Error.prototype%"]=at}var Rt=function Gs(Xs){var $i;if(Xs==="%AsyncFunction%")$i=Le("async function () {}");else if(Xs==="%GeneratorFunction%")$i=Le("function* () {}");else if(Xs==="%AsyncGeneratorFunction%")$i=Le("async function* () {}");else if(Xs==="%AsyncGenerator%"){var xs=Gs("%AsyncGeneratorFunction%");xs&&($i=xs.prototype)}else if(Xs==="%AsyncIteratorPrototype%"){var hi=Gs("%AsyncGenerator%");hi&&Ye&&($i=Ye(hi.prototype))}return rt[Xs]=$i,$i},lt={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},kt=V(612),qt=V(824),Kt=kt.call(Function.call,Array.prototype.concat),_i=kt.call(Function.apply,Array.prototype.splice),ci=kt.call(Function.call,String.prototype.replace),li=kt.call(Function.call,String.prototype.slice),qi=kt.call(Function.call,RegExp.prototype.exec),Ki=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,hs=/\\(\\)?/g,Yi=function(Xs){var $i=li(Xs,0,1),xs=li(Xs,-1);if($i==="%"&&xs!=="%")throw new pe("invalid intrinsic syntax, expected closing `%`");if(xs==="%"&&$i!=="%")throw new pe("invalid intrinsic syntax, expected opening `%`");var hi=[];return ci(Xs,Ki,function(Ri,Wi,us,Ks){hi[hi.length]=us?ci(Ks,hs,"$1"):Wi||Ri}),hi},ns=function(Xs,$i){var xs=Xs,hi;if(qt(lt,xs)&&(hi=lt[xs],xs="%"+hi[0]+"%"),qt(rt,xs)){var Ri=rt[xs];if(Ri===$e&&(Ri=Rt(xs)),typeof Ri>"u"&&!$i)throw new ve("intrinsic "+Xs+" exists, but is not available. Please file an issue!");return{alias:hi,name:xs,value:Ri}}throw new pe("intrinsic "+Xs+" does not exist!")};Z.exports=function(Xs,$i){if(typeof Xs!="string"||Xs.length===0)throw new ve("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof $i!="boolean")throw new ve('"allowMissing" argument must be a boolean');if(qi(/^%?[^%]*%?$/,Xs)===null)throw new pe("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var xs=Yi(Xs),hi=xs.length>0?xs[0]:"",Ri=ns("%"+hi+"%",$i),Wi=Ri.name,us=Ri.value,Ks=!1,ur=Ri.alias;ur&&(hi=ur[0],_i(xs,Kt([0,1],ur)));for(var js=1,sr=!0;js<xs.length;js+=1){var cr=xs[js],ln=li(cr,0,1),kr=li(cr,-1);if((ln==='"'||ln==="'"||ln==="`"||kr==='"'||kr==="'"||kr==="`")&&ln!==kr)throw new pe("property names with quotes must have matching quotes");if((cr==="constructor"||!sr)&&(Ks=!0),hi+="."+cr,Wi="%"+hi+"%",qt(rt,Wi))us=rt[Wi];else if(us!=null){if(!(cr in us)){if(!$i)throw new ve("base intrinsic for "+Xs+" exists, but the property is not available.");return}if(Ue&&js+1>=xs.length){var $r=Ue(us,cr);sr=!!$r,sr&&"get"in $r&&!("originalValue"in $r.get)?us=$r.get:us=us[cr]}else sr=qt(us,cr),us=us[cr];sr&&!Ks&&(rt[Wi]=us)}}return us}},275:function(Z,I,V){"use strict";var re=V(210),ae=re("%Object.getOwnPropertyDescriptor%",!0);if(ae)try{ae([],"length")}catch{ae=null}Z.exports=ae},44:function(Z,I,V){"use strict";var re=V(429),ae=function(){return!!re};ae.hasArrayLengthDefineBug=function(){if(!re)return null;try{return re([],"length",{value:1}).length!==1}catch{return!0}},Z.exports=ae},185:function(Z){"use strict";var I={foo:{}},V=Object;Z.exports=function(){return{__proto__:I}.foo===I.foo&&!({__proto__:null}instanceof V)}},405:function(Z,I,V){"use strict";var re=typeof Symbol<"u"&&Symbol,ae=V(419);Z.exports=function(){return typeof re!="function"||typeof Symbol!="function"||typeof re("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:ae()}},419:function(Z){"use strict";Z.exports=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var V={},re=Symbol("test"),ae=Object(re);if(typeof re=="string"||Object.prototype.toString.call(re)!=="[object Symbol]"||Object.prototype.toString.call(ae)!=="[object Symbol]")return!1;var le=42;V[re]=le;for(re in V)return!1;if(typeof Object.keys=="function"&&Object.keys(V).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(V).length!==0)return!1;var he=Object.getOwnPropertySymbols(V);if(he.length!==1||he[0]!==re||!Object.prototype.propertyIsEnumerable.call(V,re))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var ue=Object.getOwnPropertyDescriptor(V,re);if(ue.value!==le||ue.enumerable!==!0)return!1}return!0}},410:function(Z,I,V){"use strict";var re=V(419);Z.exports=function(){return re()&&!!Symbol.toStringTag}},824:function(Z,I,V){"use strict";var re=Function.prototype.call,ae=Object.prototype.hasOwnProperty,le=V(612);Z.exports=le.call(re,ae)},717:function(Z){typeof Object.create=="function"?Z.exports=function(V,re){re&&(V.super_=re,V.prototype=Object.create(re.prototype,{constructor:{value:V,enumerable:!1,writable:!0,configurable:!0}}))}:Z.exports=function(V,re){if(re){V.super_=re;var ae=function(){};ae.prototype=re.prototype,V.prototype=new ae,V.prototype.constructor=V}}},584:function(Z,I,V){"use strict";var re=V(410)(),ae=V(924),le=ae("Object.prototype.toString"),he=function(we){return re&&we&&typeof we=="object"&&Symbol.toStringTag in we?!1:le(we)==="[object Arguments]"},ue=function(we){return he(we)?!0:we!==null&&typeof we=="object"&&typeof we.length=="number"&&we.length>=0&&le(we)!=="[object Array]"&&le(we.callee)==="[object Function]"},pe=function(){return he(arguments)}();he.isLegacyArguments=ue,Z.exports=pe?he:ue},320:function(Z){"use strict";var I=Function.prototype.toString,V=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,re,ae;if(typeof V=="function"&&typeof Object.defineProperty=="function")try{re=Object.defineProperty({},"length",{get:function(){throw ae}}),ae={},V(function(){throw 42},null,re)}catch($e){$e!==ae&&(V=null)}else V=null;var le=/^\s*class\b/,he=function(je){try{var rt=I.call(je);return le.test(rt)}catch{return!1}},ue=function(je){try{return he(je)?!1:(I.call(je),!0)}catch{return!1}},pe=Object.prototype.toString,ve="[object Object]",we="[object Function]",Me="[object GeneratorFunction]",Le="[object HTMLAllCollection]",Ue="[object HTML document.all class]",Ge="[object HTMLCollection]",ze=typeof Symbol=="function"&&!!Symbol.toStringTag,He=!(0 in[,]),Ke=function(){return!1};if(typeof document=="object"){var Ye=document.all;pe.call(Ye)===pe.call(document.all)&&(Ke=function(je){if((He||!je)&&(typeof je>"u"||typeof je=="object"))try{var rt=pe.call(je);return(rt===Le||rt===Ue||rt===Ge||rt===ve)&&je("")==null}catch{}return!1})}Z.exports=V?function(je){if(Ke(je))return!0;if(!je||typeof je!="function"&&typeof je!="object")return!1;try{V(je,null,re)}catch(rt){if(rt!==ae)return!1}return!he(je)&&ue(je)}:function(je){if(Ke(je))return!0;if(!je||typeof je!="function"&&typeof je!="object")return!1;if(ze)return ue(je);if(he(je))return!1;var rt=pe.call(je);return rt!==we&&rt!==Me&&!/^\[object HTML/.test(rt)?!1:ue(je)}},662:function(Z,I,V){"use strict";var re=Object.prototype.toString,ae=Function.prototype.toString,le=/^\s*(?:function)?\*/,he=V(410)(),ue=Object.getPrototypeOf,pe=function(){if(!he)return!1;try{return Function("return function*() {}")()}catch{}},ve;Z.exports=function(Me){if(typeof Me!="function")return!1;if(le.test(ae.call(Me)))return!0;if(!he){var Le=re.call(Me);return Le==="[object GeneratorFunction]"}if(!ue)return!1;if(typeof ve>"u"){var Ue=pe();ve=Ue?ue(Ue):!1}return ue(Me)===ve}},692:function(Z,I,V){"use strict";var re=V(430);Z.exports=function(le){return!!re(le)}},300:function(Z,I,V){"use strict";var re=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof V.g<"u")return V.g;throw new Error("unable to locate global object")},ae=re();Z.exports=I=ae.fetch,ae.fetch&&(I.default=ae.fetch.bind(ae)),I.Headers=ae.Headers,I.Request=ae.Request,I.Response=ae.Response},908:function(Z){"use strict";Z.exports=["Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},771:function(Z,I,V){"use strict";var re=V(210),ae=V(296),le=V(44)(),he=V(275),ue=V(453),pe=re("%Math.floor%");Z.exports=function(we,Me){if(typeof we!="function")throw new ue("`fn` is not a function");if(typeof Me!="number"||Me<0||Me>4294967295||pe(Me)!==Me)throw new ue("`length` must be a positive 32-bit integer");var Le=arguments.length>2&&!!arguments[2],Ue=!0,Ge=!0;if("length"in we&&he){var ze=he(we,"length");ze&&!ze.configurable&&(Ue=!1),ze&&!ze.writable&&(Ge=!1)}return(Ue||Ge||!Le)&&(le?ae(we,"length",Me,!0,!0):ae(we,"length",Me)),we}},384:function(Z){Z.exports=function(V){return V&&typeof V=="object"&&typeof V.copy=="function"&&typeof V.fill=="function"&&typeof V.readUInt8=="function"}},955:function(Z,I,V){"use strict";var re=V(584),ae=V(662),le=V(430),he=V(692);function ue(ps){return ps.call.bind(ps)}var pe=typeof BigInt<"u",ve=typeof Symbol<"u",we=ue(Object.prototype.toString),Me=ue(Number.prototype.valueOf),Le=ue(String.prototype.valueOf),Ue=ue(Boolean.prototype.valueOf);if(pe)var Ge=ue(BigInt.prototype.valueOf);if(ve)var ze=ue(Symbol.prototype.valueOf);function He(ps,l0){if(typeof ps!="object")return!1;try{return l0(ps),!0}catch{return!1}}I.isArgumentsObject=re,I.isGeneratorFunction=ae,I.isTypedArray=he;function Ke(ps){return typeof Promise<"u"&&ps instanceof Promise||ps!==null&&typeof ps=="object"&&typeof ps.then=="function"&&typeof ps.catch=="function"}I.isPromise=Ke;function Ye(ps){return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?ArrayBuffer.isView(ps):he(ps)||Ri(ps)}I.isArrayBufferView=Ye;function $e(ps){return le(ps)==="Uint8Array"}I.isUint8Array=$e;function je(ps){return le(ps)==="Uint8ClampedArray"}I.isUint8ClampedArray=je;function rt(ps){return le(ps)==="Uint16Array"}I.isUint16Array=rt;function at(ps){return le(ps)==="Uint32Array"}I.isUint32Array=at;function Rt(ps){return le(ps)==="Int8Array"}I.isInt8Array=Rt;function lt(ps){return le(ps)==="Int16Array"}I.isInt16Array=lt;function kt(ps){return le(ps)==="Int32Array"}I.isInt32Array=kt;function qt(ps){return le(ps)==="Float32Array"}I.isFloat32Array=qt;function Kt(ps){return le(ps)==="Float64Array"}I.isFloat64Array=Kt;function _i(ps){return le(ps)==="BigInt64Array"}I.isBigInt64Array=_i;function ci(ps){return le(ps)==="BigUint64Array"}I.isBigUint64Array=ci;function li(ps){return we(ps)==="[object Map]"}li.working=typeof Map<"u"&&li(new Map);function qi(ps){return typeof Map>"u"?!1:li.working?li(ps):ps instanceof Map}I.isMap=qi;function Ki(ps){return we(ps)==="[object Set]"}Ki.working=typeof Set<"u"&&Ki(new Set);function hs(ps){return typeof Set>"u"?!1:Ki.working?Ki(ps):ps instanceof Set}I.isSet=hs;function Yi(ps){return we(ps)==="[object WeakMap]"}Yi.working=typeof WeakMap<"u"&&Yi(new WeakMap);function ns(ps){return typeof WeakMap>"u"?!1:Yi.working?Yi(ps):ps instanceof WeakMap}I.isWeakMap=ns;function Gs(ps){return we(ps)==="[object WeakSet]"}Gs.working=typeof WeakSet<"u"&&Gs(new WeakSet);function Xs(ps){return Gs(ps)}I.isWeakSet=Xs;function $i(ps){return we(ps)==="[object ArrayBuffer]"}$i.working=typeof ArrayBuffer<"u"&&$i(new ArrayBuffer);function xs(ps){return typeof ArrayBuffer>"u"?!1:$i.working?$i(ps):ps instanceof ArrayBuffer}I.isArrayBuffer=xs;function hi(ps){return we(ps)==="[object DataView]"}hi.working=typeof ArrayBuffer<"u"&&typeof DataView<"u"&&hi(new DataView(new ArrayBuffer(1),0,1));function Ri(ps){return typeof DataView>"u"?!1:hi.working?hi(ps):ps instanceof DataView}I.isDataView=Ri;var Wi=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:void 0;function us(ps){return we(ps)==="[object SharedArrayBuffer]"}function Ks(ps){return typeof Wi>"u"?!1:(typeof us.working>"u"&&(us.working=us(new Wi)),us.working?us(ps):ps instanceof Wi)}I.isSharedArrayBuffer=Ks;function ur(ps){return we(ps)==="[object AsyncFunction]"}I.isAsyncFunction=ur;function js(ps){return we(ps)==="[object Map Iterator]"}I.isMapIterator=js;function sr(ps){return we(ps)==="[object Set Iterator]"}I.isSetIterator=sr;function cr(ps){return we(ps)==="[object Generator]"}I.isGeneratorObject=cr;function ln(ps){return we(ps)==="[object WebAssembly.Module]"}I.isWebAssemblyCompiledModule=ln;function kr(ps){return He(ps,Me)}I.isNumberObject=kr;function $r(ps){return He(ps,Le)}I.isStringObject=$r;function Rn(ps){return He(ps,Ue)}I.isBooleanObject=Rn;function Ln(ps){return pe&&He(ps,Ge)}I.isBigIntObject=Ln;function zn(ps){return ve&&He(ps,ze)}I.isSymbolObject=zn;function ra(ps){return kr(ps)||$r(ps)||Rn(ps)||Ln(ps)||zn(ps)}I.isBoxedPrimitive=ra;function aa(ps){return typeof Uint8Array<"u"&&(xs(ps)||Ks(ps))}I.isAnyArrayBuffer=aa,["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(ps){Object.defineProperty(I,ps,{enumerable:!1,value:function(){throw new Error(ps+" is not supported in userland")}})})},539:function(Z,I,V){var re=Object.getOwnPropertyDescriptors||function(Ri){for(var Wi=Object.keys(Ri),us={},Ks=0;Ks<Wi.length;Ks++)us[Wi[Ks]]=Object.getOwnPropertyDescriptor(Ri,Wi[Ks]);return us},ae=/%[sdj%]/g;I.format=function(hi){if(!Rt(hi)){for(var Ri=[],Wi=0;Wi<arguments.length;Wi++)Ri.push(pe(arguments[Wi]));return Ri.join(" ")}for(var Wi=1,us=arguments,Ks=us.length,ur=String(hi).replace(ae,function(sr){if(sr==="%%")return"%";if(Wi>=Ks)return sr;switch(sr){case"%s":return String(us[Wi++]);case"%d":return Number(us[Wi++]);case"%j":try{return JSON.stringify(us[Wi++])}catch{return"[Circular]"}default:return sr}}),js=us[Wi];Wi<Ks;js=us[++Wi])je(js)||!Kt(js)?ur+=" "+js:ur+=" "+pe(js);return ur},I.deprecate=function(hi,Ri){if(typeof process<"u"&&process.noDeprecation===!0)return hi;if(typeof process>"u")return function(){return I.deprecate(hi,Ri).apply(this,arguments)};var Wi=!1;function us(){if(!Wi){if(process.throwDeprecation)throw new Error(Ri);process.traceDeprecation?console.trace(Ri):console.error(Ri),Wi=!0}return hi.apply(this,arguments)}return us};var le={},he=/^$/;if(process.env.NODE_DEBUG){var ue=process.env.NODE_DEBUG;ue=ue.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),he=new RegExp("^"+ue+"$","i")}I.debuglog=function(hi){if(hi=hi.toUpperCase(),!le[hi])if(he.test(hi)){var Ri=process.pid;le[hi]=function(){var Wi=I.format.apply(I,arguments);console.error("%s %d: %s",hi,Ri,Wi)}}else le[hi]=function(){};return le[hi]};function pe(hi,Ri){var Wi={seen:[],stylize:we};return arguments.length>=3&&(Wi.depth=arguments[2]),arguments.length>=4&&(Wi.colors=arguments[3]),$e(Ri)?Wi.showHidden=Ri:Ri&&I._extend(Wi,Ri),kt(Wi.showHidden)&&(Wi.showHidden=!1),kt(Wi.depth)&&(Wi.depth=2),kt(Wi.colors)&&(Wi.colors=!1),kt(Wi.customInspect)&&(Wi.customInspect=!0),Wi.colors&&(Wi.stylize=ve),Le(Wi,hi,Wi.depth)}I.inspect=pe,pe.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},pe.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};function ve(hi,Ri){var Wi=pe.styles[Ri];return Wi?"\x1B["+pe.colors[Wi][0]+"m"+hi+"\x1B["+pe.colors[Wi][1]+"m":hi}function we(hi,Ri){return hi}function Me(hi){var Ri={};return hi.forEach(function(Wi,us){Ri[Wi]=!0}),Ri}function Le(hi,Ri,Wi){if(hi.customInspect&&Ri&&li(Ri.inspect)&&Ri.inspect!==I.inspect&&!(Ri.constructor&&Ri.constructor.prototype===Ri)){var us=Ri.inspect(Wi,hi);return Rt(us)||(us=Le(hi,us,Wi)),us}var Ks=Ue(hi,Ri);if(Ks)return Ks;var ur=Object.keys(Ri),js=Me(ur);if(hi.showHidden&&(ur=Object.getOwnPropertyNames(Ri)),ci(Ri)&&(ur.indexOf("message")>=0||ur.indexOf("description")>=0))return Ge(Ri);if(ur.length===0){if(li(Ri)){var sr=Ri.name?": "+Ri.name:"";return hi.stylize("[Function"+sr+"]","special")}if(qt(Ri))return hi.stylize(RegExp.prototype.toString.call(Ri),"regexp");if(_i(Ri))return hi.stylize(Date.prototype.toString.call(Ri),"date");if(ci(Ri))return Ge(Ri)}var cr="",ln=!1,kr=["{","}"];if(Ye(Ri)&&(ln=!0,kr=["[","]"]),li(Ri)){var $r=Ri.name?": "+Ri.name:"";cr=" [Function"+$r+"]"}if(qt(Ri)&&(cr=" "+RegExp.prototype.toString.call(Ri)),_i(Ri)&&(cr=" "+Date.prototype.toUTCString.call(Ri)),ci(Ri)&&(cr=" "+Ge(Ri)),ur.length===0&&(!ln||Ri.length==0))return kr[0]+cr+kr[1];if(Wi<0)return qt(Ri)?hi.stylize(RegExp.prototype.toString.call(Ri),"regexp"):hi.stylize("[Object]","special");hi.seen.push(Ri);var Rn;return ln?Rn=ze(hi,Ri,Wi,js,ur):Rn=ur.map(function(Ln){return He(hi,Ri,Wi,js,Ln,ln)}),hi.seen.pop(),Ke(Rn,cr,kr)}function Ue(hi,Ri){if(kt(Ri))return hi.stylize("undefined","undefined");if(Rt(Ri)){var Wi="'"+JSON.stringify(Ri).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return hi.stylize(Wi,"string")}if(at(Ri))return hi.stylize(""+Ri,"number");if($e(Ri))return hi.stylize(""+Ri,"boolean");if(je(Ri))return hi.stylize("null","null")}function Ge(hi){return"["+Error.prototype.toString.call(hi)+"]"}function ze(hi,Ri,Wi,us,Ks){for(var ur=[],js=0,sr=Ri.length;js<sr;++js)Gs(Ri,String(js))?ur.push(He(hi,Ri,Wi,us,String(js),!0)):ur.push("");return Ks.forEach(function(cr){cr.match(/^\d+$/)||ur.push(He(hi,Ri,Wi,us,cr,!0))}),ur}function He(hi,Ri,Wi,us,Ks,ur){var js,sr,cr;if(cr=Object.getOwnPropertyDescriptor(Ri,Ks)||{value:Ri[Ks]},cr.get?cr.set?sr=hi.stylize("[Getter/Setter]","special"):sr=hi.stylize("[Getter]","special"):cr.set&&(sr=hi.stylize("[Setter]","special")),Gs(us,Ks)||(js="["+Ks+"]"),sr||(hi.seen.indexOf(cr.value)<0?(je(Wi)?sr=Le(hi,cr.value,null):sr=Le(hi,cr.value,Wi-1),sr.indexOf(`
`)>-1&&(ur?sr=sr.split(`
`).map(function(ln){return"  "+ln}).join(`
`).slice(2):sr=`
`+sr.split(`
`).map(function(ln){return"   "+ln}).join(`
`))):sr=hi.stylize("[Circular]","special")),kt(js)){if(ur&&Ks.match(/^\d+$/))return sr;js=JSON.stringify(""+Ks),js.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(js=js.slice(1,-1),js=hi.stylize(js,"name")):(js=js.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),js=hi.stylize(js,"string"))}return js+": "+sr}function Ke(hi,Ri,Wi){var us=0,Ks=hi.reduce(function(ur,js){return us++,js.indexOf(`
`)>=0&&us++,ur+js.replace(/\u001b\[\d\d?m/g,"").length+1},0);return Ks>60?Wi[0]+(Ri===""?"":Ri+`
 `)+" "+hi.join(`,
  `)+" "+Wi[1]:Wi[0]+Ri+" "+hi.join(", ")+" "+Wi[1]}I.types=V(955);function Ye(hi){return Array.isArray(hi)}I.isArray=Ye;function $e(hi){return typeof hi=="boolean"}I.isBoolean=$e;function je(hi){return hi===null}I.isNull=je;function rt(hi){return hi==null}I.isNullOrUndefined=rt;function at(hi){return typeof hi=="number"}I.isNumber=at;function Rt(hi){return typeof hi=="string"}I.isString=Rt;function lt(hi){return typeof hi=="symbol"}I.isSymbol=lt;function kt(hi){return hi===void 0}I.isUndefined=kt;function qt(hi){return Kt(hi)&&Ki(hi)==="[object RegExp]"}I.isRegExp=qt,I.types.isRegExp=qt;function Kt(hi){return typeof hi=="object"&&hi!==null}I.isObject=Kt;function _i(hi){return Kt(hi)&&Ki(hi)==="[object Date]"}I.isDate=_i,I.types.isDate=_i;function ci(hi){return Kt(hi)&&(Ki(hi)==="[object Error]"||hi instanceof Error)}I.isError=ci,I.types.isNativeError=ci;function li(hi){return typeof hi=="function"}I.isFunction=li;function qi(hi){return hi===null||typeof hi=="boolean"||typeof hi=="number"||typeof hi=="string"||typeof hi=="symbol"||typeof hi>"u"}I.isPrimitive=qi,I.isBuffer=V(384);function Ki(hi){return Object.prototype.toString.call(hi)}function hs(hi){return hi<10?"0"+hi.toString(10):hi.toString(10)}var Yi=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function ns(){var hi=new Date,Ri=[hs(hi.getHours()),hs(hi.getMinutes()),hs(hi.getSeconds())].join(":");return[hi.getDate(),Yi[hi.getMonth()],Ri].join(" ")}I.log=function(){console.log("%s - %s",ns(),I.format.apply(I,arguments))},I.inherits=V(717),I._extend=function(hi,Ri){if(!Ri||!Kt(Ri))return hi;for(var Wi=Object.keys(Ri),us=Wi.length;us--;)hi[Wi[us]]=Ri[Wi[us]];return hi};function Gs(hi,Ri){return Object.prototype.hasOwnProperty.call(hi,Ri)}var Xs=typeof Symbol<"u"?Symbol("util.promisify.custom"):void 0;I.promisify=function(Ri){if(typeof Ri!="function")throw new TypeError('The "original" argument must be of type Function');if(Xs&&Ri[Xs]){var Wi=Ri[Xs];if(typeof Wi!="function")throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(Wi,Xs,{value:Wi,enumerable:!1,writable:!1,configurable:!0}),Wi}function Wi(){for(var us,Ks,ur=new Promise(function(cr,ln){us=cr,Ks=ln}),js=[],sr=0;sr<arguments.length;sr++)js.push(arguments[sr]);js.push(function(cr,ln){cr?Ks(cr):us(ln)});try{Ri.apply(this,js)}catch(cr){Ks(cr)}return ur}return Object.setPrototypeOf(Wi,Object.getPrototypeOf(Ri)),Xs&&Object.defineProperty(Wi,Xs,{value:Wi,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(Wi,re(Ri))},I.promisify.custom=Xs;function $i(hi,Ri){if(!hi){var Wi=new Error("Promise was rejected with a falsy value");Wi.reason=hi,hi=Wi}return Ri(hi)}function xs(hi){if(typeof hi!="function")throw new TypeError('The "original" argument must be of type Function');function Ri(){for(var Wi=[],us=0;us<arguments.length;us++)Wi.push(arguments[us]);var Ks=Wi.pop();if(typeof Ks!="function")throw new TypeError("The last argument must be of type Function");var ur=this,js=function(){return Ks.apply(ur,arguments)};hi.apply(this,Wi).then(function(sr){process.nextTick(js.bind(null,null,sr))},function(sr){process.nextTick($i.bind(null,sr,js))})}return Object.setPrototypeOf(Ri,Object.getPrototypeOf(hi)),Object.defineProperties(Ri,re(hi)),Ri}I.callbackify=xs},430:function(Z,I,V){"use strict";var re=V(29),ae=V(83),le=V(559),he=V(924),ue=V(275),pe=he("Object.prototype.toString"),ve=V(410)(),we=typeof globalThis>"u"?V.g:globalThis,Me=ae(),Le=he("String.prototype.slice"),Ue=Object.getPrototypeOf,Ge=he("Array.prototype.indexOf",!0)||function($e,je){for(var rt=0;rt<$e.length;rt+=1)if($e[rt]===je)return rt;return-1},ze={__proto__:null};ve&&ue&&Ue?re(Me,function(Ye){var $e=new we[Ye];if(Symbol.toStringTag in $e){var je=Ue($e),rt=ue(je,Symbol.toStringTag);if(!rt){var at=Ue(je);rt=ue(at,Symbol.toStringTag)}ze["$"+Ye]=le(rt.get)}}):re(Me,function(Ye){var $e=new we[Ye],je=$e.slice||$e.set;je&&(ze["$"+Ye]=le(je))});var He=function($e){var je=!1;return re(ze,function(rt,at){if(!je)try{"$"+rt($e)===at&&(je=Le(at,1))}catch{}}),je},Ke=function($e){var je=!1;return re(ze,function(rt,at){if(!je)try{rt($e),je=Le(at,1)}catch{}}),je};Z.exports=function($e){if(!$e||typeof $e!="object")return!1;if(!ve){var je=Le(pe($e),8,-1);return Ge(Me,je)>-1?je:je!=="Object"?!1:Ke($e)}return ue?He($e):null}},653:function(){},83:function(Z,I,V){"use strict";var re=V(908),ae=typeof globalThis>"u"?V.g:globalThis;Z.exports=function(){for(var he=[],ue=0;ue<re.length;ue++)typeof ae[re[ue]]=="function"&&(he[he.length]=re[ue]);return he}}},__webpack_module_cache__={};function __webpack_require__(Z){var I=__webpack_module_cache__[Z];if(I!==void 0)return I.exports;var V=__webpack_module_cache__[Z]={exports:{}};return __webpack_modules__[Z](V,V.exports,__webpack_require__),V.exports}(function(){__webpack_require__.d=function(Z,I){for(var V in I)__webpack_require__.o(I,V)&&!__webpack_require__.o(Z,V)&&Object.defineProperty(Z,V,{enumerable:!0,get:I[V]})}})(),function(){__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}()}(),function(){__webpack_require__.o=function(Z,I){return Object.prototype.hasOwnProperty.call(Z,I)}}();var __webpack_exports__={};(function(){"use strict";var Z=__webpack_require__(862),I=__webpack_require__(187);class V extends I.EventEmitter{}var re=Object.defineProperty,ae=Object.getOwnPropertySymbols,le=Object.prototype.hasOwnProperty,he=Object.prototype.propertyIsEnumerable,ue=(_e,p,_)=>p in _e?re(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,pe=(_e,p)=>{for(var _ in p||(p={}))le.call(p,_)&&ue(_e,_,p[_]);if(ae)for(var _ of ae(p))he.call(p,_)&&ue(_e,_,p[_]);return _e};class ve{constructor(p="canvas"){this.size={width:0,height:0},this.transpose=!1,this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.capture."+p,this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}capture(p){const{context:_,clipPix:E,transpose:A}=this;if(!_)return!1;let{width:$,height:ne}=this.size;return A&&([$,ne]=[ne,$]),A&&_.setTransform(0,1,1,0,0,0),E?_.drawImage(p,E.left,E.top,E.width,E.height,0,0,$,ne):_.drawImage(p,0,0,$,ne),A&&_.resetTransform(),!0}fill(){const{context:p}=this;if(!p)return;let{width:_,height:E}=this.size;p.fillStyle="rgba(255, 255, 255, 1)",p.fillRect(0,0,_,E)}data(){const{context:p}=this;if(!p)return;const{width:_,height:E}=this.size;return p.getImageData(0,0,_,E)}setSize(p){let{width:_,height:E}=p;this.transpose&&([_,E]=[E,_]),this.size={width:_,height:E},this.canvas.width=_,this.canvas.height=E,this.setClip(this.clip)}setClip(p){let{width:_,height:E}=this.size;this.transpose&&([_,E]=[E,_]),this.clip=p,this.clipPix=p&&{left:p.left*_,top:p.top*E,width:p.width*_,height:p.height*E}}setTranspose(p){if(p==this.transpose)return;let{width:_,height:E}=this.size;this.transpose&&([_,E]=[E,_]),this.transpose=p,this.setSize({width:_,height:E})}dispose(){this.context=null,this.canvas.remove()}}class we extends V{constructor(){super(),this.buffer=new ve("capture"),this.captureTime=0}async setup(p){const _=p&&(E=>typeof E!="string"&&"size"in E)(p)&&p.size||{width:1920,height:1080};return this.updateSize(_),this.buffer.fill(),!0}dispose(){this.reset(),this.buffer.dispose()}async start(){this.captureTime=0,this.timer=Date.now()}pause(){}reset(){this.pause(),delete this.timer}capture(){return this.timer===void 0?!1:(this.captureTime=(Date.now()-this.timer)*1e3,!0)}size(){return pe({},this.buffer.size)}ratio(){const p=this.buffer.size;return p.width/p.height}updateSize(p){let{width:_,height:E}=p;const{sizeMax:A,clipRect:$,transpose:ne}=this;if(A&&(_>A||E>A)){const xe=_/E;xe>1?(_=A,E=A/xe):(E=A,_=xe*A),p={width:_,height:E}}this.buffer.setSize(p),this.buffer.setClip($),this.buffer.setTranspose(!!ne),this.emit("resize",this.buffer.size)}}class Me extends we{constructor(){super(),this.timeShift=0,this.videoRef=document.createElement("video"),this.videoRef.id="engeenee.capture.source",this.videoRef.muted=!0,this.videoRef.loop=!0,this.videoRef.playsInline=!0}async setup(p){const _=ce=>typeof ce=="string"||"url"in ce&&typeof ce.url=="string",E=ce=>_(ce)||"getVideoTracks"in ce,A=ce=>_(ce)&&typeof ce!="string"?(this.sizeMax=ce.sizeMax,ce.url):ce,$=ce=>{var Te,Re;return ce?(ke=>"video"in ke)(ce)?ce:(this.clipRect=ce.clip,this.transpose=ce.transpose,{video:{facingMode:ce.rear?"environment":"user",width:(Te=ce.size)==null?void 0:Te.width,height:(Re=ce.size)==null?void 0:Re.height,frameRate:ce.fps},audio:!1}):{video:!0,audio:!1}};delete this.sizeMax,delete this.clipRect,delete this.transpose;const ne=p!==void 0&&E(p)?A(p):await navigator.mediaDevices.getUserMedia($(p)).catch(()=>{});if(!ne)return!1;const{videoRef:xe}=this;return new Promise(ce=>{xe.onloadedmetadata=()=>{this.updateSize({width:xe.videoWidth,height:xe.videoHeight}),xe.onresize=()=>{this.updateSize({width:xe.videoWidth,height:xe.videoHeight})},xe.onseeked=()=>{this.timeShift=this.captureTime,this.captureTime=0},ce(!0)},typeof ne=="string"?xe.src=ne:xe.srcObject=ne})}dispose(){super.dispose(),this.videoRef.remove()}async start(){this.captureTime=0,this.timeShift=0,(this.videoRef.srcObject||this.videoRef.src)&&await this.videoRef.play()}pause(){this.videoRef.pause()}reset(){this.pause(),this.videoRef.srcObject&&(this.videoRef.srcObject.getTracks().forEach(p=>p.stop()),this.videoRef.srcObject=null)}capture(){const{videoRef:p,buffer:_}=this,E=p.currentTime+this.timeShift;return E<=this.captureTime?!1:(this.captureTime=E,_.capture(p))}}class Le extends V{constructor(p,_,E=Me){super(),this.engineParams=_,this.renderers=[],this.videoRatio=1920/1080,this.streamSize={width:1920,height:1080},this.processSize={width:1920,height:1080},this.resizeEnabled=!1,this.loopState=!1,this.init=async A=>{const $=await this.setupProcessor(A);return this.emit("init",$),$},this.setup=async A=>{this.pause();const $=await this.setupVideo(A);return this.emit("setup",$),$},this.start=async()=>{await this.video.start(),this.loopState=!0,this.emit("start"),this.enqueue()},this.pause=()=>{this.loopState=!1,this.loopId&&(window.cancelAnimationFrame(this.loopId),delete this.loopId),this.video.pause(),this.emit("pause")},this.reset=()=>{this.pause(),this.video.reset(),delete this.streamCanvas,delete this.processCanvas,this.processor.reset()},this.iterate=async()=>{var A;const{video:$,streamCanvas:ne,processCanvas:xe}=this;if(!$.capture()||!ne||!xe)return this.enqueue();this.resizeEnabled&&((A=this.resizeBuffer)==null||A.capture($.buffer.canvas));const ce=await this.processor.process(xe,$.captureTime);ce&&await Promise.all(this.renderers.map(Te=>Te.update(ce,ne))),this.enqueue()},this.processor=typeof p=="function"?new p:p,this.video=typeof E=="function"?new E:E,this.video.on("resize",this.resizeVideo.bind(this))}async addRenderer(p){this.renderers.push(p),await p.load(),p.setupVideo(this.video.size(),this.video.ratio()),p.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle)}removeRenderer(p){const{renderers:_}=this,E=_.indexOf(p);E<0||(_[E].dispose(),_.splice(E,1))}enqueue(){this.loopId=this.loopState?window.requestAnimationFrame(this.iterate):void 0}async setupProcessor(p){var _;const E=this.resizeEnabled&&((_=this.resizeBuffer)==null?void 0:_.size)||this.video.size();return this.processor.init(p,E,this.video.ratio())}async setupVideo(p){return this.video.reset(),await this.video.setup(p)?(this.setupSize(this.video.size()),!0):!1}async setupSize(p){var _,E;const{width:A,height:$}=p;this.videoRatio=A/$;const ne=Math.max(A,$),xe=((_=this.engineParams)==null?void 0:_.max)||this.processor.optimalSize;if(this.resizeEnabled=!1,xe<ne){this.resizeEnabled=!0;const ce=ne/xe;this.resizeBuffer||(this.resizeBuffer=new ve("resize")),this.resizeBuffer.setSize({width:A/ce,height:$/ce})}this.resizeEnabled&&this.resizeBuffer?(this.processCanvas=this.resizeBuffer.canvas,this.processSize=this.resizeBuffer.size):(this.processCanvas=this.video.buffer.canvas,this.processSize=this.video.size()),((E=this.engineParams)==null?void 0:E.orig)!==!1?(this.streamCanvas=this.video.buffer.canvas,this.streamSize=this.video.size()):(this.streamCanvas=this.processCanvas,this.streamSize=this.streamSize)}resizeVideo(p){this.setupSize(p),this.processor.setupVideo(this.processSize,this.videoRatio),this.renderers.forEach(_=>_.setupVideo(this.streamSize,this.videoRatio)),this.renderers.forEach(_=>_.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle))}}var Ue=Object.defineProperty,Ge=Object.getOwnPropertySymbols,ze=Object.prototype.hasOwnProperty,He=Object.prototype.propertyIsEnumerable,Ke=(_e,p,_)=>p in _e?Ue(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,Ye=(_e,p)=>{for(var _ in p||(p={}))ze.call(p,_)&&Ke(_e,_,p[_]);if(Ge)for(var _ of Ge(p))He.call(p,_)&&Ke(_e,_,p[_]);return _e};class $e extends V{constructor(){super(),this.params={},this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.optimalSize=1024,this.cameraRatio=this.videoRatio,this.cameraAngle=60/180*Math.PI}async process(p,_){return{}}async init(p,_,E){return this.params=p,!E&&_&&(E=_.width/_.height),this.setupVideo(_||this.videoSize,E||this.videoRatio),this.emit("init",!0),!0}reset(){this.emit("reset")}dispose(){}setupVideo(p,_){_=_||p.width/p.height,this.videoSize=Ye({},p),this.videoRatio=_,this.cameraRatio=_}}class je extends V{constructor(p,_="crop",E=1,A=!1,$=1){super(),this.container=p,this.mode=_,this.layerCount=E,this.mirror=A,this.aspectRatio=$,this.layers=[],this.padsSize=[1,1],this.setAspectRatio=ne=>{this.aspectRatio=ne,this.updateSizes(this.container.clientWidth/this.container.clientHeight)},this.setMirror=ne=>{this.mirror=ne,this.layers.forEach(xe=>{xe.style.transform=ne?"scaleX(-1)":""})},this.setMode=ne=>{if(this.mode=ne,this.mode==="pad"&&!this.pads){this.pads=[document.createElement("canvas"),document.createElement("canvas")];const xe=-10*(this.layerCount+1)+"";for(let ce=0;ce<2;ce++)this.pads[ce].id="engeenee.canvas.pad"+ce,this.pads[ce].style.position="absolute",this.pads[ce].style.zIndex=xe,this.container.appendChild(this.pads[ce])}this.mode!=="pad"&&this.pads&&(this.pads.forEach(xe=>xe.remove()),delete this.pads),this.setAspectRatio(this.aspectRatio)},this.dispose=()=>{var ne,xe;(ne=this.observer)==null||ne.disconnect(),delete this.observer,(xe=this.pads)==null||xe.forEach(ce=>ce.remove()),delete this.pads,this.layers.forEach(ce=>ce.remove()),this.layers=[]},this.updateSizes=ne=>{let xe=1,ce=1;ne>this.aspectRatio?this.mode==="crop"?ce=ne/this.aspectRatio:xe=this.aspectRatio/ne:this.mode==="crop"?xe=this.aspectRatio/ne:ce=ne/this.aspectRatio;const Te=(1-xe)/2,Re=(1-ce)/2,ke=xe*100+"%",We=ce*100+"%",Xe=Te*100+"%",xt=Re*100+"%";for(const qe of this.layers)qe.style.width=ke,qe.style.height=We,qe.style.left=Xe,qe.style.top=xt;if(this.pads){this.padsSize=Te>0?[Te,1]:[1,Re];const qe=10,{clientWidth:ht,clientHeight:Nt}=this.container,wt=[2*qe/ht,2*qe/Nt],Qt=(this.padsSize[0]+2*wt[0])*100+"%",Ht=(this.padsSize[1]+2*wt[1])*100+"%";this.pads[0].style.width=Qt,this.pads[0].style.height=Ht,this.pads[1].style.width=Qt,this.pads[1].style.height=Ht;const Wt=-wt[0]*100+"%",zt=-wt[1]*100+"%";this.pads[0].style.top=zt,this.pads[1].style.bottom=zt,this.pads[0].style.left="unset",this.pads[0].style.right="unset",this.pads[1].style.left="unset",this.pads[1].style.right="unset",this.pads[this.mirror?1:0].style.left=Wt,this.pads[this.mirror?0:1].style.right=Wt;const xi=Te>0?this.mirror?"":"scaleX(-1)":"scaleY(-1) "+(this.mirror?"scaleX(-1)":"");this.pads[0].style.transform=xi,this.pads[1].style.transform=xi;const wi="blur("+qe+"px)";this.pads[0].style.filter=wi,this.pads[1].style.filter=wi}this.emit("resize")},this.handleResize=ne=>{if(ne.length<1)return;const xe=ne[0].contentRect;this.updateSizes(xe.width/xe.height)};for(let ne=0;ne<E;ne++){const xe=document.createElement("canvas");xe.id="engeenee.canvas.layer"+ne,xe.style.position="absolute",xe.style.zIndex=-10*(E-ne)+"",this.mirror&&(xe.style.transform="scaleX(-1)"),this.container.appendChild(xe),this.layers.push(xe)}this.setMode(_),this.observer=new ResizeObserver(this.handleResize),this.observer.observe(this.container),this.container.style.overflow="hidden"}}var rt=Object.defineProperty,at=Object.getOwnPropertySymbols,Rt=Object.prototype.hasOwnProperty,lt=Object.prototype.propertyIsEnumerable,kt=(_e,p,_)=>p in _e?rt(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,qt=(_e,p)=>{for(var _ in p||(p={}))Rt.call(p,_)&&kt(_e,_,p[_]);if(at)for(var _ of at(p))lt.call(p,_)&&kt(_e,_,p[_]);return _e};class Kt extends V{constructor(){super(),this.loaded=!1,this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.cameraRatio=this.videoRatio,this.cameraAngle=10/180*Math.PI}async load(){this.loaded||(this.loaded=!0,this.emit("load"))}unload(){this.loaded&&(this.loaded=!1)}async update(p,_){this.loaded&&(this.updateVideo(_),this.updateScene(),this.emit("render"))}updateVideo(p){}updateScene(){}dispose(){this.unload()}setupVideo(p,_){this.videoSize=qt({},p),this.videoRatio=_||p.width/p.height,this.emit("resize",this.videoSize,this.videoRatio)}setupCamera(p,_){this.cameraRatio=p,this.cameraAngle=_}}class _i extends Kt{constructor(){super(...arguments),this.plugins=[]}async load(){if(!this.loaded)return await Promise.all(this.plugins.map(p=>p.load(this))),super.load()}unload(){this.plugins.forEach(p=>p.unload()),super.unload()}async update(p,_){if(this.loaded)return await this.updatePlugins(p,_),super.update(p,_)}async updatePlugins(p,_){for(let E of this.plugins)E.loaded&&await E.update(p,_)}dispose(){this.plugins.forEach(p=>p.dispose()),this.plugins=[],super.dispose()}async addPlugin(p){const{plugins:_}=this;this.loaded&&!p.loaded&&await p.load(this),_.push(p),_.sort((E,A)=>E.ordinal-A.ordinal)}removePlugin(p){const{plugins:_}=this,E=_.indexOf(p);E<0||(_[E].dispose(),_.splice(E,1))}removeAllPlugins(){this.plugins.forEach(p=>p.dispose()),this.plugins=[]}setupVideo(p,_){super.setupVideo(p,_),this.plugins.forEach(E=>E.setupVideo(p))}setupCamera(p,_){super.setupCamera(p,_),this.plugins.forEach(E=>E.setupCamera(p,_))}}class ci extends _i{constructor(p){super(),this.padCtx=[null,null],this.setupPadding=()=>{if(!this.canvas.pads)return;const{width:_,height:E}=this.videoSize,{padsSize:A}=this.canvas,$=_*A[0]/(A[0]<.5?1-2*A[0]:1),ne=E*A[1]/(A[1]<.5?1-2*A[1]:1);this.canvas.pads[0].width=$,this.canvas.pads[0].height=ne,this.canvas.pads[1].width=$,this.canvas.pads[1].height=ne},this.canvas=new je(p.container,p.mode,p.layerCount,p.mirror,p.aspectRatio),this.canvas.pads&&(this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]),this.canvas.addListener("resize",this.setupPadding)}updateVideo(p){super.updateVideo(p),this.updatePads(p)}dispose(){this.padCtx=[null,null],this.canvas.dispose(),super.dispose()}setupVideo(p,_){super.setupVideo(p,_),this.canvas.setAspectRatio(this.videoRatio)}setMirror(p){this.canvas.setMirror(p)}setMode(p){this.canvas.setMode(p),this.canvas.pads?this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]:this.padCtx=[null,null]}updatePads(p){if(!this.padCtx[0]||!this.padCtx[1]||!this.canvas.pads)return;const{videoSize:{width:_,height:E}}=this,{width:A,height:$}=this.canvas.pads[0];this.padCtx[0].clearRect(0,0,A,$),this.padCtx[0].drawImage(p,0,0,A,$,0,0,A,$),this.padCtx[1].clearRect(0,0,A,$),this.padCtx[1].drawImage(p,_-A,E-$,A,$,0,0,A,$)}}class li extends null{constructor(p){super(p),this.videoCtx=null;const _=this.canvas.layers[0];this.videoCtx=_.getContext("2d")}updateVideo(p){const{videoCtx:_}=this;if(!_)return;const{width:E,height:A}=this.videoSize;_.clearRect(0,0,E,A),_.drawImage(p,0,0),super.updateVideo(p)}setupVideo(p,_){super.setupVideo(p,_);const{width:E,height:A}=this.videoSize;this.canvas.layers[0].width=E,this.canvas.layers[0].height=A}}class qi{constructor(p,_={width:1920,height:1080},E=!1,A=!1){this.gl=p,this.size=_,this.grayscale=E,this.linear=A,this.buffer=null,this.resize(_)}update(p){const{gl:_,size:{width:E,height:A}}=this,$=_.getParameter(_.TEXTURE_BINDING_2D),ne=_.getParameter(_.UNPACK_FLIP_Y_WEBGL);return _.bindTexture(_.TEXTURE_2D,this.buffer),_.pixelStorei(_.UNPACK_FLIP_Y_WEBGL,!1),p instanceof Float32Array?_.texSubImage2D(_.TEXTURE_2D,0,0,0,E,A,this.grayscale?_.RED:_.RGBA,_.FLOAT,p):p instanceof Uint8Array?_.texSubImage2D(_.TEXTURE_2D,0,0,0,E,A,this.grayscale?_.RED:_.RGBA,_.UNSIGNED_BYTE,p):_.texSubImage2D(_.TEXTURE_2D,0,0,0,E,A,this.grayscale?_.RED:_.RGBA,_.UNSIGNED_BYTE,p),_.bindTexture(_.TEXTURE_2D,$),_.pixelStorei(_.UNPACK_FLIP_Y_WEBGL,ne),this.buffer}resize(p){const{width:_,height:E}=p;if(_===this.size.width&&E===this.size.height&&this.buffer)return!0;const{gl:A}=this;if(A.deleteTexture(this.buffer),this.buffer=null,(_>0||E>0)&&(this.buffer=A.createTexture()),!this.buffer)return!1;const $=this.linear?A.LINEAR:A.NEAREST,ne=A.getParameter(A.TEXTURE_BINDING_2D),xe=A.getParameter(A.UNPACK_FLIP_Y_WEBGL);return A.bindTexture(A.TEXTURE_2D,this.buffer),A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL,!1),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_R,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_S,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_T,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MIN_FILTER,$),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MAG_FILTER,$),this.size={width:_,height:E},A.texStorage2D(A.TEXTURE_2D,4,this.grayscale?A.R8:A.RGBA8,_,E),A.bindTexture(A.TEXTURE_2D,ne),A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL,xe),!0}dispose(){this.gl.deleteTexture(this.buffer),this.buffer=null}texture(){return this.buffer}valid(){return!!this.buffer}}var Ki=Object.defineProperty,hs=Object.getOwnPropertySymbols,Yi=Object.prototype.hasOwnProperty,ns=Object.prototype.propertyIsEnumerable,Gs=(_e,p,_)=>p in _e?Ki(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,Xs=(_e,p)=>{for(var _ in p||(p={}))Yi.call(p,_)&&Gs(_e,_,p[_]);if(hs)for(var _ of hs(p))ns.call(p,_)&&Gs(_e,_,p[_]);return _e};class $i{constructor(p,_={width:1920,height:1080},E=["image"],A={},$=hi,ne=xs,xe=!1,ce=!1){this.gl=p,this.size=_,this.inputs=E,this.uniforms=A,this.vertShader=null,this.fragShader=null,this.shaderProgram=null,this.vertBuffer=null,this.vertAttrs=null,this.uniformsLoc={},this.frameBuffer=null,$.includes("uniform vec2 wh;")&&!A.wh&&(A.wh="2f"),ne.includes("uniform float flip;")&&!A.flip&&(A.flip="1f"),this.outputTexture=new qi(p,_,xe,ce),this.compile($,ne),this.resize(_)}process(p,_={}){const{gl:E,outputTexture:A}=this;if(!E||!A||p.length!==this.inputs.length)return null;const $=A.texture();if(!$)return null;const ne=this.save(E);return E.bindFramebuffer(E.FRAMEBUFFER,this.frameBuffer),E.framebufferTexture2D(E.FRAMEBUFFER,E.COLOR_ATTACHMENT0,E.TEXTURE_2D,$,0),_=Xs({flip:[-1]},_),this.prepare(E,p,_),E.drawArrays(E.TRIANGLES,0,6),this.restore(E,ne),$}render(p,_={}){const{gl:E,outputTexture:A}=this;if(!E||!A||p.length!==this.inputs.length)return;const $=this.save(E);E.bindFramebuffer(E.FRAMEBUFFER,null),_=Xs({flip:[1]},_),this.prepare(E,p,_),E.drawArrays(E.TRIANGLES,0,6),this.restore(E,$)}output(){var p;return((p=this.outputTexture)==null?void 0:p.texture())||null}program(){return this.shaderProgram}resize(p){var _;const{gl:E}=this;this.size=Xs({},p),(_=this.outputTexture)==null||_.resize(p);const A=E.getParameter(E.CURRENT_PROGRAM);E.useProgram(this.shaderProgram),this.uniformsLoc.wh&&E.uniform2f(this.uniformsLoc.wh,p.width,p.height),E.useProgram(A)}setUniform(p,_){const{gl:E}=this,A=E.getParameter(E.CURRENT_PROGRAM);E.useProgram(this.shaderProgram),this.setUniformUnsafe(p,_),E.useProgram(A)}dispose(){var p;const{gl:_}=this;_.deleteBuffer(this.vertBuffer),this.vertBuffer=null,_.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,_.deleteShader(this.vertShader),this.vertShader=null,_.deleteShader(this.fragShader),this.fragShader=null,_.deleteProgram(this.shaderProgram),this.shaderProgram=null,(p=this.outputTexture)==null||p.dispose(),delete this.outputTexture}compile(p,_){const{gl:E}=this,A=this.save(E);if(this.vertBuffer=E.createBuffer(),this.vertAttrs=E.createVertexArray(),this.frameBuffer=E.createFramebuffer(),!this.vertBuffer||!this.frameBuffer||!this.vertAttrs){E.deleteBuffer(this.vertBuffer),this.vertBuffer=null,E.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,E.deleteVertexArray(this.vertAttrs),this.vertAttrs=null;return}if(this.vertShader=E.createShader(E.VERTEX_SHADER),this.fragShader=E.createShader(E.FRAGMENT_SHADER),this.shaderProgram=E.createProgram(),!this.vertShader||!this.fragShader||!this.shaderProgram){E.deleteBuffer(this.vertBuffer),this.vertBuffer=null,E.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,E.deleteShader(this.vertShader),this.vertShader=null,E.deleteShader(this.fragShader),this.fragShader=null,E.deleteProgram(this.shaderProgram),this.shaderProgram=null;return}E.shaderSource(this.vertShader,_),E.shaderSource(this.fragShader,p),E.compileShader(this.vertShader),E.compileShader(this.fragShader),E.attachShader(this.shaderProgram,this.vertShader),E.attachShader(this.shaderProgram,this.fragShader),E.linkProgram(this.shaderProgram),E.useProgram(this.shaderProgram),E.bindBuffer(E.ARRAY_BUFFER,this.vertBuffer),E.bufferData(E.ARRAY_BUFFER,new Float32Array([-1,-1,1,1,-1,1,-1,-1,1,-1,1,1]),E.STATIC_DRAW),E.bindVertexArray(this.vertAttrs);const $=E.getAttribLocation(this.shaderProgram,"pos");E.vertexAttribPointer($,2,E.FLOAT,!1,0,0),E.enableVertexAttribArray($),this.uniformsLoc={};for(let ne in this.uniforms)this.uniformsLoc[ne]=E.getUniformLocation(this.shaderProgram,ne);for(let ne=0;ne<this.inputs.length;ne++)E.uniform1i(E.getUniformLocation(this.shaderProgram,this.inputs[ne]),ne);this.restore(E,A)}prepare(p,_,E={}){const{size:{width:A,height:$}}=this;for(let ne=0;ne<_.length;ne++)p.activeTexture(p.TEXTURE0+ne),p.bindTexture(p.TEXTURE_2D,_[ne]);p.useProgram(this.shaderProgram),p.bindVertexArray(this.vertAttrs);for(let ne in E)this.setUniformUnsafe(ne,E[ne]);p.disable(p.CULL_FACE),p.colorMask(!0,!0,!0,!0),p.viewport(0,0,A,$),p.scissor(0,0,A,$),p.clear(p.COLOR_BUFFER_BIT)}save(p){return{program:p.getParameter(p.CURRENT_PROGRAM),arrayBuffer:p.getParameter(p.ARRAY_BUFFER_BINDING),framebuffer:p.getParameter(p.FRAMEBUFFER_BINDING),vertexArray:p.getParameter(p.VERTEX_ARRAY_BINDING),viewport:p.getParameter(p.VIEWPORT),scissor:p.getParameter(p.SCISSOR_BOX),colorMask:p.getParameter(p.COLOR_WRITEMASK),cullFace:p.getParameter(p.CULL_FACE),activeTexture:p.getParameter(p.ACTIVE_TEXTURE),textures:this.inputs.map((_,E)=>(p.activeTexture(p.TEXTURE0+E),p.getParameter(p.TEXTURE_BINDING_2D)))}}restore(p,_){p.useProgram(_.program),p.bindBuffer(p.ARRAY_BUFFER,_.arrayBuffer),p.bindFramebuffer(p.FRAMEBUFFER,_.framebuffer),p.bindVertexArray(_.vertexArray),p.viewport(_.viewport[0],_.viewport[1],_.viewport[2],_.viewport[3]),p.scissor(_.scissor[0],_.scissor[1],_.scissor[2],_.scissor[3]),p.colorMask(_.colorMask[0],_.colorMask[1],_.colorMask[2],_.colorMask[3]);for(let E=0;E<_.textures.length;E++)p.activeTexture(p.TEXTURE0+E),p.bindTexture(p.TEXTURE_2D,_.textures[E]);p.activeTexture(_.activeTexture),_.cullFace?p.enable(p.CULL_FACE):p.disable(p.CULL_FACE)}setUniformUnsafe(p,_){const E=this.uniformsLoc[p];if(!E)return;const{gl:A}=this;switch(this.uniforms[p]){case"1f":_.length===1&&A.uniform1f(E,_[0]);break;case"2f":_.length===2&&A.uniform2f(E,_[0],_[1]);break;case"3f":_.length===3&&A.uniform3f(E,_[0],_[1],_[2]);break;case"4f":_.length===4&&A.uniform4f(E,_[0],_[1],_[2],_[3]);break;case"1fv":A.uniform1fv(E,_);break;case"2fv":A.uniform2fv(E,_);break;case"3fv":A.uniform3fv(E,_);break;case"4fv":A.uniform4fv(E,_);break}}}const xs=`
    attribute vec2 pos;
    uniform float flip;
    varying vec2 xy;
    void main() {
        xy = (vec2(pos.x, -pos.y) + 1.0) * 0.5;
        gl_Position = vec4(pos.x, pos.y * flip, 0, 1.0);
    }
`,hi=`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform sampler2D image;
    void main() {
        gl_FragColor = texture2D(image, xy);
    }
`;class Ri extends ci{constructor(p){super(p),this.shaderCtx=null,this.current=null;const _=this.canvas.layers[0];this.shaderCtx=_.getContext("webgl2",{alpha:!0,preserveDrawingBuffer:!0})}async load(){if(this.loaded)return;const{shaderCtx:p,videoSize:_}=this;if(p)return this.shader=new $i(p,_),this.input=new qi(p,_),super.load()}unload(){var p,_;(p=this.input)==null||p.dispose(),delete this.input,(_=this.shader)==null||_.dispose(),delete this.shader,super.unload()}async update(p,_){if(!this.loaded)return;const{input:E}=this,A=E?.texture();if(!(!E||!A))return E.update(_),this.current=A,super.update(p,_)}updateVideo(p){this.shader&&(this.shader.render([this.current]),super.updateVideo(p))}setupVideo(p,_){var E,A;super.setupVideo(p,_);const{width:$,height:ne}=this.videoSize;this.canvas.layers[0].width=$,this.canvas.layers[0].height=ne,(E=this.input)==null||E.resize({width:$,height:ne}),(A=this.shader)==null||A.resize({width:$,height:ne})}}class Wi extends Ri{dispose(){delete this.scene,super.dispose()}}class us{constructor(){this.loaded=!1,this.ordinal=800}async load(p){this.loaded||(this.renderer=p,this.loaded=!0)}unload(){this.loaded&&(this.loaded=!1)}async update(p,_){this.loaded}dispose(){this.unload()}setupVideo(p){}setupCamera(p,_){}}var Ks=(_e=>(_e[_e.PreProcess=100]="PreProcess",_e[_e.Process=200]="Process",_e[_e.PostProcess=300]="PostProcess",_e[_e.PreRender=700]="PreRender",_e[_e.Render=800]="Render",_e[_e.PostRender=900]="PostRender",_e))(Ks||{});class ur extends null{constructor(){super(),this.ordinal=Ks.PreRender}async load(p){if(!(this.loaded||!(p instanceof li)||!p.videoCtx))return this.videoCtx=p.videoCtx,super.load(p)}unload(){this.loaded&&(delete this.videoCtx,super.unload())}}var js=Object.defineProperty,sr=Object.getOwnPropertySymbols,cr=Object.prototype.hasOwnProperty,ln=Object.prototype.propertyIsEnumerable,kr=(_e,p,_)=>p in _e?js(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,$r=(_e,p)=>{for(var _ in p||(p={}))cr.call(p,_)&&kr(_e,_,p[_]);if(sr)for(var _ of sr(p))ln.call(p,_)&&kr(_e,_,p[_]);return _e};class Rn extends null{constructor(p,_,E,A){super(),this.inputs=p,this.uniforms=_,this.fragSrc=E,this.vertSrc=A,this.size={width:0,height:0},this.ordinal=Ks.PreRender}async load(p){if(!(this.loaded||!(p instanceof Ri)||!p.shaderCtx))return this.shaderCtx=p.shaderCtx,this.shader=new $i(this.shaderCtx,this.size,this.inputs,this.uniforms,this.fragSrc,this.vertSrc),super.load(p)}unload(){var p;this.loaded&&((p=this.shader)==null||p.dispose(),delete this.shader,delete this.shaderCtx,super.unload())}async update(p,_){var E;const{renderer:A}=this;if(!this.loaded||!(A instanceof Ri)||!A.current)return;const $=await this.process(p,A.current)&&((E=this.shader)==null?void 0:E.output());$&&(A.current=$)}async process(p,_){var E;return(E=this.shader)==null||E.process([_]),!0}setupVideo(p){var _;this.size=$r({},p),(_=this.shader)==null||_.resize(p)}}class Ln extends us{constructor(){super(),this.ordinal=Ks.Render}async load(p){if(!(this.loaded||!(p instanceof Wi)||!p.scene))return this.scene=p.scene,super.load(p)}unload(){this.loaded&&(delete this.scene,super.unload())}}class zn{constructor(p,_=!1,E="video",A){this.renderer=p,this.mirror=_,this.sizeMode=E,this.sizeMax=A}async snapshot(){return new Promise(p=>{this.renderer.once("render",()=>{const{renderer:_}=this,{layers:E}=_.canvas;let{width:A,height:$}=_.canvas.layers[0];this.sizeMode==="max"?(A=Math.max(...E.map(Te=>Te.width)),$=Math.max(...E.map(Te=>Te.height))):this.sizeMode==="min"&&(A=Math.min(...E.map(Te=>Te.width)),$=Math.min(...E.map(Te=>Te.height)));const ne=document.createElement("canvas");ne.id="engeenee.snapshot",ne.hidden=!0,ne.width=A,ne.height=$;const xe=ne.getContext("2d",{alpha:!0});if(!xe)return;this.mirror&&(xe.translate(A,0),xe.scale(-1,1)),E.forEach(Te=>xe.drawImage(Te,0,0,A,$));const ce=xe.getImageData(0,0,A,$);ne.remove(),p(ce)})})}async snapshotLayers(){return new Promise(p=>{this.renderer.once("render",()=>{const _=document.createElement("canvas");_.id="engeenee.snapshot",_.hidden=!0;const E=_.getContext("2d",{alpha:!0});if(!E)return;const A=this.renderer.canvas.layers.map($=>{const{width:ne,height:xe}=$;return _.width=ne,_.height=xe,E.resetTransform(),this.mirror&&(E.translate(ne,0),E.scale(-1,1)),E.drawImage($,0,0),E.getImageData(0,0,ne,xe)});_.remove(),p(A)})})}}class ra{constructor(p,_="video/webm",E=!1,A="video",$,ne){this.renderer=p,this.type=_,this.mirror=E,this.sizeMode=A,this.sizeMax=$,this.bitRate=ne,this.context=null,this.records=[],this.frame=()=>{var xe;const{renderer:ce,context:Te,stream:Re}=this,{width:ke,height:We}=this.canvas;!Re||!Te||(ce.canvas.layers.map(Xe=>Te.drawImage(Xe,0,0,ke,We)),(xe=Re.getVideoTracks()[0])==null||xe.requestFrame())},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:p,context:_,renderer:E}=this;if(!p||!_)return!1;const{layers:A}=E.canvas;let{width:$,height:ne}=A[0];this.sizeMode==="max"?($=Math.max(...A.map(ce=>ce.width)),ne=Math.max(...A.map(ce=>ce.height))):this.sizeMode==="min"&&($=Math.min(...A.map(ce=>ce.width)),ne=Math.min(...A.map(ce=>ce.height)));const xe=Math.max($,ne);if(this.sizeMax&&xe>this.sizeMax){const ce=this.sizeMax/xe;$*=ce,ne*=ce}return p.width=$,p.height=ne,_.resetTransform(),this.mirror&&(_.translate($,0),_.scale(-1,1)),E.on("render",this.frame),this.records=[],this.stream=p.captureStream(0),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=ce=>this.records.push(ce.data),this.recorder.start(),!0}async stop(){const{recorder:p}=this;if(!(!p||p.state!="recording"))return new Promise(_=>{p.onstop=()=>{var E;_(new Blob(this.records,{type:this.type})),this.records=[],(E=this.stream)==null||E.getVideoTracks().forEach(A=>A.stop()),this.renderer.removeListener("render",this.frame),delete this.stream,delete this.recorder},p.stop()})}dispose(){this.canvas.remove()}}class aa{constructor(p,_=0,E="video/webm",A){this.renderer=p,this.layer=_,this.type=E,this.bitRate=A,this.records=[]}start(){const{renderer:p}=this,_=p.canvas.layers[this.layer];return this.records=[],this.stream=_.captureStream(),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=E=>this.records.push(E.data),this.recorder.start(),!0}async stop(){const{recorder:p}=this;if(!(!p||p.state!="recording"))return new Promise(_=>{p.onstop=()=>{var E;_(new Blob(this.records,{type:this.type})),this.records=[],(E=this.stream)==null||E.getVideoTracks().forEach(A=>A.stop()),delete this.stream,delete this.recorder},p.stop()})}}class ps{constructor(p,_=!1,E="video",A){this.renderer=p,this.mirror=_,this.sizeMode=E,this.sizeMax=A,this.context=null,this.render=()=>{const{canvas:$,context:ne}=this;!$||!ne||this.renderer.canvas.layers.map(xe=>ne.drawImage(xe,0,0,$.width,$.height))},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.mirror&&(this.canvas.style.transform="scaleX(-1)"),this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:p,context:_,renderer:E}=this;if(!p||!_)return!1;const{layers:A}=E.canvas;let{width:$,height:ne}=A[0];this.sizeMode==="max"?($=Math.max(...A.map(ce=>ce.width)),ne=Math.max(...A.map(ce=>ce.height))):this.sizeMode==="min"&&($=Math.min(...A.map(ce=>ce.width)),ne=Math.min(...A.map(ce=>ce.height)));const xe=Math.max($,ne);if(this.sizeMax&&xe>this.sizeMax){const ce=this.sizeMax/xe;$*=ce,ne*=ce}return p.width=$,p.height=ne,_.resetTransform(),this.mirror&&(_.translate($,0),_.scale(-1,1)),this.renderer.on("render",this.render),this.stream=p.captureStream(),!0}pause(){this.renderer.removeListener("render",this.render)}mediaStream(){return this.stream}}class l0 extends null{constructor(){super(...arguments),this.faceTracker=new g,this.cameraAngleBase=10/180*Math.PI}async init(p,_,E){return await this.faceTracker.init(p.token,p.root,p.cache,p.highP,p.mask,p.maskExt,p.maskSize),await this.faceTracker.prepare(),super.init(p,_,E)}reset(){this.faceTracker.reset(),super.reset()}dispose(){this.faceTracker.dispose()}async process(p,_){return{faces:(await this.faceTracker.process(p,_)).map(E=>{const{keypoints:A,mask:$,score:ne}=E,xe=E&&this.params.transform?this.faceTracker.align(E.keypoints):void 0,ce=xe&&this.params.metric?this.faceTracker.metricPoints():void 0,Te=xe&&this.params.backproj?this.faceTracker.backprojPoints():void 0;return{pixel:A,metric:ce,backproj:Te,transform:xe,mask:$,score:ne}})}}setupVideo(p,_){super.setupVideo(p,_),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.faceTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.faceTracker.reset()}}class Ro extends null{constructor(p,_=s){super(l0,p,_)}}class rx extends $e{constructor(){super(),this.poseTracker=new Z.Xv,this.cameraAngleBase=15/180*Math.PI;const p=/iPhone|iPad|iPod/i.test(navigator.userAgent);this.optimalSize=p?512:1024}async init(p,_,E){return await this.poseTracker.init(p.token,p.root,p.cache,p.mask),await this.poseTracker.prepare(),super.init(p,_,E)}reset(){return this.poseTracker.reset(),super.reset()}dispose(){this.poseTracker.dispose()}async process(p,_){return{poses:(await this.poseTracker.process(p,_)).map(E=>({points:hn(A=>E.keypoints[Wo[A]]),score:E.score,mask:E.mask,timestamp:_,debug:E.debug}))}}setupVideo(p,_){super.setupVideo(p,_),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.poseTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.poseTracker.reset()}}class Ma extends Le{constructor(p,_=Me){super(rx,p,_)}}const pn=["nose","eyeInnerL","eyeL","eyeOutterL","eyeInnerR","eyeR","eyeOutterR","earL","earR","mouthL","mouthR","shoulderL","shoulderR","elbowL","elbowR","wristL","wristR","pinkyL","pinkyR","indexL","indexR","thumbL","thumbR","hipL","hipR","kneeL","kneeR","ankleL","ankleR","heelL","heelR","footIndexL","footIndexR"];function jr(_e,p){return Object.fromEntries(p.map(_=>[_,_e(_)]))}const uo=(_e,p)=>jr(_e,p),hn=_e=>jr(_e,pn),Wo=hn(_e=>pn.indexOf(_e));class c0 extends null{constructor(){super(...arguments),this.handTracker=new W,this.cameraAngleBase=10/180*Math.PI}async init(p,_,E){return await this.handTracker.init(p.token,p.root,p.cache),await this.handTracker.prepare(),super.init(p,_,E)}reset(){this.handTracker.reset(),super.reset()}dispose(){this.handTracker.dispose()}async process(p,_){return{hands:(await this.handTracker.process(p,_)).map(E=>({points:E.keypoints,score:E.score,handedness:E.handedness,wrist:E.wrist}))}}setupVideo(p,_){super.setupVideo(p,_),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.handTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.handTracker.reset()}}class U0 extends null{constructor(p,_=s){super(c0,p,_)}}class U2 extends null{constructor(){super(...arguments),this.maskTracker=new Q}async init(p,_,E){return await this.maskTracker.init(p.token,p.root,p.cache,p.smooth,p.masksm),await this.maskTracker.prepare(),super.init(p,_,E)}reset(){this.maskTracker.reset(),super.reset()}dispose(){this.maskTracker.dispose()}async process(p,_){return{masks:(await this.maskTracker.process(p,_)).map(E=>({mask:E}))}}}class kh extends null{constructor(p,_=s){super(U2,p,_)}}class $x{constructor(p,_=!1,E,A){this.initialize(p,_,E,A)}initialize(p,_=!1,E,A){return this.mask=p,this.skipNextObservers=_,this.target=E,this.currentTarget=A,this}}class Tl{constructor(p,_,E=null){this.callback=p,this.mask=_,this.scope=E,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(){this._remove&&this._remove()}}class Mi{static FromPromise(p,_){const E=new Mi;return p.then(A=>{E.notifyObservers(A)}).catch(A=>{if(_)_.notifyObservers(A);else throw A}),E}get observers(){return this._observers}constructor(p,_=!1){this.notifyIfTriggered=_,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new $x(0),p&&(this._onObserverAdded=p)}add(p,_=-1,E=!1,A=null,$=!1){if(!p)return null;const ne=new Tl(p,_,A);return ne.unregisterOnNextCall=$,E?this._observers.unshift(ne):this._observers.push(ne),this._onObserverAdded&&this._onObserverAdded(ne),this._hasNotified&&this.notifyIfTriggered&&this._lastNotifiedValue!==void 0&&this.notifyObserver(ne,this._lastNotifiedValue),ne._remove=()=>{this.remove(ne)},ne}addOnce(p){return this.add(p,void 0,void 0,void 0,!0)}remove(p){return p?(p._remove=null,this._observers.indexOf(p)!==-1?(this._deferUnregister(p),!0):!1):!1}removeCallback(p,_){for(let E=0;E<this._observers.length;E++){const A=this._observers[E];if(!A._willBeUnregistered&&A.callback===p&&(!_||_===A.scope))return this._deferUnregister(A),!0}return!1}_deferUnregister(p){p._willBeUnregistered||(this._numObserversMarkedAsDeleted++,p.unregisterOnNextCall=!1,p._willBeUnregistered=!0,setTimeout(()=>{this._remove(p)},0))}_remove(p,_=!0){if(!p)return!1;const E=this._observers.indexOf(p);return E!==-1?(_&&this._numObserversMarkedAsDeleted--,this._observers.splice(E,1),!0):!1}makeObserverTopPriority(p){this._remove(p,!1),this._observers.unshift(p)}makeObserverBottomPriority(p){this._remove(p,!1),this._observers.push(p)}notifyObservers(p,_=-1,E,A,$){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=p),!this._observers.length)return!0;const ne=this._eventState;ne.mask=_,ne.target=E,ne.currentTarget=A,ne.skipNextObservers=!1,ne.lastReturnValue=p,ne.userInfo=$;for(const xe of this._observers)if(!xe._willBeUnregistered&&(xe.mask&_&&(xe.unregisterOnNextCall&&this._deferUnregister(xe),xe.scope?ne.lastReturnValue=xe.callback.apply(xe.scope,[p,ne]):ne.lastReturnValue=xe.callback(p,ne)),ne.skipNextObservers))return!1;return!0}notifyObserver(p,_,E=-1){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=_),p._willBeUnregistered)return;const A=this._eventState;A.mask=E,A.skipNextObservers=!1,p.unregisterOnNextCall&&this._deferUnregister(p),p.callback(_,A)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const p=this._observers.pop();p&&(p._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const p=new Mi;return p._observers=this._observers.slice(0),p}hasSpecificMask(p=-1){for(const _ of this._observers)if(_.mask&p||_.mask===p)return!0;return!1}}class Uh{get wrapU(){return this._cachedWrapU}set wrapU(p){this._cachedWrapU=p}get wrapV(){return this._cachedWrapV}set wrapV(p){this._cachedWrapV=p}get wrapR(){return this._cachedWrapR}set wrapR(p){this._cachedWrapR=p}get anisotropicFilteringLevel(){return this._cachedAnisotropicFilteringLevel}set anisotropicFilteringLevel(p){this._cachedAnisotropicFilteringLevel=p}get comparisonFunction(){return this._comparisonFunction}set comparisonFunction(p){this._comparisonFunction=p}get useMipMaps(){return this._useMipMaps}set useMipMaps(p){this._useMipMaps=p}constructor(){this.samplingMode=-1,this._useMipMaps=!0,this._cachedWrapU=null,this._cachedWrapV=null,this._cachedWrapR=null,this._cachedAnisotropicFilteringLevel=null,this._comparisonFunction=0}setParameters(p=1,_=1,E=1,A=1,$=2,ne=0){return this._cachedWrapU=p,this._cachedWrapV=_,this._cachedWrapR=E,this._cachedAnisotropicFilteringLevel=A,this.samplingMode=$,this._comparisonFunction=ne,this}compareSampler(p){return this._cachedWrapU===p._cachedWrapU&&this._cachedWrapV===p._cachedWrapV&&this._cachedWrapR===p._cachedWrapR&&this._cachedAnisotropicFilteringLevel===p._cachedAnisotropicFilteringLevel&&this.samplingMode===p.samplingMode&&this._comparisonFunction===p._comparisonFunction&&this._useMipMaps===p._useMipMaps}}var Gn;(function(_e){_e[_e.Unknown=0]="Unknown",_e[_e.Url=1]="Url",_e[_e.Temp=2]="Temp",_e[_e.Raw=3]="Raw",_e[_e.Dynamic=4]="Dynamic",_e[_e.RenderTarget=5]="RenderTarget",_e[_e.MultiRenderTarget=6]="MultiRenderTarget",_e[_e.Cube=7]="Cube",_e[_e.CubeRaw=8]="CubeRaw",_e[_e.CubePrefiltered=9]="CubePrefiltered",_e[_e.Raw3D=10]="Raw3D",_e[_e.Raw2DArray=11]="Raw2DArray",_e[_e.DepthStencil=12]="DepthStencil",_e[_e.CubeRawRGBD=13]="CubeRawRGBD",_e[_e.Depth=14]="Depth"})(Gn||(Gn={}));class u0 extends Uh{get useMipMaps(){return this.generateMipMaps}set useMipMaps(p){this.generateMipMaps=p}get uniqueId(){return this._uniqueId}_setUniqueId(p){this._uniqueId=p}getEngine(){return this._engine}get source(){return this._source}constructor(p,_,E=!1){super(),this.isReady=!1,this.isCube=!1,this.is3D=!1,this.is2DArray=!1,this.isMultiview=!1,this.url="",this.generateMipMaps=!1,this.samples=0,this.type=-1,this.format=-1,this.onLoadedObservable=new Mi,this.onErrorObservable=new Mi,this.onRebuildCallback=null,this.width=0,this.height=0,this.depth=0,this.baseWidth=0,this.baseHeight=0,this.baseDepth=0,this.invertY=!1,this._invertVScale=!1,this._associatedChannel=-1,this._source=Gn.Unknown,this._buffer=null,this._bufferView=null,this._bufferViewArray=null,this._bufferViewArrayArray=null,this._size=0,this._extension="",this._files=null,this._workingCanvas=null,this._workingContext=null,this._cachedCoordinatesMode=null,this._isDisabled=!1,this._compression=null,this._sphericalPolynomial=null,this._sphericalPolynomialPromise=null,this._sphericalPolynomialComputed=!1,this._lodGenerationScale=0,this._lodGenerationOffset=0,this._useSRGBBuffer=!1,this._creationFlags=0,this._lodTextureHigh=null,this._lodTextureMid=null,this._lodTextureLow=null,this._isRGBD=!1,this._linearSpecularLOD=!1,this._irradianceTexture=null,this._hardwareTexture=null,this._maxLodLevel=null,this._references=1,this._gammaSpace=null,this._premulAlpha=!1,this._dynamicTextureSource=null,this._engine=p,this._source=_,this._uniqueId=u0._Counter++,E||(this._hardwareTexture=p._createHardwareTexture())}incrementReferences(){this._references++}updateSize(p,_,E=1){this._engine.updateTextureDimensions(this,p,_,E),this.width=p,this.height=_,this.depth=E,this.baseWidth=p,this.baseHeight=_,this.baseDepth=E,this._size=p*_*E}_rebuild(){if(this.isReady=!1,this._cachedCoordinatesMode=null,this._cachedWrapU=null,this._cachedWrapV=null,this._cachedWrapR=null,this._cachedAnisotropicFilteringLevel=null,this.onRebuildCallback){const _=this.onRebuildCallback(this),E=A=>{A._swapAndDie(this,!1),this.isReady=_.isReady};_.isAsync?_.proxy.then(E):E(_.proxy);return}let p;switch(this.source){case Gn.Temp:break;case Gn.Url:p=this._engine.createTexture(this._originalUrl??this.url,!this.generateMipMaps,this.invertY,null,this.samplingMode,_=>{_._swapAndDie(this,!1),this.isReady=!0},null,this._buffer,void 0,this.format,this._extension,void 0,void 0,void 0,this._useSRGBBuffer);return;case Gn.Raw:p=this._engine.createRawTexture(this._bufferView,this.baseWidth,this.baseHeight,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type,this._creationFlags,this._useSRGBBuffer),p._swapAndDie(this,!1),this.isReady=!0;break;case Gn.Raw3D:p=this._engine.createRawTexture3D(this._bufferView,this.baseWidth,this.baseHeight,this.baseDepth,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type),p._swapAndDie(this,!1),this.isReady=!0;break;case Gn.Raw2DArray:p=this._engine.createRawTexture2DArray(this._bufferView,this.baseWidth,this.baseHeight,this.baseDepth,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type),p._swapAndDie(this,!1),this.isReady=!0;break;case Gn.Dynamic:p=this._engine.createDynamicTexture(this.baseWidth,this.baseHeight,this.generateMipMaps,this.samplingMode),p._swapAndDie(this,!1),this._dynamicTextureSource&&this._engine.updateDynamicTexture(this,this._dynamicTextureSource,this.invertY,this._premulAlpha,this.format,!0);break;case Gn.Cube:p=this._engine.createCubeTexture(this.url,null,this._files,!this.generateMipMaps,()=>{p._swapAndDie(this,!1),this.isReady=!0},null,this.format,this._extension,!1,0,0,null,void 0,this._useSRGBBuffer);return;case Gn.CubeRaw:p=this._engine.createRawCubeTexture(this._bufferViewArray,this.width,this._originalFormat??this.format,this.type,this.generateMipMaps,this.invertY,this.samplingMode,this._compression),p._swapAndDie(this,!1),this.isReady=!0;break;case Gn.CubeRawRGBD:return;case Gn.CubePrefiltered:p=this._engine.createPrefilteredCubeTexture(this.url,null,this._lodGenerationScale,this._lodGenerationOffset,_=>{_&&_._swapAndDie(this,!1),this.isReady=!0},null,this.format,this._extension),p._sphericalPolynomial=this._sphericalPolynomial;return;case Gn.DepthStencil:case Gn.Depth:break}}_swapAndDie(p,_=!0){this._hardwareTexture?.setUsage(p._source,this.generateMipMaps,this.is2DArray,this.isCube,this.is3D,this.width,this.height,this.depth),p._hardwareTexture=this._hardwareTexture,_&&(p._isRGBD=this._isRGBD),this._lodTextureHigh&&(p._lodTextureHigh&&p._lodTextureHigh.dispose(),p._lodTextureHigh=this._lodTextureHigh),this._lodTextureMid&&(p._lodTextureMid&&p._lodTextureMid.dispose(),p._lodTextureMid=this._lodTextureMid),this._lodTextureLow&&(p._lodTextureLow&&p._lodTextureLow.dispose(),p._lodTextureLow=this._lodTextureLow),this._irradianceTexture&&(p._irradianceTexture&&p._irradianceTexture.dispose(),p._irradianceTexture=this._irradianceTexture);const E=this._engine.getLoadedTexturesCache();let A=E.indexOf(this);A!==-1&&E.splice(A,1),A=E.indexOf(p),A===-1&&E.push(p)}dispose(){this._references--,this.onLoadedObservable.clear(),this.onErrorObservable.clear(),this._references===0&&(this._engine._releaseTexture(this),this._hardwareTexture=null,this._dynamicTextureSource=null)}}u0._Counter=0;function wa(){return typeof window<"u"}function Ho(){return typeof navigator<"u"}function px(){return typeof document<"u"}function Y0(_e){let p="",_=_e.firstChild;for(;_;)_.nodeType===3&&(p+=_.textContent),_=_.nextSibling;return p}const $l={IsWindowObjectExist:wa,IsNavigatorAvailable:Ho,IsDocumentAvailable:px,GetDOMTextContent:Y0};class wr{static get LastCreatedEngine(){return this.Instances.length===0?null:this.Instances[this.Instances.length-1]}static get LastCreatedScene(){return this._LastCreatedScene}}wr.Instances=[],wr.OnEnginesDisposedObservable=new Mi,wr._LastCreatedScene=null,wr.UseFallbackTexture=!0,wr.FallbackTexture="";const rl={};function Tr(_e,p=!1){if(!(p&&rl[_e]))return rl[_e]=!0,`${_e} needs to be imported before as it contains a side-effect required by your code.`}class vi{static _CheckLimit(p,_){let E=vi._LogLimitOutputs[p];return E?E.current++:(E={limit:_,current:1},vi._LogLimitOutputs[p]=E),E.current<=E.limit}static _GenerateLimitMessage(p,_=1){const E=vi._LogLimitOutputs[p];if(!E||!vi.MessageLimitReached)return;const A=this._Levels[_];E.current===E.limit&&vi[A.name](vi.MessageLimitReached.replace(/%LIMIT%/g,""+E.limit).replace(/%TYPE%/g,A.name??""))}static _AddLogEntry(p){vi._LogCache=p+vi._LogCache,vi.OnNewCacheEntry&&vi.OnNewCacheEntry(p)}static _FormatMessage(p){const _=A=>A<10?"0"+A:""+A,E=new Date;return"["+_(E.getHours())+":"+_(E.getMinutes())+":"+_(E.getSeconds())+"]: "+p}static _LogDisabled(p,_){}static _LogEnabled(p=1,_,E){const A=Array.isArray(_)?_[0]:_;if(E!==void 0&&!vi._CheckLimit(A,E))return;const $=vi._FormatMessage(A),ne=this._Levels[p],xe=Array.isArray(_)?_.slice(1):[];ne.logFunc&&ne.logFunc("BJS - "+$,...xe);const ce=`<div style='color:${ne.color}'>${$}</div><br>`;vi._AddLogEntry(ce),vi._GenerateLimitMessage(A,p)}static get LogCache(){return vi._LogCache}static ClearLogCache(){vi._LogCache="",vi._LogLimitOutputs={},vi.errorsCount=0}static set LogLevels(p){vi.Log=vi._LogDisabled,vi.Warn=vi._LogDisabled,vi.Error=vi._LogDisabled,[vi.MessageLogLevel,vi.WarningLogLevel,vi.ErrorLogLevel].forEach(_=>{if((p&_)===_){const E=this._Levels[_];vi[E.name]=vi._LogEnabled.bind(vi,_)}})}}vi.NoneLogLevel=0,vi.MessageLogLevel=1,vi.WarningLogLevel=2,vi.ErrorLogLevel=4,vi.AllLogLevel=7,vi.MessageLimitReached="Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.",vi._LogCache="",vi._LogLimitOutputs={},vi._Levels=[{},{color:"white",logFunc:console.log,name:"Log"},{color:"orange",logFunc:console.warn,name:"Warn"},{},{color:"red",logFunc:console.error,name:"Error"}],vi.errorsCount=0,vi.Log=vi._LogEnabled.bind(vi,vi.MessageLogLevel),vi.Warn=vi._LogEnabled.bind(vi,vi.WarningLogLevel),vi.Error=vi._LogEnabled.bind(vi,vi.ErrorLogLevel);const r2="attribute",vc="varying";class j0{constructor(){this.children=[]}isValid(p){return!0}process(p,_){let E="";if(this.line){let A=this.line;const $=_.processor;if($){$.lineProcessor&&(A=$.lineProcessor(A,_.isFragment,_.processingContext));const ne=_.processor?.attributeKeywordName??r2,xe=_.isFragment&&_.processor?.varyingFragmentKeywordName?_.processor?.varyingFragmentKeywordName:!_.isFragment&&_.processor?.varyingVertexKeywordName?_.processor?.varyingVertexKeywordName:vc;!_.isFragment&&$.attributeProcessor&&this.line.startsWith(ne)?A=$.attributeProcessor(this.line,p,_.processingContext):$.varyingProcessor&&($.varyingCheck?.(this.line,_.isFragment)||!$.varyingCheck&&this.line.startsWith(xe))?A=$.varyingProcessor(this.line,_.isFragment,p,_.processingContext):$.uniformProcessor&&$.uniformRegexp&&$.uniformRegexp.test(this.line)?_.lookForClosingBracketForUniformBuffer||(A=$.uniformProcessor(this.line,_.isFragment,p,_.processingContext)):$.uniformBufferProcessor&&$.uniformBufferRegexp&&$.uniformBufferRegexp.test(this.line)?_.lookForClosingBracketForUniformBuffer||(A=$.uniformBufferProcessor(this.line,_.isFragment,_.processingContext),_.lookForClosingBracketForUniformBuffer=!0):$.textureProcessor&&$.textureRegexp&&$.textureRegexp.test(this.line)?A=$.textureProcessor(this.line,_.isFragment,p,_.processingContext):($.uniformProcessor||$.uniformBufferProcessor)&&this.line.startsWith("uniform")&&!_.lookForClosingBracketForUniformBuffer&&(/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line)?$.uniformProcessor&&(A=$.uniformProcessor(this.line,_.isFragment,p,_.processingContext)):$.uniformBufferProcessor&&(A=$.uniformBufferProcessor(this.line,_.isFragment,_.processingContext),_.lookForClosingBracketForUniformBuffer=!0)),_.lookForClosingBracketForUniformBuffer&&this.line.indexOf("}")!==-1&&(_.lookForClosingBracketForUniformBuffer=!1,$.endOfUniformBufferProcessor&&(A=$.endOfUniformBufferProcessor(this.line,_.isFragment,_.processingContext)))}E+=A+`
`}return this.children.forEach(A=>{E+=A.process(p,_)}),this.additionalDefineKey&&(p[this.additionalDefineKey]=this.additionalDefineValue||"true"),E}}class Rc{constructor(){this._lines=[]}get currentLine(){return this._lines[this.lineIndex]}get canRead(){return this.lineIndex<this._lines.length-1}set lines(p){this._lines.length=0;for(const _ of p){if(!_||_==="\r")continue;if(_[0]==="#"){this._lines.push(_);continue}const E=_.trim();if(!E)continue;if(E.startsWith("//")){this._lines.push(_);continue}const A=E.indexOf(";");if(A===-1)this._lines.push(E);else if(A===E.length-1)E.length>1&&this._lines.push(E);else{const $=_.split(";");for(let ne=0;ne<$.length;ne++){let xe=$[ne];xe&&(xe=xe.trim(),xe&&this._lines.push(xe+(ne!==$.length-1?";":"")))}}}}}class io extends j0{process(p,_){for(let E=0;E<this.children.length;E++){const A=this.children[E];if(A.isValid(p))return A.process(p,_)}return""}}class G2 extends j0{isValid(p){return this.testExpression.isTrue(p)}}class Wn{isTrue(p){return!0}static postfixToInfix(p){const _=[];for(const E of p)if(Wn._OperatorPriority[E]===void 0)_.push(E);else{const A=_[_.length-1],$=_[_.length-2];_.length-=2,_.push(`(${$}${E}${A})`)}return _[_.length-1]}static infixToPostfix(p){const _=Wn._InfixToPostfixCache.get(p);if(_)return _.accessTime=Date.now(),_.result;if(!p.includes("&&")&&!p.includes("||")&&!p.includes(")")&&!p.includes("("))return[p];const E=[];let A=-1;const $=()=>{Re=Re.trim(),Re!==""&&(E.push(Re),Re="")},ne=ke=>{A<Wn._Stack.length-1&&(Wn._Stack[++A]=ke)},xe=()=>Wn._Stack[A],ce=()=>A===-1?"!!INVALID EXPRESSION!!":Wn._Stack[A--];let Te=0,Re="";for(;Te<p.length;){const ke=p.charAt(Te),We=Te<p.length-1?p.substr(Te,2):"";if(ke==="(")Re="",ne(ke);else if(ke===")"){for($();A!==-1&&xe()!=="(";)E.push(ce());ce()}else if(Wn._OperatorPriority[We]>1){for($();A!==-1&&Wn._OperatorPriority[xe()]>=Wn._OperatorPriority[We];)E.push(ce());ne(We),Te++}else Re+=ke;Te++}for($();A!==-1;)xe()==="("?ce():E.push(ce());return Wn._InfixToPostfixCache.size>=Wn.InfixToPostfixCacheLimitSize&&Wn.ClearCache(),Wn._InfixToPostfixCache.set(p,{result:E,accessTime:Date.now()}),E}static ClearCache(){const p=Array.from(Wn._InfixToPostfixCache.entries()).sort((_,E)=>_[1].accessTime-E[1].accessTime);for(let _=0;_<Wn.InfixToPostfixCacheCleanupSize;_++)Wn._InfixToPostfixCache.delete(p[_][0])}}Wn.InfixToPostfixCacheLimitSize=5e4,Wn.InfixToPostfixCacheCleanupSize=25e3,Wn._InfixToPostfixCache=new Map,Wn._OperatorPriority={")":0,"(":1,"||":2,"&&":3},Wn._Stack=["","","","","","","","","","","","","","","","","","","",""];class _x extends Wn{constructor(p,_=!1){super(),this.define=p,this.not=_}isTrue(p){let _=p[this.define]!==void 0;return this.not&&(_=!_),_}}class z2 extends Wn{isTrue(p){return this.leftOperand.isTrue(p)||this.rightOperand.isTrue(p)}}class Mc extends Wn{isTrue(p){return this.leftOperand.isTrue(p)&&this.rightOperand.isTrue(p)}}class wc extends Wn{constructor(p,_,E){super(),this.define=p,this.operand=_,this.testValue=E}isTrue(p){let _=p[this.define];_===void 0&&(_=this.define);let E=!1;const A=parseInt(_),$=parseInt(this.testValue);switch(this.operand){case">":E=A>$;break;case"<":E=A<$;break;case"<=":E=A<=$;break;case">=":E=A>=$;break;case"==":E=A===$;break;case"!=":E=A!==$;break}return E}}var Xa;(function(_e){_e[_e.GLSL=0]="GLSL",_e[_e.WGSL=1]="WGSL"})(Xa||(Xa={}));const n2=/defined\s*?\((.+?)\)/g,W2=/defined\s*?\[(.+?)\]/g,Gx=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,Lc=/__decl__/,Gh=/light\{X\}.(\w*)/g,vl=/\{X\}/g,zx=[];class po{static Initialize(p){p.processor&&p.processor.initializeShaders&&p.processor.initializeShaders(p.processingContext)}static Process(p,_,E,A){_.processor?.preProcessShaderCode&&(p=_.processor.preProcessShaderCode(p,_.isFragment)),this._ProcessIncludes(p,_,$=>{_.processCodeAfterIncludes&&($=_.processCodeAfterIncludes(_.isFragment?"fragment":"vertex",$));const ne=this._ProcessShaderConversion($,_,A);E(ne,$)})}static PreProcess(p,_,E,A){_.processor?.preProcessShaderCode&&(p=_.processor.preProcessShaderCode(p,_.isFragment)),this._ProcessIncludes(p,_,$=>{_.processCodeAfterIncludes&&($=_.processCodeAfterIncludes(_.isFragment?"fragment":"vertex",$));const ne=this._ApplyPreProcessing($,_,A);E(ne,$)})}static Finalize(p,_,E){return!E.processor||!E.processor.finalizeShaders?{vertexCode:p,fragmentCode:_}:E.processor.finalizeShaders(p,_,E.processingContext)}static _ProcessPrecision(p,_){if(_.processor?.noPrecision)return p;const E=_.shouldUseHighPrecisionShader;return p.indexOf("precision highp float")===-1?E?p=`precision highp float;
`+p:p=`precision mediump float;
`+p:E||(p=p.replace("precision highp float","precision mediump float")),p}static _ExtractOperation(p){const E=/defined\((.+)\)/.exec(p);if(E&&E.length)return new _x(E[1].trim(),p[0]==="!");const A=["==","!=",">=","<=","<",">"];let $="",ne=0;for($ of A)if(ne=p.indexOf($),ne>-1)break;if(ne===-1)return new _x(p);const xe=p.substring(0,ne).trim(),ce=p.substring(ne+$.length).trim();return new wc(xe,$,ce)}static _BuildSubExpression(p){p=p.replace(n2,"defined[$1]");const _=Wn.infixToPostfix(p),E=[];for(const $ of _)if($!=="||"&&$!=="&&")E.push($);else if(E.length>=2){let ne=E[E.length-1],xe=E[E.length-2];E.length-=2;const ce=$=="&&"?new Mc:new z2;typeof ne=="string"&&(ne=ne.replace(W2,"defined($1)")),typeof xe=="string"&&(xe=xe.replace(W2,"defined($1)")),ce.leftOperand=typeof xe=="string"?this._ExtractOperation(xe):xe,ce.rightOperand=typeof ne=="string"?this._ExtractOperation(ne):ne,E.push(ce)}let A=E[E.length-1];return typeof A=="string"&&(A=A.replace(W2,"defined($1)")),typeof A=="string"?this._ExtractOperation(A):A}static _BuildExpression(p,_){const E=new G2,A=p.substring(0,_);let $=p.substring(_);return $=$.substring(0,($.indexOf("//")+1||$.length+1)-1).trim(),A==="#ifdef"?E.testExpression=new _x($):A==="#ifndef"?E.testExpression=new _x($,!0):E.testExpression=this._BuildSubExpression($),E}static _MoveCursorWithinIf(p,_,E){let A=p.currentLine;for(;this._MoveCursor(p,E);){A=p.currentLine;const $=A.substring(0,5).toLowerCase();if($==="#else"){const ne=new j0;_.children.push(ne),this._MoveCursor(p,ne);return}else if($==="#elif"){const ne=this._BuildExpression(A,5);_.children.push(ne),E=ne}}}static _MoveCursor(p,_){for(;p.canRead;){p.lineIndex++;const E=p.currentLine;if(E.indexOf("#")>=0){const $=po._MoveCursorRegex.exec(E);if($&&$.length){switch($[0]){case"#ifdef":{const xe=new io;_.children.push(xe);const ce=this._BuildExpression(E,6);xe.children.push(ce),this._MoveCursorWithinIf(p,xe,ce);break}case"#else":case"#elif":return!0;case"#endif":return!1;case"#ifndef":{const xe=new io;_.children.push(xe);const ce=this._BuildExpression(E,7);xe.children.push(ce),this._MoveCursorWithinIf(p,xe,ce);break}case"#if":{const xe=new io,ce=this._BuildExpression(E,3);_.children.push(xe),xe.children.push(ce),this._MoveCursorWithinIf(p,xe,ce);break}}continue}}const A=new j0;if(A.line=E,_.children.push(A),E[0]==="#"&&E[1]==="d"){const $=E.replace(";","").split(" ");A.additionalDefineKey=$[1],$.length===3&&(A.additionalDefineValue=$[2])}}return!1}static _EvaluatePreProcessors(p,_,E){const A=new j0,$=new Rc;return $.lineIndex=-1,$.lines=p.split(`
`),this._MoveCursor($,A),A.process(_,E)}static _PreparePreProcessors(p,_){const E=p.defines,A={};for(const $ of E){const xe=$.replace("#define","").replace(";","").trim().split(" ");A[xe[0]]=xe.length>1?xe[1]:""}return p.processor?.shaderLanguage===Xa.GLSL&&(A.GL_ES="true"),A.__VERSION__=p.version,A[p.platformName]="true",_._getGlobalDefines(A),A}static _ProcessShaderConversion(p,_,E){let A=this._ProcessPrecision(p,_);if(!_.processor||_.processor.shaderLanguage===Xa.GLSL&&A.indexOf("#version 3")!==-1&&(A=A.replace("#version 300 es",""),!_.processor.parseGLES3))return A;const $=_.defines,ne=this._PreparePreProcessors(_,E);return _.processor.preProcessor&&(A=_.processor.preProcessor(A,$,_.isFragment,_.processingContext)),A=this._EvaluatePreProcessors(A,ne,_),_.processor.postProcessor&&(A=_.processor.postProcessor(A,$,_.isFragment,_.processingContext,E)),E._features.needShaderCodeInlining&&(A=E.inlineShaderCode(A)),A}static _ApplyPreProcessing(p,_,E){let A=p;const $=_.defines,ne=this._PreparePreProcessors(_,E);return _.processor?.preProcessor&&(A=_.processor.preProcessor(A,$,_.isFragment,_.processingContext)),A=this._EvaluatePreProcessors(A,ne,_),_.processor?.postProcessor&&(A=_.processor.postProcessor(A,$,_.isFragment,_.processingContext,E)),E._features.needShaderCodeInlining&&(A=E.inlineShaderCode(A)),A}static _ProcessIncludes(p,_,E){zx.length=0;let A;for(;(A=Gx.exec(p))!==null;)zx.push(A);let $=String(p),ne=[p],xe=!1;for(const ce of zx){let Te=ce[1];if(Te.indexOf("__decl__")!==-1&&(Te=Te.replace(Lc,""),_.supportsUniformBuffers&&(Te=Te.replace("Vertex","Ubo").replace("Fragment","Ubo")),Te=Te+"Declaration"),_.includesShadersStore[Te]){let Re=_.includesShadersStore[Te];if(ce[2]){const We=ce[3].split(",");for(let Xe=0;Xe<We.length;Xe+=2){const xt=new RegExp(We[Xe],"g"),qe=We[Xe+1];Re=Re.replace(xt,qe)}}if(ce[4]){const We=ce[5];if(We.indexOf("..")!==-1){const Xe=We.split(".."),xt=parseInt(Xe[0]);let qe=parseInt(Xe[1]),ht=Re.slice(0);Re="",isNaN(qe)&&(qe=_.indexParameters[Xe[1]]);for(let Nt=xt;Nt<qe;Nt++)_.supportsUniformBuffers||(ht=ht.replace(Gh,(wt,Qt)=>Qt+"{X}")),Re+=ht.replace(vl,Nt.toString())+`
`}else _.supportsUniformBuffers||(Re=Re.replace(Gh,(Xe,xt)=>xt+"{X}")),Re=Re.replace(vl,We)}const ke=[];for(const We of ne){const Xe=We.split(ce[0]);for(let xt=0;xt<Xe.length-1;xt++)ke.push(Xe[xt]),ke.push(Re);ke.push(Xe[Xe.length-1])}ne=ke,xe=xe||Re.indexOf("#include<")>=0||Re.indexOf("#include <")>=0}else{const Re=_.shadersRepository+"ShadersInclude/"+Te+".fx";po._FileToolsLoadFile(Re,ke=>{_.includesShadersStore[Te]=ke,this._ProcessIncludes(ne.join(""),_,E)});return}}zx.length=0,$=ne.join(""),xe?this._ProcessIncludes($.toString(),_,E):E($)}static _FileToolsLoadFile(p,_,E,A,$,ne){throw Tr("FileTools")}}po._MoveCursorRegex=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;class Gi{static GetShadersRepository(p=Xa.GLSL){return p===Xa.GLSL?Gi.ShadersRepository:Gi.ShadersRepositoryWGSL}static GetShadersStore(p=Xa.GLSL){return p===Xa.GLSL?Gi.ShadersStore:Gi.ShadersStoreWGSL}static GetIncludesShadersStore(p=Xa.GLSL){return p===Xa.GLSL?Gi.IncludesShadersStore:Gi.IncludesShadersStoreWGSL}}Gi.ShadersRepository="src/Shaders/",Gi.ShadersStore={},Gi.IncludesShadersStore={},Gi.ShadersRepositoryWGSL="src/ShadersWGSL/",Gi.ShadersStoreWGSL={},Gi.IncludesShadersStoreWGSL={};class va{static get ShadersRepository(){return Gi.ShadersRepository}static set ShadersRepository(p){Gi.ShadersRepository=p}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new Mi),this._onBindObservable}get shaderLanguage(){return this._shaderLanguage}constructor(p,_,E,A=null,$,ne=null,xe=null,ce=null,Te=null,Re,ke="",We=Xa.GLSL){if(this.name=null,this.defines="",this.onCompiled=null,this.onError=null,this.onBind=null,this.uniqueId=0,this.onCompileObservable=new Mi,this.onErrorObservable=new Mi,this._onBindObservable=null,this._isDisposed=!1,this._bonesComputationForcedToCPU=!1,this._uniformBuffersNames={},this._multiTarget=!1,this._samplers={},this._isReady=!1,this._compilationError="",this._allFallbacksProcessed=!1,this._uniforms={},this._key="",this._fallbacks=null,this._vertexSourceCodeOverride="",this._fragmentSourceCodeOverride="",this._transformFeedbackVaryings=null,this._pipelineContext=null,this._vertexSourceCode="",this._fragmentSourceCode="",this._vertexSourceCodeBeforeMigration="",this._fragmentSourceCodeBeforeMigration="",this._rawVertexSourceCode="",this._rawFragmentSourceCode="",this._processCodeAfterIncludes=void 0,this._processFinalCode=null,this.name=p,this._key=ke,_.attributes){const Xe=_;if(this._engine=E,this._attributesNames=Xe.attributes,this._uniformsNames=Xe.uniformsNames.concat(Xe.samplers),this._samplerList=Xe.samplers.slice(),this.defines=Xe.defines,this.onError=Xe.onError,this.onCompiled=Xe.onCompiled,this._fallbacks=Xe.fallbacks,this._indexParameters=Xe.indexParameters,this._transformFeedbackVaryings=Xe.transformFeedbackVaryings||null,this._multiTarget=!!Xe.multiTarget,this._shaderLanguage=Xe.shaderLanguage??Xa.GLSL,Xe.uniformBuffersNames){this._uniformBuffersNamesList=Xe.uniformBuffersNames.slice();for(let xt=0;xt<Xe.uniformBuffersNames.length;xt++)this._uniformBuffersNames[Xe.uniformBuffersNames[xt]]=xt}this._processFinalCode=Xe.processFinalCode??null,this._processCodeAfterIncludes=Xe.processCodeAfterIncludes??void 0}else this._engine=$,this.defines=ne??"",this._uniformsNames=E.concat(A),this._samplerList=A?A.slice():[],this._attributesNames=_,this._uniformBuffersNamesList=[],this._shaderLanguage=We,this.onError=Te,this.onCompiled=ce,this._indexParameters=Re,this._fallbacks=xe;this._attributeLocationByName={},this.uniqueId=va._UniqueIdSeed++,this._processShaderCode()}_processShaderCode(p=null,_=!1){let E,A;const $=this.name,ne=wa()?this._engine.getHostDocument():null;$.vertexSource?E="source:"+$.vertexSource:$.vertexElement?(E=ne?ne.getElementById($.vertexElement):null,E||(E=$.vertexElement)):E=$.vertex||$,$.fragmentSource?A="source:"+$.fragmentSource:$.fragmentElement?(A=ne?ne.getElementById($.fragmentElement):null,A||(A=$.fragmentElement)):A=$.fragment||$,this._processingContext=this._engine._getShaderProcessingContext(this._shaderLanguage);let xe={defines:this.defines.split(`
`),indexParameters:this._indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:p??this._engine._getShaderProcessor(this._shaderLanguage),supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:Gi.GetShadersRepository(this._shaderLanguage),includesShadersStore:Gi.GetIncludesShadersStore(this._shaderLanguage),version:(this._engine.version*100).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._processingContext,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:this._processCodeAfterIncludes};const ce=[void 0,void 0],Te=()=>{if(ce[0]&&ce[1]){xe.isFragment=!0;const[Re,ke]=ce;po.Process(ke,xe,(We,Xe)=>{this._fragmentSourceCodeBeforeMigration=Xe,this._processFinalCode&&(We=this._processFinalCode("fragment",We));const xt=po.Finalize(Re,We,xe);xe=null,this._useFinalCode(xt.vertexCode,xt.fragmentCode,$,_)},this._engine)}};this._loadShader(E,"Vertex","",Re=>{po.Initialize(xe),po.Process(Re,xe,(ke,We)=>{this._rawVertexSourceCode=Re,this._vertexSourceCodeBeforeMigration=We,this._processFinalCode&&(ke=this._processFinalCode("vertex",ke)),ce[0]=ke,Te()},this._engine)}),this._loadShader(A,"Fragment","Pixel",Re=>{this._rawFragmentSourceCode=Re,ce[1]=Re,Te()})}_useFinalCode(p,_,E,A=!1){if(E){const $=E.vertexElement||E.vertex||E.spectorName||E,ne=E.fragmentElement||E.fragment||E.spectorName||E;this._vertexSourceCode=(this._shaderLanguage===Xa.WGSL?"//":"")+"#define SHADER_NAME vertex:"+$+`
`+p,this._fragmentSourceCode=(this._shaderLanguage===Xa.WGSL?"//":"")+"#define SHADER_NAME fragment:"+ne+`
`+_}else this._vertexSourceCode=p,this._fragmentSourceCode=_;this._prepareEffect(A)}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return this._isReady?!0:this._pipelineContext?this._pipelineContext.isReady:!1}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getAttributesNames(){return this._attributesNames}getAttributeLocation(p){return this._attributes[p]}getAttributeLocationByName(p){return this._attributeLocationByName[p]}getAttributesCount(){return this._attributes.length}getUniformIndex(p){return this._uniformsNames.indexOf(p)}getUniform(p){return this._uniforms[p]}getSamplers(){return this._samplerList}getUniformNames(){return this._uniformsNames}getUniformBuffersNames(){return this._uniformBuffersNamesList}getIndexParameters(){return this._indexParameters}getCompilationError(){return this._compilationError}allFallbacksProcessed(){return this._allFallbacksProcessed}executeWhenCompiled(p){if(this.isReady()){p(this);return}this.onCompileObservable.add(_=>{p(_)}),(!this._pipelineContext||this._pipelineContext.isAsync)&&setTimeout(()=>{this._checkIsReady(null)},16)}_checkIsReady(p){try{if(this._isReadyInternal())return}catch(_){this._processCompilationErrors(_,p);return}this._isDisposed||setTimeout(()=>{this._checkIsReady(p)},16)}_loadShader(p,_,E,A){if(typeof HTMLElement<"u"&&p instanceof HTMLElement){const xe=Y0(p);A(xe);return}if(p.substr(0,7)==="source:"){A(p.substr(7));return}if(p.substr(0,7)==="base64:"){const xe=window.atob(p.substr(7));A(xe);return}const $=Gi.GetShadersStore(this._shaderLanguage);if($[p+_+"Shader"]){A($[p+_+"Shader"]);return}if(E&&$[p+E+"Shader"]){A($[p+E+"Shader"]);return}let ne;p[0]==="."||p[0]==="/"||p.indexOf("http")>-1?ne=p:ne=Gi.GetShadersRepository(this._shaderLanguage)+p,this._engine._loadFile(ne+"."+_.toLowerCase()+".fx",A)}get vertexSourceCode(){return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._vertexSourceCodeOverride:this._pipelineContext?._getVertexShaderCode()??this._vertexSourceCode}get fragmentSourceCode(){return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._fragmentSourceCodeOverride:this._pipelineContext?._getFragmentShaderCode()??this._fragmentSourceCode}get vertexSourceCodeBeforeMigration(){return this._vertexSourceCodeBeforeMigration}get fragmentSourceCodeBeforeMigration(){return this._fragmentSourceCodeBeforeMigration}get rawVertexSourceCode(){return this._rawVertexSourceCode}get rawFragmentSourceCode(){return this._rawFragmentSourceCode}_rebuildProgram(p,_,E,A){this._isReady=!1,this._vertexSourceCodeOverride=p,this._fragmentSourceCodeOverride=_,this.onError=($,ne)=>{A&&A(ne)},this.onCompiled=()=>{const $=this.getEngine().scenes;if($)for(let ne=0;ne<$.length;ne++)$[ne].markAllMaterialsAsDirty(63);this._pipelineContext._handlesSpectorRebuildCallback?.(E)},this._fallbacks=null,this._prepareEffect()}_prepareEffect(p=!1){const _=this._attributesNames,E=this.defines,A=this._pipelineContext;this._isReady=!1;try{const $=this._engine;this._pipelineContext=(p?A:void 0)??$.createPipelineContext(this._processingContext),this._pipelineContext._name=this._key.replace(/\r/g,"").replace(/\n/g,"|");const ne=(xe,ce,Te,Re)=>this._rebuildProgram(xe,ce,Te,Re);this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?$._preparePipelineContext(this._pipelineContext,this._vertexSourceCodeOverride,this._fragmentSourceCodeOverride,!0,this._rawVertexSourceCode,this._rawFragmentSourceCode,ne,null,this._transformFeedbackVaryings,this._key):$._preparePipelineContext(this._pipelineContext,this._vertexSourceCode,this._fragmentSourceCode,!1,this._rawVertexSourceCode,this._rawFragmentSourceCode,ne,E,this._transformFeedbackVaryings,this._key),$._executeWhenRenderingStateIsCompiled(this._pipelineContext,()=>{if(this._attributes=[],this._pipelineContext._fillEffectInformation(this,this._uniformBuffersNames,this._uniformsNames,this._uniforms,this._samplerList,this._samplers,_,this._attributes),_)for(let xe=0;xe<_.length;xe++){const ce=_[xe];this._attributeLocationByName[ce]=this._attributes[xe]}$.bindSamplers(this),this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh(),A&&!p&&this.getEngine()._deletePipelineContext(A)}),this._pipelineContext.isAsync&&this._checkIsReady(A)}catch($){this._processCompilationErrors($,A)}}_getShaderCodeAndErrorLine(p,_,E){const A=E?/FRAGMENT SHADER ERROR: 0:(\d+?):/:/VERTEX SHADER ERROR: 0:(\d+?):/;let $=null;if(_&&p){const ne=_.match(A);if(ne&&ne.length===2){const xe=parseInt(ne[1]),ce=p.split(`
`,-1);ce.length>=xe&&($=`Offending line [${xe}] in ${E?"fragment":"vertex"} code: ${ce[xe-1]}`)}}return[p,$]}_processCompilationErrors(p,_=null){this._compilationError=p.message;const E=this._attributesNames,A=this._fallbacks;if(vi.Error("Unable to compile effect:"),vi.Error("Uniforms: "+this._uniformsNames.map(function(ne){return" "+ne})),vi.Error("Attributes: "+E.map(function(ne){return" "+ne})),vi.Error(`Defines:
`+this.defines),va.LogShaderCodeOnCompilationError){let ne=null,xe=null,ce=null;this._pipelineContext?._getVertexShaderCode()&&([ce,ne]=this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(),this._compilationError,!1),ce&&(vi.Error("Vertex code:"),vi.Error(ce))),this._pipelineContext?._getFragmentShaderCode()&&([ce,xe]=this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(),this._compilationError,!0),ce&&(vi.Error("Fragment code:"),vi.Error(ce))),ne&&vi.Error(ne),xe&&vi.Error(xe)}vi.Error("Error: "+this._compilationError);const $=()=>{this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this)};_&&(this._pipelineContext=_,this._isReady=!0,$()),A?(this._pipelineContext=null,A.hasMoreFallbacks?(this._allFallbacksProcessed=!1,vi.Error("Trying next fallback."),this.defines=A.reduce(this.defines,this),this._prepareEffect()):(this._allFallbacksProcessed=!0,$(),this.onErrorObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh())):(this._allFallbacksProcessed=!0,_||$())}get isSupported(){return this._compilationError===""}_bindTexture(p,_){this._engine._bindTexture(this._samplers[p],_,p)}setTexture(p,_){this._engine.setTexture(this._samplers[p],this._uniforms[p],_,p)}setDepthStencilTexture(p,_){this._engine.setDepthStencilTexture(this._samplers[p],this._uniforms[p],_,p)}setTextureArray(p,_){const E=p+"Ex";if(this._samplerList.indexOf(E+"0")===-1){const A=this._samplerList.indexOf(p);for(let ne=1;ne<_.length;ne++){const xe=E+(ne-1).toString();this._samplerList.splice(A+ne,0,xe)}let $=0;for(const ne of this._samplerList)this._samplers[ne]=$,$+=1}this._engine.setTextureArray(this._samplers[p],this._uniforms[p],_,p)}setTextureFromPostProcess(p,_){this._engine.setTextureFromPostProcess(this._samplers[p],_,p)}setTextureFromPostProcessOutput(p,_){this._engine.setTextureFromPostProcessOutput(this._samplers[p],_,p)}bindUniformBuffer(p,_){const E=this._uniformBuffersNames[_];E===void 0||va._BaseCache[E]===p&&this._engine._features.useUBOBindingCache||(va._BaseCache[E]=p,this._engine.bindUniformBufferBase(p,E,_))}bindUniformBlock(p,_){this._engine.bindUniformBlock(this._pipelineContext,p,_)}setInt(p,_){return this._pipelineContext.setInt(p,_),this}setInt2(p,_,E){return this._pipelineContext.setInt2(p,_,E),this}setInt3(p,_,E,A){return this._pipelineContext.setInt3(p,_,E,A),this}setInt4(p,_,E,A,$){return this._pipelineContext.setInt4(p,_,E,A,$),this}setIntArray(p,_){return this._pipelineContext.setIntArray(p,_),this}setIntArray2(p,_){return this._pipelineContext.setIntArray2(p,_),this}setIntArray3(p,_){return this._pipelineContext.setIntArray3(p,_),this}setIntArray4(p,_){return this._pipelineContext.setIntArray4(p,_),this}setUInt(p,_){return this._pipelineContext.setUInt(p,_),this}setUInt2(p,_,E){return this._pipelineContext.setUInt2(p,_,E),this}setUInt3(p,_,E,A){return this._pipelineContext.setUInt3(p,_,E,A),this}setUInt4(p,_,E,A,$){return this._pipelineContext.setUInt4(p,_,E,A,$),this}setUIntArray(p,_){return this._pipelineContext.setUIntArray(p,_),this}setUIntArray2(p,_){return this._pipelineContext.setUIntArray2(p,_),this}setUIntArray3(p,_){return this._pipelineContext.setUIntArray3(p,_),this}setUIntArray4(p,_){return this._pipelineContext.setUIntArray4(p,_),this}setFloatArray(p,_){return this._pipelineContext.setArray(p,_),this}setFloatArray2(p,_){return this._pipelineContext.setArray2(p,_),this}setFloatArray3(p,_){return this._pipelineContext.setArray3(p,_),this}setFloatArray4(p,_){return this._pipelineContext.setArray4(p,_),this}setArray(p,_){return this._pipelineContext.setArray(p,_),this}setArray2(p,_){return this._pipelineContext.setArray2(p,_),this}setArray3(p,_){return this._pipelineContext.setArray3(p,_),this}setArray4(p,_){return this._pipelineContext.setArray4(p,_),this}setMatrices(p,_){return this._pipelineContext.setMatrices(p,_),this}setMatrix(p,_){return this._pipelineContext.setMatrix(p,_),this}setMatrix3x3(p,_){return this._pipelineContext.setMatrix3x3(p,_),this}setMatrix2x2(p,_){return this._pipelineContext.setMatrix2x2(p,_),this}setFloat(p,_){return this._pipelineContext.setFloat(p,_),this}setBool(p,_){return this._pipelineContext.setInt(p,_?1:0),this}setVector2(p,_){return this._pipelineContext.setVector2(p,_),this}setFloat2(p,_,E){return this._pipelineContext.setFloat2(p,_,E),this}setVector3(p,_){return this._pipelineContext.setVector3(p,_),this}setFloat3(p,_,E,A){return this._pipelineContext.setFloat3(p,_,E,A),this}setVector4(p,_){return this._pipelineContext.setVector4(p,_),this}setQuaternion(p,_){return this._pipelineContext.setQuaternion(p,_),this}setFloat4(p,_,E,A,$){return this._pipelineContext.setFloat4(p,_,E,A,$),this}setColor3(p,_){return this._pipelineContext.setColor3(p,_),this}setColor4(p,_,E){return this._pipelineContext.setColor4(p,_,E),this}setDirectColor4(p,_){return this._pipelineContext.setDirectColor4(p,_),this}dispose(){this._pipelineContext&&this._pipelineContext.dispose(),this._engine._releaseEffect(this),this._isDisposed=!0}static RegisterShader(p,_,E,A=Xa.GLSL){_&&(Gi.GetShadersStore(A)[`${p}PixelShader`]=_),E&&(Gi.GetShadersStore(A)[`${p}VertexShader`]=E)}static ResetCache(){va._BaseCache={}}}va.LogShaderCodeOnCompilationError=!0,va._UniqueIdSeed=0,va._BaseCache={},va.ShadersStore=Gi.ShadersStore,va.IncludesShadersStore=Gi.IncludesShadersStore;class Rl{constructor(p=!0){this._isDepthTestDirty=!1,this._isDepthMaskDirty=!1,this._isDepthFuncDirty=!1,this._isCullFaceDirty=!1,this._isCullDirty=!1,this._isZOffsetDirty=!1,this._isFrontFaceDirty=!1,p&&this.reset()}get isDirty(){return this._isDepthFuncDirty||this._isDepthTestDirty||this._isDepthMaskDirty||this._isCullFaceDirty||this._isCullDirty||this._isZOffsetDirty||this._isFrontFaceDirty}get zOffset(){return this._zOffset}set zOffset(p){this._zOffset!==p&&(this._zOffset=p,this._isZOffsetDirty=!0)}get zOffsetUnits(){return this._zOffsetUnits}set zOffsetUnits(p){this._zOffsetUnits!==p&&(this._zOffsetUnits=p,this._isZOffsetDirty=!0)}get cullFace(){return this._cullFace}set cullFace(p){this._cullFace!==p&&(this._cullFace=p,this._isCullFaceDirty=!0)}get cull(){return this._cull}set cull(p){this._cull!==p&&(this._cull=p,this._isCullDirty=!0)}get depthFunc(){return this._depthFunc}set depthFunc(p){this._depthFunc!==p&&(this._depthFunc=p,this._isDepthFuncDirty=!0)}get depthMask(){return this._depthMask}set depthMask(p){this._depthMask!==p&&(this._depthMask=p,this._isDepthMaskDirty=!0)}get depthTest(){return this._depthTest}set depthTest(p){this._depthTest!==p&&(this._depthTest=p,this._isDepthTestDirty=!0)}get frontFace(){return this._frontFace}set frontFace(p){this._frontFace!==p&&(this._frontFace=p,this._isFrontFaceDirty=!0)}reset(){this._depthMask=!0,this._depthTest=!0,this._depthFunc=null,this._cullFace=null,this._cull=null,this._zOffset=0,this._zOffsetUnits=0,this._frontFace=null,this._isDepthTestDirty=!0,this._isDepthMaskDirty=!0,this._isDepthFuncDirty=!1,this._isCullFaceDirty=!1,this._isCullDirty=!1,this._isZOffsetDirty=!0,this._isFrontFaceDirty=!1}apply(p){this.isDirty&&(this._isCullDirty&&(this.cull?p.enable(p.CULL_FACE):p.disable(p.CULL_FACE),this._isCullDirty=!1),this._isCullFaceDirty&&(p.cullFace(this.cullFace),this._isCullFaceDirty=!1),this._isDepthMaskDirty&&(p.depthMask(this.depthMask),this._isDepthMaskDirty=!1),this._isDepthTestDirty&&(this.depthTest?p.enable(p.DEPTH_TEST):p.disable(p.DEPTH_TEST),this._isDepthTestDirty=!1),this._isDepthFuncDirty&&(p.depthFunc(this.depthFunc),this._isDepthFuncDirty=!1),this._isZOffsetDirty&&(this.zOffset||this.zOffsetUnits?(p.enable(p.POLYGON_OFFSET_FILL),p.polygonOffset(this.zOffset,this.zOffsetUnits)):p.disable(p.POLYGON_OFFSET_FILL),this._isZOffsetDirty=!1),this._isFrontFaceDirty&&(p.frontFace(this.frontFace),this._isFrontFaceDirty=!1))}}class _o{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.func=_o.ALWAYS,this.funcRef=1,this.funcMask=255,this.opStencilFail=_o.KEEP,this.opDepthFail=_o.KEEP,this.opStencilDepthPass=_o.REPLACE}get stencilFunc(){return this.func}set stencilFunc(p){this.func=p}get stencilFuncRef(){return this.funcRef}set stencilFuncRef(p){this.funcRef=p}get stencilFuncMask(){return this.funcMask}set stencilFuncMask(p){this.funcMask=p}get stencilOpStencilFail(){return this.opStencilFail}set stencilOpStencilFail(p){this.opStencilFail=p}get stencilOpDepthFail(){return this.opDepthFail}set stencilOpDepthFail(p){this.opDepthFail=p}get stencilOpStencilDepthPass(){return this.opStencilDepthPass}set stencilOpStencilDepthPass(p){this.opStencilDepthPass=p}get stencilMask(){return this.mask}set stencilMask(p){this.mask=p}get stencilTest(){return this.enabled}set stencilTest(p){this.enabled=p}}_o.ALWAYS=519,_o.KEEP=7680,_o.REPLACE=7681;class X2{constructor(){this._blendFunctionParameters=new Array(4),this._blendEquationParameters=new Array(2),this._blendConstants=new Array(4),this._isBlendConstantsDirty=!1,this._alphaBlend=!1,this._isAlphaBlendDirty=!1,this._isBlendFunctionParametersDirty=!1,this._isBlendEquationParametersDirty=!1,this.reset()}get isDirty(){return this._isAlphaBlendDirty||this._isBlendFunctionParametersDirty||this._isBlendEquationParametersDirty}get alphaBlend(){return this._alphaBlend}set alphaBlend(p){this._alphaBlend!==p&&(this._alphaBlend=p,this._isAlphaBlendDirty=!0)}setAlphaBlendConstants(p,_,E,A){this._blendConstants[0]===p&&this._blendConstants[1]===_&&this._blendConstants[2]===E&&this._blendConstants[3]===A||(this._blendConstants[0]=p,this._blendConstants[1]=_,this._blendConstants[2]=E,this._blendConstants[3]=A,this._isBlendConstantsDirty=!0)}setAlphaBlendFunctionParameters(p,_,E,A){this._blendFunctionParameters[0]===p&&this._blendFunctionParameters[1]===_&&this._blendFunctionParameters[2]===E&&this._blendFunctionParameters[3]===A||(this._blendFunctionParameters[0]=p,this._blendFunctionParameters[1]=_,this._blendFunctionParameters[2]=E,this._blendFunctionParameters[3]=A,this._isBlendFunctionParametersDirty=!0)}setAlphaEquationParameters(p,_){this._blendEquationParameters[0]===p&&this._blendEquationParameters[1]===_||(this._blendEquationParameters[0]=p,this._blendEquationParameters[1]=_,this._isBlendEquationParametersDirty=!0)}reset(){this._alphaBlend=!1,this._blendFunctionParameters[0]=null,this._blendFunctionParameters[1]=null,this._blendFunctionParameters[2]=null,this._blendFunctionParameters[3]=null,this._blendEquationParameters[0]=null,this._blendEquationParameters[1]=null,this._blendConstants[0]=null,this._blendConstants[1]=null,this._blendConstants[2]=null,this._blendConstants[3]=null,this._isAlphaBlendDirty=!0,this._isBlendFunctionParametersDirty=!1,this._isBlendEquationParametersDirty=!1,this._isBlendConstantsDirty=!1}apply(p){this.isDirty&&(this._isAlphaBlendDirty&&(this._alphaBlend?p.enable(p.BLEND):p.disable(p.BLEND),this._isAlphaBlendDirty=!1),this._isBlendFunctionParametersDirty&&(p.blendFuncSeparate(this._blendFunctionParameters[0],this._blendFunctionParameters[1],this._blendFunctionParameters[2],this._blendFunctionParameters[3]),this._isBlendFunctionParametersDirty=!1),this._isBlendEquationParametersDirty&&(p.blendEquationSeparate(this._blendEquationParameters[0],this._blendEquationParameters[1]),this._isBlendEquationParametersDirty=!1),this._isBlendConstantsDirty&&(p.blendColor(this._blendConstants[0],this._blendConstants[1],this._blendConstants[2],this._blendConstants[3]),this._isBlendConstantsDirty=!1))}}class n0{constructor(){this.shaderLanguage=Xa.GLSL}postProcessor(p,_,E,A,$){if(!$.getCaps().drawBuffersExtension){const ne=/#extension.+GL_EXT_draw_buffers.+(enable|require)/g;p=p.replace(ne,"")}return p}}const kc=/(flat\s)?\s*varying\s*.*/;class _0{constructor(){this.shaderLanguage=Xa.GLSL}attributeProcessor(p){return p.replace("attribute","in")}varyingCheck(p,_){return kc.test(p)}varyingProcessor(p,_){return p.replace("varying",_?"in":"out")}postProcessor(p,_,E){const A=p.search(/#extension.+GL_EXT_draw_buffers.+require/)!==-1,$=/#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;if(p=p.replace($,""),p=p.replace(/texture2D\s*\(/g,"texture("),E){const ne=p.search(/layout *\(location *= *0\) *out/g)!==-1;p=p.replace(/texture2DLodEXT\s*\(/g,"textureLod("),p=p.replace(/textureCubeLodEXT\s*\(/g,"textureLod("),p=p.replace(/textureCube\s*\(/g,"texture("),p=p.replace(/gl_FragDepthEXT/g,"gl_FragDepth"),p=p.replace(/gl_FragColor/g,"glFragColor"),p=p.replace(/gl_FragData/g,"glFragData"),p=p.replace(/void\s+?main\s*\(/g,(A||ne?"":`layout(location = 0) out vec4 glFragColor;
`)+"void main(")}else if(_.indexOf("#define MULTIVIEW")!==-1)return`#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
`+p;return p}}class To{get underlyingResource(){return null}constructor(){this.references=0,this.capacity=0,this.is32Bits=!1,this.uniqueId=To._Counter++}}To._Counter=0;class Xo extends To{constructor(p){super(),this._buffer=p}get underlyingResource(){return this._buffer}}class K2{constructor(){this._valueCache={},this.vertexCompilationError=null,this.fragmentCompilationError=null,this.programLinkError=null,this.programValidationError=null,this._isDisposed=!1}get isAsync(){return this.isParallelCompiled}get isReady(){return this.program?this.isParallelCompiled?this.engine._isRenderingStateCompiled(this):!0:!1}_handlesSpectorRebuildCallback(p){p&&this.program&&p(this.program)}_fillEffectInformation(p,_,E,A,$,ne,xe,ce){const Te=this.engine;if(Te.supportsUniformBuffers)for(const We in _)p.bindUniformBlock(We,_[We]);this.engine.getUniforms(this,E).forEach((We,Xe)=>{A[E[Xe]]=We}),this._uniforms=A;let ke;for(ke=0;ke<$.length;ke++)p.getUniform($[ke])==null&&($.splice(ke,1),ke--);$.forEach((We,Xe)=>{ne[We]=Xe});for(const We of Te.getAttributes(this,xe))ce.push(We)}dispose(){this._uniforms={},this._isDisposed=!0}_cacheMatrix(p,_){const E=this._valueCache[p],A=_.updateFlag;return E!==void 0&&E===A?!1:(this._valueCache[p]=A,!0)}_cacheFloat2(p,_,E){let A=this._valueCache[p];if(!A||A.length!==2)return A=[_,E],this._valueCache[p]=A,!0;let $=!1;return A[0]!==_&&(A[0]=_,$=!0),A[1]!==E&&(A[1]=E,$=!0),$}_cacheFloat3(p,_,E,A){let $=this._valueCache[p];if(!$||$.length!==3)return $=[_,E,A],this._valueCache[p]=$,!0;let ne=!1;return $[0]!==_&&($[0]=_,ne=!0),$[1]!==E&&($[1]=E,ne=!0),$[2]!==A&&($[2]=A,ne=!0),ne}_cacheFloat4(p,_,E,A,$){let ne=this._valueCache[p];if(!ne||ne.length!==4)return ne=[_,E,A,$],this._valueCache[p]=ne,!0;let xe=!1;return ne[0]!==_&&(ne[0]=_,xe=!0),ne[1]!==E&&(ne[1]=E,xe=!0),ne[2]!==A&&(ne[2]=A,xe=!0),ne[3]!==$&&(ne[3]=$,xe=!0),xe}setInt(p,_){const E=this._valueCache[p];E!==void 0&&E===_||this.engine.setInt(this._uniforms[p],_)&&(this._valueCache[p]=_)}setInt2(p,_,E){this._cacheFloat2(p,_,E)&&(this.engine.setInt2(this._uniforms[p],_,E)||(this._valueCache[p]=null))}setInt3(p,_,E,A){this._cacheFloat3(p,_,E,A)&&(this.engine.setInt3(this._uniforms[p],_,E,A)||(this._valueCache[p]=null))}setInt4(p,_,E,A,$){this._cacheFloat4(p,_,E,A,$)&&(this.engine.setInt4(this._uniforms[p],_,E,A,$)||(this._valueCache[p]=null))}setIntArray(p,_){this._valueCache[p]=null,this.engine.setIntArray(this._uniforms[p],_)}setIntArray2(p,_){this._valueCache[p]=null,this.engine.setIntArray2(this._uniforms[p],_)}setIntArray3(p,_){this._valueCache[p]=null,this.engine.setIntArray3(this._uniforms[p],_)}setIntArray4(p,_){this._valueCache[p]=null,this.engine.setIntArray4(this._uniforms[p],_)}setUInt(p,_){const E=this._valueCache[p];E!==void 0&&E===_||this.engine.setUInt(this._uniforms[p],_)&&(this._valueCache[p]=_)}setUInt2(p,_,E){this._cacheFloat2(p,_,E)&&(this.engine.setUInt2(this._uniforms[p],_,E)||(this._valueCache[p]=null))}setUInt3(p,_,E,A){this._cacheFloat3(p,_,E,A)&&(this.engine.setUInt3(this._uniforms[p],_,E,A)||(this._valueCache[p]=null))}setUInt4(p,_,E,A,$){this._cacheFloat4(p,_,E,A,$)&&(this.engine.setUInt4(this._uniforms[p],_,E,A,$)||(this._valueCache[p]=null))}setUIntArray(p,_){this._valueCache[p]=null,this.engine.setUIntArray(this._uniforms[p],_)}setUIntArray2(p,_){this._valueCache[p]=null,this.engine.setUIntArray2(this._uniforms[p],_)}setUIntArray3(p,_){this._valueCache[p]=null,this.engine.setUIntArray3(this._uniforms[p],_)}setUIntArray4(p,_){this._valueCache[p]=null,this.engine.setUIntArray4(this._uniforms[p],_)}setArray(p,_){this._valueCache[p]=null,this.engine.setArray(this._uniforms[p],_)}setArray2(p,_){this._valueCache[p]=null,this.engine.setArray2(this._uniforms[p],_)}setArray3(p,_){this._valueCache[p]=null,this.engine.setArray3(this._uniforms[p],_)}setArray4(p,_){this._valueCache[p]=null,this.engine.setArray4(this._uniforms[p],_)}setMatrices(p,_){_&&(this._valueCache[p]=null,this.engine.setMatrices(this._uniforms[p],_))}setMatrix(p,_){this._cacheMatrix(p,_)&&(this.engine.setMatrices(this._uniforms[p],_.toArray())||(this._valueCache[p]=null))}setMatrix3x3(p,_){this._valueCache[p]=null,this.engine.setMatrix3x3(this._uniforms[p],_)}setMatrix2x2(p,_){this._valueCache[p]=null,this.engine.setMatrix2x2(this._uniforms[p],_)}setFloat(p,_){const E=this._valueCache[p];E!==void 0&&E===_||this.engine.setFloat(this._uniforms[p],_)&&(this._valueCache[p]=_)}setVector2(p,_){this._cacheFloat2(p,_.x,_.y)&&(this.engine.setFloat2(this._uniforms[p],_.x,_.y)||(this._valueCache[p]=null))}setFloat2(p,_,E){this._cacheFloat2(p,_,E)&&(this.engine.setFloat2(this._uniforms[p],_,E)||(this._valueCache[p]=null))}setVector3(p,_){this._cacheFloat3(p,_.x,_.y,_.z)&&(this.engine.setFloat3(this._uniforms[p],_.x,_.y,_.z)||(this._valueCache[p]=null))}setFloat3(p,_,E,A){this._cacheFloat3(p,_,E,A)&&(this.engine.setFloat3(this._uniforms[p],_,E,A)||(this._valueCache[p]=null))}setVector4(p,_){this._cacheFloat4(p,_.x,_.y,_.z,_.w)&&(this.engine.setFloat4(this._uniforms[p],_.x,_.y,_.z,_.w)||(this._valueCache[p]=null))}setQuaternion(p,_){this._cacheFloat4(p,_.x,_.y,_.z,_.w)&&(this.engine.setFloat4(this._uniforms[p],_.x,_.y,_.z,_.w)||(this._valueCache[p]=null))}setFloat4(p,_,E,A,$){this._cacheFloat4(p,_,E,A,$)&&(this.engine.setFloat4(this._uniforms[p],_,E,A,$)||(this._valueCache[p]=null))}setColor3(p,_){this._cacheFloat3(p,_.r,_.g,_.b)&&(this.engine.setFloat3(this._uniforms[p],_.r,_.g,_.b)||(this._valueCache[p]=null))}setColor4(p,_,E){this._cacheFloat4(p,_.r,_.g,_.b,E)&&(this.engine.setFloat4(this._uniforms[p],_.r,_.g,_.b,E)||(this._valueCache[p]=null))}setDirectColor4(p,_){this._cacheFloat4(p,_.r,_.g,_.b,_.a)&&(this.engine.setFloat4(this._uniforms[p],_.r,_.g,_.b,_.a)||(this._valueCache[p]=null))}_getVertexShaderCode(){return this.vertexShader?this.engine._getShaderSource(this.vertexShader):null}_getFragmentShaderCode(){return this.fragmentShader?this.engine._getShaderSource(this.fragmentShader):null}}class ha{static SetMatrixPrecision(p){if(ha.MatrixTrackPrecisionChange=!1,p&&!ha.MatrixUse64Bits&&ha.MatrixTrackedMatrices)for(let _=0;_<ha.MatrixTrackedMatrices.length;++_){const E=ha.MatrixTrackedMatrices[_],A=E._m;E._m=new Array(16);for(let $=0;$<16;++$)E._m[$]=A[$]}ha.MatrixUse64Bits=p,ha.MatrixCurrentType=ha.MatrixUse64Bits?Array:Float32Array,ha.MatrixTrackedMatrices=null}}ha.MatrixUse64Bits=!1,ha.MatrixTrackPrecisionChange=!0,ha.MatrixCurrentType=Float32Array,ha.MatrixTrackedMatrices=[];class nl{get underlyingResource(){return this._webGLTexture}constructor(p=null,_){if(this._MSAARenderBuffers=null,this._context=_,!p&&(p=_.createTexture(),!p))throw new Error("Unable to create webGL texture");this.set(p)}setUsage(){}set(p){this._webGLTexture=p}reset(){this._webGLTexture=null,this._MSAARenderBuffers=null}addMSAARenderBuffer(p){this._MSAARenderBuffers||(this._MSAARenderBuffers=[]),this._MSAARenderBuffers.push(p)}releaseMSAARenderBuffers(){if(this._MSAARenderBuffers){for(const p of this._MSAARenderBuffers)this._context.deleteRenderbuffer(p);this._MSAARenderBuffers=null}}getMSAARenderBuffer(p=0){return this._MSAARenderBuffers?.[p]??null}release(){this.releaseMSAARenderBuffers(),this._webGLTexture&&this._context.deleteTexture(this._webGLTexture),this.reset()}}class nx{static IsWrapper(p){return p.getPipelineContext===void 0}static GetEffect(p){return p.getPipelineContext===void 0?p.effect:p}constructor(p,_=!0){this._wasPreviouslyReady=!1,this._forceRebindOnNextCall=!0,this._wasPreviouslyUsingInstances=null,this.effect=null,this.defines=null,this.drawContext=p.createDrawContext(),_&&(this.materialContext=p.createMaterialContext())}setEffect(p,_,E=!0){this.effect=p,_!==void 0&&(this.defines=_),E&&this.drawContext?.reset()}dispose(){this.drawContext?.dispose()}}class zh{get isDirty(){return this._isStencilTestDirty||this._isStencilMaskDirty||this._isStencilFuncDirty||this._isStencilOpDirty}get func(){return this._func}set func(p){this._func!==p&&(this._func=p,this._isStencilFuncDirty=!0)}get funcRef(){return this._funcRef}set funcRef(p){this._funcRef!==p&&(this._funcRef=p,this._isStencilFuncDirty=!0)}get funcMask(){return this._funcMask}set funcMask(p){this._funcMask!==p&&(this._funcMask=p,this._isStencilFuncDirty=!0)}get opStencilFail(){return this._opStencilFail}set opStencilFail(p){this._opStencilFail!==p&&(this._opStencilFail=p,this._isStencilOpDirty=!0)}get opDepthFail(){return this._opDepthFail}set opDepthFail(p){this._opDepthFail!==p&&(this._opDepthFail=p,this._isStencilOpDirty=!0)}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(p){this._opStencilDepthPass!==p&&(this._opStencilDepthPass=p,this._isStencilOpDirty=!0)}get mask(){return this._mask}set mask(p){this._mask!==p&&(this._mask=p,this._isStencilMaskDirty=!0)}get enabled(){return this._enabled}set enabled(p){this._enabled!==p&&(this._enabled=p,this._isStencilTestDirty=!0)}constructor(p=!0){this._isStencilTestDirty=!1,this._isStencilMaskDirty=!1,this._isStencilFuncDirty=!1,this._isStencilOpDirty=!1,this.useStencilGlobalOnly=!1,p&&this.reset()}reset(){this.stencilMaterial=void 0,this.stencilGlobal?.reset(),this._isStencilTestDirty=!0,this._isStencilMaskDirty=!0,this._isStencilFuncDirty=!0,this._isStencilOpDirty=!0}apply(p){if(!p)return;const _=!this.useStencilGlobalOnly&&!!this.stencilMaterial?.enabled;this.enabled=_?this.stencilMaterial.enabled:this.stencilGlobal.enabled,this.func=_?this.stencilMaterial.func:this.stencilGlobal.func,this.funcRef=_?this.stencilMaterial.funcRef:this.stencilGlobal.funcRef,this.funcMask=_?this.stencilMaterial.funcMask:this.stencilGlobal.funcMask,this.opStencilFail=_?this.stencilMaterial.opStencilFail:this.stencilGlobal.opStencilFail,this.opDepthFail=_?this.stencilMaterial.opDepthFail:this.stencilGlobal.opDepthFail,this.opStencilDepthPass=_?this.stencilMaterial.opStencilDepthPass:this.stencilGlobal.opStencilDepthPass,this.mask=_?this.stencilMaterial.mask:this.stencilGlobal.mask,this.isDirty&&(this._isStencilTestDirty&&(this.enabled?p.enable(p.STENCIL_TEST):p.disable(p.STENCIL_TEST),this._isStencilTestDirty=!1),this._isStencilMaskDirty&&(p.stencilMask(this.mask),this._isStencilMaskDirty=!1),this._isStencilFuncDirty&&(p.stencilFunc(this.func,this.funcRef,this.funcMask),this._isStencilFuncDirty=!1),this._isStencilOpDirty&&(p.stencilOp(this.opStencilFail,this.opDepthFail,this.opStencilDepthPass),this._isStencilOpDirty=!1))}}class Ko{static get Now(){return wa()&&window.performance&&window.performance.now?window.performance.now():Date.now()}}class Uc{}class rr{static get NpmPackage(){return"babylonjs@6.41.2"}static get Version(){return"6.41.2"}get description(){let p=this.name+this.webGLVersion;return this._caps.parallelShaderCompile&&(p+=" - Parallel shader compilation"),p}get name(){return this._name}set name(p){this._name=p}get version(){return this._webGLVersion}get isDisposed(){return this._isDisposed}static get ShadersRepository(){return va.ShadersRepository}static set ShadersRepository(p){va.ShadersRepository=p}_getShaderProcessor(p){return this._shaderProcessor}get useReverseDepthBuffer(){return this._useReverseDepthBuffer}set useReverseDepthBuffer(p){p!==this._useReverseDepthBuffer&&(this._useReverseDepthBuffer=p,p?this._depthCullingState.depthFunc=518:this._depthCullingState.depthFunc=515)}get frameId(){return this._frameId}get supportsUniformBuffers(){return this.webGLVersion>1&&!this.disableUniformBuffers}getCreationOptions(){return this._creationOptions}get _shouldUseHighPrecisionShader(){return!!(this._caps.highPrecisionShaderSupported&&this._highPrecisionShadersAllowed)}get needPOTTextures(){return this._webGLVersion<2||this.forcePOTTextures}get activeRenderLoops(){return this._activeRenderLoops}get doNotHandleContextLost(){return this._doNotHandleContextLost}set doNotHandleContextLost(p){this._doNotHandleContextLost=p}get _supportsHardwareTextureRescaling(){return!1}set framebufferDimensionsObject(p){this._framebufferDimensionsObject=p}get currentViewport(){return this._cachedViewport}get emptyTexture(){return this._emptyTexture||(this._emptyTexture=this.createRawTexture(new Uint8Array(4),1,1,5,!1,!1,1)),this._emptyTexture}get emptyTexture3D(){return this._emptyTexture3D||(this._emptyTexture3D=this.createRawTexture3D(new Uint8Array(4),1,1,1,5,!1,!1,1)),this._emptyTexture3D}get emptyTexture2DArray(){return this._emptyTexture2DArray||(this._emptyTexture2DArray=this.createRawTexture2DArray(new Uint8Array(4),1,1,1,5,!1,!1,1)),this._emptyTexture2DArray}get emptyCubeTexture(){if(!this._emptyCubeTexture){const p=new Uint8Array(4),_=[p,p,p,p,p,p];this._emptyCubeTexture=this.createRawCubeTexture(_,1,5,0,!1,!1,1)}return this._emptyCubeTexture}get isWebGPU(){return this._isWebGPU}get shaderPlatformName(){return this._shaderPlatformName}get snapshotRendering(){return!1}set snapshotRendering(p){}get snapshotRenderingMode(){return this._snapshotRenderingMode}set snapshotRenderingMode(p){this._snapshotRenderingMode=p}snapshotRenderingReset(){this.snapshotRendering=!1}static _CreateCanvas(p,_){if(typeof document>"u")return new OffscreenCanvas(p,_);const E=document.createElement("canvas");return E.width=p,E.height=_,E}createCanvas(p,_){return rr._CreateCanvas(p,_)}createCanvasImage(){return document.createElement("img")}constructor(p,_,E,A){this._name="WebGL",this._isDisposed=!1,this.forcePOTTextures=!1,this.isFullscreen=!1,this.cullBackFaces=null,this.renderEvenInBackground=!0,this.preventCacheWipeBetweenFrames=!1,this.validateShaderPrograms=!1,this._useReverseDepthBuffer=!1,this.isNDCHalfZRange=!1,this.hasOriginBottomLeft=!0,this.disableUniformBuffers=!1,this.onDisposeObservable=new Mi,this._frameId=0,this._uniformBuffers=new Array,this._storageBuffers=new Array,this._webGLVersion=1,this._windowIsBackground=!1,this._highPrecisionShadersAllowed=!0,this._badOS=!1,this._badDesktopOS=!1,this._renderingQueueLaunched=!1,this._activeRenderLoops=new Array,this.onContextLostObservable=new Mi,this.onContextRestoredObservable=new Mi,this._contextWasLost=!1,this._doNotHandleContextLost=!1,this.disableVertexArrayObjects=!1,this._colorWrite=!0,this._colorWriteChanged=!0,this._depthCullingState=new Rl,this._stencilStateComposer=new zh,this._stencilState=new _o,this._alphaState=new X2,this._alphaMode=1,this._alphaEquation=0,this._internalTexturesCache=new Array,this._renderTargetWrapperCache=new Array,this._activeChannel=0,this._currentTextureChannel=-1,this._boundTexturesCache={},this._compiledEffects={},this._vertexAttribArraysEnabled=[],this._currentRenderTarget=null,this._uintIndicesCurrentlySet=!1,this._currentBoundBuffer=new Array,this._currentFramebuffer=null,this._dummyFramebuffer=null,this._currentBufferPointers=new Array,this._currentInstanceLocations=new Array,this._currentInstanceBuffers=new Array,this._vaoRecordInProgress=!1,this._mustWipeVertexAttributes=!1,this._nextFreeTextureSlots=new Array,this._maxSimultaneousTextures=0,this._maxMSAASamplesOverride=null,this._activeRequests=new Array,this.adaptToDeviceRatio=!1,this._lastDevicePixelRatio=1,this._transformTextureUrl=null,this.hostInformation={isMobile:!1},this.premultipliedAlpha=!0,this.onBeforeTextureInitObservable=new Mi,this._isWebGPU=!1,this._snapshotRenderingMode=0,this._viewportCached={x:0,y:0,z:0,w:0},this._unpackFlipYCached=null,this.enableUnpackFlipYCached=!0,this._boundUniforms={},this.startTime=Ko.Now;let $=null;E=E||{},this._creationOptions=E,this.adaptToDeviceRatio=A??!1,this._stencilStateComposer.stencilGlobal=this._stencilState,ha.SetMatrixPrecision(!!E.useHighPrecisionMatrix),E.antialias=_??E.antialias,E.deterministicLockstep=E.deterministicLockstep??!1,E.lockstepMaxSteps=E.lockstepMaxSteps??4,E.timeStep=E.timeStep??1/60,E.audioEngine=E.audioEngine??!0,E.stencil=E.stencil??!0,this._audioContext=E.audioEngineOptions?.audioContext??null,this._audioDestination=E.audioEngineOptions?.audioDestination??null,this.premultipliedAlpha=E.premultipliedAlpha??!0,this.useExactSrgbConversions=E.useExactSrgbConversions??!1,this._doNotHandleContextLost=!!E.doNotHandleContextLost,this._isStencilEnable=!!E.stencil,A=A||E.adaptToDeviceRatio||!1;const ne=wa()&&window.devicePixelRatio||1,xe=E.limitDeviceRatio||ne;if(this._hardwareScalingLevel=A?1/Math.min(xe,ne):1,this._lastDevicePixelRatio=ne,!p)return;if(p.getContext){if($=p,this._renderingCanvas=$,E.preserveDrawingBuffer===void 0&&(E.preserveDrawingBuffer=!1),E.xrCompatible===void 0&&(E.xrCompatible=!0),navigator&&navigator.userAgent){this._setupMobileChecks();const Te=navigator.userAgent;for(const Re of rr.ExceptionList){const ke=Re.key,We=Re.targets;if(new RegExp(ke).test(Te)){if(Re.capture&&Re.captureConstraint){const xt=Re.capture,qe=Re.captureConstraint,Nt=new RegExp(xt).exec(Te);if(Nt&&Nt.length>0&&parseInt(Nt[Nt.length-1])>=qe)continue}for(const xt of We)switch(xt){case"uniformBuffer":this.disableUniformBuffers=!0;break;case"vao":this.disableVertexArrayObjects=!0;break;case"antialias":E.antialias=!1;break;case"maxMSAASamples":this._maxMSAASamplesOverride=1;break}}}}if(this._doNotHandleContextLost||(this._onContextLost=Te=>{Te.preventDefault(),this._contextWasLost=!0,vi.Warn("WebGL context lost."),this.onContextLostObservable.notifyObservers(this)},this._onContextRestored=()=>{this._restoreEngineAfterContextLost(()=>this._initGLContext())},$.addEventListener("webglcontextlost",this._onContextLost,!1),$.addEventListener("webglcontextrestored",this._onContextRestored,!1),E.powerPreference=E.powerPreference||"high-performance"),this._badDesktopOS=/^((?!chrome|android).)*safari/i.test(navigator.userAgent),this._badDesktopOS&&(E.xrCompatible=!1),!E.disableWebGL2Support)try{this._gl=$.getContext("webgl2",E)||$.getContext("experimental-webgl2",E),this._gl&&(this._webGLVersion=2,this._shaderPlatformName="WEBGL2",this._gl.deleteQuery||(this._webGLVersion=1,this._shaderPlatformName="WEBGL1"))}catch{}if(!this._gl){if(!$)throw new Error("The provided canvas is null or undefined.");try{this._gl=$.getContext("webgl",E)||$.getContext("experimental-webgl",E)}catch{throw new Error("WebGL not supported")}}if(!this._gl)throw new Error("WebGL not supported")}else{this._gl=p,this._renderingCanvas=this._gl.canvas,this._gl.renderbufferStorageMultisample?(this._webGLVersion=2,this._shaderPlatformName="WEBGL2"):this._shaderPlatformName="WEBGL1";const Te=this._gl.getContextAttributes();Te&&(E.stencil=Te.stencil)}this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,this._gl.NONE),E.useHighPrecisionFloats!==void 0&&(this._highPrecisionShadersAllowed=E.useHighPrecisionFloats),this.resize(),this._initGLContext(),this._initFeatures();for(let Te=0;Te<this._caps.maxVertexAttribs;Te++)this._currentBufferPointers[Te]=new Uc;this._shaderProcessor=this.webGLVersion>1?new _0:new n0,this._badOS=/iPad/i.test(navigator.userAgent)||/iPhone/i.test(navigator.userAgent);const ce=`Babylon.js v${rr.Version}`;vi.Log(ce+` - ${this.description}`),this._renderingCanvas&&this._renderingCanvas.setAttribute&&this._renderingCanvas.setAttribute("data-engine",ce)}_setupMobileChecks(){navigator&&navigator.userAgent&&(this._checkForMobile=()=>{const p=navigator.userAgent;this.hostInformation.isMobile=p.indexOf("Mobile")!==-1||p.indexOf("Mac")!==-1&&px()&&"ontouchend"in document},this._checkForMobile(),wa()&&window.addEventListener("resize",this._checkForMobile))}_restoreEngineAfterContextLost(p){setTimeout(async()=>{this._dummyFramebuffer=null,this._emptyTexture=null,this._emptyCubeTexture=null,this._emptyTexture3D=null,this._emptyTexture2DArray=null;const _=this._depthCullingState.depthTest,E=this._depthCullingState.depthFunc,A=this._depthCullingState.depthMask,$=this._stencilState.stencilTest;await p(),this.wipeCaches(!0),this._rebuildEffects(),this._rebuildComputeEffects?.(),this._rebuildBuffers(),this._rebuildInternalTextures(),this._rebuildTextures(),this._rebuildRenderTargetWrappers(),this.wipeCaches(!0),this._depthCullingState.depthTest=_,this._depthCullingState.depthFunc=E,this._depthCullingState.depthMask=A,this._stencilState.stencilTest=$,vi.Warn(this.name+" context successfully restored."),this.onContextRestoredObservable.notifyObservers(this),this._contextWasLost=!1},0)}_sharedInit(p){this._renderingCanvas=p}_getShaderProcessingContext(p){return null}_rebuildInternalTextures(){const p=this._internalTexturesCache.slice();for(const _ of p)_._rebuild()}_rebuildRenderTargetWrappers(){const p=this._renderTargetWrapperCache.slice();for(const _ of p)_._rebuild()}_rebuildEffects(){for(const p in this._compiledEffects){const _=this._compiledEffects[p];_._pipelineContext=null,_._prepareEffect()}va.ResetCache()}areAllEffectsReady(){for(const p in this._compiledEffects)if(!this._compiledEffects[p].isReady())return!1;return!0}_rebuildBuffers(){for(const p of this._uniformBuffers)p._rebuildAfterContextLost()}_rebuildTextures(){}_initGLContext(){this._caps={maxTexturesImageUnits:this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),maxCombinedTexturesImageUnits:this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),maxVertexTextureImageUnits:this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),maxTextureSize:this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),maxSamples:this._webGLVersion>1?this._gl.getParameter(this._gl.MAX_SAMPLES):1,maxCubemapTextureSize:this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),maxRenderTextureSize:this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),maxVertexAttribs:this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),maxVaryingVectors:this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),maxFragmentUniformVectors:this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),maxVertexUniformVectors:this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),parallelShaderCompile:this._gl.getExtension("KHR_parallel_shader_compile")||void 0,standardDerivatives:this._webGLVersion>1||this._gl.getExtension("OES_standard_derivatives")!==null,maxAnisotropy:1,astc:this._gl.getExtension("WEBGL_compressed_texture_astc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),bptc:this._gl.getExtension("EXT_texture_compression_bptc")||this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),s3tc:this._gl.getExtension("WEBGL_compressed_texture_s3tc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),s3tc_srgb:this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),pvrtc:this._gl.getExtension("WEBGL_compressed_texture_pvrtc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),etc1:this._gl.getExtension("WEBGL_compressed_texture_etc1")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),etc2:this._gl.getExtension("WEBGL_compressed_texture_etc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc")||this._gl.getExtension("WEBGL_compressed_texture_es3_0"),textureAnisotropicFilterExtension:this._gl.getExtension("EXT_texture_filter_anisotropic")||this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),uintIndices:this._webGLVersion>1||this._gl.getExtension("OES_element_index_uint")!==null,fragmentDepthSupported:this._webGLVersion>1||this._gl.getExtension("EXT_frag_depth")!==null,highPrecisionShaderSupported:!1,timerQuery:this._gl.getExtension("EXT_disjoint_timer_query_webgl2")||this._gl.getExtension("EXT_disjoint_timer_query"),supportOcclusionQuery:this._webGLVersion>1,canUseTimestampForTimerQuery:!1,drawBuffersExtension:!1,maxMSAASamples:1,colorBufferFloat:!!(this._webGLVersion>1&&this._gl.getExtension("EXT_color_buffer_float")),supportFloatTexturesResolve:!1,rg11b10ufColorRenderable:!1,colorBufferHalfFloat:!!(this._webGLVersion>1&&this._gl.getExtension("EXT_color_buffer_half_float")),textureFloat:!!(this._webGLVersion>1||this._gl.getExtension("OES_texture_float")),textureHalfFloat:!!(this._webGLVersion>1||this._gl.getExtension("OES_texture_half_float")),textureHalfFloatRender:!1,textureFloatLinearFiltering:!1,textureFloatRender:!1,textureHalfFloatLinearFiltering:!1,vertexArrayObject:!1,instancedArrays:!1,textureLOD:!!(this._webGLVersion>1||this._gl.getExtension("EXT_shader_texture_lod")),texelFetch:this._webGLVersion!==1,blendMinMax:!1,multiview:this._gl.getExtension("OVR_multiview2"),oculusMultiview:this._gl.getExtension("OCULUS_multiview"),depthTextureExtension:!1,canUseGLInstanceID:this._webGLVersion>1,canUseGLVertexID:this._webGLVersion>1,supportComputeShaders:!1,supportSRGBBuffers:!1,supportTransformFeedbacks:this._webGLVersion>1,textureMaxLevel:this._webGLVersion>1,texture2DArrayMaxLayerCount:this._webGLVersion>1?this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS):128,disableMorphTargetTexture:!1},this._caps.supportFloatTexturesResolve=this._caps.colorBufferFloat,this._caps.rg11b10ufColorRenderable=this._caps.colorBufferFloat,this._glVersion=this._gl.getParameter(this._gl.VERSION);const p=this._gl.getExtension("WEBGL_debug_renderer_info");if(p!=null&&(this._glRenderer=this._gl.getParameter(p.UNMASKED_RENDERER_WEBGL),this._glVendor=this._gl.getParameter(p.UNMASKED_VENDOR_WEBGL)),this._glVendor||(this._glVendor=this._gl.getParameter(this._gl.VENDOR)||"Unknown vendor"),this._glRenderer||(this._glRenderer=this._gl.getParameter(this._gl.RENDERER)||"Unknown renderer"),this._gl.HALF_FLOAT_OES!==36193&&(this._gl.HALF_FLOAT_OES=36193),this._gl.RGBA16F!==34842&&(this._gl.RGBA16F=34842),this._gl.RGBA32F!==34836&&(this._gl.RGBA32F=34836),this._gl.DEPTH24_STENCIL8!==35056&&(this._gl.DEPTH24_STENCIL8=35056),this._caps.timerQuery&&(this._webGLVersion===1&&(this._gl.getQuery=this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)),this._caps.canUseTimestampForTimerQuery=(this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT,this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)??0)>0),this._caps.maxAnisotropy=this._caps.textureAnisotropicFilterExtension?this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,this._caps.textureFloatLinearFiltering=!!(this._caps.textureFloat&&this._gl.getExtension("OES_texture_float_linear")),this._caps.textureFloatRender=!!(this._caps.textureFloat&&this._canRenderToFloatFramebuffer()),this._caps.textureHalfFloatLinearFiltering=!!(this._webGLVersion>1||this._caps.textureHalfFloat&&this._gl.getExtension("OES_texture_half_float_linear")),this._caps.astc&&(this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR),this._caps.bptc&&(this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT=this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT),this._caps.s3tc_srgb&&(this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT,this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT),this._caps.etc2&&(this._gl.COMPRESSED_SRGB8_ETC2=this._caps.etc2.COMPRESSED_SRGB8_ETC2,this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC),this._webGLVersion>1&&this._gl.HALF_FLOAT_OES!==5131&&(this._gl.HALF_FLOAT_OES=5131),this._caps.textureHalfFloatRender=this._caps.textureHalfFloat&&this._canRenderToHalfFloatFramebuffer(),this._webGLVersion>1)this._caps.drawBuffersExtension=!0,this._caps.maxMSAASamples=this._maxMSAASamplesOverride!==null?this._maxMSAASamplesOverride:this._gl.getParameter(this._gl.MAX_SAMPLES);else{const _=this._gl.getExtension("WEBGL_draw_buffers");if(_!==null){this._caps.drawBuffersExtension=!0,this._gl.drawBuffers=_.drawBuffersWEBGL.bind(_),this._gl.DRAW_FRAMEBUFFER=this._gl.FRAMEBUFFER;for(let E=0;E<16;E++)this._gl["COLOR_ATTACHMENT"+E+"_WEBGL"]=_["COLOR_ATTACHMENT"+E+"_WEBGL"]}}if(this._webGLVersion>1)this._caps.depthTextureExtension=!0;else{const _=this._gl.getExtension("WEBGL_depth_texture");_!=null&&(this._caps.depthTextureExtension=!0,this._gl.UNSIGNED_INT_24_8=_.UNSIGNED_INT_24_8_WEBGL)}if(this.disableVertexArrayObjects)this._caps.vertexArrayObject=!1;else if(this._webGLVersion>1)this._caps.vertexArrayObject=!0;else{const _=this._gl.getExtension("OES_vertex_array_object");_!=null&&(this._caps.vertexArrayObject=!0,this._gl.createVertexArray=_.createVertexArrayOES.bind(_),this._gl.bindVertexArray=_.bindVertexArrayOES.bind(_),this._gl.deleteVertexArray=_.deleteVertexArrayOES.bind(_))}if(this._webGLVersion>1)this._caps.instancedArrays=!0;else{const _=this._gl.getExtension("ANGLE_instanced_arrays");_!=null?(this._caps.instancedArrays=!0,this._gl.drawArraysInstanced=_.drawArraysInstancedANGLE.bind(_),this._gl.drawElementsInstanced=_.drawElementsInstancedANGLE.bind(_),this._gl.vertexAttribDivisor=_.vertexAttribDivisorANGLE.bind(_)):this._caps.instancedArrays=!1}if(this._gl.getShaderPrecisionFormat){const _=this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER,this._gl.HIGH_FLOAT),E=this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER,this._gl.HIGH_FLOAT);_&&E&&(this._caps.highPrecisionShaderSupported=_.precision!==0&&E.precision!==0)}if(this._webGLVersion>1)this._caps.blendMinMax=!0;else{const _=this._gl.getExtension("EXT_blend_minmax");_!=null&&(this._caps.blendMinMax=!0,this._gl.MAX=_.MAX_EXT,this._gl.MIN=_.MIN_EXT)}if(!this._caps.supportSRGBBuffers){if(this._webGLVersion>1)this._caps.supportSRGBBuffers=!0,this._glSRGBExtensionValues={SRGB:WebGL2RenderingContext.SRGB,SRGB8:WebGL2RenderingContext.SRGB8,SRGB8_ALPHA8:WebGL2RenderingContext.SRGB8_ALPHA8};else{const _=this._gl.getExtension("EXT_sRGB");_!=null&&(this._caps.supportSRGBBuffers=!0,this._glSRGBExtensionValues={SRGB:_.SRGB_EXT,SRGB8:_.SRGB_ALPHA_EXT,SRGB8_ALPHA8:_.SRGB_ALPHA_EXT})}this._caps.supportSRGBBuffers=this._caps.supportSRGBBuffers&&!!(this._creationOptions&&this._creationOptions.forceSRGBBufferSupportState)}this._depthCullingState.depthTest=!0,this._depthCullingState.depthFunc=this._gl.LEQUAL,this._depthCullingState.depthMask=!0,this._maxSimultaneousTextures=this._caps.maxCombinedTexturesImageUnits;for(let _=0;_<this._maxSimultaneousTextures;_++)this._nextFreeTextureSlots.push(_);this._glRenderer==="Mali-G72"&&(this._caps.disableMorphTargetTexture=!0)}_initFeatures(){this._features={forceBitmapOverHTMLImageElement:typeof HTMLImageElement>"u",supportRenderAndCopyToLodForFloatTextures:this._webGLVersion!==1,supportDepthStencilTexture:this._webGLVersion!==1,supportShadowSamplers:this._webGLVersion!==1,uniformBufferHardCheckMatrix:!1,allowTexturePrefiltering:this._webGLVersion!==1,trackUbosInFrame:!1,checkUbosContentBeforeUpload:!1,supportCSM:this._webGLVersion!==1,basisNeedsPOT:this._webGLVersion===1,support3DTextures:this._webGLVersion!==1,needTypeSuffixInShaderConstants:this._webGLVersion!==1,supportMSAA:this._webGLVersion!==1,supportSSAO2:this._webGLVersion!==1,supportExtendedTextureFormats:this._webGLVersion!==1,supportSwitchCaseInShader:this._webGLVersion!==1,supportSyncTextureRead:!0,needsInvertingBitmap:!0,useUBOBindingCache:!0,needShaderCodeInlining:!1,needToAlwaysBindUniformBuffers:!1,supportRenderPasses:!1,supportSpriteInstancing:!0,forceVertexBufferStrideMultiple4Bytes:!1,_collectUbosUpdatedInFrame:!1}}get webGLVersion(){return this._webGLVersion}getClassName(){return"ThinEngine"}get isStencilEnable(){return this._isStencilEnable}_prepareWorkingCanvas(){if(this._workingCanvas)return;this._workingCanvas=this.createCanvas(1,1);const p=this._workingCanvas.getContext("2d");p&&(this._workingContext=p)}resetTextureCache(){for(const p in this._boundTexturesCache)Object.prototype.hasOwnProperty.call(this._boundTexturesCache,p)&&(this._boundTexturesCache[p]=null);this._currentTextureChannel=-1}getInfo(){return this.getGlInfo()}getGlInfo(){return{vendor:this._glVendor,renderer:this._glRenderer,version:this._glVersion}}setHardwareScalingLevel(p){this._hardwareScalingLevel=p,this.resize()}getHardwareScalingLevel(){return this._hardwareScalingLevel}getLoadedTexturesCache(){return this._internalTexturesCache}getCaps(){return this._caps}stopRenderLoop(p){if(!p){this._activeRenderLoops.length=0,this._cancelFrame();return}const _=this._activeRenderLoops.indexOf(p);_>=0&&(this._activeRenderLoops.splice(_,1),this._activeRenderLoops.length==0&&this._cancelFrame())}_cancelFrame(){if(this._renderingQueueLaunched&&this._frameHandler){if(this._renderingQueueLaunched=!1,wa()){const{cancelAnimationFrame:p}=this.getHostWindow()||window;if(typeof p=="function")return p(this._frameHandler)}else if(typeof cancelAnimationFrame=="function")return cancelAnimationFrame(this._frameHandler);return clearTimeout(this._frameHandler)}}_renderLoop(){if(!this._contextWasLost){let p=!0;if((this._isDisposed||!this.renderEvenInBackground&&this._windowIsBackground)&&(p=!1),p){this.beginFrame();for(let _=0;_<this._activeRenderLoops.length;_++){const E=this._activeRenderLoops[_];E()}this.endFrame()}}this._activeRenderLoops.length>0?this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow()):this._renderingQueueLaunched=!1}getRenderingCanvas(){return this._renderingCanvas}getAudioContext(){return this._audioContext}getAudioDestination(){return this._audioDestination}getHostWindow(){return wa()?this._renderingCanvas&&this._renderingCanvas.ownerDocument&&this._renderingCanvas.ownerDocument.defaultView?this._renderingCanvas.ownerDocument.defaultView:window:null}getRenderWidth(p=!1){return!p&&this._currentRenderTarget?this._currentRenderTarget.width:this._framebufferDimensionsObject?this._framebufferDimensionsObject.framebufferWidth:this._gl.drawingBufferWidth}getRenderHeight(p=!1){return!p&&this._currentRenderTarget?this._currentRenderTarget.height:this._framebufferDimensionsObject?this._framebufferDimensionsObject.framebufferHeight:this._gl.drawingBufferHeight}_queueNewFrame(p,_){return rr.QueueNewFrame(p,_)}runRenderLoop(p){this._activeRenderLoops.indexOf(p)===-1&&(this._activeRenderLoops.push(p),this._renderingQueueLaunched||(this._renderingQueueLaunched=!0,this._boundRenderFunction=()=>this._renderLoop(),this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow())))}clear(p,_,E,A=!1){const $=this.stencilStateComposer.useStencilGlobalOnly;this.stencilStateComposer.useStencilGlobalOnly=!0,this.applyStates(),this.stencilStateComposer.useStencilGlobalOnly=$;let ne=0;if(_&&p){let xe=!0;if(this._currentRenderTarget){const ce=this._currentRenderTarget.texture?.format;if(ce===8||ce===9||ce===10||ce===11){const Te=this._currentRenderTarget.texture?.type;Te===7||Te===5?(rr._TempClearColorUint32[0]=p.r*255,rr._TempClearColorUint32[1]=p.g*255,rr._TempClearColorUint32[2]=p.b*255,rr._TempClearColorUint32[3]=p.a*255,this._gl.clearBufferuiv(this._gl.COLOR,0,rr._TempClearColorUint32),xe=!1):(rr._TempClearColorInt32[0]=p.r*255,rr._TempClearColorInt32[1]=p.g*255,rr._TempClearColorInt32[2]=p.b*255,rr._TempClearColorInt32[3]=p.a*255,this._gl.clearBufferiv(this._gl.COLOR,0,rr._TempClearColorInt32),xe=!1)}}xe&&(this._gl.clearColor(p.r,p.g,p.b,p.a!==void 0?p.a:1),ne|=this._gl.COLOR_BUFFER_BIT)}E&&(this.useReverseDepthBuffer?(this._depthCullingState.depthFunc=this._gl.GEQUAL,this._gl.clearDepth(0)):this._gl.clearDepth(1),ne|=this._gl.DEPTH_BUFFER_BIT),A&&(this._gl.clearStencil(0),ne|=this._gl.STENCIL_BUFFER_BIT),this._gl.clear(ne)}_viewport(p,_,E,A){(p!==this._viewportCached.x||_!==this._viewportCached.y||E!==this._viewportCached.z||A!==this._viewportCached.w)&&(this._viewportCached.x=p,this._viewportCached.y=_,this._viewportCached.z=E,this._viewportCached.w=A,this._gl.viewport(p,_,E,A))}setViewport(p,_,E){const A=_||this.getRenderWidth(),$=E||this.getRenderHeight(),ne=p.x||0,xe=p.y||0;this._cachedViewport=p,this._viewport(ne*A,xe*$,A*p.width,$*p.height)}beginFrame(){}endFrame(){this._badOS&&this.flushFramebuffer(),this._frameId++}resize(p=!1){let _,E;if(this.adaptToDeviceRatio){const A=wa()&&window.devicePixelRatio||1,$=this._lastDevicePixelRatio/A;this._lastDevicePixelRatio=A,this._hardwareScalingLevel*=$}if(wa()&&px())if(this._renderingCanvas){const A=this._renderingCanvas.getBoundingClientRect?this._renderingCanvas.getBoundingClientRect():{width:this._renderingCanvas.width*this._hardwareScalingLevel,height:this._renderingCanvas.height*this._hardwareScalingLevel};_=this._renderingCanvas.clientWidth||A.width||this._renderingCanvas.width||100,E=this._renderingCanvas.clientHeight||A.height||this._renderingCanvas.height||100}else _=window.innerWidth,E=window.innerHeight;else _=this._renderingCanvas?this._renderingCanvas.width:100,E=this._renderingCanvas?this._renderingCanvas.height:100;this.setSize(_/this._hardwareScalingLevel,E/this._hardwareScalingLevel,p)}setSize(p,_,E=!1){return!this._renderingCanvas||(p=p|0,_=_|0,!E&&this._renderingCanvas.width===p&&this._renderingCanvas.height===_)?!1:(this._renderingCanvas.width=p,this._renderingCanvas.height=_,!0)}bindFramebuffer(p,_=0,E,A,$,ne=0,xe=0){const ce=p;this._currentRenderTarget&&this.unBindFramebuffer(this._currentRenderTarget),this._currentRenderTarget=p,this._bindUnboundFramebuffer(ce._MSAAFramebuffer?ce._MSAAFramebuffer:ce._framebuffer);const Te=this._gl;p.isMulti||(p.is2DArray?Te.framebufferTextureLayer(Te.FRAMEBUFFER,Te.COLOR_ATTACHMENT0,p.texture._hardwareTexture?.underlyingResource,ne,xe):p.isCube?Te.framebufferTexture2D(Te.FRAMEBUFFER,Te.COLOR_ATTACHMENT0,Te.TEXTURE_CUBE_MAP_POSITIVE_X+_,p.texture._hardwareTexture?.underlyingResource,ne):ce._currentLOD!==ne&&(Te.framebufferTexture2D(Te.FRAMEBUFFER,Te.COLOR_ATTACHMENT0,Te.TEXTURE_2D,p.texture._hardwareTexture?.underlyingResource,ne),ce._currentLOD=ne));const Re=p._depthStencilTexture;if(Re){const ke=p._depthStencilTextureWithStencil?Te.DEPTH_STENCIL_ATTACHMENT:Te.DEPTH_ATTACHMENT;p.is2DArray?Te.framebufferTextureLayer(Te.FRAMEBUFFER,ke,Re._hardwareTexture?.underlyingResource,ne,xe):p.isCube?Te.framebufferTexture2D(Te.FRAMEBUFFER,ke,Te.TEXTURE_CUBE_MAP_POSITIVE_X+_,Re._hardwareTexture?.underlyingResource,ne):Te.framebufferTexture2D(Te.FRAMEBUFFER,ke,Te.TEXTURE_2D,Re._hardwareTexture?.underlyingResource,ne)}this._cachedViewport&&!$?this.setViewport(this._cachedViewport,E,A):(E||(E=p.width,ne&&(E=E/Math.pow(2,ne))),A||(A=p.height,ne&&(A=A/Math.pow(2,ne))),this._viewport(0,0,E,A)),this.wipeCaches()}setState(p,_=0,E,A=!1,$,ne,xe=0){(this._depthCullingState.cull!==p||E)&&(this._depthCullingState.cull=p);const ce=this.cullBackFaces??$??!0?this._gl.BACK:this._gl.FRONT;(this._depthCullingState.cullFace!==ce||E)&&(this._depthCullingState.cullFace=ce),this.setZOffset(_),this.setZOffsetUnits(xe);const Te=A?this._gl.CW:this._gl.CCW;(this._depthCullingState.frontFace!==Te||E)&&(this._depthCullingState.frontFace=Te),this._stencilStateComposer.stencilMaterial=ne}getDepthBuffer(){return this._depthCullingState.depthTest}setDepthBuffer(p){this._depthCullingState.depthTest=p}setZOffset(p){this._depthCullingState.zOffset=this.useReverseDepthBuffer?-p:p}getZOffset(){const p=this._depthCullingState.zOffset;return this.useReverseDepthBuffer?-p:p}setZOffsetUnits(p){this._depthCullingState.zOffsetUnits=this.useReverseDepthBuffer?-p:p}getZOffsetUnits(){const p=this._depthCullingState.zOffsetUnits;return this.useReverseDepthBuffer?-p:p}_bindUnboundFramebuffer(p){this._currentFramebuffer!==p&&(this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,p),this._currentFramebuffer=p)}_currentFrameBufferIsDefaultFrameBuffer(){return this._currentFramebuffer===null}generateMipmaps(p){this._bindTextureDirectly(this._gl.TEXTURE_2D,p,!0),this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null)}unBindFramebuffer(p,_=!1,E){const A=p;this._currentRenderTarget=null;const $=this._gl;if(A._MSAAFramebuffer){if(p.isMulti){this.unBindMultiColorAttachmentFramebuffer(p,_,E);return}$.bindFramebuffer($.READ_FRAMEBUFFER,A._MSAAFramebuffer),$.bindFramebuffer($.DRAW_FRAMEBUFFER,A._framebuffer),$.blitFramebuffer(0,0,p.width,p.height,0,0,p.width,p.height,$.COLOR_BUFFER_BIT,$.NEAREST)}p.texture?.generateMipMaps&&!_&&!p.isCube&&this.generateMipmaps(p.texture),E&&(A._MSAAFramebuffer&&this._bindUnboundFramebuffer(A._framebuffer),E()),this._bindUnboundFramebuffer(null)}flushFramebuffer(){this._gl.flush()}restoreDefaultFramebuffer(){this._currentRenderTarget?this.unBindFramebuffer(this._currentRenderTarget):this._bindUnboundFramebuffer(null),this._cachedViewport&&this.setViewport(this._cachedViewport),this.wipeCaches()}_resetVertexBufferBinding(){this.bindArrayBuffer(null),this._cachedVertexBuffers=null}createVertexBuffer(p,_,E){return this._createVertexBuffer(p,this._gl.STATIC_DRAW)}_createVertexBuffer(p,_){const E=this._gl.createBuffer();if(!E)throw new Error("Unable to create vertex buffer");const A=new Xo(E);return this.bindArrayBuffer(A),typeof p!="number"?p instanceof Array?(this._gl.bufferData(this._gl.ARRAY_BUFFER,new Float32Array(p),_),A.capacity=p.length*4):(this._gl.bufferData(this._gl.ARRAY_BUFFER,p,_),A.capacity=p.byteLength):(this._gl.bufferData(this._gl.ARRAY_BUFFER,new Uint8Array(p),_),A.capacity=p),this._resetVertexBufferBinding(),A.references=1,A}createDynamicVertexBuffer(p,_){return this._createVertexBuffer(p,this._gl.DYNAMIC_DRAW)}_resetIndexBufferBinding(){this.bindIndexBuffer(null),this._cachedIndexBuffer=null}createIndexBuffer(p,_,E){const A=this._gl.createBuffer(),$=new Xo(A);if(!A)throw new Error("Unable to create index buffer");this.bindIndexBuffer($);const ne=this._normalizeIndexData(p);return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,ne,_?this._gl.DYNAMIC_DRAW:this._gl.STATIC_DRAW),this._resetIndexBufferBinding(),$.references=1,$.is32Bits=ne.BYTES_PER_ELEMENT===4,$}_normalizeIndexData(p){if(p.BYTES_PER_ELEMENT===2)return p;if(this._caps.uintIndices){if(p instanceof Uint32Array)return p;for(let E=0;E<p.length;E++)if(p[E]>=65535)return new Uint32Array(p);return new Uint16Array(p)}return new Uint16Array(p)}bindArrayBuffer(p){this._vaoRecordInProgress||this._unbindVertexArrayObject(),this._bindBuffer(p,this._gl.ARRAY_BUFFER)}bindUniformBlock(p,_,E){const A=p.program,$=this._gl.getUniformBlockIndex(A,_);this._gl.uniformBlockBinding(A,$,E)}bindIndexBuffer(p){this._vaoRecordInProgress||this._unbindVertexArrayObject(),this._bindBuffer(p,this._gl.ELEMENT_ARRAY_BUFFER)}_bindBuffer(p,_){(this._vaoRecordInProgress||this._currentBoundBuffer[_]!==p)&&(this._gl.bindBuffer(_,p?p.underlyingResource:null),this._currentBoundBuffer[_]=p)}updateArrayBuffer(p){this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,p)}_vertexAttribPointer(p,_,E,A,$,ne,xe){const ce=this._currentBufferPointers[_];if(!ce)return;let Te=!1;ce.active?(ce.buffer!==p&&(ce.buffer=p,Te=!0),ce.size!==E&&(ce.size=E,Te=!0),ce.type!==A&&(ce.type=A,Te=!0),ce.normalized!==$&&(ce.normalized=$,Te=!0),ce.stride!==ne&&(ce.stride=ne,Te=!0),ce.offset!==xe&&(ce.offset=xe,Te=!0)):(Te=!0,ce.active=!0,ce.index=_,ce.size=E,ce.type=A,ce.normalized=$,ce.stride=ne,ce.offset=xe,ce.buffer=p),(Te||this._vaoRecordInProgress)&&(this.bindArrayBuffer(p),A===this._gl.UNSIGNED_INT||A===this._gl.INT?this._gl.vertexAttribIPointer(_,E,A,ne,xe):this._gl.vertexAttribPointer(_,E,A,$,ne,xe))}_bindIndexBufferWithCache(p){p!=null&&this._cachedIndexBuffer!==p&&(this._cachedIndexBuffer=p,this.bindIndexBuffer(p),this._uintIndicesCurrentlySet=p.is32Bits)}_bindVertexBuffersAttributes(p,_,E){const A=_.getAttributesNames();this._vaoRecordInProgress||this._unbindVertexArrayObject(),this.unbindAllAttributes();for(let $=0;$<A.length;$++){const ne=_.getAttributeLocation($);if(ne>=0){const xe=A[$];let ce=null;if(E&&(ce=E[xe]),ce||(ce=p[xe]),!ce)continue;this._gl.enableVertexAttribArray(ne),this._vaoRecordInProgress||(this._vertexAttribArraysEnabled[ne]=!0);const Te=ce.getBuffer();Te&&(this._vertexAttribPointer(Te,ne,ce.getSize(),ce.type,ce.normalized,ce.byteStride,ce.byteOffset),ce.getIsInstanced()&&(this._gl.vertexAttribDivisor(ne,ce.getInstanceDivisor()),this._vaoRecordInProgress||(this._currentInstanceLocations.push(ne),this._currentInstanceBuffers.push(Te))))}}}recordVertexArrayObject(p,_,E,A){const $=this._gl.createVertexArray();if(!$)throw new Error("Unable to create VAO");return this._vaoRecordInProgress=!0,this._gl.bindVertexArray($),this._mustWipeVertexAttributes=!0,this._bindVertexBuffersAttributes(p,E,A),this.bindIndexBuffer(_),this._vaoRecordInProgress=!1,this._gl.bindVertexArray(null),$}bindVertexArrayObject(p,_){this._cachedVertexArrayObject!==p&&(this._cachedVertexArrayObject=p,this._gl.bindVertexArray(p),this._cachedVertexBuffers=null,this._cachedIndexBuffer=null,this._uintIndicesCurrentlySet=_!=null&&_.is32Bits,this._mustWipeVertexAttributes=!0)}bindBuffersDirectly(p,_,E,A,$){if(this._cachedVertexBuffers!==p||this._cachedEffectForVertexBuffers!==$){this._cachedVertexBuffers=p,this._cachedEffectForVertexBuffers=$;const ne=$.getAttributesCount();this._unbindVertexArrayObject(),this.unbindAllAttributes();let xe=0;for(let ce=0;ce<ne;ce++)if(ce<E.length){const Te=$.getAttributeLocation(ce);Te>=0&&(this._gl.enableVertexAttribArray(Te),this._vertexAttribArraysEnabled[Te]=!0,this._vertexAttribPointer(p,Te,E[ce],this._gl.FLOAT,!1,A,xe)),xe+=E[ce]*4}}this._bindIndexBufferWithCache(_)}_unbindVertexArrayObject(){this._cachedVertexArrayObject&&(this._cachedVertexArrayObject=null,this._gl.bindVertexArray(null))}bindBuffers(p,_,E,A){(this._cachedVertexBuffers!==p||this._cachedEffectForVertexBuffers!==E)&&(this._cachedVertexBuffers=p,this._cachedEffectForVertexBuffers=E,this._bindVertexBuffersAttributes(p,E,A)),this._bindIndexBufferWithCache(_)}unbindInstanceAttributes(){let p;for(let _=0,E=this._currentInstanceLocations.length;_<E;_++){const A=this._currentInstanceBuffers[_];p!=A&&A.references&&(p=A,this.bindArrayBuffer(A));const $=this._currentInstanceLocations[_];this._gl.vertexAttribDivisor($,0)}this._currentInstanceBuffers.length=0,this._currentInstanceLocations.length=0}releaseVertexArrayObject(p){this._gl.deleteVertexArray(p)}_releaseBuffer(p){return p.references--,p.references===0?(this._deleteBuffer(p),!0):!1}_deleteBuffer(p){this._gl.deleteBuffer(p.underlyingResource)}updateAndBindInstancesBuffer(p,_,E){if(this.bindArrayBuffer(p),_&&this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,_),E[0].index!==void 0)this.bindInstancesBuffer(p,E,!0);else for(let A=0;A<4;A++){const $=E[A];this._vertexAttribArraysEnabled[$]||(this._gl.enableVertexAttribArray($),this._vertexAttribArraysEnabled[$]=!0),this._vertexAttribPointer(p,$,4,this._gl.FLOAT,!1,64,A*16),this._gl.vertexAttribDivisor($,1),this._currentInstanceLocations.push($),this._currentInstanceBuffers.push(p)}}bindInstancesBuffer(p,_,E=!0){this.bindArrayBuffer(p);let A=0;if(E)for(let $=0;$<_.length;$++){const ne=_[$];A+=ne.attributeSize*4}for(let $=0;$<_.length;$++){const ne=_[$];ne.index===void 0&&(ne.index=this._currentEffect.getAttributeLocationByName(ne.attributeName)),!(ne.index<0)&&(this._vertexAttribArraysEnabled[ne.index]||(this._gl.enableVertexAttribArray(ne.index),this._vertexAttribArraysEnabled[ne.index]=!0),this._vertexAttribPointer(p,ne.index,ne.attributeSize,ne.attributeType||this._gl.FLOAT,ne.normalized||!1,A,ne.offset),this._gl.vertexAttribDivisor(ne.index,ne.divisor===void 0?1:ne.divisor),this._currentInstanceLocations.push(ne.index),this._currentInstanceBuffers.push(p))}}disableInstanceAttributeByName(p){if(!this._currentEffect)return;const _=this._currentEffect.getAttributeLocationByName(p);this.disableInstanceAttribute(_)}disableInstanceAttribute(p){let _=!1,E;for(;(E=this._currentInstanceLocations.indexOf(p))!==-1;)this._currentInstanceLocations.splice(E,1),this._currentInstanceBuffers.splice(E,1),_=!0,E=this._currentInstanceLocations.indexOf(p);_&&(this._gl.vertexAttribDivisor(p,0),this.disableAttributeByIndex(p))}disableAttributeByIndex(p){this._gl.disableVertexAttribArray(p),this._vertexAttribArraysEnabled[p]=!1,this._currentBufferPointers[p].active=!1}draw(p,_,E,A){this.drawElementsType(p?0:1,_,E,A)}drawPointClouds(p,_,E){this.drawArraysType(2,p,_,E)}drawUnIndexed(p,_,E,A){this.drawArraysType(p?0:1,_,E,A)}drawElementsType(p,_,E,A){this.applyStates(),this._reportDrawCall();const $=this._drawMode(p),ne=this._uintIndicesCurrentlySet?this._gl.UNSIGNED_INT:this._gl.UNSIGNED_SHORT,xe=this._uintIndicesCurrentlySet?4:2;A?this._gl.drawElementsInstanced($,E,ne,_*xe,A):this._gl.drawElements($,E,ne,_*xe)}drawArraysType(p,_,E,A){this.applyStates(),this._reportDrawCall();const $=this._drawMode(p);A?this._gl.drawArraysInstanced($,_,E,A):this._gl.drawArrays($,_,E)}_drawMode(p){switch(p){case 0:return this._gl.TRIANGLES;case 2:return this._gl.POINTS;case 1:return this._gl.LINES;case 3:return this._gl.POINTS;case 4:return this._gl.LINES;case 5:return this._gl.LINE_LOOP;case 6:return this._gl.LINE_STRIP;case 7:return this._gl.TRIANGLE_STRIP;case 8:return this._gl.TRIANGLE_FAN;default:return this._gl.TRIANGLES}}_reportDrawCall(){}_releaseEffect(p){this._compiledEffects[p._key]&&delete this._compiledEffects[p._key];const _=p.getPipelineContext();_&&this._deletePipelineContext(_)}_deletePipelineContext(p){const _=p;_&&_.program&&(_.program.__SPECTOR_rebuildProgram=null,this._gl.deleteProgram(_.program))}_getGlobalDefines(p){if(p){this.isNDCHalfZRange?p.IS_NDC_HALF_ZRANGE="":delete p.IS_NDC_HALF_ZRANGE,this.useReverseDepthBuffer?p.USE_REVERSE_DEPTHBUFFER="":delete p.USE_REVERSE_DEPTHBUFFER,this.useExactSrgbConversions?p.USE_EXACT_SRGB_CONVERSIONS="":delete p.USE_EXACT_SRGB_CONVERSIONS;return}else{let _="";return this.isNDCHalfZRange&&(_+="#define IS_NDC_HALF_ZRANGE"),this.useReverseDepthBuffer&&(_&&(_+=`
`),_+="#define USE_REVERSE_DEPTHBUFFER"),this.useExactSrgbConversions&&(_&&(_+=`
`),_+="#define USE_EXACT_SRGB_CONVERSIONS"),_}}createEffect(p,_,E,A,$,ne,xe,ce,Te,Re=Xa.GLSL){const ke=p.vertexElement||p.vertex||p.vertexToken||p.vertexSource||p,We=p.fragmentElement||p.fragment||p.fragmentToken||p.fragmentSource||p,Xe=this._getGlobalDefines();let xt=$??_.defines??"";Xe&&(xt+=Xe);const qe=ke+"+"+We+"@"+xt;if(this._compiledEffects[qe]){const Nt=this._compiledEffects[qe];return xe&&Nt.isReady()&&xe(Nt),Nt}const ht=new va(p,_,E,A,this,$,ne,xe,ce,Te,qe,Re);return this._compiledEffects[qe]=ht,ht}static _ConcatenateShader(p,_,E=""){return E+(_?_+`
`:"")+p}_compileShader(p,_,E,A){return this._compileRawShader(rr._ConcatenateShader(p,E,A),_)}_compileRawShader(p,_){const E=this._gl,A=E.createShader(_==="vertex"?E.VERTEX_SHADER:E.FRAGMENT_SHADER);if(!A){let $=E.NO_ERROR,ne=E.NO_ERROR;for(;(ne=E.getError())!==E.NO_ERROR;)$=ne;throw new Error(`Something went wrong while creating a gl ${_} shader object. gl error=${$}, gl isContextLost=${E.isContextLost()}, _contextWasLost=${this._contextWasLost}`)}return E.shaderSource(A,p),E.compileShader(A),A}_getShaderSource(p){return this._gl.getShaderSource(p)}createRawShaderProgram(p,_,E,A,$=null){A=A||this._gl;const ne=this._compileRawShader(_,"vertex"),xe=this._compileRawShader(E,"fragment");return this._createShaderProgram(p,ne,xe,A,$)}createShaderProgram(p,_,E,A,$,ne=null){$=$||this._gl;const xe=this._webGLVersion>1?`#version 300 es
#define WEBGL2 
`:"",ce=this._compileShader(_,"vertex",A,xe),Te=this._compileShader(E,"fragment",A,xe);return this._createShaderProgram(p,ce,Te,$,ne)}inlineShaderCode(p){return p}createPipelineContext(p){const _=new K2;return _.engine=this,this._caps.parallelShaderCompile&&(_.isParallelCompiled=!0),_}createMaterialContext(){}createDrawContext(){}_createShaderProgram(p,_,E,A,$=null){const ne=A.createProgram();if(p.program=ne,!ne)throw new Error("Unable to create program");return A.attachShader(ne,_),A.attachShader(ne,E),A.linkProgram(ne),p.context=A,p.vertexShader=_,p.fragmentShader=E,p.isParallelCompiled||this._finalizePipelineContext(p),ne}_finalizePipelineContext(p){const _=p.context,E=p.vertexShader,A=p.fragmentShader,$=p.program;if(!_.getProgramParameter($,_.LINK_STATUS)){if(!this._gl.getShaderParameter(E,this._gl.COMPILE_STATUS)){const ce=this._gl.getShaderInfoLog(E);if(ce)throw p.vertexCompilationError=ce,new Error("VERTEX SHADER "+ce)}if(!this._gl.getShaderParameter(A,this._gl.COMPILE_STATUS)){const ce=this._gl.getShaderInfoLog(A);if(ce)throw p.fragmentCompilationError=ce,new Error("FRAGMENT SHADER "+ce)}const xe=_.getProgramInfoLog($);if(xe)throw p.programLinkError=xe,new Error(xe)}if(this.validateShaderPrograms&&(_.validateProgram($),!_.getProgramParameter($,_.VALIDATE_STATUS))){const ce=_.getProgramInfoLog($);if(ce)throw p.programValidationError=ce,new Error(ce)}_.deleteShader(E),_.deleteShader(A),p.vertexShader=void 0,p.fragmentShader=void 0,p.onCompiled&&(p.onCompiled(),p.onCompiled=void 0)}_preparePipelineContext(p,_,E,A,$,ne,xe,ce,Te,Re){const ke=p;A?ke.program=this.createRawShaderProgram(ke,_,E,void 0,Te):ke.program=this.createShaderProgram(ke,_,E,ce,void 0,Te),ke.program.__SPECTOR_rebuildProgram=xe}_isRenderingStateCompiled(p){const _=p;return this._isDisposed||_._isDisposed?!1:this._gl.getProgramParameter(_.program,this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)?(this._finalizePipelineContext(_),!0):!1}_executeWhenRenderingStateIsCompiled(p,_){const E=p;if(!E.isParallelCompiled){_();return}const A=E.onCompiled;A?E.onCompiled=()=>{A(),_()}:E.onCompiled=_}getUniforms(p,_){const E=new Array,A=p;for(let $=0;$<_.length;$++)E.push(this._gl.getUniformLocation(A.program,_[$]));return E}getAttributes(p,_){const E=[],A=p;for(let $=0;$<_.length;$++)try{E.push(this._gl.getAttribLocation(A.program,_[$]))}catch{E.push(-1)}return E}enableEffect(p){p=p!==null&&nx.IsWrapper(p)?p.effect:p,!(!p||p===this._currentEffect)&&(this._stencilStateComposer.stencilMaterial=void 0,p=p,this.bindSamplers(p),this._currentEffect=p,p.onBind&&p.onBind(p),p._onBindObservable&&p._onBindObservable.notifyObservers(p))}setInt(p,_){return p?(this._gl.uniform1i(p,_),!0):!1}setInt2(p,_,E){return p?(this._gl.uniform2i(p,_,E),!0):!1}setInt3(p,_,E,A){return p?(this._gl.uniform3i(p,_,E,A),!0):!1}setInt4(p,_,E,A,$){return p?(this._gl.uniform4i(p,_,E,A,$),!0):!1}setIntArray(p,_){return p?(this._gl.uniform1iv(p,_),!0):!1}setIntArray2(p,_){return!p||_.length%2!==0?!1:(this._gl.uniform2iv(p,_),!0)}setIntArray3(p,_){return!p||_.length%3!==0?!1:(this._gl.uniform3iv(p,_),!0)}setIntArray4(p,_){return!p||_.length%4!==0?!1:(this._gl.uniform4iv(p,_),!0)}setUInt(p,_){return p?(this._gl.uniform1ui(p,_),!0):!1}setUInt2(p,_,E){return p?(this._gl.uniform2ui(p,_,E),!0):!1}setUInt3(p,_,E,A){return p?(this._gl.uniform3ui(p,_,E,A),!0):!1}setUInt4(p,_,E,A,$){return p?(this._gl.uniform4ui(p,_,E,A,$),!0):!1}setUIntArray(p,_){return p?(this._gl.uniform1uiv(p,_),!0):!1}setUIntArray2(p,_){return!p||_.length%2!==0?!1:(this._gl.uniform2uiv(p,_),!0)}setUIntArray3(p,_){return!p||_.length%3!==0?!1:(this._gl.uniform3uiv(p,_),!0)}setUIntArray4(p,_){return!p||_.length%4!==0?!1:(this._gl.uniform4uiv(p,_),!0)}setArray(p,_){return!p||_.length<1?!1:(this._gl.uniform1fv(p,_),!0)}setArray2(p,_){return!p||_.length%2!==0?!1:(this._gl.uniform2fv(p,_),!0)}setArray3(p,_){return!p||_.length%3!==0?!1:(this._gl.uniform3fv(p,_),!0)}setArray4(p,_){return!p||_.length%4!==0?!1:(this._gl.uniform4fv(p,_),!0)}setMatrices(p,_){return p?(this._gl.uniformMatrix4fv(p,!1,_),!0):!1}setMatrix3x3(p,_){return p?(this._gl.uniformMatrix3fv(p,!1,_),!0):!1}setMatrix2x2(p,_){return p?(this._gl.uniformMatrix2fv(p,!1,_),!0):!1}setFloat(p,_){return p?(this._gl.uniform1f(p,_),!0):!1}setFloat2(p,_,E){return p?(this._gl.uniform2f(p,_,E),!0):!1}setFloat3(p,_,E,A){return p?(this._gl.uniform3f(p,_,E,A),!0):!1}setFloat4(p,_,E,A,$){return p?(this._gl.uniform4f(p,_,E,A,$),!0):!1}applyStates(){if(this._depthCullingState.apply(this._gl),this._stencilStateComposer.apply(this._gl),this._alphaState.apply(this._gl),this._colorWriteChanged){this._colorWriteChanged=!1;const p=this._colorWrite;this._gl.colorMask(p,p,p,p)}}setColorWrite(p){p!==this._colorWrite&&(this._colorWriteChanged=!0,this._colorWrite=p)}getColorWrite(){return this._colorWrite}get depthCullingState(){return this._depthCullingState}get alphaState(){return this._alphaState}get stencilState(){return this._stencilState}get stencilStateComposer(){return this._stencilStateComposer}clearInternalTexturesCache(){this._internalTexturesCache.length=0}wipeCaches(p){this.preventCacheWipeBetweenFrames&&!p||(this._currentEffect=null,this._viewportCached.x=0,this._viewportCached.y=0,this._viewportCached.z=0,this._viewportCached.w=0,this._unbindVertexArrayObject(),p&&(this._currentProgram=null,this.resetTextureCache(),this._stencilStateComposer.reset(),this._depthCullingState.reset(),this._depthCullingState.depthFunc=this._gl.LEQUAL,this._alphaState.reset(),this._alphaMode=1,this._alphaEquation=0,this._colorWrite=!0,this._colorWriteChanged=!0,this._unpackFlipYCached=null,this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,this._gl.NONE),this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,0),this._mustWipeVertexAttributes=!0,this.unbindAllAttributes()),this._resetVertexBufferBinding(),this._cachedIndexBuffer=null,this._cachedEffectForVertexBuffers=null,this.bindIndexBuffer(null))}_getSamplingParameters(p,_){const E=this._gl;let A=E.NEAREST,$=E.NEAREST;switch(p){case 11:A=E.LINEAR,_?$=E.LINEAR_MIPMAP_NEAREST:$=E.LINEAR;break;case 3:A=E.LINEAR,_?$=E.LINEAR_MIPMAP_LINEAR:$=E.LINEAR;break;case 8:A=E.NEAREST,_?$=E.NEAREST_MIPMAP_LINEAR:$=E.NEAREST;break;case 4:A=E.NEAREST,_?$=E.NEAREST_MIPMAP_NEAREST:$=E.NEAREST;break;case 5:A=E.NEAREST,_?$=E.LINEAR_MIPMAP_NEAREST:$=E.LINEAR;break;case 6:A=E.NEAREST,_?$=E.LINEAR_MIPMAP_LINEAR:$=E.LINEAR;break;case 7:A=E.NEAREST,$=E.LINEAR;break;case 1:A=E.NEAREST,$=E.NEAREST;break;case 9:A=E.LINEAR,_?$=E.NEAREST_MIPMAP_NEAREST:$=E.NEAREST;break;case 10:A=E.LINEAR,_?$=E.NEAREST_MIPMAP_LINEAR:$=E.NEAREST;break;case 2:A=E.LINEAR,$=E.LINEAR;break;case 12:A=E.LINEAR,$=E.NEAREST;break}return{min:$,mag:A}}_createTexture(){const p=this._gl.createTexture();if(!p)throw new Error("Unable to create texture");return p}_createHardwareTexture(){return new nl(this._createTexture(),this._gl)}_createInternalTexture(p,_,E=!0,A=Gn.Unknown){let $=!1,ne=0,xe=3,ce=5,Te=!1,Re=1,ke;_!==void 0&&typeof _=="object"?($=!!_.generateMipMaps,ne=_.type===void 0?0:_.type,xe=_.samplingMode===void 0?3:_.samplingMode,ce=_.format===void 0?5:_.format,Te=_.useSRGBBuffer===void 0?!1:_.useSRGBBuffer,Re=_.samples??1,ke=_.label):$=!!_,Te&&(Te=this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU)),(ne===1&&!this._caps.textureFloatLinearFiltering||ne===2&&!this._caps.textureHalfFloatLinearFiltering)&&(xe=1),ne===1&&!this._caps.textureFloat&&(ne=0,vi.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));const We=this._gl,Xe=new u0(this,A),xt=p.width||p,qe=p.height||p,ht=p.layers||0,Nt=this._getSamplingParameters(xe,$),wt=ht!==0?We.TEXTURE_2D_ARRAY:We.TEXTURE_2D,Qt=this._getRGBABufferInternalSizedFormat(ne,ce,Te),Ht=this._getInternalFormat(ce),Wt=this._getWebGLTextureType(ne);return this._bindTextureDirectly(wt,Xe),ht!==0?(Xe.is2DArray=!0,We.texImage3D(wt,0,Qt,xt,qe,ht,0,Ht,Wt,null)):We.texImage2D(wt,0,Qt,xt,qe,0,Ht,Wt,null),We.texParameteri(wt,We.TEXTURE_MAG_FILTER,Nt.mag),We.texParameteri(wt,We.TEXTURE_MIN_FILTER,Nt.min),We.texParameteri(wt,We.TEXTURE_WRAP_S,We.CLAMP_TO_EDGE),We.texParameteri(wt,We.TEXTURE_WRAP_T,We.CLAMP_TO_EDGE),$&&this._gl.generateMipmap(wt),this._bindTextureDirectly(wt,null),Xe._useSRGBBuffer=Te,Xe.baseWidth=xt,Xe.baseHeight=qe,Xe.width=xt,Xe.height=qe,Xe.depth=ht,Xe.isReady=!0,Xe.samples=Re,Xe.generateMipMaps=$,Xe.samplingMode=xe,Xe.type=ne,Xe.format=ce,Xe.label=ke,this._internalTexturesCache.push(Xe),Xe}_getUseSRGBBuffer(p,_){return p&&this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU||_)}_createTextureBase(p,_,E,A,$=3,ne=null,xe=null,ce,Te,Re=null,ke=null,We=null,Xe=null,xt,qe,ht){p=p||"";const Nt=p.substr(0,5)==="data:",wt=p.substr(0,5)==="blob:",Qt=Nt&&p.indexOf(";base64,")!==-1,Ht=ke||new u0(this,Gn.Url);Ht!==ke&&(Ht.label=p.substring(0,60));const Wt=p;this._transformTextureUrl&&!Qt&&!ke&&!Re&&(p=this._transformTextureUrl(p)),Wt!==p&&(Ht._originalUrl=Wt);const zt=p.lastIndexOf(".");let xi=Xe||(zt>-1?p.substring(zt).toLowerCase():""),wi=null;xi.indexOf("?")>-1&&(xi=xi.split("?")[0]);for(const xn of rr._TextureLoaders)if(xn.canLoad(xi,xt)){wi=xn;break}A&&A.addPendingData(Ht),Ht.url=p,Ht.generateMipMaps=!_,Ht.samplingMode=$,Ht.invertY=E,Ht._useSRGBBuffer=this._getUseSRGBBuffer(!!ht,_),this._doNotHandleContextLost||(Ht._buffer=Re);let cs=null;ne&&!ke&&(cs=Ht.onLoadedObservable.add(ne)),ke||this._internalTexturesCache.push(Ht);const Mr=(xn,qr)=>{A&&A.removePendingData(Ht),p===Wt?(cs&&Ht.onLoadedObservable.remove(cs),wr.UseFallbackTexture&&p!==wr.FallbackTexture&&this._createTextureBase(wr.FallbackTexture,_,Ht.invertY,A,$,null,xe,ce,Te,Re,Ht),xn=(xn||"Unknown error")+(wr.UseFallbackTexture?" - Fallback texture was used":""),Ht.onErrorObservable.notifyObservers({message:xn,exception:qr}),xe&&xe(xn,qr)):(vi.Warn(`Failed to load ${p}, falling back to ${Wt}`),this._createTextureBase(Wt,_,Ht.invertY,A,$,ne,xe,ce,Te,Re,Ht,We,Xe,xt,qe,ht))};if(wi){const xn=qr=>{wi.loadData(qr,Ht,(Tn,h0,Ra,x0,X0,K0)=>{K0?Mr("TextureLoader failed to load data"):ce(Ht,xi,A,{width:Tn,height:h0},Ht.invertY,!Ra,x0,()=>(X0(),!1),$)},qe)};Re?Re instanceof ArrayBuffer?xn(new Uint8Array(Re)):ArrayBuffer.isView(Re)?xn(Re):xe&&xe("Unable to load: only ArrayBuffer or ArrayBufferView is supported",null):this._loadFile(p,qr=>xn(new Uint8Array(qr)),void 0,A?A.offlineProvider:void 0,!0,(qr,Tn)=>{Mr("Unable to load "+(qr&&qr.responseURL,Tn))})}else{const xn=qr=>{wt&&!this._doNotHandleContextLost&&(Ht._buffer=qr),ce(Ht,xi,A,qr,Ht.invertY,_,!1,Te,$)};!Nt||Qt?Re&&(typeof Re.decoding=="string"||Re.close)?xn(Re):rr._FileToolsLoadImage(p,xn,Mr,A?A.offlineProvider:null,xt,Ht.invertY&&this._features.needsInvertingBitmap?{imageOrientation:"flipY"}:void 0):typeof Re=="string"||Re instanceof ArrayBuffer||ArrayBuffer.isView(Re)||Re instanceof Blob?rr._FileToolsLoadImage(Re,xn,Mr,A?A.offlineProvider:null,xt,Ht.invertY&&this._features.needsInvertingBitmap?{imageOrientation:"flipY"}:void 0):Re&&xn(Re)}return Ht}createTexture(p,_,E,A,$=3,ne=null,xe=null,ce=null,Te=null,Re=null,ke=null,We,Xe,xt,qe){return this._createTextureBase(p,_,E,A,$,ne,xe,this._prepareWebGLTexture.bind(this),(ht,Nt,wt,Qt,Ht,Wt)=>{const zt=this._gl,xi=wt.width===ht&&wt.height===Nt;Ht._creationFlags=xt??0;const wi=this._getTexImageParametersForCreateTexture(Re,Qt,Ht._useSRGBBuffer);if(xi)return zt.texImage2D(zt.TEXTURE_2D,0,wi.internalFormat,wi.format,wi.type,wt),!1;const vs=this._caps.maxTextureSize;if(wt.width>vs||wt.height>vs||!this._supportsHardwareTextureRescaling)return this._prepareWorkingCanvas(),!this._workingCanvas||!this._workingContext||(this._workingCanvas.width=ht,this._workingCanvas.height=Nt,this._workingContext.drawImage(wt,0,0,wt.width,wt.height,0,0,ht,Nt),zt.texImage2D(zt.TEXTURE_2D,0,wi.internalFormat,wi.format,wi.type,this._workingCanvas),Ht.width=ht,Ht.height=Nt),!1;{const cs=new u0(this,Gn.Temp);this._bindTextureDirectly(zt.TEXTURE_2D,cs,!0),zt.texImage2D(zt.TEXTURE_2D,0,wi.internalFormat,wi.format,wi.type,wt),this._rescaleTexture(cs,Ht,A,wi.format,()=>{this._releaseTexture(cs),this._bindTextureDirectly(zt.TEXTURE_2D,Ht,!0),Wt()})}return!0},ce,Te,Re,ke,We,Xe,qe)}_getTexImageParametersForCreateTexture(p,_,E){p==null&&(p=_===".jpg"&&!E?4:5);let A,$;return this.webGLVersion===1?(A=this._getInternalFormat(p,E),$=A):(A=this._getInternalFormat(p,!1),$=this._getRGBABufferInternalSizedFormat(0,p,E)),{internalFormat:$,format:A,type:this._gl.UNSIGNED_BYTE}}static _FileToolsLoadImage(p,_,E,A,$,ne){throw Tr("FileTools")}_rescaleTexture(p,_,E,A,$){}createRawTexture(p,_,E,A,$,ne,xe,ce=null,Te=0,Re=0,ke=!1){throw Tr("Engine.RawTexture")}createRawCubeTexture(p,_,E,A,$,ne,xe,ce=null){throw Tr("Engine.RawTexture")}createRawTexture3D(p,_,E,A,$,ne,xe,ce,Te=null,Re=0){throw Tr("Engine.RawTexture")}createRawTexture2DArray(p,_,E,A,$,ne,xe,ce,Te=null,Re=0){throw Tr("Engine.RawTexture")}_unpackFlipY(p){this._unpackFlipYCached!==p&&(this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL,p?1:0),this.enableUnpackFlipYCached&&(this._unpackFlipYCached=p))}_getUnpackAlignement(){return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT)}_getTextureTarget(p){return p.isCube?this._gl.TEXTURE_CUBE_MAP:p.is3D?this._gl.TEXTURE_3D:p.is2DArray||p.isMultiview?this._gl.TEXTURE_2D_ARRAY:this._gl.TEXTURE_2D}updateTextureSamplingMode(p,_,E=!1){const A=this._getTextureTarget(_),$=this._getSamplingParameters(p,_.useMipMaps||E);this._setTextureParameterInteger(A,this._gl.TEXTURE_MAG_FILTER,$.mag,_),this._setTextureParameterInteger(A,this._gl.TEXTURE_MIN_FILTER,$.min),E&&(_.generateMipMaps=!0,this._gl.generateMipmap(A)),this._bindTextureDirectly(A,null),_.samplingMode=p}updateTextureDimensions(p,_,E,A=1){}updateTextureWrappingMode(p,_,E=null,A=null){const $=this._getTextureTarget(p);_!==null&&(this._setTextureParameterInteger($,this._gl.TEXTURE_WRAP_S,this._getTextureWrapMode(_),p),p._cachedWrapU=_),E!==null&&(this._setTextureParameterInteger($,this._gl.TEXTURE_WRAP_T,this._getTextureWrapMode(E),p),p._cachedWrapV=E),(p.is2DArray||p.is3D)&&A!==null&&(this._setTextureParameterInteger($,this._gl.TEXTURE_WRAP_R,this._getTextureWrapMode(A),p),p._cachedWrapR=A),this._bindTextureDirectly($,null)}_setupDepthStencilTexture(p,_,E,A,$,ne=1){const xe=_.width||_,ce=_.height||_,Te=_.layers||0;p.baseWidth=xe,p.baseHeight=ce,p.width=xe,p.height=ce,p.is2DArray=Te>0,p.depth=Te,p.isReady=!0,p.samples=ne,p.generateMipMaps=!1,p.samplingMode=A?2:1,p.type=0,p._comparisonFunction=$;const Re=this._gl,ke=this._getTextureTarget(p),We=this._getSamplingParameters(p.samplingMode,!1);Re.texParameteri(ke,Re.TEXTURE_MAG_FILTER,We.mag),Re.texParameteri(ke,Re.TEXTURE_MIN_FILTER,We.min),Re.texParameteri(ke,Re.TEXTURE_WRAP_S,Re.CLAMP_TO_EDGE),Re.texParameteri(ke,Re.TEXTURE_WRAP_T,Re.CLAMP_TO_EDGE),this.webGLVersion>1&&($===0?(Re.texParameteri(ke,Re.TEXTURE_COMPARE_FUNC,515),Re.texParameteri(ke,Re.TEXTURE_COMPARE_MODE,Re.NONE)):(Re.texParameteri(ke,Re.TEXTURE_COMPARE_FUNC,$),Re.texParameteri(ke,Re.TEXTURE_COMPARE_MODE,Re.COMPARE_REF_TO_TEXTURE)))}_uploadCompressedDataToTextureDirectly(p,_,E,A,$,ne=0,xe=0){const ce=this._gl;let Te=ce.TEXTURE_2D;if(p.isCube&&(Te=ce.TEXTURE_CUBE_MAP_POSITIVE_X+ne),p._useSRGBBuffer)switch(_){case 37492:case 36196:this._caps.etc2?_=ce.COMPRESSED_SRGB8_ETC2:p._useSRGBBuffer=!1;break;case 37496:this._caps.etc2?_=ce.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:p._useSRGBBuffer=!1;break;case 36492:_=ce.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;break;case 37808:_=ce.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;break;case 33776:this._caps.s3tc_srgb?_=ce.COMPRESSED_SRGB_S3TC_DXT1_EXT:p._useSRGBBuffer=!1;break;case 33777:this._caps.s3tc_srgb?_=ce.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:p._useSRGBBuffer=!1;break;case 33779:this._caps.s3tc_srgb?_=ce.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:p._useSRGBBuffer=!1;break;default:p._useSRGBBuffer=!1;break}this._gl.compressedTexImage2D(Te,xe,_,E,A,0,$)}_uploadDataToTextureDirectly(p,_,E=0,A=0,$,ne=!1){const xe=this._gl,ce=this._getWebGLTextureType(p.type),Te=this._getInternalFormat(p.format),Re=$===void 0?this._getRGBABufferInternalSizedFormat(p.type,p.format,p._useSRGBBuffer):this._getInternalFormat($,p._useSRGBBuffer);this._unpackFlipY(p.invertY);let ke=xe.TEXTURE_2D;p.isCube&&(ke=xe.TEXTURE_CUBE_MAP_POSITIVE_X+E);const We=Math.round(Math.log(p.width)*Math.LOG2E),Xe=Math.round(Math.log(p.height)*Math.LOG2E),xt=ne?p.width:Math.pow(2,Math.max(We-A,0)),qe=ne?p.height:Math.pow(2,Math.max(Xe-A,0));xe.texImage2D(ke,A,Re,xt,qe,0,Te,ce,_)}updateTextureData(p,_,E,A,$,ne,xe=0,ce=0,Te=!1){const Re=this._gl,ke=this._getWebGLTextureType(p.type),We=this._getInternalFormat(p.format);this._unpackFlipY(p.invertY);let Xe=Re.TEXTURE_2D,xt=Re.TEXTURE_2D;p.isCube&&(xt=Re.TEXTURE_CUBE_MAP_POSITIVE_X+xe,Xe=Re.TEXTURE_CUBE_MAP),this._bindTextureDirectly(Xe,p,!0),Re.texSubImage2D(xt,ce,E,A,$,ne,We,ke,_),Te&&this._gl.generateMipmap(xt),this._bindTextureDirectly(Xe,null)}_uploadArrayBufferViewToTexture(p,_,E=0,A=0){const $=this._gl,ne=p.isCube?$.TEXTURE_CUBE_MAP:$.TEXTURE_2D;this._bindTextureDirectly(ne,p,!0),this._uploadDataToTextureDirectly(p,_,E,A),this._bindTextureDirectly(ne,null,!0)}_prepareWebGLTextureContinuation(p,_,E,A,$){const ne=this._gl;if(!ne)return;const xe=this._getSamplingParameters($,!E);ne.texParameteri(ne.TEXTURE_2D,ne.TEXTURE_MAG_FILTER,xe.mag),ne.texParameteri(ne.TEXTURE_2D,ne.TEXTURE_MIN_FILTER,xe.min),!E&&!A&&ne.generateMipmap(ne.TEXTURE_2D),this._bindTextureDirectly(ne.TEXTURE_2D,null),_&&_.removePendingData(p),p.onLoadedObservable.notifyObservers(p),p.onLoadedObservable.clear()}_prepareWebGLTexture(p,_,E,A,$,ne,xe,ce,Te=3){const Re=this.getCaps().maxTextureSize,ke=Math.min(Re,this.needPOTTextures?rr.GetExponentOfTwo(A.width,Re):A.width),We=Math.min(Re,this.needPOTTextures?rr.GetExponentOfTwo(A.height,Re):A.height),Xe=this._gl;if(Xe){if(!p._hardwareTexture){E&&E.removePendingData(p);return}this._bindTextureDirectly(Xe.TEXTURE_2D,p,!0),this._unpackFlipY($===void 0?!0:!!$),p.baseWidth=A.width,p.baseHeight=A.height,p.width=ke,p.height=We,p.isReady=!0,p.type=p.type!==-1?p.type:0,p.format=p.format!==-1?p.format:_===".jpg"&&!p._useSRGBBuffer?4:5,!ce(ke,We,A,_,p,()=>{this._prepareWebGLTextureContinuation(p,E,ne,xe,Te)})&&this._prepareWebGLTextureContinuation(p,E,ne,xe,Te)}}_setupFramebufferDepthAttachments(p,_,E,A,$=1){const ne=this._gl;if(p&&_)return this._createRenderBuffer(E,A,$,ne.DEPTH_STENCIL,ne.DEPTH24_STENCIL8,ne.DEPTH_STENCIL_ATTACHMENT);if(_){let xe=ne.DEPTH_COMPONENT16;return this._webGLVersion>1&&(xe=ne.DEPTH_COMPONENT32F),this._createRenderBuffer(E,A,$,xe,xe,ne.DEPTH_ATTACHMENT)}return p?this._createRenderBuffer(E,A,$,ne.STENCIL_INDEX8,ne.STENCIL_INDEX8,ne.STENCIL_ATTACHMENT):null}_createRenderBuffer(p,_,E,A,$,ne,xe=!0){const Te=this._gl.createRenderbuffer();return this._updateRenderBuffer(Te,p,_,E,A,$,ne,xe)}_updateRenderBuffer(p,_,E,A,$,ne,xe,ce=!0){const Te=this._gl;return Te.bindRenderbuffer(Te.RENDERBUFFER,p),A>1&&Te.renderbufferStorageMultisample?Te.renderbufferStorageMultisample(Te.RENDERBUFFER,A,ne,_,E):Te.renderbufferStorage(Te.RENDERBUFFER,$,_,E),Te.framebufferRenderbuffer(Te.FRAMEBUFFER,xe,Te.RENDERBUFFER,p),ce&&Te.bindRenderbuffer(Te.RENDERBUFFER,null),p}_releaseTexture(p){this._deleteTexture(p._hardwareTexture?.underlyingResource),this.unbindAllTextures();const _=this._internalTexturesCache.indexOf(p);_!==-1&&this._internalTexturesCache.splice(_,1),p._lodTextureHigh&&p._lodTextureHigh.dispose(),p._lodTextureMid&&p._lodTextureMid.dispose(),p._lodTextureLow&&p._lodTextureLow.dispose(),p._irradianceTexture&&p._irradianceTexture.dispose()}_releaseRenderTargetWrapper(p){const _=this._renderTargetWrapperCache.indexOf(p);_!==-1&&this._renderTargetWrapperCache.splice(_,1)}_deleteTexture(p){p&&this._gl.deleteTexture(p)}_setProgram(p){this._currentProgram!==p&&(this._gl.useProgram(p),this._currentProgram=p)}bindSamplers(p){const _=p.getPipelineContext();this._setProgram(_.program);const E=p.getSamplers();for(let A=0;A<E.length;A++){const $=p.getUniform(E[A]);$&&(this._boundUniforms[A]=$)}this._currentEffect=null}_activateCurrentTexture(){this._currentTextureChannel!==this._activeChannel&&(this._gl.activeTexture(this._gl.TEXTURE0+this._activeChannel),this._currentTextureChannel=this._activeChannel)}_bindTextureDirectly(p,_,E=!1,A=!1){let $=!1;const ne=_&&_._associatedChannel>-1;if(E&&ne&&(this._activeChannel=_._associatedChannel),this._boundTexturesCache[this._activeChannel]!==_||A){if(this._activateCurrentTexture(),_&&_.isMultiview)throw vi.Error(["_bindTextureDirectly called with a multiview texture!",p,_]),"_bindTextureDirectly called with a multiview texture!";this._gl.bindTexture(p,_?._hardwareTexture?.underlyingResource??null),this._boundTexturesCache[this._activeChannel]=_,_&&(_._associatedChannel=this._activeChannel)}else E&&($=!0,this._activateCurrentTexture());return ne&&!E&&this._bindSamplerUniformToChannel(_._associatedChannel,this._activeChannel),$}_bindTexture(p,_,E){if(p===void 0)return;_&&(_._associatedChannel=p),this._activeChannel=p;const A=_?this._getTextureTarget(_):this._gl.TEXTURE_2D;this._bindTextureDirectly(A,_)}unbindAllTextures(){for(let p=0;p<this._maxSimultaneousTextures;p++)this._activeChannel=p,this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),this.webGLVersion>1&&(this._bindTextureDirectly(this._gl.TEXTURE_3D,null),this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY,null))}setTexture(p,_,E,A){p!==void 0&&(_&&(this._boundUniforms[p]=_),this._setTexture(p,E))}_bindSamplerUniformToChannel(p,_){const E=this._boundUniforms[p];!E||E._currentState===_||(this._gl.uniform1i(E,_),E._currentState=_)}_getTextureWrapMode(p){switch(p){case 1:return this._gl.REPEAT;case 0:return this._gl.CLAMP_TO_EDGE;case 2:return this._gl.MIRRORED_REPEAT}return this._gl.REPEAT}_setTexture(p,_,E=!1,A=!1,$=""){if(!_)return this._boundTexturesCache[p]!=null&&(this._activeChannel=p,this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),this.webGLVersion>1&&(this._bindTextureDirectly(this._gl.TEXTURE_3D,null),this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY,null))),!1;if(_.video){this._activeChannel=p;const Te=_.getInternalTexture();Te&&(Te._associatedChannel=p),_.update()}else if(_.delayLoadState===4)return _.delayLoad(),!1;let ne;A?ne=_.depthStencilTexture:_.isReady()?ne=_.getInternalTexture():_.isCube?ne=this.emptyCubeTexture:_.is3D?ne=this.emptyTexture3D:_.is2DArray?ne=this.emptyTexture2DArray:ne=this.emptyTexture,!E&&ne&&(ne._associatedChannel=p);let xe=!0;this._boundTexturesCache[p]===ne&&(E||this._bindSamplerUniformToChannel(ne._associatedChannel,p),xe=!1),this._activeChannel=p;const ce=this._getTextureTarget(ne);if(xe&&this._bindTextureDirectly(ce,ne,E),ne&&!ne.isMultiview){if(ne.isCube&&ne._cachedCoordinatesMode!==_.coordinatesMode){ne._cachedCoordinatesMode=_.coordinatesMode;const Te=_.coordinatesMode!==3&&_.coordinatesMode!==5?1:0;_.wrapU=Te,_.wrapV=Te}ne._cachedWrapU!==_.wrapU&&(ne._cachedWrapU=_.wrapU,this._setTextureParameterInteger(ce,this._gl.TEXTURE_WRAP_S,this._getTextureWrapMode(_.wrapU),ne)),ne._cachedWrapV!==_.wrapV&&(ne._cachedWrapV=_.wrapV,this._setTextureParameterInteger(ce,this._gl.TEXTURE_WRAP_T,this._getTextureWrapMode(_.wrapV),ne)),ne.is3D&&ne._cachedWrapR!==_.wrapR&&(ne._cachedWrapR=_.wrapR,this._setTextureParameterInteger(ce,this._gl.TEXTURE_WRAP_R,this._getTextureWrapMode(_.wrapR),ne)),this._setAnisotropicLevel(ce,ne,_.anisotropicFilteringLevel)}return!0}setTextureArray(p,_,E,A){if(!(p===void 0||!_)){(!this._textureUnits||this._textureUnits.length!==E.length)&&(this._textureUnits=new Int32Array(E.length));for(let $=0;$<E.length;$++){const ne=E[$].getInternalTexture();ne?(this._textureUnits[$]=p+$,ne._associatedChannel=p+$):this._textureUnits[$]=-1}this._gl.uniform1iv(_,this._textureUnits);for(let $=0;$<E.length;$++)this._setTexture(this._textureUnits[$],E[$],!0)}}_setAnisotropicLevel(p,_,E){const A=this._caps.textureAnisotropicFilterExtension;_.samplingMode!==11&&_.samplingMode!==3&&_.samplingMode!==2&&(E=1),A&&_._cachedAnisotropicFilteringLevel!==E&&(this._setTextureParameterFloat(p,A.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(E,this._caps.maxAnisotropy),_),_._cachedAnisotropicFilteringLevel=E)}_setTextureParameterFloat(p,_,E,A){this._bindTextureDirectly(p,A,!0,!0),this._gl.texParameterf(p,_,E)}_setTextureParameterInteger(p,_,E,A){A&&this._bindTextureDirectly(p,A,!0,!0),this._gl.texParameteri(p,_,E)}unbindAllAttributes(){if(this._mustWipeVertexAttributes){this._mustWipeVertexAttributes=!1;for(let p=0;p<this._caps.maxVertexAttribs;p++)this.disableAttributeByIndex(p);return}for(let p=0,_=this._vertexAttribArraysEnabled.length;p<_;p++)p>=this._caps.maxVertexAttribs||!this._vertexAttribArraysEnabled[p]||this.disableAttributeByIndex(p)}releaseEffects(){for(const p in this._compiledEffects){const _=this._compiledEffects[p].getPipelineContext();this._deletePipelineContext(_)}this._compiledEffects={}}dispose(){this._isDisposed=!0,this.stopRenderLoop(),this.onBeforeTextureInitObservable&&this.onBeforeTextureInitObservable.clear(),this._emptyTexture&&(this._releaseTexture(this._emptyTexture),this._emptyTexture=null),this._emptyCubeTexture&&(this._releaseTexture(this._emptyCubeTexture),this._emptyCubeTexture=null),this._dummyFramebuffer&&this._gl.deleteFramebuffer(this._dummyFramebuffer),this.releaseEffects(),this.releaseComputeEffects?.(),this.unbindAllAttributes(),this._boundUniforms={},wa()&&this._renderingCanvas&&(this._doNotHandleContextLost||(this._renderingCanvas.removeEventListener("webglcontextlost",this._onContextLost),this._renderingCanvas.removeEventListener("webglcontextrestored",this._onContextRestored)),window.removeEventListener("resize",this._checkForMobile)),this._workingCanvas=null,this._workingContext=null,this._currentBufferPointers.length=0,this._renderingCanvas=null,this._currentProgram=null,this._boundRenderFunction=null,va.ResetCache();for(const p of this._activeRequests)p.abort();this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this._creationOptions.loseContextOnDispose&&this._gl.getExtension("WEBGL_lose_context")?.loseContext()}attachContextLostEvent(p){this._renderingCanvas&&this._renderingCanvas.addEventListener("webglcontextlost",p,!1)}attachContextRestoredEvent(p){this._renderingCanvas&&this._renderingCanvas.addEventListener("webglcontextrestored",p,!1)}getError(){return this._gl.getError()}_canRenderToFloatFramebuffer(){return this._webGLVersion>1?this._caps.colorBufferFloat:this._canRenderToFramebuffer(1)}_canRenderToHalfFloatFramebuffer(){return this._webGLVersion>1?this._caps.colorBufferFloat:this._canRenderToFramebuffer(2)}_canRenderToFramebuffer(p){const _=this._gl;for(;_.getError()!==_.NO_ERROR;);let E=!0;const A=_.createTexture();_.bindTexture(_.TEXTURE_2D,A),_.texImage2D(_.TEXTURE_2D,0,this._getRGBABufferInternalSizedFormat(p),1,1,0,_.RGBA,this._getWebGLTextureType(p),null),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MIN_FILTER,_.NEAREST),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MAG_FILTER,_.NEAREST);const $=_.createFramebuffer();_.bindFramebuffer(_.FRAMEBUFFER,$),_.framebufferTexture2D(_.FRAMEBUFFER,_.COLOR_ATTACHMENT0,_.TEXTURE_2D,A,0);const ne=_.checkFramebufferStatus(_.FRAMEBUFFER);if(E=E&&ne===_.FRAMEBUFFER_COMPLETE,E=E&&_.getError()===_.NO_ERROR,E&&(_.clear(_.COLOR_BUFFER_BIT),E=E&&_.getError()===_.NO_ERROR),E){_.bindFramebuffer(_.FRAMEBUFFER,null);const xe=_.RGBA,ce=_.UNSIGNED_BYTE,Te=new Uint8Array(4);_.readPixels(0,0,1,1,xe,ce,Te),E=E&&_.getError()===_.NO_ERROR}for(_.deleteTexture(A),_.deleteFramebuffer($),_.bindFramebuffer(_.FRAMEBUFFER,null);!E&&_.getError()!==_.NO_ERROR;);return E}_getWebGLTextureType(p){if(this._webGLVersion===1){switch(p){case 1:return this._gl.FLOAT;case 2:return this._gl.HALF_FLOAT_OES;case 0:return this._gl.UNSIGNED_BYTE;case 8:return this._gl.UNSIGNED_SHORT_4_4_4_4;case 9:return this._gl.UNSIGNED_SHORT_5_5_5_1;case 10:return this._gl.UNSIGNED_SHORT_5_6_5}return this._gl.UNSIGNED_BYTE}switch(p){case 3:return this._gl.BYTE;case 0:return this._gl.UNSIGNED_BYTE;case 4:return this._gl.SHORT;case 5:return this._gl.UNSIGNED_SHORT;case 6:return this._gl.INT;case 7:return this._gl.UNSIGNED_INT;case 1:return this._gl.FLOAT;case 2:return this._gl.HALF_FLOAT;case 8:return this._gl.UNSIGNED_SHORT_4_4_4_4;case 9:return this._gl.UNSIGNED_SHORT_5_5_5_1;case 10:return this._gl.UNSIGNED_SHORT_5_6_5;case 11:return this._gl.UNSIGNED_INT_2_10_10_10_REV;case 12:return this._gl.UNSIGNED_INT_24_8;case 13:return this._gl.UNSIGNED_INT_10F_11F_11F_REV;case 14:return this._gl.UNSIGNED_INT_5_9_9_9_REV;case 15:return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV}return this._gl.UNSIGNED_BYTE}_getInternalFormat(p,_=!1){let E=_?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA;switch(p){case 0:E=this._gl.ALPHA;break;case 1:E=this._gl.LUMINANCE;break;case 2:E=this._gl.LUMINANCE_ALPHA;break;case 6:E=this._gl.RED;break;case 7:E=this._gl.RG;break;case 4:E=_?this._glSRGBExtensionValues.SRGB:this._gl.RGB;break;case 5:E=_?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA;break}if(this._webGLVersion>1)switch(p){case 8:E=this._gl.RED_INTEGER;break;case 9:E=this._gl.RG_INTEGER;break;case 10:E=this._gl.RGB_INTEGER;break;case 11:E=this._gl.RGBA_INTEGER;break}return E}_getRGBABufferInternalSizedFormat(p,_,E=!1){if(this._webGLVersion===1){if(_!==void 0)switch(_){case 0:return this._gl.ALPHA;case 1:return this._gl.LUMINANCE;case 2:return this._gl.LUMINANCE_ALPHA;case 4:return E?this._glSRGBExtensionValues.SRGB:this._gl.RGB}return this._gl.RGBA}switch(p){case 3:switch(_){case 6:return this._gl.R8_SNORM;case 7:return this._gl.RG8_SNORM;case 4:return this._gl.RGB8_SNORM;case 8:return this._gl.R8I;case 9:return this._gl.RG8I;case 10:return this._gl.RGB8I;case 11:return this._gl.RGBA8I;default:return this._gl.RGBA8_SNORM}case 0:switch(_){case 6:return this._gl.R8;case 7:return this._gl.RG8;case 4:return E?this._glSRGBExtensionValues.SRGB8:this._gl.RGB8;case 5:return E?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA8;case 8:return this._gl.R8UI;case 9:return this._gl.RG8UI;case 10:return this._gl.RGB8UI;case 11:return this._gl.RGBA8UI;case 0:return this._gl.ALPHA;case 1:return this._gl.LUMINANCE;case 2:return this._gl.LUMINANCE_ALPHA;default:return this._gl.RGBA8}case 4:switch(_){case 8:return this._gl.R16I;case 9:return this._gl.RG16I;case 10:return this._gl.RGB16I;case 11:return this._gl.RGBA16I;default:return this._gl.RGBA16I}case 5:switch(_){case 8:return this._gl.R16UI;case 9:return this._gl.RG16UI;case 10:return this._gl.RGB16UI;case 11:return this._gl.RGBA16UI;default:return this._gl.RGBA16UI}case 6:switch(_){case 8:return this._gl.R32I;case 9:return this._gl.RG32I;case 10:return this._gl.RGB32I;case 11:return this._gl.RGBA32I;default:return this._gl.RGBA32I}case 7:switch(_){case 8:return this._gl.R32UI;case 9:return this._gl.RG32UI;case 10:return this._gl.RGB32UI;case 11:return this._gl.RGBA32UI;default:return this._gl.RGBA32UI}case 1:switch(_){case 6:return this._gl.R32F;case 7:return this._gl.RG32F;case 4:return this._gl.RGB32F;case 5:return this._gl.RGBA32F;default:return this._gl.RGBA32F}case 2:switch(_){case 6:return this._gl.R16F;case 7:return this._gl.RG16F;case 4:return this._gl.RGB16F;case 5:return this._gl.RGBA16F;default:return this._gl.RGBA16F}case 10:return this._gl.RGB565;case 13:return this._gl.R11F_G11F_B10F;case 14:return this._gl.RGB9_E5;case 8:return this._gl.RGBA4;case 9:return this._gl.RGB5_A1;case 11:switch(_){case 5:return this._gl.RGB10_A2;case 11:return this._gl.RGB10_A2UI;default:return this._gl.RGB10_A2}}return E?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA8}_loadFile(p,_,E,A,$,ne){const xe=rr._FileToolsLoadFile(p,_,E,A,$,ne);return this._activeRequests.push(xe),xe.onCompleteObservable.add(ce=>{this._activeRequests.splice(this._activeRequests.indexOf(ce),1)}),xe}static _FileToolsLoadFile(p,_,E,A,$,ne){throw Tr("FileTools")}readPixels(p,_,E,A,$=!0,ne=!0){const xe=$?4:3,ce=$?this._gl.RGBA:this._gl.RGB,Te=new Uint8Array(A*E*xe);return ne&&this.flushFramebuffer(),this._gl.readPixels(p,_,E,A,ce,this._gl.UNSIGNED_BYTE,Te),Promise.resolve(Te)}static get IsSupportedAsync(){return Promise.resolve(this.isSupported())}static get IsSupported(){return this.isSupported()}static isSupported(){if(this._HasMajorPerformanceCaveat!==null)return!this._HasMajorPerformanceCaveat;if(this._IsSupported===null)try{const p=this._CreateCanvas(1,1),_=p.getContext("webgl")||p.getContext("experimental-webgl");this._IsSupported=_!=null&&!!window.WebGLRenderingContext}catch{this._IsSupported=!1}return this._IsSupported}static get HasMajorPerformanceCaveat(){if(this._HasMajorPerformanceCaveat===null)try{const p=this._CreateCanvas(1,1),_=p.getContext("webgl",{failIfMajorPerformanceCaveat:!0})||p.getContext("experimental-webgl",{failIfMajorPerformanceCaveat:!0});this._HasMajorPerformanceCaveat=!_}catch{this._HasMajorPerformanceCaveat=!1}return this._HasMajorPerformanceCaveat}static CeilingPOT(p){return p--,p|=p>>1,p|=p>>2,p|=p>>4,p|=p>>8,p|=p>>16,p++,p}static FloorPOT(p){return p=p|p>>1,p=p|p>>2,p=p|p>>4,p=p|p>>8,p=p|p>>16,p-(p>>1)}static NearestPOT(p){const _=rr.CeilingPOT(p),E=rr.FloorPOT(p);return _-p>p-E?E:_}static GetExponentOfTwo(p,_,E=2){let A;switch(E){case 1:A=rr.FloorPOT(p);break;case 2:A=rr.NearestPOT(p);break;case 3:default:A=rr.CeilingPOT(p);break}return Math.min(A,_)}static QueueNewFrame(p,_){if(wa()){const{requestAnimationFrame:E}=_||window;if(typeof E=="function")return E(p)}else if(typeof requestAnimationFrame=="function")return requestAnimationFrame(p);return setTimeout(p,16)}getHostDocument(){return this._renderingCanvas&&this._renderingCanvas.ownerDocument?this._renderingCanvas.ownerDocument:px()?document:null}}rr._TempClearColorUint32=new Uint32Array(4),rr._TempClearColorInt32=new Int32Array(4),rr.ExceptionList=[{key:"Chrome/63.0",capture:"63\\.0\\.3239\\.(\\d+)",captureConstraint:108,targets:["uniformBuffer"]},{key:"Firefox/58",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Firefox/59",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Chrome/72.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Chrome/73.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Chrome/74.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome/71",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome/72",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Chrome/12\\d\\..+?Mobile",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:".*AppleWebKit.*(15.4).*Safari",capture:null,captureConstraint:null,targets:["antialias","maxMSAASamples"]},{key:".*(15.4).*AppleWebKit.*Safari",capture:null,captureConstraint:null,targets:["antialias","maxMSAASamples"]}],rr._TextureLoaders=[],rr.CollisionsEpsilon=.001,rr._IsSupported=null,rr._HasMajorPerformanceCaveat=null;class Gc{constructor(p=30){this._enabled=!0,this._rollingFrameTime=new a2(p)}sampleFrame(p=Ko.Now){if(this._enabled){if(this._lastFrameTimeMs!=null){const _=p-this._lastFrameTimeMs;this._rollingFrameTime.add(_)}this._lastFrameTimeMs=p}}get averageFrameTime(){return this._rollingFrameTime.average}get averageFrameTimeVariance(){return this._rollingFrameTime.variance}get instantaneousFrameTime(){return this._rollingFrameTime.history(0)}get averageFPS(){return 1e3/this._rollingFrameTime.average}get instantaneousFPS(){const p=this._rollingFrameTime.history(0);return p===0?0:1e3/p}get isSaturated(){return this._rollingFrameTime.isSaturated()}enable(){this._enabled=!0}disable(){this._enabled=!1,this._lastFrameTimeMs=null}get isEnabled(){return this._enabled}reset(){this._lastFrameTimeMs=null,this._rollingFrameTime.reset()}}class a2{constructor(p){this._samples=new Array(p),this.reset()}add(p){let _;if(this.isSaturated()){const E=this._samples[this._pos];_=E-this.average,this.average-=_/(this._sampleCount-1),this._m2-=_*(E-this.average)}else this._sampleCount++;_=p-this.average,this.average+=_/this._sampleCount,this._m2+=_*(p-this.average),this.variance=this._m2/(this._sampleCount-1),this._samples[this._pos]=p,this._pos++,this._pos%=this._samples.length}history(p){if(p>=this._sampleCount||p>=this._samples.length)return 0;const _=this._wrapPosition(this._pos-1);return this._samples[this._wrapPosition(_-p)]}isSaturated(){return this._sampleCount>=this._samples.length}reset(){this.average=0,this.variance=0,this._sampleCount=0,this._pos=0,this._m2=0}_wrapPosition(p){const _=this._samples.length;return(p%_+_)%_}}class T0{get min(){return this._min}get max(){return this._max}get average(){return this._average}get lastSecAverage(){return this._lastSecAverage}get current(){return this._current}get total(){return this._totalAccumulated}get count(){return this._totalValueCount}constructor(){this._startMonitoringTime=0,this._min=0,this._max=0,this._average=0,this._lastSecAverage=0,this._current=0,this._totalValueCount=0,this._totalAccumulated=0,this._lastSecAccumulated=0,this._lastSecTime=0,this._lastSecValueCount=0}fetchNewFrame(){this._totalValueCount++,this._current=0,this._lastSecValueCount++}addCount(p,_){T0.Enabled&&(this._current+=p,_&&this._fetchResult())}beginMonitoring(){T0.Enabled&&(this._startMonitoringTime=Ko.Now)}endMonitoring(p=!0){if(!T0.Enabled)return;p&&this.fetchNewFrame();const _=Ko.Now;this._current=_-this._startMonitoringTime,p&&this._fetchResult()}endFrame(){this._fetchResult()}_fetchResult(){this._totalAccumulated+=this._current,this._lastSecAccumulated+=this._current,this._min=Math.min(this._min,this._current),this._max=Math.max(this._max,this._current),this._average=this._totalAccumulated/this._totalValueCount;const p=Ko.Now;p-this._lastSecTime>1e3&&(this._lastSecAverage=this._lastSecAccumulated/this._lastSecValueCount,this._lastSecTime=p,this._lastSecAccumulated=0,this._lastSecValueCount=0)}}T0.Enabled=!0,rr.prototype.setAlphaConstants=function(_e,p,_,E){this._alphaState.setAlphaBlendConstants(_e,p,_,E)},rr.prototype.setAlphaMode=function(_e,p=!1){if(this._alphaMode===_e){if(!p){const _=_e===0;this.depthCullingState.depthMask!==_&&(this.depthCullingState.depthMask=_)}return}switch(_e){case 0:this._alphaState.alphaBlend=!1;break;case 7:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 8:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 2:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 6:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE,this._gl.ZERO,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 1:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE,this._gl.ZERO,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 3:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 4:this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR,this._gl.ZERO,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 5:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 9:this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR,this._gl.ONE_MINUS_CONSTANT_COLOR,this._gl.CONSTANT_ALPHA,this._gl.ONE_MINUS_CONSTANT_ALPHA),this._alphaState.alphaBlend=!0;break;case 10:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 11:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 12:this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA,this._gl.ONE,this._gl.ZERO,this._gl.ZERO),this._alphaState.alphaBlend=!0;break;case 13:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE_MINUS_DST_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 14:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 15:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE,this._gl.ONE,this._gl.ZERO),this._alphaState.alphaBlend=!0;break;case 16:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ZERO,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 17:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break}p||(this.depthCullingState.depthMask=_e===0),this._alphaMode=_e},rr.prototype.getAlphaMode=function(){return this._alphaMode},rr.prototype.setAlphaEquation=function(_e){if(this._alphaEquation!==_e){switch(_e){case 0:this._alphaState.setAlphaEquationParameters(32774,32774);break;case 1:this._alphaState.setAlphaEquationParameters(32778,32778);break;case 2:this._alphaState.setAlphaEquationParameters(32779,32779);break;case 3:this._alphaState.setAlphaEquationParameters(32776,32776);break;case 4:this._alphaState.setAlphaEquationParameters(32775,32775);break;case 5:this._alphaState.setAlphaEquationParameters(32775,32774);break}this._alphaEquation=_e}},rr.prototype.getAlphaEquation=function(){return this._alphaEquation};function x2(_e,p,_=!1,E){switch(_e){case 3:{const $=p instanceof ArrayBuffer?new Int8Array(p):new Int8Array(p);return E&&$.set(new Int8Array(E)),$}case 0:{const $=p instanceof ArrayBuffer?new Uint8Array(p):new Uint8Array(p);return E&&$.set(new Uint8Array(E)),$}case 4:{const $=p instanceof ArrayBuffer?new Int16Array(p):new Int16Array(_?p/2:p);return E&&$.set(new Int16Array(E)),$}case 5:case 8:case 9:case 10:case 2:{const $=p instanceof ArrayBuffer?new Uint16Array(p):new Uint16Array(_?p/2:p);return E&&$.set(new Uint16Array(E)),$}case 6:{const $=p instanceof ArrayBuffer?new Int32Array(p):new Int32Array(_?p/4:p);return E&&$.set(new Int32Array(E)),$}case 7:case 11:case 12:case 13:case 14:case 15:{const $=p instanceof ArrayBuffer?new Uint32Array(p):new Uint32Array(_?p/4:p);return E&&$.set(new Uint32Array(E)),$}case 1:{const $=p instanceof ArrayBuffer?new Float32Array(p):new Float32Array(_?p/4:p);return E&&$.set(new Float32Array(E)),$}}const A=p instanceof ArrayBuffer?new Uint8Array(p):new Uint8Array(p);return E&&A.set(new Uint8Array(E)),A}rr.prototype._readTexturePixelsSync=function(_e,p,_,E=-1,A=0,$=null,ne=!0,xe=!1,ce=0,Te=0){const Re=this._gl;if(!Re)throw new Error("Engine does not have gl rendering context.");if(!this._dummyFramebuffer){const We=Re.createFramebuffer();if(!We)throw new Error("Unable to create dummy framebuffer");this._dummyFramebuffer=We}Re.bindFramebuffer(Re.FRAMEBUFFER,this._dummyFramebuffer),E>-1?Re.framebufferTexture2D(Re.FRAMEBUFFER,Re.COLOR_ATTACHMENT0,Re.TEXTURE_CUBE_MAP_POSITIVE_X+E,_e._hardwareTexture?.underlyingResource,A):Re.framebufferTexture2D(Re.FRAMEBUFFER,Re.COLOR_ATTACHMENT0,Re.TEXTURE_2D,_e._hardwareTexture?.underlyingResource,A);let ke=_e.type!==void 0?this._getWebGLTextureType(_e.type):Re.UNSIGNED_BYTE;if(xe)$||($=x2(_e.type,4*p*_));else switch(ke){case Re.UNSIGNED_BYTE:$||($=new Uint8Array(4*p*_)),ke=Re.UNSIGNED_BYTE;break;default:$||($=new Float32Array(4*p*_)),ke=Re.FLOAT;break}return ne&&this.flushFramebuffer(),Re.readPixels(ce,Te,p,_,Re.RGBA,ke,$),Re.bindFramebuffer(Re.FRAMEBUFFER,this._currentFramebuffer),$},rr.prototype._readTexturePixels=function(_e,p,_,E=-1,A=0,$=null,ne=!0,xe=!1,ce=0,Te=0){return Promise.resolve(this._readTexturePixelsSync(_e,p,_,E,A,$,ne,xe,ce,Te))},rr.prototype.updateDynamicIndexBuffer=function(_e,p,_=0){this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER]=null,this.bindIndexBuffer(_e);let E;_e.is32Bits?E=p instanceof Uint32Array?p:new Uint32Array(p):E=p instanceof Uint16Array?p:new Uint16Array(p),this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,E,this._gl.DYNAMIC_DRAW),this._resetIndexBufferBinding()},rr.prototype.updateDynamicVertexBuffer=function(_e,p,_,E){this.bindArrayBuffer(_e),_===void 0&&(_=0);const A=p.byteLength||p.length;E===void 0||E>=A&&_===0?p instanceof Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,_,new Float32Array(p)):this._gl.bufferSubData(this._gl.ARRAY_BUFFER,_,p):p instanceof Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,new Float32Array(p).subarray(_,_+E)):(p instanceof ArrayBuffer?p=new Uint8Array(p,_,E):p=new Uint8Array(p.buffer,p.byteOffset+_,E),this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,p)),this._resetVertexBufferBinding()};class ui extends rr{static get NpmPackage(){return rr.NpmPackage}static get Version(){return rr.Version}static get Instances(){return wr.Instances}static get LastCreatedEngine(){return wr.LastCreatedEngine}static get LastCreatedScene(){return wr.LastCreatedScene}_createImageBitmapFromSource(p,_){return new Promise((A,$)=>{const ne=new Image;ne.onload=()=>{ne.decode().then(()=>{this.createImageBitmap(ne,_).then(xe=>{A(xe)})})},ne.onerror=()=>{$(`Error loading image ${ne.src}`)},ne.src=p})}createImageBitmap(p,_){return createImageBitmap(p,_)}resizeImageBitmap(p,_,E){const $=this.createCanvas(_,E).getContext("2d");if(!$)throw new Error("Unable to get 2d context for resizeImageBitmap");return $.drawImage(p,0,0),$.getImageData(0,0,_,E).data}static MarkAllMaterialsAsDirty(p,_){for(let E=0;E<ui.Instances.length;E++){const A=ui.Instances[E];for(let $=0;$<A.scenes.length;$++)A.scenes[$].markAllMaterialsAsDirty(p,_)}}static DefaultLoadingScreenFactory(p){throw Tr("LoadingScreen")}get _supportsHardwareTextureRescaling(){return!!ui._RescalePostProcessFactory}get performanceMonitor(){return this._performanceMonitor}get compatibilityMode(){return this._compatibilityMode}set compatibilityMode(p){this._compatibilityMode=!0}getInputElement(){return this._renderingCanvas}constructor(p,_,E,A=!1){if(super(p,_,E,A),this.enableOfflineSupport=!1,this.disableManifestCheck=!1,this.disableContextMenu=!0,this.scenes=[],this._virtualScenes=new Array,this.onNewSceneAddedObservable=new Mi,this.postProcesses=[],this.isPointerLock=!1,this.onResizeObservable=new Mi,this.onCanvasBlurObservable=new Mi,this.onCanvasFocusObservable=new Mi,this.onCanvasPointerOutObservable=new Mi,this.onBeginFrameObservable=new Mi,this.customAnimationFrameRequester=null,this.onEndFrameObservable=new Mi,this.onBeforeShaderCompilationObservable=new Mi,this.onAfterShaderCompilationObservable=new Mi,this._deterministicLockstep=!1,this._lockstepMaxSteps=4,this._timeStep=1/60,this._fps=60,this._deltaTime=0,this._drawCalls=new T0,this.canvasTabIndex=1,this.disablePerformanceMonitorInBackground=!1,this._performanceMonitor=new Gc,this._compatibilityMode=!0,this.currentRenderPassId=0,this._renderPassNames=["main"],ui.Instances.push(this),!!p&&(this._features.supportRenderPasses=!0,E=this._creationOptions,p.getContext)){const $=p;this._sharedInit($)}}_initGLContext(){super._initGLContext(),this._rescalePostProcess=null}_sharedInit(p){super._sharedInit(p),this._onCanvasFocus=()=>{this.onCanvasFocusObservable.notifyObservers(this)},this._onCanvasBlur=()=>{this.onCanvasBlurObservable.notifyObservers(this)},this._onCanvasContextMenu=E=>{this.disableContextMenu&&E.preventDefault()},p.addEventListener("focus",this._onCanvasFocus),p.addEventListener("blur",this._onCanvasBlur),p.addEventListener("contextmenu",this._onCanvasContextMenu),this._onBlur=()=>{this.disablePerformanceMonitorInBackground&&this._performanceMonitor.disable(),this._windowIsBackground=!0},this._onFocus=()=>{this.disablePerformanceMonitorInBackground&&this._performanceMonitor.enable(),this._windowIsBackground=!1},this._onCanvasPointerOut=E=>{document.elementFromPoint(E.clientX,E.clientY)!==p&&this.onCanvasPointerOutObservable.notifyObservers(E)};const _=this.getHostWindow();_&&typeof _.addEventListener=="function"&&(_.addEventListener("blur",this._onBlur),_.addEventListener("focus",this._onFocus)),p.addEventListener("pointerout",this._onCanvasPointerOut),this._creationOptions.doNotHandleTouchAction||this._disableTouchAction(),!ui.audioEngine&&this._creationOptions.audioEngine&&ui.AudioEngineFactory&&(ui.audioEngine=ui.AudioEngineFactory(this.getRenderingCanvas(),this.getAudioContext(),this.getAudioDestination())),px()&&(this._onFullscreenChange=()=>{this.isFullscreen=!!document.fullscreenElement,this.isFullscreen&&this._pointerLockRequested&&p&&ui._RequestPointerlock(p)},document.addEventListener("fullscreenchange",this._onFullscreenChange,!1),document.addEventListener("webkitfullscreenchange",this._onFullscreenChange,!1),this._onPointerLockChange=()=>{this.isPointerLock=document.pointerLockElement===p},document.addEventListener("pointerlockchange",this._onPointerLockChange,!1),document.addEventListener("webkitpointerlockchange",this._onPointerLockChange,!1)),this.enableOfflineSupport=ui.OfflineProviderFactory!==void 0,this._deterministicLockstep=!!this._creationOptions.deterministicLockstep,this._lockstepMaxSteps=this._creationOptions.lockstepMaxSteps||0,this._timeStep=this._creationOptions.timeStep||1/60}_verifyPointerLock(){this._onPointerLockChange?.()}getAspectRatio(p,_=!1){const E=p.viewport;return this.getRenderWidth(_)*E.width/(this.getRenderHeight(_)*E.height)}getScreenAspectRatio(){return this.getRenderWidth(!0)/this.getRenderHeight(!0)}getRenderingCanvasClientRect(){return this._renderingCanvas?this._renderingCanvas.getBoundingClientRect():null}getInputElementClientRect(){return this._renderingCanvas?this.getInputElement().getBoundingClientRect():null}isDeterministicLockStep(){return this._deterministicLockstep}getLockstepMaxSteps(){return this._lockstepMaxSteps}getTimeStep(){return this._timeStep*1e3}generateMipMapsForCubemap(p,_=!0){if(p.generateMipMaps){const E=this._gl;this._bindTextureDirectly(E.TEXTURE_CUBE_MAP,p,!0),E.generateMipmap(E.TEXTURE_CUBE_MAP),_&&this._bindTextureDirectly(E.TEXTURE_CUBE_MAP,null)}}getDepthWrite(){return this._depthCullingState.depthMask}setDepthWrite(p){this._depthCullingState.depthMask=p}getStencilBuffer(){return this._stencilState.stencilTest}setStencilBuffer(p){this._stencilState.stencilTest=p}getStencilMask(){return this._stencilState.stencilMask}setStencilMask(p){this._stencilState.stencilMask=p}getStencilFunction(){return this._stencilState.stencilFunc}getStencilFunctionReference(){return this._stencilState.stencilFuncRef}getStencilFunctionMask(){return this._stencilState.stencilFuncMask}setStencilFunction(p){this._stencilState.stencilFunc=p}setStencilFunctionReference(p){this._stencilState.stencilFuncRef=p}setStencilFunctionMask(p){this._stencilState.stencilFuncMask=p}getStencilOperationFail(){return this._stencilState.stencilOpStencilFail}getStencilOperationDepthFail(){return this._stencilState.stencilOpDepthFail}getStencilOperationPass(){return this._stencilState.stencilOpStencilDepthPass}setStencilOperationFail(p){this._stencilState.stencilOpStencilFail=p}setStencilOperationDepthFail(p){this._stencilState.stencilOpDepthFail=p}setStencilOperationPass(p){this._stencilState.stencilOpStencilDepthPass=p}setDitheringState(p){p?this._gl.enable(this._gl.DITHER):this._gl.disable(this._gl.DITHER)}setRasterizerState(p){p?this._gl.disable(this._gl.RASTERIZER_DISCARD):this._gl.enable(this._gl.RASTERIZER_DISCARD)}getDepthFunction(){return this._depthCullingState.depthFunc}setDepthFunction(p){this._depthCullingState.depthFunc=p}setDepthFunctionToGreater(){this.setDepthFunction(516)}setDepthFunctionToGreaterOrEqual(){this.setDepthFunction(518)}setDepthFunctionToLess(){this.setDepthFunction(513)}setDepthFunctionToLessOrEqual(){this.setDepthFunction(515)}cacheStencilState(){this._cachedStencilBuffer=this.getStencilBuffer(),this._cachedStencilFunction=this.getStencilFunction(),this._cachedStencilMask=this.getStencilMask(),this._cachedStencilOperationPass=this.getStencilOperationPass(),this._cachedStencilOperationFail=this.getStencilOperationFail(),this._cachedStencilOperationDepthFail=this.getStencilOperationDepthFail(),this._cachedStencilReference=this.getStencilFunctionReference()}restoreStencilState(){this.setStencilFunction(this._cachedStencilFunction),this.setStencilMask(this._cachedStencilMask),this.setStencilBuffer(this._cachedStencilBuffer),this.setStencilOperationPass(this._cachedStencilOperationPass),this.setStencilOperationFail(this._cachedStencilOperationFail),this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail),this.setStencilFunctionReference(this._cachedStencilReference)}setDirectViewport(p,_,E,A){const $=this._cachedViewport;return this._cachedViewport=null,this._viewport(p,_,E,A),$}scissorClear(p,_,E,A,$){this.enableScissor(p,_,E,A),this.clear($,!0,!0,!0),this.disableScissor()}enableScissor(p,_,E,A){const $=this._gl;$.enable($.SCISSOR_TEST),$.scissor(p,_,E,A)}disableScissor(){const p=this._gl;p.disable(p.SCISSOR_TEST)}_reportDrawCall(p=1){this._drawCalls.addCount(p,!1)}_loadFileAsync(p,_,E){return new Promise((A,$)=>{this._loadFile(p,ne=>{A(ne)},void 0,_,E,(ne,xe)=>{$(xe)})})}getVertexShaderSource(p){const _=this._gl.getAttachedShaders(p);return _?this._gl.getShaderSource(_[0]):null}getFragmentShaderSource(p){const _=this._gl.getAttachedShaders(p);return _?this._gl.getShaderSource(_[1]):null}setDepthStencilTexture(p,_,E,A){p!==void 0&&(_&&(this._boundUniforms[p]=_),!E||!E.depthStencilTexture?this._setTexture(p,null,void 0,void 0,A):this._setTexture(p,E,!1,!0,A))}setTextureFromPostProcess(p,_,E){let A=null;_&&(_._forcedOutputTexture?A=_._forcedOutputTexture:_._textures.data[_._currentRenderTextureInd]&&(A=_._textures.data[_._currentRenderTextureInd])),this._bindTexture(p,A?.texture??null,E)}setTextureFromPostProcessOutput(p,_,E){this._bindTexture(p,_?._outputTexture?.texture??null,E)}_rebuildBuffers(){for(const p of this.scenes)p.resetCachedMaterial(),p._rebuildGeometries();for(const p of this._virtualScenes)p.resetCachedMaterial(),p._rebuildGeometries();super._rebuildBuffers()}_rebuildTextures(){for(const p of this.scenes)p._rebuildTextures();for(const p of this._virtualScenes)p._rebuildTextures();super._rebuildTextures()}_renderFrame(){for(let p=0;p<this._activeRenderLoops.length;p++){const _=this._activeRenderLoops[p];_()}}_cancelFrame(){if(this._renderingQueueLaunched&&this.customAnimationFrameRequester){this._renderingQueueLaunched=!1;const{cancelAnimationFrame:p}=this.customAnimationFrameRequester;p&&p(this.customAnimationFrameRequester.requestID)}else super._cancelFrame()}_renderLoop(){if(!this._contextWasLost){let p=!0;(this.isDisposed||!this.renderEvenInBackground&&this._windowIsBackground)&&(p=!1),p&&(this.beginFrame(),this._renderViews()||this._renderFrame(),this.endFrame())}this._activeRenderLoops.length>0?this.customAnimationFrameRequester?(this.customAnimationFrameRequester.requestID=this._queueNewFrame(this.customAnimationFrameRequester.renderFunction||this._boundRenderFunction,this.customAnimationFrameRequester),this._frameHandler=this.customAnimationFrameRequester.requestID):this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow()):this._renderingQueueLaunched=!1}_renderViews(){return!1}switchFullscreen(p){this.isFullscreen?this.exitFullscreen():this.enterFullscreen(p)}enterFullscreen(p){this.isFullscreen||(this._pointerLockRequested=p,this._renderingCanvas&&ui._RequestFullscreen(this._renderingCanvas))}exitFullscreen(){this.isFullscreen&&ui._ExitFullscreen()}enterPointerlock(){this._renderingCanvas&&ui._RequestPointerlock(this._renderingCanvas)}exitPointerlock(){ui._ExitPointerlock()}beginFrame(){this._measureFps(),this.onBeginFrameObservable.notifyObservers(this),super.beginFrame()}endFrame(){super.endFrame(),this.onEndFrameObservable.notifyObservers(this)}setSize(p,_,E=!1){if(!this._renderingCanvas||!super.setSize(p,_,E))return!1;if(this.scenes){for(let A=0;A<this.scenes.length;A++){const $=this.scenes[A];for(let ne=0;ne<$.cameras.length;ne++){const xe=$.cameras[ne];xe._currentRenderId=0}}this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this)}return!0}_deletePipelineContext(p){const _=p;_&&_.program&&_.transformFeedback&&(this.deleteTransformFeedback(_.transformFeedback),_.transformFeedback=null),super._deletePipelineContext(p)}createShaderProgram(p,_,E,A,$,ne=null){$=$||this._gl,this.onBeforeShaderCompilationObservable.notifyObservers(this);const xe=super.createShaderProgram(p,_,E,A,$,ne);return this.onAfterShaderCompilationObservable.notifyObservers(this),xe}_createShaderProgram(p,_,E,A,$=null){const ne=A.createProgram();if(p.program=ne,!ne)throw new Error("Unable to create program");if(A.attachShader(ne,_),A.attachShader(ne,E),this.webGLVersion>1&&$){const xe=this.createTransformFeedback();this.bindTransformFeedback(xe),this.setTranformFeedbackVaryings(ne,$),p.transformFeedback=xe}return A.linkProgram(ne),this.webGLVersion>1&&$&&this.bindTransformFeedback(null),p.context=A,p.vertexShader=_,p.fragmentShader=E,p.isParallelCompiled||this._finalizePipelineContext(p),ne}_releaseTexture(p){super._releaseTexture(p)}_releaseRenderTargetWrapper(p){super._releaseRenderTargetWrapper(p),this.scenes.forEach(_=>{_.postProcesses.forEach(E=>{E._outputTexture===p&&(E._outputTexture=null)}),_.cameras.forEach(E=>{E._postProcesses.forEach(A=>{A&&A._outputTexture===p&&(A._outputTexture=null)})})})}getRenderPassNames(){return this._renderPassNames}getCurrentRenderPassName(){return this._renderPassNames[this.currentRenderPassId]}createRenderPassId(p){const _=++ui._RenderPassIdCounter;return this._renderPassNames[_]=p??"NONAME",_}releaseRenderPassId(p){this._renderPassNames[p]=void 0;for(let _=0;_<this.scenes.length;++_){const E=this.scenes[_];for(let A=0;A<E.meshes.length;++A){const $=E.meshes[A];if($.subMeshes)for(let ne=0;ne<$.subMeshes.length;++ne)$.subMeshes[ne]._removeDrawWrapper(p)}}}_rescaleTexture(p,_,E,A,$){this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,this._gl.LINEAR),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,this._gl.LINEAR),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.CLAMP_TO_EDGE),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.CLAMP_TO_EDGE);const ne=this.createRenderTargetTexture({width:_.width,height:_.height},{generateMipMaps:!1,type:0,samplingMode:2,generateDepthBuffer:!1,generateStencilBuffer:!1});!this._rescalePostProcess&&ui._RescalePostProcessFactory&&(this._rescalePostProcess=ui._RescalePostProcessFactory(this)),this._rescalePostProcess&&(this._rescalePostProcess.externalTextureSamplerBinding=!0,this._rescalePostProcess.getEffect().executeWhenCompiled(()=>{this._rescalePostProcess.onApply=function(ce){ce._bindTexture("textureSampler",p)};let xe=E;xe||(xe=this.scenes[this.scenes.length-1]),xe.postProcessManager.directRender([this._rescalePostProcess],ne,!0),this._bindTextureDirectly(this._gl.TEXTURE_2D,_,!0),this._gl.copyTexImage2D(this._gl.TEXTURE_2D,0,A,0,0,_.width,_.height,0),this.unBindFramebuffer(ne),ne.dispose(),$&&$()}))}getFps(){return this._fps}getDeltaTime(){return this._deltaTime}_measureFps(){this._performanceMonitor.sampleFrame(),this._fps=this._performanceMonitor.averageFPS,this._deltaTime=this._performanceMonitor.instantaneousFrameTime||0}wrapWebGLTexture(p,_=!1,E=3,A=0,$=0){const ne=new nl(p,this._gl),xe=new u0(this,Gn.Unknown,!0);return xe._hardwareTexture=ne,xe.baseWidth=A,xe.baseHeight=$,xe.width=A,xe.height=$,xe.isReady=!0,xe.useMipMaps=_,this.updateTextureSamplingMode(E,xe),xe}_uploadImageToTexture(p,_,E=0,A=0){const $=this._gl,ne=this._getWebGLTextureType(p.type),xe=this._getInternalFormat(p.format),ce=this._getRGBABufferInternalSizedFormat(p.type,xe),Te=p.isCube?$.TEXTURE_CUBE_MAP:$.TEXTURE_2D;this._bindTextureDirectly(Te,p,!0),this._unpackFlipY(p.invertY);let Re=$.TEXTURE_2D;p.isCube&&(Re=$.TEXTURE_CUBE_MAP_POSITIVE_X+E),$.texImage2D(Re,A,ce,xe,ne,_),this._bindTextureDirectly(Te,null,!0)}updateTextureComparisonFunction(p,_){if(this.webGLVersion===1){vi.Error("WebGL 1 does not support texture comparison.");return}const E=this._gl;p.isCube?(this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,p,!0),_===0?(E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_COMPARE_FUNC,515),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_COMPARE_MODE,E.NONE)):(E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_COMPARE_FUNC,_),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_COMPARE_MODE,E.COMPARE_REF_TO_TEXTURE)),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null)):(this._bindTextureDirectly(this._gl.TEXTURE_2D,p,!0),_===0?(E.texParameteri(E.TEXTURE_2D,E.TEXTURE_COMPARE_FUNC,515),E.texParameteri(E.TEXTURE_2D,E.TEXTURE_COMPARE_MODE,E.NONE)):(E.texParameteri(E.TEXTURE_2D,E.TEXTURE_COMPARE_FUNC,_),E.texParameteri(E.TEXTURE_2D,E.TEXTURE_COMPARE_MODE,E.COMPARE_REF_TO_TEXTURE)),this._bindTextureDirectly(this._gl.TEXTURE_2D,null)),p._comparisonFunction=_}createInstancesBuffer(p){const _=this._gl.createBuffer();if(!_)throw new Error("Unable to create instance buffer");const E=new Xo(_);return E.capacity=p,this.bindArrayBuffer(E),this._gl.bufferData(this._gl.ARRAY_BUFFER,p,this._gl.DYNAMIC_DRAW),E.references=1,E}deleteInstancesBuffer(p){this._gl.deleteBuffer(p)}_clientWaitAsync(p,_=0,E=10){const A=this._gl;return new Promise(($,ne)=>{const xe=()=>{const ce=A.clientWaitSync(p,_,0);if(ce==A.WAIT_FAILED){ne();return}if(ce==A.TIMEOUT_EXPIRED){setTimeout(xe,E);return}$()};xe()})}_readPixelsAsync(p,_,E,A,$,ne,xe){if(this._webGLVersion<2)throw new Error("_readPixelsAsync only work on WebGL2+");const ce=this._gl,Te=ce.createBuffer();ce.bindBuffer(ce.PIXEL_PACK_BUFFER,Te),ce.bufferData(ce.PIXEL_PACK_BUFFER,xe.byteLength,ce.STREAM_READ),ce.readPixels(p,_,E,A,$,ne,0),ce.bindBuffer(ce.PIXEL_PACK_BUFFER,null);const Re=ce.fenceSync(ce.SYNC_GPU_COMMANDS_COMPLETE,0);return Re?(ce.flush(),this._clientWaitAsync(Re,0,10).then(()=>(ce.deleteSync(Re),ce.bindBuffer(ce.PIXEL_PACK_BUFFER,Te),ce.getBufferSubData(ce.PIXEL_PACK_BUFFER,0,xe),ce.bindBuffer(ce.PIXEL_PACK_BUFFER,null),ce.deleteBuffer(Te),xe))):null}dispose(){for(this.hideLoadingUI(),this.onNewSceneAddedObservable.clear();this.postProcesses.length;)this.postProcesses[0].dispose();for(this._rescalePostProcess&&this._rescalePostProcess.dispose();this.scenes.length;)this.scenes[0].dispose();for(;this._virtualScenes.length;)this._virtualScenes[0].dispose();wr.Instances.length===1&&ui.audioEngine&&(ui.audioEngine.dispose(),ui.audioEngine=null);const p=this.getHostWindow();p&&typeof p.removeEventListener=="function"&&(p.removeEventListener("blur",this._onBlur),p.removeEventListener("focus",this._onFocus)),this._renderingCanvas&&(this._renderingCanvas.removeEventListener("focus",this._onCanvasFocus),this._renderingCanvas.removeEventListener("blur",this._onCanvasBlur),this._renderingCanvas.removeEventListener("pointerout",this._onCanvasPointerOut),this._renderingCanvas.removeEventListener("contextmenu",this._onCanvasContextMenu)),px()&&(document.removeEventListener("fullscreenchange",this._onFullscreenChange),document.removeEventListener("mozfullscreenchange",this._onFullscreenChange),document.removeEventListener("webkitfullscreenchange",this._onFullscreenChange),document.removeEventListener("msfullscreenchange",this._onFullscreenChange),document.removeEventListener("pointerlockchange",this._onPointerLockChange),document.removeEventListener("mspointerlockchange",this._onPointerLockChange),document.removeEventListener("mozpointerlockchange",this._onPointerLockChange),document.removeEventListener("webkitpointerlockchange",this._onPointerLockChange)),super.dispose();const _=wr.Instances.indexOf(this);_>=0&&wr.Instances.splice(_,1),ui.Instances.length||wr.OnEnginesDisposedObservable.notifyObservers(this),this.onResizeObservable.clear(),this.onCanvasBlurObservable.clear(),this.onCanvasFocusObservable.clear(),this.onCanvasPointerOutObservable.clear(),this.onBeginFrameObservable.clear(),this.onEndFrameObservable.clear()}_disableTouchAction(){!this._renderingCanvas||!this._renderingCanvas.setAttribute||(this._renderingCanvas.setAttribute("touch-action","none"),this._renderingCanvas.style.touchAction="none",this._renderingCanvas.style.webkitTapHighlightColor="transparent")}displayLoadingUI(){if(!wa())return;const p=this.loadingScreen;p&&p.displayLoadingUI()}hideLoadingUI(){if(!wa())return;const p=this._loadingScreen;p&&p.hideLoadingUI()}get loadingScreen(){return!this._loadingScreen&&this._renderingCanvas&&(this._loadingScreen=ui.DefaultLoadingScreenFactory(this._renderingCanvas)),this._loadingScreen}set loadingScreen(p){this._loadingScreen=p}set loadingUIText(p){this.loadingScreen.loadingUIText=p}set loadingUIBackgroundColor(p){this.loadingScreen.loadingUIBackgroundColor=p}createVideoElement(p){return document.createElement("video")}static _RequestPointerlock(p){if(p.requestPointerLock){const _=p.requestPointerLock();_ instanceof Promise?_.then(()=>{p.focus()}).catch(()=>{}):p.focus()}}static _ExitPointerlock(){document.exitPointerLock&&document.exitPointerLock()}static _RequestFullscreen(p){const _=p.requestFullscreen||p.webkitRequestFullscreen;_&&_.call(p)}static _ExitFullscreen(){const p=document;document.exitFullscreen?document.exitFullscreen():p.webkitCancelFullScreen&&p.webkitCancelFullScreen()}getFontOffset(p){const _=document.createElement("span");_.innerHTML="Hg",_.setAttribute("style",`font: ${p} !important`);const E=document.createElement("div");E.style.display="inline-block",E.style.width="1px",E.style.height="0px",E.style.verticalAlign="bottom";const A=document.createElement("div");A.style.whiteSpace="nowrap",A.appendChild(_),A.appendChild(E),document.body.appendChild(A);let $=0,ne=0;try{ne=E.getBoundingClientRect().top-_.getBoundingClientRect().top,E.style.verticalAlign="baseline",$=E.getBoundingClientRect().top-_.getBoundingClientRect().top}finally{document.body.removeChild(A)}return{ascent:$,height:ne,descent:ne-$}}}ui.ALPHA_DISABLE=0,ui.ALPHA_ADD=1,ui.ALPHA_COMBINE=2,ui.ALPHA_SUBTRACT=3,ui.ALPHA_MULTIPLY=4,ui.ALPHA_MAXIMIZED=5,ui.ALPHA_ONEONE=6,ui.ALPHA_PREMULTIPLIED=7,ui.ALPHA_PREMULTIPLIED_PORTERDUFF=8,ui.ALPHA_INTERPOLATE=9,ui.ALPHA_SCREENMODE=10,ui.DELAYLOADSTATE_NONE=0,ui.DELAYLOADSTATE_LOADED=1,ui.DELAYLOADSTATE_LOADING=2,ui.DELAYLOADSTATE_NOTLOADED=4,ui.NEVER=512,ui.ALWAYS=519,ui.LESS=513,ui.EQUAL=514,ui.LEQUAL=515,ui.GREATER=516,ui.GEQUAL=518,ui.NOTEQUAL=517,ui.KEEP=7680,ui.REPLACE=7681,ui.INCR=7682,ui.DECR=7683,ui.INVERT=5386,ui.INCR_WRAP=34055,ui.DECR_WRAP=34056,ui.TEXTURE_CLAMP_ADDRESSMODE=0,ui.TEXTURE_WRAP_ADDRESSMODE=1,ui.TEXTURE_MIRROR_ADDRESSMODE=2,ui.TEXTUREFORMAT_ALPHA=0,ui.TEXTUREFORMAT_LUMINANCE=1,ui.TEXTUREFORMAT_LUMINANCE_ALPHA=2,ui.TEXTUREFORMAT_RGB=4,ui.TEXTUREFORMAT_RGBA=5,ui.TEXTUREFORMAT_RED=6,ui.TEXTUREFORMAT_R=6,ui.TEXTUREFORMAT_RG=7,ui.TEXTUREFORMAT_RED_INTEGER=8,ui.TEXTUREFORMAT_R_INTEGER=8,ui.TEXTUREFORMAT_RG_INTEGER=9,ui.TEXTUREFORMAT_RGB_INTEGER=10,ui.TEXTUREFORMAT_RGBA_INTEGER=11,ui.TEXTURETYPE_UNSIGNED_BYTE=0,ui.TEXTURETYPE_UNSIGNED_INT=0,ui.TEXTURETYPE_FLOAT=1,ui.TEXTURETYPE_HALF_FLOAT=2,ui.TEXTURETYPE_BYTE=3,ui.TEXTURETYPE_SHORT=4,ui.TEXTURETYPE_UNSIGNED_SHORT=5,ui.TEXTURETYPE_INT=6,ui.TEXTURETYPE_UNSIGNED_INTEGER=7,ui.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4=8,ui.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1=9,ui.TEXTURETYPE_UNSIGNED_SHORT_5_6_5=10,ui.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV=11,ui.TEXTURETYPE_UNSIGNED_INT_24_8=12,ui.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV=13,ui.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV=14,ui.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV=15,ui.TEXTURE_NEAREST_SAMPLINGMODE=1,ui.TEXTURE_BILINEAR_SAMPLINGMODE=2,ui.TEXTURE_TRILINEAR_SAMPLINGMODE=3,ui.TEXTURE_NEAREST_NEAREST_MIPLINEAR=8,ui.TEXTURE_LINEAR_LINEAR_MIPNEAREST=11,ui.TEXTURE_LINEAR_LINEAR_MIPLINEAR=3,ui.TEXTURE_NEAREST_NEAREST_MIPNEAREST=4,ui.TEXTURE_NEAREST_LINEAR_MIPNEAREST=5,ui.TEXTURE_NEAREST_LINEAR_MIPLINEAR=6,ui.TEXTURE_NEAREST_LINEAR=7,ui.TEXTURE_NEAREST_NEAREST=1,ui.TEXTURE_LINEAR_NEAREST_MIPNEAREST=9,ui.TEXTURE_LINEAR_NEAREST_MIPLINEAR=10,ui.TEXTURE_LINEAR_LINEAR=2,ui.TEXTURE_LINEAR_NEAREST=12,ui.TEXTURE_EXPLICIT_MODE=0,ui.TEXTURE_SPHERICAL_MODE=1,ui.TEXTURE_PLANAR_MODE=2,ui.TEXTURE_CUBIC_MODE=3,ui.TEXTURE_PROJECTION_MODE=4,ui.TEXTURE_SKYBOX_MODE=5,ui.TEXTURE_INVCUBIC_MODE=6,ui.TEXTURE_EQUIRECTANGULAR_MODE=7,ui.TEXTURE_FIXED_EQUIRECTANGULAR_MODE=8,ui.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,ui.SCALEMODE_FLOOR=1,ui.SCALEMODE_NEAREST=2,ui.SCALEMODE_CEILING=3,ui._RescalePostProcessFactory=null,ui._RenderPassIdCounter=0;const l2=(_e,p,_)=>!_e||_e.getClassName&&_e.getClassName()==="Mesh"?null:_e.getClassName&&(_e.getClassName()==="SubMesh"||_e.getClassName()==="PhysicsBody")?_e.clone(p):_e.clone?_e.clone():Array.isArray(_e)?_e.slice():_&&typeof _e=="object"?{..._e}:null;function Uo(_e){const p=[];do Object.getOwnPropertyNames(_e).forEach(function(_){p.indexOf(_)===-1&&p.push(_)});while(_e=Object.getPrototypeOf(_e));return p}class al{static DeepCopy(p,_,E,A,$=!1){const ne=Uo(p);for(const xe of ne){if(xe[0]==="_"&&(!A||A.indexOf(xe)===-1)||xe.endsWith("Observable")||E&&E.indexOf(xe)!==-1)continue;const ce=p[xe],Te=typeof ce;if(Te!=="function")try{if(Te==="object")if(ce instanceof Uint8Array)_[xe]=Uint8Array.from(ce);else if(ce instanceof Array){if(_[xe]=[],ce.length>0)if(typeof ce[0]=="object")for(let Re=0;Re<ce.length;Re++){const ke=l2(ce[Re],_,$);_[xe].indexOf(ke)===-1&&_[xe].push(ke)}else _[xe]=ce.slice(0)}else _[xe]=l2(ce,_,$);else _[xe]=ce}catch(Re){vi.Warn(Re.message)}}}}function h2(){return typeof _native<"u"&&_native.XMLHttpRequest?new _native.XMLHttpRequest:new XMLHttpRequest}class za{constructor(){this._xhr=h2(),this._requestURL=""}static get IsCustomRequestAvailable(){return Object.keys(za.CustomRequestHeaders).length>0||za.CustomRequestModifiers.length>0}_injectCustomRequestHeaders(){if(!this._shouldSkipRequestModifications(this._requestURL))for(const p in za.CustomRequestHeaders){const _=za.CustomRequestHeaders[p];_&&this._xhr.setRequestHeader(p,_)}}_shouldSkipRequestModifications(p){return za.SkipRequestModificationForBabylonCDN&&(p.includes("preview.babylonjs.com")||p.includes("cdn.babylonjs.com"))}get onprogress(){return this._xhr.onprogress}set onprogress(p){this._xhr.onprogress=p}get readyState(){return this._xhr.readyState}get status(){return this._xhr.status}get statusText(){return this._xhr.statusText}get response(){return this._xhr.response}get responseURL(){return this._xhr.responseURL}get responseText(){return this._xhr.responseText}get responseType(){return this._xhr.responseType}set responseType(p){this._xhr.responseType=p}get timeout(){return this._xhr.timeout}set timeout(p){this._xhr.timeout=p}addEventListener(p,_,E){this._xhr.addEventListener(p,_,E)}removeEventListener(p,_,E){this._xhr.removeEventListener(p,_,E)}abort(){this._xhr.abort()}send(p){za.CustomRequestHeaders&&this._injectCustomRequestHeaders(),this._xhr.send(p)}open(p,_){for(const E of za.CustomRequestModifiers){if(this._shouldSkipRequestModifications(_))return;E(this._xhr,_)}_=_.replace("file:http:","http:"),_=_.replace("file:https:","https:"),this._requestURL=_,this._xhr.open(p,_,!0)}setRequestHeader(p,_){this._xhr.setRequestHeader(p,_)}getResponseHeader(p){return this._xhr.getResponseHeader(p)}}za.CustomRequestHeaders={},za.CustomRequestModifiers=new Array,za.SkipRequestModificationForBabylonCDN=!0;class v0{}v0.FilesToLoad={};class Y2{static ExponentialBackoff(p=3,_=500){return(E,A,$)=>A.status!==0||$>=p||E.indexOf("file:")!==-1?-1:Math.pow(2,$)*_}}class xl extends Error{}xl._setPrototypeOf=Object.setPrototypeOf||((_e,p)=>(_e.__proto__=p,_e));const Yo={MeshInvalidPositionsError:0,UnsupportedTextureError:1e3,GLTFLoaderUnexpectedMagicError:2e3,SceneLoaderError:3e3,LoadFileError:4e3,RequestFileError:4001,ReadFileError:4002};class jo extends xl{constructor(p,_,E){super(p),this.errorCode=_,this.innerError=E,this.name="RuntimeError",xl._setPrototypeOf(this,jo.prototype)}}const zc=(_e,p)=>_e.endsWith(p),Wc=(_e,p)=>_e?_e.startsWith(p):!1,Wh=_e=>{if(typeof TextDecoder<"u")return new TextDecoder().decode(_e);let p="";for(let _=0;_<_e.byteLength;_++)p+=String.fromCharCode(_e[_]);return p},c2=_e=>{const p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";let _="",E,A,$,ne,xe,ce,Te,Re=0;const ke=ArrayBuffer.isView(_e)?new Uint8Array(_e.buffer,_e.byteOffset,_e.byteLength):new Uint8Array(_e);for(;Re<ke.length;)E=ke[Re++],A=Re<ke.length?ke[Re++]:Number.NaN,$=Re<ke.length?ke[Re++]:Number.NaN,ne=E>>2,xe=(E&3)<<4|A>>4,ce=(A&15)<<2|$>>6,Te=$&63,isNaN(A)?ce=Te=64:isNaN($)&&(Te=64),_+=p.charAt(ne)+p.charAt(xe)+p.charAt(ce)+p.charAt(Te);return _},u2=_e=>atob(_e),Mo=_e=>{const p=u2(_e),_=p.length,E=new Uint8Array(new ArrayBuffer(_));for(let A=0;A<_;A++)E[A]=p.charCodeAt(A);return E.buffer},Hh={EndsWith:zc,StartsWith:Wc,Decode:Wh,EncodeArrayBufferToBase64:c2,DecodeBase64ToString:u2,DecodeBase64ToBinary:Mo,PadNumber:(_e,p)=>{let _=String(_e);for(;_.length<p;)_="0"+_;return _}};class _2{static SetImmediate(p){wa()&&window.setImmediate?window.setImmediate(p):setTimeout(p,1)}}const G0=new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);class Ml extends jo{constructor(p,_){super(p,Yo.LoadFileError),this.name="LoadFileError",xl._setPrototypeOf(this,Ml.prototype),_ instanceof za?this.request=_:this.file=_}}class wl extends jo{constructor(p,_){super(p,Yo.RequestFileError),this.request=_,this.name="RequestFileError",xl._setPrototypeOf(this,wl.prototype)}}class j2 extends jo{constructor(p,_){super(p,Yo.ReadFileError),this.file=_,this.name="ReadFileError",xl._setPrototypeOf(this,j2.prototype)}}const La={DefaultRetryStrategy:Y2.ExponentialBackoff(),BaseUrl:"",CorsBehavior:"anonymous",PreprocessUrl:_e=>_e,ScriptBaseUrl:"",ScriptPreprocessUrl:_e=>_e},Xh=_e=>(_e=_e.replace(/#/gm,"%23"),_e),q2=(_e,p)=>{if(!(_e&&_e.indexOf("data:")===0)&&La.CorsBehavior)if(typeof La.CorsBehavior=="string"||La.CorsBehavior instanceof String)p.crossOrigin=La.CorsBehavior;else{const _=La.CorsBehavior(_e);_&&(p.crossOrigin=_)}},T2=(_e,p,_,E,A="",$)=>{const ne=wr.LastCreatedEngine;if(typeof HTMLImageElement>"u"&&!ne?._features.forceBitmapOverHTMLImageElement)return _("LoadImage is only supported in web or BabylonNative environments."),null;let xe,ce=!1;_e instanceof ArrayBuffer||ArrayBuffer.isView(_e)?typeof Blob<"u"&&typeof URL<"u"?(xe=URL.createObjectURL(new Blob([_e],{type:A})),ce=!0):xe=`data:${A};base64,`+c2(_e):_e instanceof Blob?(xe=URL.createObjectURL(_e),ce=!0):(xe=Xh(_e),xe=La.PreprocessUrl(_e));const Te=Wt=>{if(_){const zt=xe||_e.toString();_(`Error while trying to load image: ${zt.indexOf("http")===0||zt.length<=128?zt:zt.slice(0,128)+"..."}`,Wt)}};if(ne?._features.forceBitmapOverHTMLImageElement)return Tx(xe,Wt=>{ne.createImageBitmap(new Blob([Wt],{type:A}),{premultiplyAlpha:"none",...$}).then(zt=>{p(zt),ce&&URL.revokeObjectURL(xe)}).catch(zt=>{_&&_("Error while trying to load image: "+_e,zt)})},void 0,E||void 0,!0,(Wt,zt)=>{Te(zt)}),null;const Re=new Image;q2(xe,Re);const ke=[],We=()=>{ke.forEach(Wt=>{Wt.target.addEventListener(Wt.name,Wt.handler)})},Xe=()=>{ke.forEach(Wt=>{Wt.target.removeEventListener(Wt.name,Wt.handler)}),ke.length=0},xt=()=>{Xe(),p(Re),ce&&Re.src&&URL.revokeObjectURL(Re.src)},qe=Wt=>{Xe(),Te(Wt),ce&&Re.src&&URL.revokeObjectURL(Re.src)},ht=Wt=>{if(Wt.blockedURI!==Re.src)return;Xe();const zt=new Error(`CSP violation of policy ${Wt.effectiveDirective} ${Wt.blockedURI}. Current policy is ${Wt.originalPolicy}`);wr.UseFallbackTexture=!1,Te(zt),ce&&Re.src&&URL.revokeObjectURL(Re.src),Re.src=""};ke.push({target:Re,name:"load",handler:xt}),ke.push({target:Re,name:"error",handler:qe}),ke.push({target:document,name:"securitypolicyviolation",handler:ht}),We();const Nt=xe.substring(0,5)==="blob:",wt=xe.substring(0,5)==="data:",Qt=()=>{Nt||wt||!za.IsCustomRequestAvailable?Re.src=xe:Tx(xe,(Wt,zt,xi)=>{const wi=!A&&xi?xi:A,vs=new Blob([Wt],{type:wi}),cs=URL.createObjectURL(vs);ce=!0,Re.src=cs},void 0,E||void 0,!0,(Wt,zt)=>{Te(zt)})},Ht=()=>{E&&E.loadImage(xe,Re)};if(!Nt&&!wt&&E&&E.enableTexturesOffline)E.open(Ht,Qt);else{if(xe.indexOf("file:")!==-1){const Wt=decodeURIComponent(xe.substring(5).toLowerCase());if(v0.FilesToLoad[Wt]&&typeof URL<"u"){try{let zt;try{zt=URL.createObjectURL(v0.FilesToLoad[Wt])}catch{zt=URL.createObjectURL(v0.FilesToLoad[Wt])}Re.src=zt,ce=!0}catch{Re.src=""}return Re}}Qt()}return Re},Ll=(_e,p,_,E,A)=>{const $=new FileReader,ne={onCompleteObservable:new Mi,abort:()=>$.abort()};return $.onloadend=()=>ne.onCompleteObservable.notifyObservers(ne),A&&($.onerror=()=>{A(new j2(`Unable to read ${_e.name}`,_e))}),$.onload=xe=>{p(xe.target.result)},_&&($.onprogress=_),E?$.readAsArrayBuffer(_e):$.readAsText(_e),ne},Tx=(_e,p,_,E,A,$,ne)=>{if(_e.name)return Ll(_e,p,_,A,$?Re=>{$(void 0,Re)}:void 0);const xe=_e;if(xe.indexOf("file:")!==-1){let Re=decodeURIComponent(xe.substring(5).toLowerCase());Re.indexOf("./")===0&&(Re=Re.substring(2));const ke=v0.FilesToLoad[Re];if(ke)return Ll(ke,p,_,A,$?We=>$(void 0,new Ml(We.message,We.file)):void 0)}const{match:ce,type:Te}=Xc(xe);if(ce){const Re={onCompleteObservable:new Mi,abort:()=>()=>{}};try{const ke=A?Ul(xe):Yh(xe);p(ke,void 0,Te)}catch(ke){$?$(void 0,ke):vi.Error(ke.message||"Failed to parse the Data URL")}return _2.SetImmediate(()=>{Re.onCompleteObservable.notifyObservers(Re)}),Re}return $2(xe,(Re,ke)=>{p(Re,ke?.responseURL,ke?.getResponseHeader("content-type"))},_,E,A,$?Re=>{$(Re.request,new Ml(Re.message,Re.request))}:void 0,ne)},$2=(_e,p,_,E,A,$,ne)=>{_e=Xh(_e),_e=La.PreprocessUrl(_e);const xe=La.BaseUrl+_e;let ce=!1;const Te={onCompleteObservable:new Mi,abort:()=>ce=!0},Re=()=>{let ke=new za,We=null,Xe;const xt=()=>{ke&&(_&&ke.removeEventListener("progress",_),Xe&&ke.removeEventListener("readystatechange",Xe),ke.removeEventListener("loadend",qe))};let qe=()=>{xt(),Te.onCompleteObservable.notifyObservers(Te),Te.onCompleteObservable.clear(),_=void 0,Xe=null,qe=null,$=void 0,ne=void 0,p=void 0};Te.abort=()=>{ce=!0,qe&&qe(),ke&&ke.readyState!==(XMLHttpRequest.DONE||4)&&ke.abort(),We!==null&&(clearTimeout(We),We=null),ke=null};const ht=wt=>{const Qt=wt.message||"Unknown error";$&&ke?$(new wl(Qt,ke)):vi.Error(Qt)},Nt=wt=>{if(ke){if(ke.open("GET",xe),ne)try{ne(ke)}catch(Qt){ht(Qt);return}A&&(ke.responseType="arraybuffer"),_&&ke.addEventListener("progress",_),qe&&ke.addEventListener("loadend",qe),Xe=()=>{if(!(ce||!ke)&&ke.readyState===(XMLHttpRequest.DONE||4)){if(Xe&&ke.removeEventListener("readystatechange",Xe),ke.status>=200&&ke.status<300||ke.status===0&&(!wa()||Kh())){try{p&&p(A?ke.response:ke.responseText,ke)}catch(Wt){ht(Wt)}return}const Qt=La.DefaultRetryStrategy;if(Qt){const Wt=Qt(xe,ke,wt);if(Wt!==-1){xt(),ke=new za,We=setTimeout(()=>Nt(wt+1),Wt);return}}const Ht=new wl("Error status: "+ke.status+" "+ke.statusText+" - Unable to load "+xe,ke);$&&$(Ht)}},ke.addEventListener("readystatechange",Xe),ke.send()}};Nt(0)};if(E&&E.enableSceneOffline){const ke=Xe=>{Xe&&Xe.status>400?$&&$(Xe):Re()},We=()=>{E&&E.loadFile(La.BaseUrl+_e,Xe=>{!ce&&p&&p(Xe),Te.onCompleteObservable.notifyObservers(Te)},_?Xe=>{!ce&&_&&_(Xe)}:void 0,ke,A)};E.open(We,ke)}else Re();return Te},Kh=()=>typeof location<"u"&&location.protocol==="file:",kl=_e=>G0.test(_e),Xc=_e=>{const p=G0.exec(_e);return p===null||p.length===0?{match:!1,type:""}:{match:!0,type:p[0].replace("data:","").replace("base64,","")}};function Ul(_e){return Mo(_e.split(",")[1])}const Yh=_e=>u2(_e.split(",")[1]);(()=>{rr._FileToolsLoadImage=T2,rr._FileToolsLoadFile=Tx,po._FileToolsLoadFile=Tx})();let ro;((_e,p,_,E,A,$,ne,xe,ce,Te)=>{ro={DecodeBase64UrlToBinary:_e,DecodeBase64UrlToString:p,DefaultRetryStrategy:_.DefaultRetryStrategy,BaseUrl:_.BaseUrl,CorsBehavior:_.CorsBehavior,PreprocessUrl:_.PreprocessUrl,IsBase64DataUrl:E,IsFileURL:A,LoadFile:$,LoadImage:ne,ReadFile:xe,RequestFile:ce,SetCorsBehavior:Te},Object.defineProperty(ro,"DefaultRetryStrategy",{get:function(){return _.DefaultRetryStrategy},set:function(Re){_.DefaultRetryStrategy=Re}}),Object.defineProperty(ro,"BaseUrl",{get:function(){return _.BaseUrl},set:function(Re){_.BaseUrl=Re}}),Object.defineProperty(ro,"PreprocessUrl",{get:function(){return _.PreprocessUrl},set:function(Re){_.PreprocessUrl=Re}}),Object.defineProperty(ro,"CorsBehavior",{get:function(){return _.CorsBehavior},set:function(Re){_.CorsBehavior=Re}})})(Ul,Yh,La,kl,Kh,Tx,T2,Ll,$2,q2);const v2={};function zs(_e,p){v2[_e]=p}function a0(_e){return v2[_e]}class z0{static Instantiate(p){if(this.RegisteredExternalClasses&&this.RegisteredExternalClasses[p])return this.RegisteredExternalClasses[p];const _=a0(p);if(_)return _;vi.Warn(p+" not found, you may have missed an import.");const E=p.split(".");let A=window||this;for(let $=0,ne=E.length;$<ne;$++)A=A[E[$]];return typeof A!="function"?null:A}}z0.RegisteredExternalClasses={};function q0(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,_e=>{const p=Math.random()*16|0;return(_e==="x"?p:p&3|8).toString(16)})}const Lt={RandomId:q0};class ct{static get BaseUrl(){return La.BaseUrl}static set BaseUrl(p){La.BaseUrl=p}static IsAbsoluteUrl(p){return p.indexOf("//")===0?!0:p.indexOf("://")===-1||p.indexOf(".")===-1||p.indexOf("/")===-1||p.indexOf(":")>p.indexOf("/")?!1:p.indexOf("://")<p.indexOf(".")||p.indexOf("data:")===0||p.indexOf("blob:")===0}static set ScriptBaseUrl(p){La.ScriptBaseUrl=p}static get ScriptBaseUrl(){return La.ScriptBaseUrl}static set ScriptPreprocessUrl(p){La.ScriptPreprocessUrl=p}static get ScriptPreprocessUrl(){return La.ScriptPreprocessUrl}static get DefaultRetryStrategy(){return La.DefaultRetryStrategy}static set DefaultRetryStrategy(p){La.DefaultRetryStrategy=p}static get CorsBehavior(){return La.CorsBehavior}static set CorsBehavior(p){La.CorsBehavior=p}static get UseFallbackTexture(){return wr.UseFallbackTexture}static set UseFallbackTexture(p){wr.UseFallbackTexture=p}static get RegisteredExternalClasses(){return z0.RegisteredExternalClasses}static set RegisteredExternalClasses(p){z0.RegisteredExternalClasses=p}static get fallbackTexture(){return wr.FallbackTexture}static set fallbackTexture(p){wr.FallbackTexture=p}static FetchToRef(p,_,E,A,$,ne){const xe=Math.abs(p)*E%E|0,ce=Math.abs(_)*A%A|0,Te=(xe+ce*E)*4;ne.r=$[Te]/255,ne.g=$[Te+1]/255,ne.b=$[Te+2]/255,ne.a=$[Te+3]/255}static Mix(p,_,E){return p*(1-E)+_*E}static Instantiate(p){return z0.Instantiate(p)}static SetImmediate(p){_2.SetImmediate(p)}static IsExponentOfTwo(p){let _=1;do _*=2;while(_<p);return _===p}static FloatRound(p){return Math.fround(p)}static GetFilename(p){const _=p.lastIndexOf("/");return _<0?p:p.substring(_+1)}static GetFolderPath(p,_=!1){const E=p.lastIndexOf("/");return E<0?_?p:"":p.substring(0,E+1)}static ToDegrees(p){return p*180/Math.PI}static ToRadians(p){return p*Math.PI/180}static SmoothAngleChange(p,_,E=.9){const A=this.ToRadians(p),$=this.ToRadians(_);return this.ToDegrees(Math.atan2((1-E)*Math.sin($)+E*Math.sin(A),(1-E)*Math.cos($)+E*Math.cos(A)))}static MakeArray(p,_){return _!==!0&&(p===void 0||p==null)?null:Array.isArray(p)?p:[p]}static GetPointerPrefix(p){let _="pointer";return wa()&&!window.PointerEvent&&(_="mouse"),p._badDesktopOS&&!p._badOS&&!(document&&"ontouchend"in document)&&(_="mouse"),_}static SetCorsBehavior(p,_){q2(p,_)}static SetReferrerPolicyBehavior(p,_){_.referrerPolicy=p}static CleanUrl(p){return p=p.replace(/#/gm,"%23"),p}static get PreprocessUrl(){return La.PreprocessUrl}static set PreprocessUrl(p){La.PreprocessUrl=p}static LoadImage(p,_,E,A,$,ne){return T2(p,_,E,A,$,ne)}static LoadFile(p,_,E,A,$,ne){return Tx(p,_,E,A,$,ne)}static LoadFileAsync(p,_=!0){return new Promise((E,A)=>{Tx(p,$=>{E($)},void 0,void 0,_,($,ne)=>{A(ne)})})}static GetBabylonScriptURL(p,_){if(!p)return"";if(ct.ScriptBaseUrl&&p.startsWith(ct._DefaultCdnUrl)){const E=ct.ScriptBaseUrl[ct.ScriptBaseUrl.length-1]==="/"?ct.ScriptBaseUrl.substring(0,ct.ScriptBaseUrl.length-1):ct.ScriptBaseUrl;p=p.replace(ct._DefaultCdnUrl,E)}return p=ct.ScriptPreprocessUrl(p),_&&(p=ct.GetAbsoluteUrl(p)),p}static LoadBabylonScript(p,_,E,A){p=ct.GetBabylonScriptURL(p),ct.LoadScript(p,_,E)}static LoadBabylonScriptAsync(p){return p=ct.GetBabylonScriptURL(p),ct.LoadScriptAsync(p)}static LoadScript(p,_,E,A){if(typeof importScripts=="function"){try{importScripts(p),_()}catch(xe){E?.(`Unable to load script '${p}' in worker`,xe)}return}else if(!wa()){E?.(`Cannot load script '${p}' outside of a window or a worker`);return}const $=document.getElementsByTagName("head")[0],ne=document.createElement("script");ne.setAttribute("type","text/javascript"),ne.setAttribute("src",p),A&&(ne.id=A),ne.onload=()=>{_&&_()},ne.onerror=xe=>{E&&E(`Unable to load script '${p}'`,xe)},$.appendChild(ne)}static LoadScriptAsync(p,_){return new Promise((E,A)=>{this.LoadScript(p,()=>{E()},($,ne)=>{A(ne||new Error($))},_)})}static ReadFileAsDataURL(p,_,E){const A=new FileReader,$={onCompleteObservable:new Mi,abort:()=>A.abort()};return A.onloadend=()=>{$.onCompleteObservable.notifyObservers($)},A.onload=ne=>{_(ne.target.result)},A.onprogress=E,A.readAsDataURL(p),$}static ReadFile(p,_,E,A,$){return Ll(p,_,E,A,$)}static FileAsURL(p){const _=new Blob([p]);return window.URL.createObjectURL(_)}static Format(p,_=2){return p.toFixed(_)}static DeepCopy(p,_,E,A){al.DeepCopy(p,_,E,A)}static IsEmpty(p){for(const _ in p)if(Object.prototype.hasOwnProperty.call(p,_))return!1;return!0}static RegisterTopRootEvents(p,_){for(let E=0;E<_.length;E++){const A=_[E];p.addEventListener(A.name,A.handler,!1);try{window.parent&&window.parent.addEventListener(A.name,A.handler,!1)}catch{}}}static UnregisterTopRootEvents(p,_){for(let E=0;E<_.length;E++){const A=_[E];p.removeEventListener(A.name,A.handler);try{p.parent&&p.parent.removeEventListener(A.name,A.handler)}catch{}}}static async DumpFramebuffer(p,_,E,A,$="image/png",ne,xe){throw Tr("DumpTools")}static DumpData(p,_,E,A,$="image/png",ne,xe=!1,ce=!1,Te){throw Tr("DumpTools")}static DumpDataAsync(p,_,E,A="image/png",$,ne=!1,xe=!1,ce){throw Tr("DumpTools")}static _IsOffScreenCanvas(p){return p.convertToBlob!==void 0}static ToBlob(p,_,E="image/png",A){!ct._IsOffScreenCanvas(p)&&!p.toBlob&&(p.toBlob=function($,ne,xe){setTimeout(()=>{const ce=atob(this.toDataURL(ne,xe).split(",")[1]),Te=ce.length,Re=new Uint8Array(Te);for(let ke=0;ke<Te;ke++)Re[ke]=ce.charCodeAt(ke);$(new Blob([Re]))})}),ct._IsOffScreenCanvas(p)?p.convertToBlob({type:E,quality:A}).then($=>_($)):p.toBlob(function($){_($)},E,A)}static DownloadBlob(p,_){if("download"in document.createElement("a")){if(!_){const E=new Date;_="screenshot_"+((E.getFullYear()+"-"+(E.getMonth()+1)).slice(2)+"-"+E.getDate()+"_"+E.getHours()+"-"+("0"+E.getMinutes()).slice(-2))+".png"}ct.Download(p,_)}else if(p&&typeof URL<"u"){const E=URL.createObjectURL(p),A=window.open("");if(!A)return;const $=A.document.createElement("img");$.onload=function(){URL.revokeObjectURL(E)},$.src=E,A.document.body.appendChild($)}}static EncodeScreenshotCanvasData(p,_,E="image/png",A,$){if(typeof A=="string"||!_)this.ToBlob(p,function(ne){ne&&ct.DownloadBlob(ne,A),_&&_("")},E,$);else if(_){if(ct._IsOffScreenCanvas(p)){p.convertToBlob({type:E,quality:$}).then(xe=>{const ce=new FileReader;ce.readAsDataURL(xe),ce.onloadend=()=>{const Te=ce.result;_(Te)}});return}const ne=p.toDataURL(E,$);_(ne)}}static Download(p,_){if(typeof URL>"u")return;const E=window.URL.createObjectURL(p),A=document.createElement("a");document.body.appendChild(A),A.style.display="none",A.href=E,A.download=_,A.addEventListener("click",()=>{A.parentElement&&A.parentElement.removeChild(A)}),A.click(),window.URL.revokeObjectURL(E)}static BackCompatCameraNoPreventDefault(p){return typeof p[0]=="boolean"?p[0]:typeof p[1]=="boolean"?p[1]:!1}static CreateScreenshot(p,_,E,A,$="image/png",ne=!1,xe){throw Tr("ScreenshotTools")}static CreateScreenshotAsync(p,_,E,A="image/png",$){throw Tr("ScreenshotTools")}static CreateScreenshotUsingRenderTarget(p,_,E,A,$="image/png",ne=1,xe=!1,ce,Te=!1,Re=!1,ke=!0,We){throw Tr("ScreenshotTools")}static CreateScreenshotUsingRenderTargetAsync(p,_,E,A="image/png",$=1,ne=!1,xe,ce=!1,Te=!1,Re=!0,ke){throw Tr("ScreenshotTools")}static RandomId(){return q0()}static IsBase64(p){return kl(p)}static DecodeBase64(p){return Ul(p)}static get errorsCount(){return vi.errorsCount}static Log(p){vi.Log(p)}static Warn(p){vi.Warn(p)}static Error(p){vi.Error(p)}static get LogCache(){return vi.LogCache}static ClearLogCache(){vi.ClearLogCache()}static set LogLevels(p){vi.LogLevels=p}static set PerformanceLogLevel(p){if((p&ct.PerformanceUserMarkLogLevel)===ct.PerformanceUserMarkLogLevel){ct.StartPerformanceCounter=ct._StartUserMark,ct.EndPerformanceCounter=ct._EndUserMark;return}if((p&ct.PerformanceConsoleLogLevel)===ct.PerformanceConsoleLogLevel){ct.StartPerformanceCounter=ct._StartPerformanceConsole,ct.EndPerformanceCounter=ct._EndPerformanceConsole;return}ct.StartPerformanceCounter=ct._StartPerformanceCounterDisabled,ct.EndPerformanceCounter=ct._EndPerformanceCounterDisabled}static _StartPerformanceCounterDisabled(p,_){}static _EndPerformanceCounterDisabled(p,_){}static _StartUserMark(p,_=!0){if(!ct._Performance){if(!wa())return;ct._Performance=window.performance}!_||!ct._Performance.mark||ct._Performance.mark(p+"-Begin")}static _EndUserMark(p,_=!0){!_||!ct._Performance.mark||(ct._Performance.mark(p+"-End"),ct._Performance.measure(p,p+"-Begin",p+"-End"))}static _StartPerformanceConsole(p,_=!0){_&&(ct._StartUserMark(p,_),console.time&&console.time(p))}static _EndPerformanceConsole(p,_=!0){_&&(ct._EndUserMark(p,_),console.timeEnd(p))}static get Now(){return Ko.Now}static GetClassName(p,_=!1){let E=null;return!_&&p.getClassName?E=p.getClassName():(p instanceof Object&&(E=(_?p:Object.getPrototypeOf(p)).constructor.__bjsclassName__),E||(E=typeof p)),E}static First(p,_){for(const E of p)if(_(E))return E;return null}static getFullClassName(p,_=!1){let E=null,A=null;if(!_&&p.getClassName)E=p.getClassName();else{if(p instanceof Object){const $=_?p:Object.getPrototypeOf(p);E=$.constructor.__bjsclassName__,A=$.constructor.__bjsmoduleName__}E||(E=typeof p)}return E?(A!=null?A+".":"")+E:null}static DelayAsync(p){return new Promise(_=>{setTimeout(()=>{_()},p)})}static IsSafari(){return Ho()?/^((?!chrome|android).)*safari/i.test(navigator.userAgent):!1}}ct.UseCustomRequestHeaders=!1,ct.CustomRequestHeaders=za.CustomRequestHeaders,ct.GetDOMTextContent=Y0,ct._DefaultCdnUrl="https://cdn.babylonjs.com",ct.GetAbsoluteUrl=typeof document=="object"?_e=>{const p=document.createElement("a");return p.href=_e,p.href}:typeof URL=="function"&&typeof location=="object"?_e=>new URL(_e,location.origin).href:()=>{throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.")},ct.NoneLogLevel=vi.NoneLogLevel,ct.MessageLogLevel=vi.MessageLogLevel,ct.WarningLogLevel=vi.WarningLogLevel,ct.ErrorLogLevel=vi.ErrorLogLevel,ct.AllLogLevel=vi.AllLogLevel,ct.IsWindowObjectExist=wa,ct.PerformanceNoneLogLevel=0,ct.PerformanceUserMarkLogLevel=1,ct.PerformanceConsoleLogLevel=2,ct.StartPerformanceCounter=ct._StartPerformanceCounterDisabled,ct.EndPerformanceCounter=ct._EndPerformanceCounterDisabled;function ai(_e,p){return _=>{_.__bjsclassName__=_e,_.__bjsmoduleName__=p??null}}class ki{constructor(p,_,E,A=0){this.iterations=p,this.index=A-1,this._done=!1,this._fn=_,this._successCallback=E}executeNext(){this._done||(this.index+1<this.iterations?(++this.index,this._fn(this)):this.breakLoop())}breakLoop(){this._done=!0,this._successCallback()}static Run(p,_,E,A=0){const $=new ki(p,_,E,A);return $.executeNext(),$}static SyncAsyncForLoop(p,_,E,A,$,ne=0){return ki.Run(Math.ceil(p/_),xe=>{$&&$()?xe.breakLoop():setTimeout(()=>{for(let ce=0;ce<_;++ce){const Te=xe.index*_+ce;if(Te>=p)break;if(E(Te),$&&$()){xe.breakLoop();break}}xe.executeNext()},ne)},A)}}wr.FallbackTexture="data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";class _t{constructor(p){this.length=0,this.data=new Array(p),this._id=_t._GlobalId++}push(p){this.data[this.length++]=p,this.length>this.data.length&&(this.data.length*=2)}forEach(p){for(let _=0;_<this.length;_++)p(this.data[_])}sort(p){this.data.sort(p)}reset(){this.length=0}dispose(){this.reset(),this.data&&(this.data.length=0)}concat(p){if(p.length!==0){this.length+p.length>this.data.length&&(this.data.length=(this.length+p.length)*2);for(let _=0;_<p.length;_++)this.data[this.length++]=(p.data||p)[_]}}indexOf(p){const _=this.data.indexOf(p);return _>=this.length?-1:_}contains(p){return this.indexOf(p)!==-1}}_t._GlobalId=0;class vt extends _t{constructor(){super(...arguments),this._duplicateId=0}push(p){super.push(p),p.__smartArrayFlags||(p.__smartArrayFlags={}),p.__smartArrayFlags[this._id]=this._duplicateId}pushNoDuplicate(p){return p.__smartArrayFlags&&p.__smartArrayFlags[this._id]===this._duplicateId?!1:(this.push(p),!0)}reset(){super.reset(),this._duplicateId++}concatWithNoDuplicate(p){if(p.length!==0){this.length+p.length>this.data.length&&(this.data.length=(this.length+p.length)*2);for(let _=0;_<p.length;_++){const E=(p.data||p)[_];this.pushNoDuplicate(E)}}}}class Ut{constructor(){this._count=0,this._data={}}copyFrom(p){this.clear(),p.forEach((_,E)=>this.add(_,E))}get(p){const _=this._data[p];if(_!==void 0)return _}getOrAddWithFactory(p,_){let E=this.get(p);return E!==void 0||(E=_(p),E&&this.add(p,E)),E}getOrAdd(p,_){const E=this.get(p);return E!==void 0?E:(this.add(p,_),_)}contains(p){return this._data[p]!==void 0}add(p,_){return this._data[p]!==void 0?!1:(this._data[p]=_,++this._count,!0)}set(p,_){return this._data[p]===void 0?!1:(this._data[p]=_,!0)}getAndRemove(p){const _=this.get(p);return _!==void 0?(delete this._data[p],--this._count,_):null}remove(p){return this.contains(p)?(delete this._data[p],--this._count,!0):!1}clear(){this._data={},this._count=0}get count(){return this._count}forEach(p){for(const _ in this._data){const E=this._data[_];p(_,E)}}first(p){for(const _ in this._data){const E=this._data[_],A=p(_,E);if(A)return A}return null}}class jt{static Eval(p,_){return p.match(/\([^()]*\)/g)?p=p.replace(/\([^()]*\)/g,E=>(E=E.slice(1,E.length-1),jt._HandleParenthesisContent(E,_))):p=jt._HandleParenthesisContent(p,_),p==="true"?!0:p==="false"?!1:jt.Eval(p,_)}static _HandleParenthesisContent(p,_){_=_||($=>$==="true");let E;const A=p.split("||");for(const $ in A)if(Object.prototype.hasOwnProperty.call(A,$)){let ne=jt._SimplifyNegation(A[$].trim());const xe=ne.split("&&");if(xe.length>1)for(let ce=0;ce<xe.length;++ce){const Te=jt._SimplifyNegation(xe[ce].trim());if(Te!=="true"&&Te!=="false"?Te[0]==="!"?E=!_(Te.substring(1)):E=_(Te):E=Te==="true",!E){ne="false";break}}if(E||ne==="true"){E=!0;break}ne!=="true"&&ne!=="false"?ne[0]==="!"?E=!_(ne.substring(1)):E=_(ne):E=ne==="true"}return E?"true":"false"}static _SimplifyNegation(p){return p=p.replace(/^[\s!]+/,_=>(_=_.replace(/[\s]/g,()=>""),_.length%2?"!":"")),p=p.trim(),p==="!true"?p="false":p==="!false"&&(p="true"),p}}class ni{static EnableFor(p){p._tags=p._tags||{},p.hasTags=()=>ni.HasTags(p),p.addTags=_=>ni.AddTagsTo(p,_),p.removeTags=_=>ni.RemoveTagsFrom(p,_),p.matchesTagsQuery=_=>ni.MatchesQuery(p,_)}static DisableFor(p){delete p._tags,delete p.hasTags,delete p.addTags,delete p.removeTags,delete p.matchesTagsQuery}static HasTags(p){if(!p._tags)return!1;const _=p._tags;for(const E in _)if(Object.prototype.hasOwnProperty.call(_,E))return!0;return!1}static GetTags(p,_=!0){if(!p._tags)return null;if(_){const E=[];for(const A in p._tags)Object.prototype.hasOwnProperty.call(p._tags,A)&&p._tags[A]===!0&&E.push(A);return E.join(" ")}else return p._tags}static AddTagsTo(p,_){if(!_||typeof _!="string")return;_.split(" ").forEach(function(A){ni._AddTagTo(p,A)})}static _AddTagTo(p,_){_=_.trim(),!(_===""||_==="true"||_==="false")&&(_.match(/[\s]/)||_.match(/^([!]|([|]|[&]){2})/)||(ni.EnableFor(p),p._tags[_]=!0))}static RemoveTagsFrom(p,_){if(!ni.HasTags(p))return;const E=_.split(" ");for(const A in E)ni._RemoveTagFrom(p,E[A])}static _RemoveTagFrom(p,_){delete p._tags[_]}static MatchesQuery(p,_){return _===void 0?!0:_===""?ni.HasTags(p):jt.Eval(_,E=>ni.HasTags(p)&&p._tags[E])}}class ri{static WithinEpsilon(p,_,E=1401298e-51){return Math.abs(p-_)<=E}static ToHex(p){const _=p.toString(16);return p<=15?("0"+_).toUpperCase():_.toUpperCase()}static Sign(p){return p=+p,p===0||isNaN(p)?p:p>0?1:-1}static Clamp(p,_=0,E=1){return Math.min(E,Math.max(_,p))}static Log2(p){return Math.log(p)*Math.LOG2E}static ILog2(p){if(Math.log2)return Math.floor(Math.log2(p));if(p<0)return NaN;if(p===0)return-1/0;let _=0;if(p<1){for(;p<1;)_++,p=p*2;_=-_}else if(p>1)for(;p>1;)_++,p=Math.floor(p/2);return _}static Repeat(p,_){return p-Math.floor(p/_)*_}static Normalize(p,_,E){return(p-_)/(E-_)}static Denormalize(p,_,E){return p*(E-_)+_}static DeltaAngle(p,_){let E=ri.Repeat(_-p,360);return E>180&&(E-=360),E}static PingPong(p,_){const E=ri.Repeat(p,_*2);return _-Math.abs(E-_)}static SmoothStep(p,_,E){let A=ri.Clamp(E);return A=-2*A*A*A+3*A*A,_*A+p*(1-A)}static MoveTowards(p,_,E){let A=0;return Math.abs(_-p)<=E?A=_:A=p+ri.Sign(_-p)*E,A}static MoveTowardsAngle(p,_,E){const A=ri.DeltaAngle(p,_);let $=0;return-E<A&&A<E?$=_:(_=p+A,$=ri.MoveTowards(p,_,E)),$}static Lerp(p,_,E){return p+(_-p)*E}static LerpAngle(p,_,E){let A=ri.Repeat(_-p,360);return A>180&&(A-=360),p+A*ri.Clamp(E)}static InverseLerp(p,_,E){let A=0;return p!=_?A=ri.Clamp((E-p)/(_-p)):A=0,A}static Hermite(p,_,E,A,$){const ne=$*$,xe=$*ne,ce=2*xe-3*ne+1,Te=-2*xe+3*ne,Re=xe-2*ne+$,ke=xe-ne;return p*ce+E*Te+_*Re+A*ke}static Hermite1stDerivative(p,_,E,A,$){const ne=$*$;return(ne-$)*6*p+(3*ne-4*$+1)*_+(-ne+$)*6*E+(3*ne-2*$)*A}static RandomRange(p,_){return p===_?p:Math.random()*(_-p)+p}static RangeToPercent(p,_,E){return(p-_)/(E-_)}static PercentToRange(p,_,E){return(E-_)*p+_}static NormalizeRadians(p){return p-=ri.TwoPi*Math.floor((p+Math.PI)/ri.TwoPi),p}static HCF(p,_){const E=p%_;return E===0?_:ri.HCF(_,E)}}ri.TwoPi=Math.PI*2;const Li=1/2.2,zi=2.2,Rs=(1+Math.sqrt(5))/2,as=.001;class Ms{static BuildArray(p,_){const E=[];for(let A=0;A<p;++A)E.push(_());return E}static BuildTuple(p,_){return Ms.BuildArray(p,_)}}function an(_e,p,_){const E=_e[p];if(typeof E!="function")return null;const A=function(){const $=_e.length,ne=A.previous.apply(_e,arguments);return _(p,$),ne};return E.next=A,A.previous=E,_e[p]=A,()=>{const $=A.previous;if(!$)return;const ne=A.next;ne?($.next=ne,ne.previous=$):($.next=void 0,_e[p]=$),A.next=void 0,A.previous=void 0}}const cn=["push","splice","pop","shift","unshift"];function Mn(_e,p){const _=cn.map(E=>an(_e,E,p));return()=>{_.forEach(E=>{E?.()})}}const wn=_e=>parseInt(_e.toString().replace(/\W/g,""));class xr{constructor(p=0,_=0){this.x=p,this.y=_}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){const p=wn(this.x),_=wn(this.y);let E=p;return E=E*397^_,E}toArray(p,_=0){return p[_]=this.x,p[_+1]=this.y,this}fromArray(p,_=0){return xr.FromArrayToRef(p,_,this),this}asArray(){const p=[];return this.toArray(p,0),p}copyFrom(p){return this.x=p.x,this.y=p.y,this}copyFromFloats(p,_){return this.x=p,this.y=_,this}set(p,_){return this.copyFromFloats(p,_)}add(p){return new this.constructor(this.x+p.x,this.y+p.y)}addToRef(p,_){return _.x=this.x+p.x,_.y=this.y+p.y,_}addInPlace(p){return this.x+=p.x,this.y+=p.y,this}addVector3(p){return new this.constructor(this.x+p.x,this.y+p.y)}subtract(p){return new this.constructor(this.x-p.x,this.y-p.y)}subtractToRef(p,_){return _.x=this.x-p.x,_.y=this.y-p.y,_}subtractInPlace(p){return this.x-=p.x,this.y-=p.y,this}multiplyInPlace(p){return this.x*=p.x,this.y*=p.y,this}multiply(p){return new this.constructor(this.x*p.x,this.y*p.y)}multiplyToRef(p,_){return _.x=this.x*p.x,_.y=this.y*p.y,_}multiplyByFloats(p,_){return new this.constructor(this.x*p,this.y*_)}divide(p){return new this.constructor(this.x/p.x,this.y/p.y)}divideToRef(p,_){return _.x=this.x/p.x,_.y=this.y/p.y,_}divideInPlace(p){return this.divideToRef(p,this)}negate(){return new this.constructor(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(p){return p.copyFromFloats(this.x*-1,this.y*-1)}scaleInPlace(p){return this.x*=p,this.y*=p,this}scale(p){const _=new this.constructor(0,0);return this.scaleToRef(p,_),_}scaleToRef(p,_){return _.x=this.x*p,_.y=this.y*p,_}scaleAndAddToRef(p,_){return _.x+=this.x*p,_.y+=this.y*p,_}equals(p){return p&&this.x===p.x&&this.y===p.y}equalsWithEpsilon(p,_=as){return p&&ri.WithinEpsilon(this.x,p.x,_)&&ri.WithinEpsilon(this.y,p.y,_)}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y))}fract(){return new this.constructor(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}rotateToRef(p,_){const E=Math.cos(p),A=Math.sin(p),$=E*this.x-A*this.y,ne=A*this.x+E*this.y;return _.x=$,_.y=ne,_}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(p){return p===0||p===1?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new this.constructor(0,0);return this.normalizeToRef(p),p}normalizeToRef(p){const _=this.length();return _===0||_===1?p.copyFromFloats(this.x,this.y):this.scaleToRef(1/_,p)}clone(){return new this.constructor(this.x,this.y)}dot(p){return this.x*p.x+this.y*p.y}static Zero(){return new xr(0,0)}static One(){return new xr(1,1)}static Random(p=0,_=1){return new xr(ri.RandomRange(p,_),ri.RandomRange(p,_))}static get ZeroReadOnly(){return xr._ZeroReadOnly}static FromArray(p,_=0){return new xr(p[_],p[_+1])}static FromArrayToRef(p,_,E){return E.x=p[_],E.y=p[_+1],E}static CatmullRom(p,_,E,A,$){const ne=$*$,xe=$*ne,ce=.5*(2*_.x+(-p.x+E.x)*$+(2*p.x-5*_.x+4*E.x-A.x)*ne+(-p.x+3*_.x-3*E.x+A.x)*xe),Te=.5*(2*_.y+(-p.y+E.y)*$+(2*p.y-5*_.y+4*E.y-A.y)*ne+(-p.y+3*_.y-3*E.y+A.y)*xe);return new p.constructor(ce,Te)}static Clamp(p,_,E){let A=p.x;A=A>E.x?E.x:A,A=A<_.x?_.x:A;let $=p.y;return $=$>E.y?E.y:$,$=$<_.y?_.y:$,new p.constructor(A,$)}static Hermite(p,_,E,A,$){const ne=$*$,xe=$*ne,ce=2*xe-3*ne+1,Te=-2*xe+3*ne,Re=xe-2*ne+$,ke=xe-ne,We=p.x*ce+E.x*Te+_.x*Re+A.x*ke,Xe=p.y*ce+E.y*Te+_.y*Re+A.y*ke;return new p.constructor(We,Xe)}static Hermite1stDerivative(p,_,E,A,$){const ne=new p.constructor;return this.Hermite1stDerivativeToRef(p,_,E,A,$,ne),ne}static Hermite1stDerivativeToRef(p,_,E,A,$,ne){const xe=$*$;return ne.x=(xe-$)*6*p.x+(3*xe-4*$+1)*_.x+(-xe+$)*6*E.x+(3*xe-2*$)*A.x,ne.y=(xe-$)*6*p.y+(3*xe-4*$+1)*_.y+(-xe+$)*6*E.y+(3*xe-2*$)*A.y,ne}static Lerp(p,_,E){const A=p.x+(_.x-p.x)*E,$=p.y+(_.y-p.y)*E;return new p.constructor(A,$)}static Dot(p,_){return p.x*_.x+p.y*_.y}static Normalize(p){const _=new p.constructor;return xr.NormalizeToRef(p,_),_}static NormalizeToRef(p,_){return p.normalizeToRef(_),_}static Minimize(p,_){const E=p.x<_.x?p.x:_.x,A=p.y<_.y?p.y:_.y;return new p.constructor(E,A)}static Maximize(p,_){const E=p.x>_.x?p.x:_.x,A=p.y>_.y?p.y:_.y;return new p.constructor(E,A)}static Transform(p,_){const E=new p.constructor;return xr.TransformToRef(p,_,E),E}static TransformToRef(p,_,E){const A=_.m,$=p.x*A[0]+p.y*A[4]+A[12],ne=p.x*A[1]+p.y*A[5]+A[13];return E.x=$,E.y=ne,E}static PointInTriangle(p,_,E,A){const $=.5*(-E.y*A.x+_.y*(-E.x+A.x)+_.x*(E.y-A.y)+E.x*A.y),ne=$<0?-1:1,xe=(_.y*A.x-_.x*A.y+(A.y-_.y)*p.x+(_.x-A.x)*p.y)*ne,ce=(_.x*E.y-_.y*E.x+(_.y-E.y)*p.x+(E.x-_.x)*p.y)*ne;return xe>0&&ce>0&&xe+ce<2*$*ne}static Distance(p,_){return Math.sqrt(xr.DistanceSquared(p,_))}static DistanceSquared(p,_){const E=p.x-_.x,A=p.y-_.y;return E*E+A*A}static Center(p,_){const E=new p.constructor;return xr.CenterToRef(p,_,E)}static CenterToRef(p,_,E){return E.copyFromFloats((p.x+_.x)/2,(p.y+_.y)/2)}static DistanceOfPointFromSegment(p,_,E){const A=xr.DistanceSquared(_,E);if(A===0)return xr.Distance(p,_);const $=E.subtract(_),ne=Math.max(0,Math.min(1,xr.Dot(p.subtract(_),$)/A)),xe=_.add($.multiplyByFloats(ne,ne));return xr.Distance(p,xe)}}xr._ZeroReadOnly=xr.Zero();class nt{get x(){return this._x}set x(p){this._x=p,this._isDirty=!0}get y(){return this._y}set y(p){this._y=p,this._isDirty=!0}get z(){return this._z}set z(p){this._z=p,this._isDirty=!0}constructor(p=0,_=0,E=0){this._isDirty=!0,this._x=p,this._y=_,this._z=E}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vector3"}getHashCode(){const p=wn(this._x),_=wn(this._y),E=wn(this._z);let A=p;return A=A*397^_,A=A*397^E,A}asArray(){const p=[];return this.toArray(p,0),p}toArray(p,_=0){return p[_]=this._x,p[_+1]=this._y,p[_+2]=this._z,this}fromArray(p,_=0){return nt.FromArrayToRef(p,_,this),this}toQuaternion(){return _s.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(p){return this.addInPlaceFromFloats(p._x,p._y,p._z)}addInPlaceFromFloats(p,_,E){return this._x+=p,this._y+=_,this._z+=E,this._isDirty=!0,this}add(p){return new this.constructor(this._x+p._x,this._y+p._y,this._z+p._z)}addToRef(p,_){return _.copyFromFloats(this._x+p._x,this._y+p._y,this._z+p._z)}subtractInPlace(p){return this._x-=p._x,this._y-=p._y,this._z-=p._z,this._isDirty=!0,this}subtract(p){return new this.constructor(this._x-p._x,this._y-p._y,this._z-p._z)}subtractToRef(p,_){return this.subtractFromFloatsToRef(p._x,p._y,p._z,_)}subtractFromFloats(p,_,E){return new this.constructor(this._x-p,this._y-_,this._z-E)}subtractFromFloatsToRef(p,_,E,A){return A.copyFromFloats(this._x-p,this._y-_,this._z-E)}negate(){return new this.constructor(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(p){return p.copyFromFloats(this._x*-1,this._y*-1,this._z*-1)}scaleInPlace(p){return this._x*=p,this._y*=p,this._z*=p,this._isDirty=!0,this}scale(p){return new this.constructor(this._x*p,this._y*p,this._z*p)}scaleToRef(p,_){return _.copyFromFloats(this._x*p,this._y*p,this._z*p)}getNormalToRef(p){const _=this.length();let E=Math.acos(this.y/_);const A=Math.atan2(this.z,this.x);E>Math.PI/2?E-=Math.PI/2:E+=Math.PI/2;const $=_*Math.sin(E)*Math.cos(A),ne=_*Math.cos(E),xe=_*Math.sin(E)*Math.sin(A);return p.set($,ne,xe),p}applyRotationQuaternionToRef(p,_){const E=this._x,A=this._y,$=this._z,ne=p._x,xe=p._y,ce=p._z,Te=p._w,Re=2*(xe*$-ce*A),ke=2*(ce*E-ne*$),We=2*(ne*A-xe*E);return _._x=E+Te*Re+xe*We-ce*ke,_._y=A+Te*ke+ce*Re-ne*We,_._z=$+Te*We+ne*ke-xe*Re,_._isDirty=!0,_}applyRotationQuaternionInPlace(p){return this.applyRotationQuaternionToRef(p,this)}applyRotationQuaternion(p){return this.applyRotationQuaternionToRef(p,new this.constructor)}scaleAndAddToRef(p,_){return _.addInPlaceFromFloats(this._x*p,this._y*p,this._z*p)}projectOnPlane(p,_){const E=new this.constructor;return this.projectOnPlaneToRef(p,_,E),E}projectOnPlaneToRef(p,_,E){const A=p.normal,$=p.d,ne=Us.Vector3[0];this.subtractToRef(_,ne),ne.normalize();const xe=nt.Dot(ne,A);if(Math.abs(xe)<1e-10)E.setAll(1/0);else{const ce=-(nt.Dot(_,A)+$)/xe,Te=ne.scaleInPlace(ce);_.addToRef(Te,E)}return E}equals(p){return p&&this._x===p._x&&this._y===p._y&&this._z===p._z}equalsWithEpsilon(p,_=as){return p&&ri.WithinEpsilon(this._x,p._x,_)&&ri.WithinEpsilon(this._y,p._y,_)&&ri.WithinEpsilon(this._z,p._z,_)}equalsToFloats(p,_,E){return this._x===p&&this._y===_&&this._z===E}multiplyInPlace(p){return this._x*=p._x,this._y*=p._y,this._z*=p._z,this._isDirty=!0,this}multiply(p){return this.multiplyByFloats(p._x,p._y,p._z)}multiplyToRef(p,_){return _.copyFromFloats(this._x*p._x,this._y*p._y,this._z*p._z)}multiplyByFloats(p,_,E){return new this.constructor(this._x*p,this._y*_,this._z*E)}divide(p){return new this.constructor(this._x/p._x,this._y/p._y,this._z/p._z)}divideToRef(p,_){return _.copyFromFloats(this._x/p._x,this._y/p._y,this._z/p._z)}divideInPlace(p){return this.divideToRef(p,this)}minimizeInPlace(p){return this.minimizeInPlaceFromFloats(p._x,p._y,p._z)}maximizeInPlace(p){return this.maximizeInPlaceFromFloats(p._x,p._y,p._z)}minimizeInPlaceFromFloats(p,_,E){return p<this._x&&(this.x=p),_<this._y&&(this.y=_),E<this._z&&(this.z=E),this}maximizeInPlaceFromFloats(p,_,E){return p>this._x&&(this.x=p),_>this._y&&(this.y=_),E>this._z&&(this.z=E),this}isNonUniformWithinEpsilon(p){const _=Math.abs(this._x),E=Math.abs(this._y);if(!ri.WithinEpsilon(_,E,p))return!0;const A=Math.abs(this._z);return!ri.WithinEpsilon(_,A,p)||!ri.WithinEpsilon(E,A,p)}get isNonUniform(){const p=Math.abs(this._x),_=Math.abs(this._y);if(p!==_)return!0;const E=Math.abs(this._z);return p!==E}floor(){return new this.constructor(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fract(){return new this.constructor(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(p){if(p=p.toLowerCase(),p==="xyz")return this;const _=Us.Vector3[0].copyFrom(this);return this.x=_[p[0]],this.y=_[p[1]],this.z=_[p[2]],this}rotateByQuaternionToRef(p,_){return p.toRotationMatrix(Us.Matrix[0]),nt.TransformCoordinatesToRef(this,Us.Matrix[0],_),_}rotateByQuaternionAroundPointToRef(p,_,E){return this.subtractToRef(_,Us.Vector3[0]),Us.Vector3[0].rotateByQuaternionToRef(p,Us.Vector3[0]),_.addToRef(Us.Vector3[0],E),E}cross(p){const _=new this.constructor;return nt.CrossToRef(this,p,_)}normalizeFromLength(p){return p===0||p===1?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new this.constructor(0,0,0);return this.normalizeToRef(p),p}normalizeToRef(p){const _=this.length();return _===0||_===1?p.copyFromFloats(this._x,this._y,this._z):this.scaleToRef(1/_,p)}clone(){return new this.constructor(this._x,this._y,this._z)}copyFrom(p){return this.copyFromFloats(p._x,p._y,p._z)}copyFromFloats(p,_,E){return this._x=p,this._y=_,this._z=E,this._isDirty=!0,this}set(p,_,E){return this.copyFromFloats(p,_,E)}setAll(p){return this._x=this._y=this._z=p,this._isDirty=!0,this}static GetClipFactor(p,_,E,A){const $=nt.Dot(p,E),ne=nt.Dot(_,E);return($-A)/($-ne)}static GetAngleBetweenVectors(p,_,E){const A=p.normalizeToRef(Us.Vector3[1]),$=_.normalizeToRef(Us.Vector3[2]);let ne=nt.Dot(A,$);ne=ri.Clamp(ne,-1,1);const xe=Math.acos(ne),ce=Us.Vector3[3];return nt.CrossToRef(A,$,ce),nt.Dot(ce,E)>0?isNaN(xe)?0:xe:isNaN(xe)?-Math.PI:-Math.acos(ne)}static GetAngleBetweenVectorsOnPlane(p,_,E){Us.Vector3[0].copyFrom(p);const A=Us.Vector3[0];Us.Vector3[1].copyFrom(_);const $=Us.Vector3[1];Us.Vector3[2].copyFrom(E);const ne=Us.Vector3[2],xe=Us.Vector3[3],ce=Us.Vector3[4];A.normalize(),$.normalize(),ne.normalize(),nt.CrossToRef(ne,A,xe),nt.CrossToRef(xe,ne,ce);const Te=Math.atan2(nt.Dot($,xe),nt.Dot($,ce));return ri.NormalizeRadians(Te)}static PitchYawRollToMoveBetweenPointsToRef(p,_,E){const A=pi.Vector3[0];return _.subtractToRef(p,A),E._y=Math.atan2(A.x,A.z)||0,E._x=Math.atan2(Math.sqrt(A.x**2+A.z**2),A.y)||0,E._z=0,E._isDirty=!0,E}static PitchYawRollToMoveBetweenPoints(p,_){const E=nt.Zero();return nt.PitchYawRollToMoveBetweenPointsToRef(p,_,E)}static SlerpToRef(p,_,E,A){E=ri.Clamp(E,0,1);const $=Us.Vector3[0],ne=Us.Vector3[1];$.copyFrom(p);const xe=$.length();$.normalizeFromLength(xe),ne.copyFrom(_);const ce=ne.length();ne.normalizeFromLength(ce);const Te=nt.Dot($,ne);let Re,ke;if(Te<1-as){const We=Math.acos(Te),Xe=1/Math.sin(We);Re=Math.sin((1-E)*We)*Xe,ke=Math.sin(E*We)*Xe}else Re=1-E,ke=E;return $.scaleInPlace(Re),ne.scaleInPlace(ke),A.copyFrom($).addInPlace(ne),A.scaleInPlace(ri.Lerp(xe,ce,E)),A}static SmoothToRef(p,_,E,A,$){return nt.SlerpToRef(p,_,A===0?1:E/A,$),$}static FromArray(p,_=0){return new nt(p[_],p[_+1],p[_+2])}static FromFloatArray(p,_){return nt.FromArray(p,_)}static FromArrayToRef(p,_,E){return E._x=p[_],E._y=p[_+1],E._z=p[_+2],E._isDirty=!0,E}static FromFloatArrayToRef(p,_,E){return nt.FromArrayToRef(p,_,E)}static FromFloatsToRef(p,_,E,A){return A.copyFromFloats(p,_,E),A}static Zero(){return new nt(0,0,0)}static One(){return new nt(1,1,1)}static Up(){return new nt(0,1,0)}static get UpReadOnly(){return nt._UpReadOnly}static get DownReadOnly(){return nt._DownReadOnly}static get RightReadOnly(){return nt._RightReadOnly}static get LeftReadOnly(){return nt._LeftReadOnly}static get LeftHandedForwardReadOnly(){return nt._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return nt._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return nt._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return nt._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return nt._ZeroReadOnly}static get OneReadOnly(){return nt._OneReadOnly}static Down(){return new nt(0,-1,0)}static Forward(p=!1){return new nt(0,0,p?-1:1)}static Backward(p=!1){return new nt(0,0,p?1:-1)}static Right(){return new nt(1,0,0)}static Left(){return new nt(-1,0,0)}static Random(p=0,_=1){return new nt(ri.RandomRange(p,_),ri.RandomRange(p,_),ri.RandomRange(p,_))}static TransformCoordinates(p,_){const E=nt.Zero();return nt.TransformCoordinatesToRef(p,_,E),E}static TransformCoordinatesToRef(p,_,E){return nt.TransformCoordinatesFromFloatsToRef(p._x,p._y,p._z,_,E),E}static TransformCoordinatesFromFloatsToRef(p,_,E,A,$){const ne=A.m,xe=p*ne[0]+_*ne[4]+E*ne[8]+ne[12],ce=p*ne[1]+_*ne[5]+E*ne[9]+ne[13],Te=p*ne[2]+_*ne[6]+E*ne[10]+ne[14],Re=1/(p*ne[3]+_*ne[7]+E*ne[11]+ne[15]);return $._x=xe*Re,$._y=ce*Re,$._z=Te*Re,$._isDirty=!0,$}static TransformNormal(p,_){const E=nt.Zero();return nt.TransformNormalToRef(p,_,E),E}static TransformNormalToRef(p,_,E){return this.TransformNormalFromFloatsToRef(p._x,p._y,p._z,_,E),E}static TransformNormalFromFloatsToRef(p,_,E,A,$){const ne=A.m;return $._x=p*ne[0]+_*ne[4]+E*ne[8],$._y=p*ne[1]+_*ne[5]+E*ne[9],$._z=p*ne[2]+_*ne[6]+E*ne[10],$._isDirty=!0,$}static CatmullRom(p,_,E,A,$){const ne=$*$,xe=$*ne,ce=.5*(2*_._x+(-p._x+E._x)*$+(2*p._x-5*_._x+4*E._x-A._x)*ne+(-p._x+3*_._x-3*E._x+A._x)*xe),Te=.5*(2*_._y+(-p._y+E._y)*$+(2*p._y-5*_._y+4*E._y-A._y)*ne+(-p._y+3*_._y-3*E._y+A._y)*xe),Re=.5*(2*_._z+(-p._z+E._z)*$+(2*p._z-5*_._z+4*E._z-A._z)*ne+(-p._z+3*_._z-3*E._z+A._z)*xe);return new p.constructor(ce,Te,Re)}static Clamp(p,_,E){const A=new p.constructor;return nt.ClampToRef(p,_,E,A),A}static ClampToRef(p,_,E,A){let $=p._x;$=$>E._x?E._x:$,$=$<_._x?_._x:$;let ne=p._y;ne=ne>E._y?E._y:ne,ne=ne<_._y?_._y:ne;let xe=p._z;return xe=xe>E._z?E._z:xe,xe=xe<_._z?_._z:xe,A.copyFromFloats($,ne,xe),A}static CheckExtends(p,_,E){_.minimizeInPlace(p),E.maximizeInPlace(p)}static Hermite(p,_,E,A,$){const ne=$*$,xe=$*ne,ce=2*xe-3*ne+1,Te=-2*xe+3*ne,Re=xe-2*ne+$,ke=xe-ne,We=p._x*ce+E._x*Te+_._x*Re+A._x*ke,Xe=p._y*ce+E._y*Te+_._y*Re+A._y*ke,xt=p._z*ce+E._z*Te+_._z*Re+A._z*ke;return new p.constructor(We,Xe,xt)}static Hermite1stDerivative(p,_,E,A,$){const ne=new p.constructor;return this.Hermite1stDerivativeToRef(p,_,E,A,$,ne),ne}static Hermite1stDerivativeToRef(p,_,E,A,$,ne){const xe=$*$;return ne._x=(xe-$)*6*p._x+(3*xe-4*$+1)*_._x+(-xe+$)*6*E._x+(3*xe-2*$)*A._x,ne._y=(xe-$)*6*p._y+(3*xe-4*$+1)*_._y+(-xe+$)*6*E._y+(3*xe-2*$)*A._y,ne._z=(xe-$)*6*p._z+(3*xe-4*$+1)*_._z+(-xe+$)*6*E._z+(3*xe-2*$)*A._z,ne._isDirty=!0,ne}static Lerp(p,_,E){const A=new p.constructor(0,0,0);return nt.LerpToRef(p,_,E,A),A}static LerpToRef(p,_,E,A){return A._x=p._x+(_._x-p._x)*E,A._y=p._y+(_._y-p._y)*E,A._z=p._z+(_._z-p._z)*E,A._isDirty=!0,A}static Dot(p,_){return p._x*_._x+p._y*_._y+p._z*_._z}dot(p){return this._x*p._x+this._y*p._y+this._z*p._z}static Cross(p,_){const E=new p.constructor;return nt.CrossToRef(p,_,E),E}static CrossToRef(p,_,E){const A=p._y*_._z-p._z*_._y,$=p._z*_._x-p._x*_._z,ne=p._x*_._y-p._y*_._x;return E.copyFromFloats(A,$,ne),E}static Normalize(p){const _=nt.Zero();return nt.NormalizeToRef(p,_),_}static NormalizeToRef(p,_){return p.normalizeToRef(_),_}static Project(p,_,E,A){const $=new p.constructor;return nt.ProjectToRef(p,_,E,A,$),$}static ProjectToRef(p,_,E,A,$){const ne=A.width,xe=A.height,ce=A.x,Te=A.y,Re=Us.Matrix[1];Yt.FromValuesToRef(ne/2,0,0,0,0,-xe/2,0,0,0,0,.5,0,ce+ne/2,xe/2+Te,.5,1,Re);const ke=Us.Matrix[0];return _.multiplyToRef(E,ke),ke.multiplyToRef(Re,ke),nt.TransformCoordinatesToRef(p,ke,$),$}static Reflect(p,_){return this.ReflectToRef(p,_,new nt)}static ReflectToRef(p,_,E){const A=pi.Vector3[0];return A.copyFrom(_).scaleInPlace(2*nt.Dot(p,_)),E.copyFrom(p).subtractInPlace(A)}static _UnprojectFromInvertedMatrixToRef(p,_,E){nt.TransformCoordinatesToRef(p,_,E);const A=_.m,$=p._x*A[3]+p._y*A[7]+p._z*A[11]+A[15];return ri.WithinEpsilon($,1)&&E.scaleInPlace(1/$),E}static UnprojectFromTransform(p,_,E,A,$){return this.Unproject(p,_,E,A,$,Yt.IdentityReadOnly)}static Unproject(p,_,E,A,$,ne){const xe=new p.constructor;return nt.UnprojectToRef(p,_,E,A,$,ne,xe),xe}static UnprojectToRef(p,_,E,A,$,ne,xe){return nt.UnprojectFloatsToRef(p._x,p._y,p._z,_,E,A,$,ne,xe),xe}static UnprojectFloatsToRef(p,_,E,A,$,ne,xe,ce,Te){const Re=Us.Matrix[0];ne.multiplyToRef(xe,Re),Re.multiplyToRef(ce,Re),Re.invert();const ke=Us.Vector3[0];return ke.x=p/A*2-1,ke.y=-(_/$*2-1),wr.LastCreatedEngine?.isNDCHalfZRange?ke.z=E:ke.z=2*E-1,nt._UnprojectFromInvertedMatrixToRef(ke,Re,Te),Te}static Minimize(p,_){const E=new p.constructor;return E.copyFrom(p),E.minimizeInPlace(_),E}static Maximize(p,_){const E=new p.constructor;return E.copyFrom(p),E.maximizeInPlace(_),E}static Distance(p,_){return Math.sqrt(nt.DistanceSquared(p,_))}static DistanceSquared(p,_){const E=p._x-_._x,A=p._y-_._y,$=p._z-_._z;return E*E+A*A+$*$}static ProjectOnTriangleToRef(p,_,E,A,$){const ne=Us.Vector3[0],xe=Us.Vector3[1],ce=Us.Vector3[2],Te=Us.Vector3[3],Re=Us.Vector3[4];E.subtractToRef(_,ne),A.subtractToRef(_,xe),A.subtractToRef(E,ce);const ke=ne.length(),We=xe.length(),Xe=ce.length();if(ke<as||We<as||Xe<as)return $.copyFrom(_),nt.Distance(p,_);p.subtractToRef(_,Re),nt.CrossToRef(ne,xe,Te);const xt=Te.length();if(xt<as)return $.copyFrom(_),nt.Distance(p,_);Te.normalizeFromLength(xt);let qe=Re.length();if(qe<as)return $.copyFrom(_),0;Re.normalizeFromLength(qe);const ht=nt.Dot(Te,Re),Nt=Us.Vector3[5],wt=Us.Vector3[6];Nt.copyFrom(Te).scaleInPlace(-qe*ht),wt.copyFrom(p).addInPlace(Nt);const Qt=Us.Vector3[4],Ht=Us.Vector3[5],Wt=Us.Vector3[7],zt=Us.Vector3[8];Qt.copyFrom(ne).scaleInPlace(1/ke),zt.copyFrom(xe).scaleInPlace(1/We),Qt.addInPlace(zt).scaleInPlace(-1),Ht.copyFrom(ne).scaleInPlace(-1/ke),zt.copyFrom(ce).scaleInPlace(1/Xe),Ht.addInPlace(zt).scaleInPlace(-1),Wt.copyFrom(ce).scaleInPlace(-1/Xe),zt.copyFrom(xe).scaleInPlace(-1/We),Wt.addInPlace(zt).scaleInPlace(-1);const xi=Us.Vector3[9];let wi;xi.copyFrom(wt).subtractInPlace(_),nt.CrossToRef(Qt,xi,zt),wi=nt.Dot(zt,Te);const vs=wi;xi.copyFrom(wt).subtractInPlace(E),nt.CrossToRef(Ht,xi,zt),wi=nt.Dot(zt,Te);const cs=wi;xi.copyFrom(wt).subtractInPlace(A),nt.CrossToRef(Wt,xi,zt),wi=nt.Dot(zt,Te);const Mr=wi,xn=Us.Vector3[10];let qr,Tn;vs>0&&cs<0?(xn.copyFrom(ne),qr=_,Tn=E):cs>0&&Mr<0?(xn.copyFrom(ce),qr=E,Tn=A):(xn.copyFrom(xe).scaleInPlace(-1),qr=A,Tn=_);const h0=Us.Vector3[9],Ra=Us.Vector3[4];if(qr.subtractToRef(wt,zt),Tn.subtractToRef(wt,h0),nt.CrossToRef(zt,h0,Ra),!(nt.Dot(Ra,Te)<0))return $.copyFrom(wt),Math.abs(qe*ht);const X0=Us.Vector3[5];nt.CrossToRef(xn,Ra,X0),X0.normalize();const K0=Us.Vector3[9];K0.copyFrom(qr).subtractInPlace(wt);const qx=K0.length();if(qx<as)return $.copyFrom(qr),nt.Distance(p,qr);K0.normalizeFromLength(qx);const Ux=nt.Dot(X0,K0),k2=Us.Vector3[7];k2.copyFrom(wt).addInPlace(X0.scaleInPlace(qx*Ux)),zt.copyFrom(k2).subtractInPlace(qr),qe=xn.length(),xn.normalizeFromLength(qe);let Tc=nt.Dot(zt,xn)/Math.max(qe,as);return Tc=ri.Clamp(Tc,0,1),k2.copyFrom(qr).addInPlace(xn.scaleInPlace(Tc*qe)),$.copyFrom(k2),nt.Distance(p,k2)}static Center(p,_){return nt.CenterToRef(p,_,nt.Zero())}static CenterToRef(p,_,E){return E.copyFromFloats((p._x+_._x)/2,(p._y+_._y)/2,(p._z+_._z)/2)}static RotationFromAxis(p,_,E){const A=new p.constructor;return nt.RotationFromAxisToRef(p,_,E,A),A}static RotationFromAxisToRef(p,_,E,A){const $=Us.Quaternion[0];return _s.RotationQuaternionFromAxisToRef(p,_,E,$),$.toEulerAnglesToRef(A),A}}nt._UpReadOnly=nt.Up(),nt._DownReadOnly=nt.Down(),nt._LeftHandedForwardReadOnly=nt.Forward(!1),nt._RightHandedForwardReadOnly=nt.Forward(!0),nt._LeftHandedBackwardReadOnly=nt.Backward(!1),nt._RightHandedBackwardReadOnly=nt.Backward(!0),nt._RightReadOnly=nt.Right(),nt._LeftReadOnly=nt.Left(),nt._ZeroReadOnly=nt.Zero(),nt._OneReadOnly=nt.One();class Gr{constructor(p=0,_=0,E=0,A=0){this.x=p,this.y=_,this.z=E,this.w=A}toString(){return`{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`}getClassName(){return"Vector4"}getHashCode(){const p=wn(this.x),_=wn(this.y),E=wn(this.z),A=wn(this.w);let $=p;return $=$*397^_,$=$*397^E,$=$*397^A,$}asArray(){const p=[];return this.toArray(p,0),p}toArray(p,_){return _===void 0&&(_=0),p[_]=this.x,p[_+1]=this.y,p[_+2]=this.z,p[_+3]=this.w,this}fromArray(p,_=0){return Gr.FromArrayToRef(p,_,this),this}addInPlace(p){return this.x+=p.x,this.y+=p.y,this.z+=p.z,this.w+=p.w,this}add(p){return new this.constructor(this.x+p.x,this.y+p.y,this.z+p.z,this.w+p.w)}addToRef(p,_){return _.x=this.x+p.x,_.y=this.y+p.y,_.z=this.z+p.z,_.w=this.w+p.w,_}subtractInPlace(p){return this.x-=p.x,this.y-=p.y,this.z-=p.z,this.w-=p.w,this}subtract(p){return new this.constructor(this.x-p.x,this.y-p.y,this.z-p.z,this.w-p.w)}subtractToRef(p,_){return _.x=this.x-p.x,_.y=this.y-p.y,_.z=this.z-p.z,_.w=this.w-p.w,_}subtractFromFloats(p,_,E,A){return new this.constructor(this.x-p,this.y-_,this.z-E,this.w-A)}subtractFromFloatsToRef(p,_,E,A,$){return $.x=this.x-p,$.y=this.y-_,$.z=this.z-E,$.w=this.w-A,$}negate(){return new this.constructor(-this.x,-this.y,-this.z,-this.w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(p){return p.copyFromFloats(this.x*-1,this.y*-1,this.z*-1,this.w*-1)}scaleInPlace(p){return this.x*=p,this.y*=p,this.z*=p,this.w*=p,this}scale(p){return new this.constructor(this.x*p,this.y*p,this.z*p,this.w*p)}scaleToRef(p,_){return _.x=this.x*p,_.y=this.y*p,_.z=this.z*p,_.w=this.w*p,_}scaleAndAddToRef(p,_){return _.x+=this.x*p,_.y+=this.y*p,_.z+=this.z*p,_.w+=this.w*p,_}equals(p){return p&&this.x===p.x&&this.y===p.y&&this.z===p.z&&this.w===p.w}equalsWithEpsilon(p,_=as){return p&&ri.WithinEpsilon(this.x,p.x,_)&&ri.WithinEpsilon(this.y,p.y,_)&&ri.WithinEpsilon(this.z,p.z,_)&&ri.WithinEpsilon(this.w,p.w,_)}equalsToFloats(p,_,E,A){return this.x===p&&this.y===_&&this.z===E&&this.w===A}multiplyInPlace(p){return this.x*=p.x,this.y*=p.y,this.z*=p.z,this.w*=p.w,this}multiply(p){return new this.constructor(this.x*p.x,this.y*p.y,this.z*p.z,this.w*p.w)}multiplyToRef(p,_){return _.x=this.x*p.x,_.y=this.y*p.y,_.z=this.z*p.z,_.w=this.w*p.w,_}multiplyByFloats(p,_,E,A){return new this.constructor(this.x*p,this.y*_,this.z*E,this.w*A)}divide(p){return new this.constructor(this.x/p.x,this.y/p.y,this.z/p.z,this.w/p.w)}divideToRef(p,_){return _.x=this.x/p.x,_.y=this.y/p.y,_.z=this.z/p.z,_.w=this.w/p.w,_}divideInPlace(p){return this.divideToRef(p,this)}minimizeInPlace(p){return p.x<this.x&&(this.x=p.x),p.y<this.y&&(this.y=p.y),p.z<this.z&&(this.z=p.z),p.w<this.w&&(this.w=p.w),this}maximizeInPlace(p){return p.x>this.x&&(this.x=p.x),p.y>this.y&&(this.y=p.y),p.z>this.z&&(this.z=p.z),p.w>this.w&&(this.w=p.w),this}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z),Math.floor(this.w))}fract(){return new this.constructor(this.x-Math.floor(this.x),this.y-Math.floor(this.y),this.z-Math.floor(this.z),this.w-Math.floor(this.w))}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(p){return p===0||p===1?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new this.constructor(0,0,0,0);return this.normalizeToRef(p),p}normalizeToRef(p){const _=this.length();return _===0||_===1?p.copyFromFloats(this.x,this.y,this.z,this.w):this.scaleToRef(1/_,p)}toVector3(){return new nt(this.x,this.y,this.z)}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copyFrom(p){return this.x=p.x,this.y=p.y,this.z=p.z,this.w=p.w,this}copyFromFloats(p,_,E,A){return this.x=p,this.y=_,this.z=E,this.w=A,this}set(p,_,E,A){return this.copyFromFloats(p,_,E,A)}setAll(p){return this.x=this.y=this.z=this.w=p,this}dot(p){return this.x*p.x+this.y*p.y+this.z*p.z+this.w*p.w}static FromArray(p,_){return _||(_=0),new Gr(p[_],p[_+1],p[_+2],p[_+3])}static FromArrayToRef(p,_,E){return E.x=p[_],E.y=p[_+1],E.z=p[_+2],E.w=p[_+3],E}static FromFloatArrayToRef(p,_,E){return Gr.FromArrayToRef(p,_,E),E}static FromFloatsToRef(p,_,E,A,$){return $.x=p,$.y=_,$.z=E,$.w=A,$}static Zero(){return new Gr(0,0,0,0)}static One(){return new Gr(1,1,1,1)}static Random(p=0,_=1){return new Gr(ri.RandomRange(p,_),ri.RandomRange(p,_),ri.RandomRange(p,_),ri.RandomRange(p,_))}static get ZeroReadOnly(){return Gr._ZeroReadOnly}static Normalize(p){const _=Gr.Zero();return Gr.NormalizeToRef(p,_),_}static NormalizeToRef(p,_){return p.normalizeToRef(_),_}static Minimize(p,_){const E=new p.constructor;return E.copyFrom(p),E.minimizeInPlace(_),E}static Maximize(p,_){const E=new p.constructor;return E.copyFrom(p),E.maximizeInPlace(_),E}static Distance(p,_){return Math.sqrt(Gr.DistanceSquared(p,_))}static DistanceSquared(p,_){const E=p.x-_.x,A=p.y-_.y,$=p.z-_.z,ne=p.w-_.w;return E*E+A*A+$*$+ne*ne}static Center(p,_){return Gr.CenterToRef(p,_,Gr.Zero())}static CenterToRef(p,_,E){return E.copyFromFloats((p.x+_.x)/2,(p.y+_.y)/2,(p.z+_.z)/2,(p.w+_.w)/2)}static TransformCoordinates(p,_){const E=Gr.Zero();return Gr.TransformCoordinatesToRef(p,_,E),E}static TransformCoordinatesToRef(p,_,E){return Gr.TransformCoordinatesFromFloatsToRef(p._x,p._y,p._z,_,E),E}static TransformCoordinatesFromFloatsToRef(p,_,E,A,$){const ne=A.m,xe=p*ne[0]+_*ne[4]+E*ne[8]+ne[12],ce=p*ne[1]+_*ne[5]+E*ne[9]+ne[13],Te=p*ne[2]+_*ne[6]+E*ne[10]+ne[14],Re=p*ne[3]+_*ne[7]+E*ne[11]+ne[15];return $.x=xe,$.y=ce,$.z=Te,$.w=Re,$}static TransformNormal(p,_){const E=new p.constructor;return Gr.TransformNormalToRef(p,_,E),E}static TransformNormalToRef(p,_,E){const A=_.m,$=p.x*A[0]+p.y*A[4]+p.z*A[8],ne=p.x*A[1]+p.y*A[5]+p.z*A[9],xe=p.x*A[2]+p.y*A[6]+p.z*A[10];return E.x=$,E.y=ne,E.z=xe,E.w=p.w,E}static TransformNormalFromFloatsToRef(p,_,E,A,$,ne){const xe=$.m;return ne.x=p*xe[0]+_*xe[4]+E*xe[8],ne.y=p*xe[1]+_*xe[5]+E*xe[9],ne.z=p*xe[2]+_*xe[6]+E*xe[10],ne.w=A,ne}static FromVector3(p,_=0){return new Gr(p._x,p._y,p._z,_)}static Dot(p,_){return p.dot(_)}}Gr._ZeroReadOnly=Gr.Zero();class _s{get x(){return this._x}set x(p){this._x=p,this._isDirty=!0}get y(){return this._y}set y(p){this._y=p,this._isDirty=!0}get z(){return this._z}set z(p){this._z=p,this._isDirty=!0}get w(){return this._w}set w(p){this._w=p,this._isDirty=!0}constructor(p=0,_=0,E=0,A=1){this._isDirty=!0,this._x=p,this._y=_,this._z=E,this._w=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){const p=wn(this._x),_=wn(this._y),E=wn(this._z),A=wn(this._w);let $=p;return $=$*397^_,$=$*397^E,$=$*397^A,$}asArray(){return[this._x,this._y,this._z,this._w]}toArray(p,_=0){return p[_]=this._x,p[_+1]=this._y,p[_+2]=this._z,p[_+3]=this._w,this}equals(p){return p&&this._x===p._x&&this._y===p._y&&this._z===p._z&&this._w===p._w}equalsWithEpsilon(p,_=as){return p&&ri.WithinEpsilon(this._x,p._x,_)&&ri.WithinEpsilon(this._y,p._y,_)&&ri.WithinEpsilon(this._z,p._z,_)&&ri.WithinEpsilon(this._w,p._w,_)}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copyFrom(p){return this._x=p._x,this._y=p._y,this._z=p._z,this._w=p._w,this._isDirty=!0,this}copyFromFloats(p,_,E,A){return this._x=p,this._y=_,this._z=E,this._w=A,this._isDirty=!0,this}set(p,_,E,A){return this.copyFromFloats(p,_,E,A)}add(p){return new this.constructor(this._x+p._x,this._y+p._y,this._z+p._z,this._w+p._w)}addInPlace(p){return this._x+=p._x,this._y+=p._y,this._z+=p._z,this._w+=p._w,this._isDirty=!0,this}subtract(p){return new this.constructor(this._x-p._x,this._y-p._y,this._z-p._z,this._w-p._w)}subtractInPlace(p){return this._x-=p._x,this._y-=p._y,this._z-=p._z,this._w-=p._w,this._isDirty=!0,this}scale(p){return new this.constructor(this._x*p,this._y*p,this._z*p,this._w*p)}scaleToRef(p,_){return _._x=this._x*p,_._y=this._y*p,_._z=this._z*p,_._w=this._w*p,_._isDirty=!0,_}scaleInPlace(p){return this._x*=p,this._y*=p,this._z*=p,this._w*=p,this._isDirty=!0,this}scaleAndAddToRef(p,_){return _._x+=this._x*p,_._y+=this._y*p,_._z+=this._z*p,_._w+=this._w*p,_._isDirty=!0,_}multiply(p){const _=new this.constructor(0,0,0,1);return this.multiplyToRef(p,_),_}multiplyToRef(p,_){const E=this._x*p._w+this._y*p._z-this._z*p._y+this._w*p._x,A=-this._x*p._z+this._y*p._w+this._z*p._x+this._w*p._y,$=this._x*p._y-this._y*p._x+this._z*p._w+this._w*p._z,ne=-this._x*p._x-this._y*p._y-this._z*p._z+this._w*p._w;return _.copyFromFloats(E,A,$,ne),_}multiplyInPlace(p){return this.multiplyToRef(p,this),this}conjugateToRef(p){return p.copyFromFloats(-this._x,-this._y,-this._z,this._w),p}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new this.constructor(-this._x,-this._y,-this._z,this._w)}invert(){const p=this.conjugate(),_=this.lengthSquared();return _==0||_==1||p.scaleInPlace(1/_),p}invertInPlace(){this.conjugateInPlace();const p=this.lengthSquared();return p==0||p==1?this:(this.scaleInPlace(1/p),this)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(p){return p===0||p===1?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new this.constructor(0,0,0,1);return this.normalizeToRef(p),p}normalizeToRef(p){const _=this.length();return _===0||_===1?p.copyFromFloats(this._x,this._y,this._z,this._w):this.scaleToRef(1/_,p)}toEulerAngles(){const p=nt.Zero();return this.toEulerAnglesToRef(p),p}toEulerAnglesToRef(p){const _=this._z,E=this._x,A=this._y,$=this._w,ne=A*_-E*$,xe=.4999999;if(ne<-xe)p._y=2*Math.atan2(A,$),p._x=Math.PI/2,p._z=0,p._isDirty=!0;else if(ne>xe)p._y=2*Math.atan2(A,$),p._x=-Math.PI/2,p._z=0,p._isDirty=!0;else{const ce=$*$,Te=_*_,Re=E*E,ke=A*A;p._z=Math.atan2(2*(E*A+_*$),-Te-Re+ke+ce),p._x=Math.asin(-2*ne),p._y=Math.atan2(2*(_*E+A*$),Te-Re-ke+ce),p._isDirty=!0}return p}toRotationMatrix(p){return Yt.FromQuaternionToRef(this,p),p}fromRotationMatrix(p){return _s.FromRotationMatrixToRef(p,this),this}dot(p){return this._x*p._x+this._y*p._y+this._z*p._z+this._w*p._w}static FromRotationMatrix(p){const _=new _s;return _s.FromRotationMatrixToRef(p,_),_}static FromRotationMatrixToRef(p,_){const E=p.m,A=E[0],$=E[4],ne=E[8],xe=E[1],ce=E[5],Te=E[9],Re=E[2],ke=E[6],We=E[10],Xe=A+ce+We;let xt;return Xe>0?(xt=.5/Math.sqrt(Xe+1),_._w=.25/xt,_._x=(ke-Te)*xt,_._y=(ne-Re)*xt,_._z=(xe-$)*xt,_._isDirty=!0):A>ce&&A>We?(xt=2*Math.sqrt(1+A-ce-We),_._w=(ke-Te)/xt,_._x=.25*xt,_._y=($+xe)/xt,_._z=(ne+Re)/xt,_._isDirty=!0):ce>We?(xt=2*Math.sqrt(1+ce-A-We),_._w=(ne-Re)/xt,_._x=($+xe)/xt,_._y=.25*xt,_._z=(Te+ke)/xt,_._isDirty=!0):(xt=2*Math.sqrt(1+We-A-ce),_._w=(xe-$)/xt,_._x=(ne+Re)/xt,_._y=(Te+ke)/xt,_._z=.25*xt,_._isDirty=!0),_}static Dot(p,_){return p._x*_._x+p._y*_._y+p._z*_._z+p._w*_._w}static AreClose(p,_,E=.1){const A=_s.Dot(p,_);return 1-A*A<=E}static SmoothToRef(p,_,E,A,$){let ne=A===0?1:E/A;return ne=ri.Clamp(ne,0,1),_s.SlerpToRef(p,_,ne,$),$}static Zero(){return new _s(0,0,0,0)}static Inverse(p){return new p.constructor(-p._x,-p._y,-p._z,p._w)}static InverseToRef(p,_){return _.set(-p._x,-p._y,-p._z,p._w),_}static Identity(){return new _s(0,0,0,1)}static IsIdentity(p){return p&&p._x===0&&p._y===0&&p._z===0&&p._w===1}static RotationAxis(p,_){return _s.RotationAxisToRef(p,_,new _s)}static RotationAxisToRef(p,_,E){const A=Math.sin(_/2);return p.normalize(),E._w=Math.cos(_/2),E._x=p._x*A,E._y=p._y*A,E._z=p._z*A,E._isDirty=!0,E}static FromArray(p,_){return _||(_=0),new _s(p[_],p[_+1],p[_+2],p[_+3])}static FromArrayToRef(p,_,E){return E._x=p[_],E._y=p[_+1],E._z=p[_+2],E._w=p[_+3],E._isDirty=!0,E}static FromEulerAngles(p,_,E){const A=new _s;return _s.RotationYawPitchRollToRef(_,p,E,A),A}static FromEulerAnglesToRef(p,_,E,A){return _s.RotationYawPitchRollToRef(_,p,E,A),A}static FromEulerVector(p){const _=new _s;return _s.RotationYawPitchRollToRef(p._y,p._x,p._z,_),_}static FromEulerVectorToRef(p,_){return _s.RotationYawPitchRollToRef(p._y,p._x,p._z,_),_}static FromUnitVectorsToRef(p,_,E,A=as){const $=nt.Dot(p,_)+1;return $<A?Math.abs(p.x)>Math.abs(p.z)?E.set(-p.y,p.x,0,0):E.set(0,-p.z,p.y,0):(nt.CrossToRef(p,_,pi.Vector3[0]),E.set(pi.Vector3[0].x,pi.Vector3[0].y,pi.Vector3[0].z,$)),E.normalize()}static RotationYawPitchRoll(p,_,E){const A=new _s;return _s.RotationYawPitchRollToRef(p,_,E,A),A}static RotationYawPitchRollToRef(p,_,E,A){const $=E*.5,ne=_*.5,xe=p*.5,ce=Math.sin($),Te=Math.cos($),Re=Math.sin(ne),ke=Math.cos(ne),We=Math.sin(xe),Xe=Math.cos(xe);return A._x=Xe*Re*Te+We*ke*ce,A._y=We*ke*Te-Xe*Re*ce,A._z=Xe*ke*ce-We*Re*Te,A._w=Xe*ke*Te+We*Re*ce,A._isDirty=!0,A}static RotationAlphaBetaGamma(p,_,E){const A=new _s;return _s.RotationAlphaBetaGammaToRef(p,_,E,A),A}static RotationAlphaBetaGammaToRef(p,_,E,A){const $=(E+p)*.5,ne=(E-p)*.5,xe=_*.5;return A._x=Math.cos(ne)*Math.sin(xe),A._y=Math.sin(ne)*Math.sin(xe),A._z=Math.sin($)*Math.cos(xe),A._w=Math.cos($)*Math.cos(xe),A._isDirty=!0,A}static RotationQuaternionFromAxis(p,_,E){const A=new _s(0,0,0,0);return _s.RotationQuaternionFromAxisToRef(p,_,E,A),A}static RotationQuaternionFromAxisToRef(p,_,E,A){const $=Us.Matrix[0];return Yt.FromXYZAxesToRef(p.normalize(),_.normalize(),E.normalize(),$),_s.FromRotationMatrixToRef($,A),A}static FromLookDirectionLH(p,_){const E=new _s;return _s.FromLookDirectionLHToRef(p,_,E),E}static FromLookDirectionLHToRef(p,_,E){const A=Us.Matrix[0];return Yt.LookDirectionLHToRef(p,_,A),_s.FromRotationMatrixToRef(A,E),E}static FromLookDirectionRH(p,_){const E=new _s;return _s.FromLookDirectionRHToRef(p,_,E),E}static FromLookDirectionRHToRef(p,_,E){const A=Us.Matrix[0];return Yt.LookDirectionRHToRef(p,_,A),_s.FromRotationMatrixToRef(A,E)}static Slerp(p,_,E){const A=_s.Identity();return _s.SlerpToRef(p,_,E,A),A}static SlerpToRef(p,_,E,A){let $,ne,xe=p._x*_._x+p._y*_._y+p._z*_._z+p._w*_._w,ce=!1;if(xe<0&&(ce=!0,xe=-xe),xe>.999999)ne=1-E,$=ce?-E:E;else{const Te=Math.acos(xe),Re=1/Math.sin(Te);ne=Math.sin((1-E)*Te)*Re,$=ce?-Math.sin(E*Te)*Re:Math.sin(E*Te)*Re}return A._x=ne*p._x+$*_._x,A._y=ne*p._y+$*_._y,A._z=ne*p._z+$*_._z,A._w=ne*p._w+$*_._w,A._isDirty=!0,A}static Hermite(p,_,E,A,$){const ne=$*$,xe=$*ne,ce=2*xe-3*ne+1,Te=-2*xe+3*ne,Re=xe-2*ne+$,ke=xe-ne,We=p._x*ce+E._x*Te+_._x*Re+A._x*ke,Xe=p._y*ce+E._y*Te+_._y*Re+A._y*ke,xt=p._z*ce+E._z*Te+_._z*Re+A._z*ke,qe=p._w*ce+E._w*Te+_._w*Re+A._w*ke;return new p.constructor(We,Xe,xt,qe)}static Hermite1stDerivative(p,_,E,A,$){const ne=new p.constructor;return this.Hermite1stDerivativeToRef(p,_,E,A,$,ne),ne}static Hermite1stDerivativeToRef(p,_,E,A,$,ne){const xe=$*$;return ne._x=(xe-$)*6*p._x+(3*xe-4*$+1)*_._x+(-xe+$)*6*E._x+(3*xe-2*$)*A._x,ne._y=(xe-$)*6*p._y+(3*xe-4*$+1)*_._y+(-xe+$)*6*E._y+(3*xe-2*$)*A._y,ne._z=(xe-$)*6*p._z+(3*xe-4*$+1)*_._z+(-xe+$)*6*E._z+(3*xe-2*$)*A._z,ne._w=(xe-$)*6*p._w+(3*xe-4*$+1)*_._w+(-xe+$)*6*E._w+(3*xe-2*$)*A._w,ne._isDirty=!0,ne}static Normalize(p){const _=_s.Zero();return _s.NormalizeToRef(p,_),_}static NormalizeToRef(p,_){return p.normalizeToRef(_),_}}class Yt{static get Use64Bits(){return ha.MatrixUse64Bits}get m(){return this._m}markAsUpdated(){this.updateFlag=Yt._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(p,_=!1,E=!1,A=!0){this._isIdentity=p,this._isIdentity3x2=p||E,this._isIdentityDirty=this._isIdentity?!1:_,this._isIdentity3x2Dirty=this._isIdentity3x2?!1:A}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,ha.MatrixTrackPrecisionChange&&ha.MatrixTrackedMatrices.push(this),this._m=new ha.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const p=this._m;this._isIdentity=p[0]===1&&p[1]===0&&p[2]===0&&p[3]===0&&p[4]===0&&p[5]===1&&p[6]===0&&p[7]===0&&p[8]===0&&p[9]===0&&p[10]===1&&p[11]===0&&p[12]===0&&p[13]===0&&p[14]===0&&p[15]===1}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,this._m[0]!==1||this._m[5]!==1||this._m[15]!==1?this._isIdentity3x2=!1:this._m[1]!==0||this._m[2]!==0||this._m[3]!==0||this._m[4]!==0||this._m[6]!==0||this._m[7]!==0||this._m[8]!==0||this._m[9]!==0||this._m[10]!==0||this._m[11]!==0||this._m[12]!==0||this._m[13]!==0||this._m[14]!==0?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(this._isIdentity===!0)return 1;const p=this._m,_=p[0],E=p[1],A=p[2],$=p[3],ne=p[4],xe=p[5],ce=p[6],Te=p[7],Re=p[8],ke=p[9],We=p[10],Xe=p[11],xt=p[12],qe=p[13],ht=p[14],Nt=p[15],wt=We*Nt-ht*Xe,Qt=ke*Nt-qe*Xe,Ht=ke*ht-qe*We,Wt=Re*Nt-xt*Xe,zt=Re*ht-We*xt,xi=Re*qe-xt*ke,wi=+(xe*wt-ce*Qt+Te*Ht),vs=-(ne*wt-ce*Wt+Te*zt),cs=+(ne*Qt-xe*Wt+Te*xi),Mr=-(ne*Ht-xe*zt+ce*xi);return _*wi+E*vs+A*cs+$*Mr}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}
${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}
${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}
${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){return this._m}asArray(){return this._m}invert(){return this.invertToRef(this),this}reset(){return Yt.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(p){const _=new this.constructor;return this.addToRef(p,_),_}addToRef(p,_){const E=this._m,A=_._m,$=p.m;for(let ne=0;ne<16;ne++)A[ne]=E[ne]+$[ne];return _.markAsUpdated(),_}addToSelf(p){const _=this._m,E=p.m;for(let A=0;A<16;A++)_[A]+=E[A];return this.markAsUpdated(),this}invertToRef(p){if(this._isIdentity===!0)return Yt.IdentityToRef(p),p;const _=this._m,E=_[0],A=_[1],$=_[2],ne=_[3],xe=_[4],ce=_[5],Te=_[6],Re=_[7],ke=_[8],We=_[9],Xe=_[10],xt=_[11],qe=_[12],ht=_[13],Nt=_[14],wt=_[15],Qt=Xe*wt-Nt*xt,Ht=We*wt-ht*xt,Wt=We*Nt-ht*Xe,zt=ke*wt-qe*xt,xi=ke*Nt-Xe*qe,wi=ke*ht-qe*We,vs=+(ce*Qt-Te*Ht+Re*Wt),cs=-(xe*Qt-Te*zt+Re*xi),Mr=+(xe*Ht-ce*zt+Re*wi),xn=-(xe*Wt-ce*xi+Te*wi),qr=E*vs+A*cs+$*Mr+ne*xn;if(qr===0)return p.copyFrom(this),p;const Tn=1/qr,h0=Te*wt-Nt*Re,Ra=ce*wt-ht*Re,x0=ce*Nt-ht*Te,X0=xe*wt-qe*Re,K0=xe*Nt-qe*Te,qx=xe*ht-qe*ce,Ux=Te*xt-Xe*Re,k2=ce*xt-We*Re,Tc=ce*Xe-We*Te,e_=xe*xt-ke*Re,t_=xe*Xe-ke*Te,i_=xe*We-ke*ce,Wy=-(A*Qt-$*Ht+ne*Wt),Hy=+(E*Qt-$*zt+ne*xi),Xy=-(E*Ht-A*zt+ne*wi),Ky=+(E*Wt-A*xi+$*wi),Yy=+(A*h0-$*Ra+ne*x0),jy=-(E*h0-$*X0+ne*K0),Rh=+(E*Ra-A*X0+ne*qx),Mh=-(E*x0-A*K0+$*qx),wh=-(A*Ux-$*k2+ne*Tc),Lh=+(E*Ux-$*e_+ne*t_),hk=-(E*k2-A*e_+ne*i_),ck=+(E*Tc-A*t_+$*i_);return Yt.FromValuesToRef(vs*Tn,Wy*Tn,Yy*Tn,wh*Tn,cs*Tn,Hy*Tn,jy*Tn,Lh*Tn,Mr*Tn,Xy*Tn,Rh*Tn,hk*Tn,xn*Tn,Ky*Tn,Mh*Tn,ck*Tn,p),p}addAtIndex(p,_){return this._m[p]+=_,this.markAsUpdated(),this}multiplyAtIndex(p,_){return this._m[p]*=_,this.markAsUpdated(),this}setTranslationFromFloats(p,_,E){return this._m[12]=p,this._m[13]=_,this._m[14]=E,this.markAsUpdated(),this}addTranslationFromFloats(p,_,E){return this._m[12]+=p,this._m[13]+=_,this._m[14]+=E,this.markAsUpdated(),this}setTranslation(p){return this.setTranslationFromFloats(p._x,p._y,p._z)}getTranslation(){return new nt(this._m[12],this._m[13],this._m[14])}getTranslationToRef(p){return p.x=this._m[12],p.y=this._m[13],p.z=this._m[14],p}removeRotationAndScaling(){const p=this.m;return Yt.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,p[12],p[13],p[14],p[15],this),this._updateIdentityStatus(p[12]===0&&p[13]===0&&p[14]===0&&p[15]===1),this}multiply(p){const _=new this.constructor;return this.multiplyToRef(p,_),_}copyFrom(p){p.copyToArray(this._m);const _=p;return this.updateFlag=_.updateFlag,this._updateIdentityStatus(_._isIdentity,_._isIdentityDirty,_._isIdentity3x2,_._isIdentity3x2Dirty),this}copyToArray(p,_=0){const E=this._m;return p[_]=E[0],p[_+1]=E[1],p[_+2]=E[2],p[_+3]=E[3],p[_+4]=E[4],p[_+5]=E[5],p[_+6]=E[6],p[_+7]=E[7],p[_+8]=E[8],p[_+9]=E[9],p[_+10]=E[10],p[_+11]=E[11],p[_+12]=E[12],p[_+13]=E[13],p[_+14]=E[14],p[_+15]=E[15],this}multiplyToRef(p,_){return this._isIdentity?(_.copyFrom(p),_):p._isIdentity?(_.copyFrom(this),_):(this.multiplyToArray(p,_._m,0),_.markAsUpdated(),_)}multiplyToArray(p,_,E){const A=this._m,$=p.m,ne=A[0],xe=A[1],ce=A[2],Te=A[3],Re=A[4],ke=A[5],We=A[6],Xe=A[7],xt=A[8],qe=A[9],ht=A[10],Nt=A[11],wt=A[12],Qt=A[13],Ht=A[14],Wt=A[15],zt=$[0],xi=$[1],wi=$[2],vs=$[3],cs=$[4],Mr=$[5],xn=$[6],qr=$[7],Tn=$[8],h0=$[9],Ra=$[10],x0=$[11],X0=$[12],K0=$[13],qx=$[14],Ux=$[15];return _[E]=ne*zt+xe*cs+ce*Tn+Te*X0,_[E+1]=ne*xi+xe*Mr+ce*h0+Te*K0,_[E+2]=ne*wi+xe*xn+ce*Ra+Te*qx,_[E+3]=ne*vs+xe*qr+ce*x0+Te*Ux,_[E+4]=Re*zt+ke*cs+We*Tn+Xe*X0,_[E+5]=Re*xi+ke*Mr+We*h0+Xe*K0,_[E+6]=Re*wi+ke*xn+We*Ra+Xe*qx,_[E+7]=Re*vs+ke*qr+We*x0+Xe*Ux,_[E+8]=xt*zt+qe*cs+ht*Tn+Nt*X0,_[E+9]=xt*xi+qe*Mr+ht*h0+Nt*K0,_[E+10]=xt*wi+qe*xn+ht*Ra+Nt*qx,_[E+11]=xt*vs+qe*qr+ht*x0+Nt*Ux,_[E+12]=wt*zt+Qt*cs+Ht*Tn+Wt*X0,_[E+13]=wt*xi+Qt*Mr+Ht*h0+Wt*K0,_[E+14]=wt*wi+Qt*xn+Ht*Ra+Wt*qx,_[E+15]=wt*vs+Qt*qr+Ht*x0+Wt*Ux,this}equals(p){const _=p;if(!_)return!1;if((this._isIdentity||_._isIdentity)&&!this._isIdentityDirty&&!_._isIdentityDirty)return this._isIdentity&&_._isIdentity;const E=this.m,A=_.m;return E[0]===A[0]&&E[1]===A[1]&&E[2]===A[2]&&E[3]===A[3]&&E[4]===A[4]&&E[5]===A[5]&&E[6]===A[6]&&E[7]===A[7]&&E[8]===A[8]&&E[9]===A[9]&&E[10]===A[10]&&E[11]===A[11]&&E[12]===A[12]&&E[13]===A[13]&&E[14]===A[14]&&E[15]===A[15]}clone(){const p=new this.constructor;return p.copyFrom(this),p}getClassName(){return"Matrix"}getHashCode(){let p=wn(this._m[0]);for(let _=1;_<16;_++)p=p*397^wn(this._m[_]);return p}decomposeToTransformNode(p){return p.rotationQuaternion=p.rotationQuaternion||new _s,this.decompose(p.scaling,p.rotationQuaternion,p.position)}decompose(p,_,E,A,$=!0){if(this._isIdentity)return E&&E.setAll(0),p&&p.setAll(1),_&&_.copyFromFloats(0,0,0,1),!0;const ne=this._m;if(E&&E.copyFromFloats(ne[12],ne[13],ne[14]),p=p||Us.Vector3[0],p.x=Math.sqrt(ne[0]*ne[0]+ne[1]*ne[1]+ne[2]*ne[2]),p.y=Math.sqrt(ne[4]*ne[4]+ne[5]*ne[5]+ne[6]*ne[6]),p.z=Math.sqrt(ne[8]*ne[8]+ne[9]*ne[9]+ne[10]*ne[10]),A){const xe=($?A.absoluteScaling.x:A.scaling.x)<0?-1:1,ce=($?A.absoluteScaling.y:A.scaling.y)<0?-1:1,Te=($?A.absoluteScaling.z:A.scaling.z)<0?-1:1;p.x*=xe,p.y*=ce,p.z*=Te}else this.determinant()<=0&&(p.y*=-1);if(p._x===0||p._y===0||p._z===0)return _&&_.copyFromFloats(0,0,0,1),!1;if(_){const xe=1/p._x,ce=1/p._y,Te=1/p._z;Yt.FromValuesToRef(ne[0]*xe,ne[1]*xe,ne[2]*xe,0,ne[4]*ce,ne[5]*ce,ne[6]*ce,0,ne[8]*Te,ne[9]*Te,ne[10]*Te,0,0,0,0,1,Us.Matrix[0]),_s.FromRotationMatrixToRef(Us.Matrix[0],_)}return!0}getRow(p){if(p<0||p>3)return null;const _=p*4;return new Gr(this._m[_+0],this._m[_+1],this._m[_+2],this._m[_+3])}getRowToRef(p,_){if(p>=0&&p<=3){const E=p*4;_.x=this._m[E+0],_.y=this._m[E+1],_.z=this._m[E+2],_.w=this._m[E+3]}return _}setRow(p,_){return this.setRowFromFloats(p,_.x,_.y,_.z,_.w)}transpose(){const p=new this.constructor;return Yt.TransposeToRef(this,p),p}transposeToRef(p){return Yt.TransposeToRef(this,p),p}setRowFromFloats(p,_,E,A,$){if(p<0||p>3)return this;const ne=p*4;return this._m[ne+0]=_,this._m[ne+1]=E,this._m[ne+2]=A,this._m[ne+3]=$,this.markAsUpdated(),this}scale(p){const _=new this.constructor;return this.scaleToRef(p,_),_}scaleToRef(p,_){for(let E=0;E<16;E++)_._m[E]=this._m[E]*p;return _.markAsUpdated(),_}scaleAndAddToRef(p,_){for(let E=0;E<16;E++)_._m[E]+=this._m[E]*p;return _.markAsUpdated(),_}toNormalMatrix(p){const _=Us.Matrix[0];this.invertToRef(_),_.transposeToRef(p);const E=p._m;return Yt.FromValuesToRef(E[0],E[1],E[2],0,E[4],E[5],E[6],0,E[8],E[9],E[10],0,0,0,0,1,p),p}getRotationMatrix(){const p=new this.constructor;return this.getRotationMatrixToRef(p),p}getRotationMatrixToRef(p){const _=Us.Vector3[0];if(!this.decompose(_))return Yt.IdentityToRef(p),p;const E=this._m,A=1/_._x,$=1/_._y,ne=1/_._z;return Yt.FromValuesToRef(E[0]*A,E[1]*A,E[2]*A,0,E[4]*$,E[5]*$,E[6]*$,0,E[8]*ne,E[9]*ne,E[10]*ne,0,0,0,0,1,p),p}toggleModelMatrixHandInPlace(){const p=this._m;return p[2]*=-1,p[6]*=-1,p[8]*=-1,p[9]*=-1,p[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const p=this._m;return p[8]*=-1,p[9]*=-1,p[10]*=-1,p[11]*=-1,this.markAsUpdated(),this}static FromArray(p,_=0){const E=new Yt;return Yt.FromArrayToRef(p,_,E),E}static FromArrayToRef(p,_,E){for(let A=0;A<16;A++)E._m[A]=p[A+_];return E.markAsUpdated(),E}static FromFloat32ArrayToRefScaled(p,_,E,A){for(let $=0;$<16;$++)A._m[$]=p[$+_]*E;return A.markAsUpdated(),A}static get IdentityReadOnly(){return Yt._IdentityReadOnly}static FromValuesToRef(p,_,E,A,$,ne,xe,ce,Te,Re,ke,We,Xe,xt,qe,ht,Nt){const wt=Nt._m;wt[0]=p,wt[1]=_,wt[2]=E,wt[3]=A,wt[4]=$,wt[5]=ne,wt[6]=xe,wt[7]=ce,wt[8]=Te,wt[9]=Re,wt[10]=ke,wt[11]=We,wt[12]=Xe,wt[13]=xt,wt[14]=qe,wt[15]=ht,Nt.markAsUpdated()}static FromValues(p,_,E,A,$,ne,xe,ce,Te,Re,ke,We,Xe,xt,qe,ht){const Nt=new Yt,wt=Nt._m;return wt[0]=p,wt[1]=_,wt[2]=E,wt[3]=A,wt[4]=$,wt[5]=ne,wt[6]=xe,wt[7]=ce,wt[8]=Te,wt[9]=Re,wt[10]=ke,wt[11]=We,wt[12]=Xe,wt[13]=xt,wt[14]=qe,wt[15]=ht,Nt.markAsUpdated(),Nt}static Compose(p,_,E){const A=new Yt;return Yt.ComposeToRef(p,_,E,A),A}static ComposeToRef(p,_,E,A){const $=A._m,ne=_._x,xe=_._y,ce=_._z,Te=_._w,Re=ne+ne,ke=xe+xe,We=ce+ce,Xe=ne*Re,xt=ne*ke,qe=ne*We,ht=xe*ke,Nt=xe*We,wt=ce*We,Qt=Te*Re,Ht=Te*ke,Wt=Te*We,zt=p._x,xi=p._y,wi=p._z;return $[0]=(1-(ht+wt))*zt,$[1]=(xt+Wt)*zt,$[2]=(qe-Ht)*zt,$[3]=0,$[4]=(xt-Wt)*xi,$[5]=(1-(Xe+wt))*xi,$[6]=(Nt+Qt)*xi,$[7]=0,$[8]=(qe+Ht)*wi,$[9]=(Nt-Qt)*wi,$[10]=(1-(Xe+ht))*wi,$[11]=0,$[12]=E._x,$[13]=E._y,$[14]=E._z,$[15]=1,A.markAsUpdated(),A}static Identity(){const p=Yt.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return p._updateIdentityStatus(!0),p}static IdentityToRef(p){return Yt.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,p),p._updateIdentityStatus(!0),p}static Zero(){const p=Yt.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return p._updateIdentityStatus(!1),p}static RotationX(p){const _=new Yt;return Yt.RotationXToRef(p,_),_}static Invert(p){const _=new p.constructor;return p.invertToRef(_),_}static RotationXToRef(p,_){const E=Math.sin(p),A=Math.cos(p);return Yt.FromValuesToRef(1,0,0,0,0,A,E,0,0,-E,A,0,0,0,0,1,_),_._updateIdentityStatus(A===1&&E===0),_}static RotationY(p){const _=new Yt;return Yt.RotationYToRef(p,_),_}static RotationYToRef(p,_){const E=Math.sin(p),A=Math.cos(p);return Yt.FromValuesToRef(A,0,-E,0,0,1,0,0,E,0,A,0,0,0,0,1,_),_._updateIdentityStatus(A===1&&E===0),_}static RotationZ(p){const _=new Yt;return Yt.RotationZToRef(p,_),_}static RotationZToRef(p,_){const E=Math.sin(p),A=Math.cos(p);return Yt.FromValuesToRef(A,E,0,0,-E,A,0,0,0,0,1,0,0,0,0,1,_),_._updateIdentityStatus(A===1&&E===0),_}static RotationAxis(p,_){const E=new Yt;return Yt.RotationAxisToRef(p,_,E),E}static RotationAxisToRef(p,_,E){const A=Math.sin(-_),$=Math.cos(-_),ne=1-$;p.normalize();const xe=E._m;return xe[0]=p._x*p._x*ne+$,xe[1]=p._x*p._y*ne-p._z*A,xe[2]=p._x*p._z*ne+p._y*A,xe[3]=0,xe[4]=p._y*p._x*ne+p._z*A,xe[5]=p._y*p._y*ne+$,xe[6]=p._y*p._z*ne-p._x*A,xe[7]=0,xe[8]=p._z*p._x*ne-p._y*A,xe[9]=p._z*p._y*ne+p._x*A,xe[10]=p._z*p._z*ne+$,xe[11]=0,xe[12]=0,xe[13]=0,xe[14]=0,xe[15]=1,E.markAsUpdated(),E}static RotationAlignToRef(p,_,E,A=!1){const $=nt.Dot(_,p),ne=E._m;if($<-1+as)ne[0]=-1,ne[1]=0,ne[2]=0,ne[3]=0,ne[4]=0,ne[5]=A?1:-1,ne[6]=0,ne[7]=0,ne[8]=0,ne[9]=0,ne[10]=A?-1:1,ne[11]=0;else{const xe=nt.Cross(_,p),ce=1/(1+$);ne[0]=xe._x*xe._x*ce+$,ne[1]=xe._y*xe._x*ce-xe._z,ne[2]=xe._z*xe._x*ce+xe._y,ne[3]=0,ne[4]=xe._x*xe._y*ce+xe._z,ne[5]=xe._y*xe._y*ce+$,ne[6]=xe._z*xe._y*ce-xe._x,ne[7]=0,ne[8]=xe._x*xe._z*ce-xe._y,ne[9]=xe._y*xe._z*ce+xe._x,ne[10]=xe._z*xe._z*ce+$,ne[11]=0}return ne[12]=0,ne[13]=0,ne[14]=0,ne[15]=1,E.markAsUpdated(),E}static RotationYawPitchRoll(p,_,E){const A=new Yt;return Yt.RotationYawPitchRollToRef(p,_,E,A),A}static RotationYawPitchRollToRef(p,_,E,A){return _s.RotationYawPitchRollToRef(p,_,E,Us.Quaternion[0]),Us.Quaternion[0].toRotationMatrix(A),A}static Scaling(p,_,E){const A=new Yt;return Yt.ScalingToRef(p,_,E,A),A}static ScalingToRef(p,_,E,A){return Yt.FromValuesToRef(p,0,0,0,0,_,0,0,0,0,E,0,0,0,0,1,A),A._updateIdentityStatus(p===1&&_===1&&E===1),A}static Translation(p,_,E){const A=new Yt;return Yt.TranslationToRef(p,_,E,A),A}static TranslationToRef(p,_,E,A){return Yt.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,p,_,E,1,A),A._updateIdentityStatus(p===0&&_===0&&E===0),A}static Lerp(p,_,E){const A=new p.constructor;return Yt.LerpToRef(p,_,E,A),A}static LerpToRef(p,_,E,A){const $=A._m,ne=p.m,xe=_.m;for(let ce=0;ce<16;ce++)$[ce]=ne[ce]*(1-E)+xe[ce]*E;return A.markAsUpdated(),A}static DecomposeLerp(p,_,E){const A=new p.constructor;return Yt.DecomposeLerpToRef(p,_,E,A),A}static DecomposeLerpToRef(p,_,E,A){const $=Us.Vector3[0],ne=Us.Quaternion[0],xe=Us.Vector3[1];p.decompose($,ne,xe);const ce=Us.Vector3[2],Te=Us.Quaternion[1],Re=Us.Vector3[3];_.decompose(ce,Te,Re);const ke=Us.Vector3[4];nt.LerpToRef($,ce,E,ke);const We=Us.Quaternion[2];_s.SlerpToRef(ne,Te,E,We);const Xe=Us.Vector3[5];return nt.LerpToRef(xe,Re,E,Xe),Yt.ComposeToRef(ke,We,Xe,A),A}static LookAtLH(p,_,E){const A=new Yt;return Yt.LookAtLHToRef(p,_,E,A),A}static LookAtLHToRef(p,_,E,A){const $=Us.Vector3[0],ne=Us.Vector3[1],xe=Us.Vector3[2];_.subtractToRef(p,xe),xe.normalize(),nt.CrossToRef(E,xe,$);const ce=$.lengthSquared();ce===0?$.x=1:$.normalizeFromLength(Math.sqrt(ce)),nt.CrossToRef(xe,$,ne),ne.normalize();const Te=-nt.Dot($,p),Re=-nt.Dot(ne,p),ke=-nt.Dot(xe,p);return Yt.FromValuesToRef($._x,ne._x,xe._x,0,$._y,ne._y,xe._y,0,$._z,ne._z,xe._z,0,Te,Re,ke,1,A),A}static LookAtRH(p,_,E){const A=new Yt;return Yt.LookAtRHToRef(p,_,E,A),A}static LookAtRHToRef(p,_,E,A){const $=Us.Vector3[0],ne=Us.Vector3[1],xe=Us.Vector3[2];p.subtractToRef(_,xe),xe.normalize(),nt.CrossToRef(E,xe,$);const ce=$.lengthSquared();ce===0?$.x=1:$.normalizeFromLength(Math.sqrt(ce)),nt.CrossToRef(xe,$,ne),ne.normalize();const Te=-nt.Dot($,p),Re=-nt.Dot(ne,p),ke=-nt.Dot(xe,p);return Yt.FromValuesToRef($._x,ne._x,xe._x,0,$._y,ne._y,xe._y,0,$._z,ne._z,xe._z,0,Te,Re,ke,1,A),A}static LookDirectionLH(p,_){const E=new Yt;return Yt.LookDirectionLHToRef(p,_,E),E}static LookDirectionLHToRef(p,_,E){const A=Us.Vector3[0];A.copyFrom(p),A.scaleInPlace(-1);const $=Us.Vector3[1];return nt.CrossToRef(_,A,$),Yt.FromValuesToRef($._x,$._y,$._z,0,_._x,_._y,_._z,0,A._x,A._y,A._z,0,0,0,0,1,E),E}static LookDirectionRH(p,_){const E=new Yt;return Yt.LookDirectionRHToRef(p,_,E),E}static LookDirectionRHToRef(p,_,E){const A=Us.Vector3[2];return nt.CrossToRef(_,p,A),Yt.FromValuesToRef(A._x,A._y,A._z,0,_._x,_._y,_._z,0,p._x,p._y,p._z,0,0,0,0,1,E),E}static OrthoLH(p,_,E,A,$){const ne=new Yt;return Yt.OrthoLHToRef(p,_,E,A,ne,$),ne}static OrthoLHToRef(p,_,E,A,$,ne){const xe=E,ce=A,Te=2/p,Re=2/_,ke=2/(ce-xe),We=-(ce+xe)/(ce-xe);return Yt.FromValuesToRef(Te,0,0,0,0,Re,0,0,0,0,ke,0,0,0,We,1,$),ne&&$.multiplyToRef(Rx,$),$._updateIdentityStatus(Te===1&&Re===1&&ke===1&&We===0),$}static OrthoOffCenterLH(p,_,E,A,$,ne,xe){const ce=new Yt;return Yt.OrthoOffCenterLHToRef(p,_,E,A,$,ne,ce,xe),ce}static OrthoOffCenterLHToRef(p,_,E,A,$,ne,xe,ce){const Te=$,Re=ne,ke=2/(_-p),We=2/(A-E),Xe=2/(Re-Te),xt=-(Re+Te)/(Re-Te),qe=(p+_)/(p-_),ht=(A+E)/(E-A);return Yt.FromValuesToRef(ke,0,0,0,0,We,0,0,0,0,Xe,0,qe,ht,xt,1,xe),ce&&xe.multiplyToRef(Rx,xe),xe.markAsUpdated(),xe}static ObliqueOffCenterLHToRef(p,_,E,A,$,ne,xe,ce,Te,Re,ke){const We=-xe*Math.cos(ce),Xe=-xe*Math.sin(ce);return Yt.TranslationToRef(0,0,-Te,Us.Matrix[1]),Yt.FromValuesToRef(1,0,0,0,0,1,0,0,We,Xe,1,0,0,0,0,1,Us.Matrix[0]),Us.Matrix[1].multiplyToRef(Us.Matrix[0],Us.Matrix[0]),Yt.TranslationToRef(0,0,Te,Us.Matrix[1]),Us.Matrix[0].multiplyToRef(Us.Matrix[1],Us.Matrix[0]),Yt.OrthoOffCenterLHToRef(p,_,E,A,$,ne,Re,ke),Us.Matrix[0].multiplyToRef(Re,Re),Re}static OrthoOffCenterRH(p,_,E,A,$,ne,xe){const ce=new Yt;return Yt.OrthoOffCenterRHToRef(p,_,E,A,$,ne,ce,xe),ce}static OrthoOffCenterRHToRef(p,_,E,A,$,ne,xe,ce){return Yt.OrthoOffCenterLHToRef(p,_,E,A,$,ne,xe,ce),xe._m[10]*=-1,xe}static ObliqueOffCenterRHToRef(p,_,E,A,$,ne,xe,ce,Te,Re,ke){const We=xe*Math.cos(ce),Xe=xe*Math.sin(ce);return Yt.TranslationToRef(0,0,Te,Us.Matrix[1]),Yt.FromValuesToRef(1,0,0,0,0,1,0,0,We,Xe,1,0,0,0,0,1,Us.Matrix[0]),Us.Matrix[1].multiplyToRef(Us.Matrix[0],Us.Matrix[0]),Yt.TranslationToRef(0,0,-Te,Us.Matrix[1]),Us.Matrix[0].multiplyToRef(Us.Matrix[1],Us.Matrix[0]),Yt.OrthoOffCenterRHToRef(p,_,E,A,$,ne,Re,ke),Us.Matrix[0].multiplyToRef(Re,Re),Re}static PerspectiveLH(p,_,E,A,$,ne=0){const xe=new Yt,ce=E,Te=A,Re=2*ce/p,ke=2*ce/_,We=(Te+ce)/(Te-ce),Xe=-2*Te*ce/(Te-ce),xt=Math.tan(ne);return Yt.FromValuesToRef(Re,0,0,0,0,ke,0,xt,0,0,We,1,0,0,Xe,0,xe),$&&xe.multiplyToRef(Rx,xe),xe._updateIdentityStatus(!1),xe}static PerspectiveFovLH(p,_,E,A,$,ne=0,xe=!1){const ce=new Yt;return Yt.PerspectiveFovLHToRef(p,_,E,A,ce,!0,$,ne,xe),ce}static PerspectiveFovLHToRef(p,_,E,A,$,ne=!0,xe,ce=0,Te=!1){const Re=E,ke=A,We=1/Math.tan(p*.5),Xe=ne?We/_:We,xt=ne?We:We*_,qe=Te&&Re===0?-1:ke!==0?(ke+Re)/(ke-Re):1,ht=Te&&Re===0?2*ke:ke!==0?-2*ke*Re/(ke-Re):-2*Re,Nt=Math.tan(ce);return Yt.FromValuesToRef(Xe,0,0,0,0,xt,0,Nt,0,0,qe,1,0,0,ht,0,$),xe&&$.multiplyToRef(Rx,$),$._updateIdentityStatus(!1),$}static PerspectiveFovReverseLHToRef(p,_,E,A,$,ne=!0,xe,ce=0){const Te=1/Math.tan(p*.5),Re=ne?Te/_:Te,ke=ne?Te:Te*_,We=Math.tan(ce);return Yt.FromValuesToRef(Re,0,0,0,0,ke,0,We,0,0,-E,1,0,0,1,0,$),xe&&$.multiplyToRef(Rx,$),$._updateIdentityStatus(!1),$}static PerspectiveFovRH(p,_,E,A,$,ne=0,xe=!1){const ce=new Yt;return Yt.PerspectiveFovRHToRef(p,_,E,A,ce,!0,$,ne,xe),ce}static PerspectiveFovRHToRef(p,_,E,A,$,ne=!0,xe,ce=0,Te=!1){const Re=E,ke=A,We=1/Math.tan(p*.5),Xe=ne?We/_:We,xt=ne?We:We*_,qe=Te&&Re===0?1:ke!==0?-(ke+Re)/(ke-Re):-1,ht=Te&&Re===0?2*ke:ke!==0?-2*ke*Re/(ke-Re):-2*Re,Nt=Math.tan(ce);return Yt.FromValuesToRef(Xe,0,0,0,0,xt,0,Nt,0,0,qe,-1,0,0,ht,0,$),xe&&$.multiplyToRef(Rx,$),$._updateIdentityStatus(!1),$}static PerspectiveFovReverseRHToRef(p,_,E,A,$,ne=!0,xe,ce=0){const Te=1/Math.tan(p*.5),Re=ne?Te/_:Te,ke=ne?Te:Te*_,We=Math.tan(ce);return Yt.FromValuesToRef(Re,0,0,0,0,ke,0,We,0,0,-E,-1,0,0,-1,0,$),xe&&$.multiplyToRef(Rx,$),$._updateIdentityStatus(!1),$}static GetFinalMatrix(p,_,E,A,$,ne){const xe=p.width,ce=p.height,Te=p.x,Re=p.y,ke=Yt.FromValues(xe/2,0,0,0,0,-ce/2,0,0,0,0,ne-$,0,Te+xe/2,ce/2+Re,$,1),We=new _.constructor;return _.multiplyToRef(E,We),We.multiplyToRef(A,We),We.multiplyToRef(ke,We)}static GetAsMatrix2x2(p){const _=p.m,E=[_[0],_[1],_[4],_[5]];return ha.MatrixUse64Bits?E:new Float32Array(E)}static GetAsMatrix3x3(p){const _=p.m,E=[_[0],_[1],_[2],_[4],_[5],_[6],_[8],_[9],_[10]];return ha.MatrixUse64Bits?E:new Float32Array(E)}static Transpose(p){const _=new p.constructor;return Yt.TransposeToRef(p,_),_}static TransposeToRef(p,_){const E=p.m,A=E[0],$=E[4],ne=E[8],xe=E[12],ce=E[1],Te=E[5],Re=E[9],ke=E[13],We=E[2],Xe=E[6],xt=E[10],qe=E[14],ht=E[3],Nt=E[7],wt=E[11],Qt=E[15],Ht=_._m;return Ht[0]=A,Ht[1]=$,Ht[2]=ne,Ht[3]=xe,Ht[4]=ce,Ht[5]=Te,Ht[6]=Re,Ht[7]=ke,Ht[8]=We,Ht[9]=Xe,Ht[10]=xt,Ht[11]=qe,Ht[12]=ht,Ht[13]=Nt,Ht[14]=wt,Ht[15]=Qt,_.markAsUpdated(),_._updateIdentityStatus(p._isIdentity,p._isIdentityDirty),_}static Reflection(p){const _=new Yt;return Yt.ReflectionToRef(p,_),_}static ReflectionToRef(p,_){p.normalize();const E=p.normal.x,A=p.normal.y,$=p.normal.z,ne=-2*E,xe=-2*A,ce=-2*$;return Yt.FromValuesToRef(ne*E+1,xe*E,ce*E,0,ne*A,xe*A+1,ce*A,0,ne*$,xe*$,ce*$+1,0,ne*p.d,xe*p.d,ce*p.d,1,_),_}static FromXYZAxesToRef(p,_,E,A){return Yt.FromValuesToRef(p._x,p._y,p._z,0,_._x,_._y,_._z,0,E._x,E._y,E._z,0,0,0,0,1,A),A}static FromQuaternionToRef(p,_){const E=p._x*p._x,A=p._y*p._y,$=p._z*p._z,ne=p._x*p._y,xe=p._z*p._w,ce=p._z*p._x,Te=p._y*p._w,Re=p._y*p._z,ke=p._x*p._w;return _._m[0]=1-2*(A+$),_._m[1]=2*(ne+xe),_._m[2]=2*(ce-Te),_._m[3]=0,_._m[4]=2*(ne-xe),_._m[5]=1-2*($+E),_._m[6]=2*(Re+ke),_._m[7]=0,_._m[8]=2*(ce+Te),_._m[9]=2*(Re-ke),_._m[10]=1-2*(A+E),_._m[11]=0,_._m[12]=0,_._m[13]=0,_._m[14]=0,_._m[15]=1,_.markAsUpdated(),_}}Yt._UpdateFlagSeed=0,Yt._IdentityReadOnly=Yt.Identity();class Us{}Us.Vector3=Ms.BuildTuple(11,nt.Zero),Us.Matrix=Ms.BuildTuple(2,Yt.Identity),Us.Quaternion=Ms.BuildTuple(3,_s.Zero);class pi{}pi.Vector2=Ms.BuildTuple(3,xr.Zero),pi.Vector3=Ms.BuildTuple(13,nt.Zero),pi.Vector4=Ms.BuildTuple(3,Gr.Zero),pi.Quaternion=Ms.BuildTuple(2,_s.Zero),pi.Matrix=Ms.BuildTuple(8,Yt.Identity),zs("BABYLON.Vector2",xr),zs("BABYLON.Vector3",nt),zs("BABYLON.Vector4",Gr),zs("BABYLON.Matrix",Yt);const Rx=Yt.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1);class Mx{constructor(){this.rootNodes=[],this.cameras=[],this.lights=[],this.meshes=[],this.skeletons=[],this.particleSystems=[],this.animations=[],this.animationGroups=[],this.multiMaterials=[],this.materials=[],this.morphTargetManagers=[],this.geometries=[],this.transformNodes=[],this.actionManagers=[],this.textures=[],this._environmentTexture=null,this.postProcesses=[]}static AddParser(p,_){this._BabylonFileParsers[p]=_}static GetParser(p){return this._BabylonFileParsers[p]?this._BabylonFileParsers[p]:null}static AddIndividualParser(p,_){this._IndividualBabylonFileParsers[p]=_}static GetIndividualParser(p){return this._IndividualBabylonFileParsers[p]?this._IndividualBabylonFileParsers[p]:null}static Parse(p,_,E,A){for(const $ in this._BabylonFileParsers)Object.prototype.hasOwnProperty.call(this._BabylonFileParsers,$)&&this._BabylonFileParsers[$](p,_,E,A)}get environmentTexture(){return this._environmentTexture}set environmentTexture(p){this._environmentTexture=p}getNodes(){let p=[];return p=p.concat(this.meshes),p=p.concat(this.lights),p=p.concat(this.cameras),p=p.concat(this.transformNodes),this.skeletons.forEach(_=>p=p.concat(_.bones)),p}}Mx._BabylonFileParsers={},Mx._IndividualBabylonFileParsers={};var rh=function(_e,p){return rh=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_,E){_.__proto__=E}||function(_,E){for(var A in E)Object.prototype.hasOwnProperty.call(E,A)&&(_[A]=E[A])},rh(_e,p)};function Tu(_e,p){if(typeof p!="function"&&p!==null)throw new TypeError("Class extends value "+String(p)+" is not a constructor or null");rh(_e,p);function _(){this.constructor=_e}_e.prototype=p===null?Object.create(p):(_.prototype=p.prototype,new _)}var $p=function(){return $p=Object.assign||function(p){for(var _,E=1,A=arguments.length;E<A;E++){_=arguments[E];for(var $ in _)Object.prototype.hasOwnProperty.call(_,$)&&(p[$]=_[$])}return p},$p.apply(this,arguments)};function qy(_e,p){var _={};for(var E in _e)Object.prototype.hasOwnProperty.call(_e,E)&&p.indexOf(E)<0&&(_[E]=_e[E]);if(_e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var A=0,E=Object.getOwnPropertySymbols(_e);A<E.length;A++)p.indexOf(E[A])<0&&Object.prototype.propertyIsEnumerable.call(_e,E[A])&&(_[E[A]]=_e[E[A]]);return _}function Mt(_e,p,_,E){var A=arguments.length,$=A<3?p:E===null?E=Object.getOwnPropertyDescriptor(p,_):E,ne;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")$=Reflect.decorate(_e,p,_,E);else for(var xe=_e.length-1;xe>=0;xe--)(ne=_e[xe])&&($=(A<3?ne($):A>3?ne(p,_,$):ne(p,_))||$);return A>3&&$&&Object.defineProperty(p,_,$),$}function $y(_e,p){return function(_,E){p(_,E,_e)}}function rb(_e,p){if(typeof Reflect=="object"&&typeof Reflect.metadata=="function")return Reflect.metadata(_e,p)}function nb(_e,p,_,E){function A($){return $ instanceof _?$:new _(function(ne){ne($)})}return new(_||(_=Promise))(function($,ne){function xe(Re){try{Te(E.next(Re))}catch(ke){ne(ke)}}function ce(Re){try{Te(E.throw(Re))}catch(ke){ne(ke)}}function Te(Re){Re.done?$(Re.value):A(Re.value).then(xe,ce)}Te((E=E.apply(_e,p||[])).next())})}function ab(_e,p){var _={label:0,sent:function(){if($[0]&1)throw $[1];return $[1]},trys:[],ops:[]},E,A,$,ne;return ne={next:xe(0),throw:xe(1),return:xe(2)},typeof Symbol=="function"&&(ne[Symbol.iterator]=function(){return this}),ne;function xe(Te){return function(Re){return ce([Te,Re])}}function ce(Te){if(E)throw new TypeError("Generator is already executing.");for(;_;)try{if(E=1,A&&($=Te[0]&2?A.return:Te[0]?A.throw||(($=A.return)&&$.call(A),0):A.next)&&!($=$.call(A,Te[1])).done)return $;switch(A=0,$&&(Te=[Te[0]&2,$.value]),Te[0]){case 0:case 1:$=Te;break;case 4:return _.label++,{value:Te[1],done:!1};case 5:_.label++,A=Te[1],Te=[0];continue;case 7:Te=_.ops.pop(),_.trys.pop();continue;default:if($=_.trys,!($=$.length>0&&$[$.length-1])&&(Te[0]===6||Te[0]===2)){_=0;continue}if(Te[0]===3&&(!$||Te[1]>$[0]&&Te[1]<$[3])){_.label=Te[1];break}if(Te[0]===6&&_.label<$[1]){_.label=$[1],$=Te;break}if($&&_.label<$[2]){_.label=$[2],_.ops.push(Te);break}$[2]&&_.ops.pop(),_.trys.pop();continue}Te=p.call(_e,_)}catch(Re){Te=[6,Re],A=0}finally{E=$=0}if(Te[0]&5)throw Te[1];return{value:Te[0]?Te[1]:void 0,done:!0}}}var qo=Object.create?function(_e,p,_,E){E===void 0&&(E=_);var A=Object.getOwnPropertyDescriptor(p,_);(!A||("get"in A?!p.__esModule:A.writable||A.configurable))&&(A={enumerable:!0,get:function(){return p[_]}}),Object.defineProperty(_e,E,A)}:function(_e,p,_,E){E===void 0&&(E=_),_e[E]=p[_]};function Yc(_e,p){for(var _ in _e)_!=="default"&&!Object.prototype.hasOwnProperty.call(p,_)&&qo(p,_e,_)}function Wx(_e){var p=typeof Symbol=="function"&&Symbol.iterator,_=p&&_e[p],E=0;if(_)return _.call(_e);if(_e&&typeof _e.length=="number")return{next:function(){return _e&&E>=_e.length&&(_e=void 0),{value:_e&&_e[E++],done:!_e}}};throw new TypeError(p?"Object is not iterable.":"Symbol.iterator is not defined.")}function Ym(_e,p){var _=typeof Symbol=="function"&&_e[Symbol.iterator];if(!_)return _e;var E=_.call(_e),A,$=[],ne;try{for(;(p===void 0||p-- >0)&&!(A=E.next()).done;)$.push(A.value)}catch(xe){ne={error:xe}}finally{try{A&&!A.done&&(_=E.return)&&_.call(E)}finally{if(ne)throw ne.error}}return $}function s_(){for(var _e=[],p=0;p<arguments.length;p++)_e=_e.concat(Ym(arguments[p]));return _e}function rm(){for(var _e=0,p=0,_=arguments.length;p<_;p++)_e+=arguments[p].length;for(var E=Array(_e),A=0,p=0;p<_;p++)for(var $=arguments[p],ne=0,xe=$.length;ne<xe;ne++,A++)E[A]=$[ne];return E}function r_(_e,p,_){if(_||arguments.length===2)for(var E=0,A=p.length,$;E<A;E++)($||!(E in p))&&($||($=Array.prototype.slice.call(p,0,E)),$[E]=p[E]);return _e.concat($||Array.prototype.slice.call(p))}function Tt(_e){return this instanceof Tt?(this.v=_e,this):new Tt(_e)}function pt(_e,p,_){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var E=_.apply(_e,p||[]),A,$=[];return A={},ne("next"),ne("throw"),ne("return"),A[Symbol.asyncIterator]=function(){return this},A;function ne(We){E[We]&&(A[We]=function(Xe){return new Promise(function(xt,qe){$.push([We,Xe,xt,qe])>1||xe(We,Xe)})})}function xe(We,Xe){try{ce(E[We](Xe))}catch(xt){ke($[0][3],xt)}}function ce(We){We.value instanceof Tt?Promise.resolve(We.value.v).then(Te,Re):ke($[0][2],We)}function Te(We){xe("next",We)}function Re(We){xe("throw",We)}function ke(We,Xe){We(Xe),$.shift(),$.length&&xe($[0][0],$[0][1])}}function Xt(_e){var p,_;return p={},E("next"),E("throw",function(A){throw A}),E("return"),p[Symbol.iterator]=function(){return this},p;function E(A,$){p[A]=_e[A]?function(ne){return(_=!_)?{value:Tt(_e[A](ne)),done:A==="return"}:$?$(ne):ne}:$}}function Ti(_e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var p=_e[Symbol.asyncIterator],_;return p?p.call(_e):(_e=typeof Wx=="function"?Wx(_e):_e[Symbol.iterator](),_={},E("next"),E("throw"),E("return"),_[Symbol.asyncIterator]=function(){return this},_);function E($){_[$]=_e[$]&&function(ne){return new Promise(function(xe,ce){ne=_e[$](ne),A(xe,ce,ne.done,ne.value)})}}function A($,ne,xe,ce){Promise.resolve(ce).then(function(Te){$({value:Te,done:xe})},ne)}}function ji(_e,p){return Object.defineProperty?Object.defineProperty(_e,"raw",{value:p}):_e.raw=p,_e}var rs=Object.create?function(_e,p){Object.defineProperty(_e,"default",{enumerable:!0,value:p})}:function(_e,p){_e.default=p};function Ts(_e){if(_e&&_e.__esModule)return _e;var p={};if(_e!=null)for(var _ in _e)_!=="default"&&Object.prototype.hasOwnProperty.call(_e,_)&&qo(p,_e,_);return rs(p,_e),p}function ls(_e){return _e&&_e.__esModule?_e:{default:_e}}function lr(_e,p,_,E){if(_==="a"&&!E)throw new TypeError("Private accessor was defined without a getter");if(typeof p=="function"?_e!==p||!E:!p.has(_e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return _==="m"?E:_==="a"?E.call(_e):E?E.value:p.get(_e)}function Rr(_e,p,_,E,A){if(E==="m")throw new TypeError("Private method is not writable");if(E==="a"&&!A)throw new TypeError("Private accessor was defined without a setter");if(typeof p=="function"?_e!==p||!A:!p.has(_e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return E==="a"?A.call(_e,_):A?A.value=_:p.set(_e,_),_}function hr(_e,p){if(p===null||typeof p!="object"&&typeof p!="function")throw new TypeError("Cannot use 'in' operator on non-object");return typeof _e=="function"?p===_e:_e.has(p)}function _n(_e){return Math.pow(_e,zi)}function un(_e){return _e<=.04045?.0773993808*_e:Math.pow(.947867299*(_e+.055),2.4)}function Un(_e){return Math.pow(_e,Li)}function ca(_e){return _e<=.0031308?12.92*_e:1.055*Math.pow(_e,.41666)-.055}class ws{constructor(p=0,_=0,E=0){this.r=p,this.g=_,this.b=E}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Color3"}getHashCode(){let p=this.r*255|0;return p=p*397^(this.g*255|0),p=p*397^(this.b*255|0),p}toArray(p,_=0){return p[_]=this.r,p[_+1]=this.g,p[_+2]=this.b,this}fromArray(p,_=0){return ws.FromArrayToRef(p,_,this),this}toColor4(p=1){return new vr(this.r,this.g,this.b,p)}asArray(){return[this.r,this.g,this.b]}toLuminance(){return this.r*.3+this.g*.59+this.b*.11}multiply(p){return new ws(this.r*p.r,this.g*p.g,this.b*p.b)}multiplyToRef(p,_){return _.r=this.r*p.r,_.g=this.g*p.g,_.b=this.b*p.b,this}equals(p){return p&&this.r===p.r&&this.g===p.g&&this.b===p.b}equalsFloats(p,_,E){return this.r===p&&this.g===_&&this.b===E}scale(p){return new ws(this.r*p,this.g*p,this.b*p)}scaleInPlace(p){return this.r*=p,this.g*=p,this.b*=p,this}scaleToRef(p,_){return _.r=this.r*p,_.g=this.g*p,_.b=this.b*p,this}scaleAndAddToRef(p,_){return _.r+=this.r*p,_.g+=this.g*p,_.b+=this.b*p,this}clampToRef(p=0,_=1,E){return E.r=ri.Clamp(this.r,p,_),E.g=ri.Clamp(this.g,p,_),E.b=ri.Clamp(this.b,p,_),this}add(p){return new ws(this.r+p.r,this.g+p.g,this.b+p.b)}addToRef(p,_){return _.r=this.r+p.r,_.g=this.g+p.g,_.b=this.b+p.b,this}subtract(p){return new ws(this.r-p.r,this.g-p.g,this.b-p.b)}subtractToRef(p,_){return _.r=this.r-p.r,_.g=this.g-p.g,_.b=this.b-p.b,this}clone(){return new ws(this.r,this.g,this.b)}copyFrom(p){return this.r=p.r,this.g=p.g,this.b=p.b,this}copyFromFloats(p,_,E){return this.r=p,this.g=_,this.b=E,this}set(p,_,E){return this.copyFromFloats(p,_,E)}toHexString(){const p=Math.round(this.r*255),_=Math.round(this.g*255),E=Math.round(this.b*255);return"#"+ri.ToHex(p)+ri.ToHex(_)+ri.ToHex(E)}toHSV(){const p=new ws;return this.toHSVToRef(p),p}toHSVToRef(p){const _=this.r,E=this.g,A=this.b,$=Math.max(_,E,A),ne=Math.min(_,E,A);let xe=0,ce=0;const Te=$,Re=$-ne;$!==0&&(ce=Re/$),$!=ne&&($==_?(xe=(E-A)/Re,E<A&&(xe+=6)):$==E?xe=(A-_)/Re+2:$==A&&(xe=(_-E)/Re+4),xe*=60),p.r=xe,p.g=ce,p.b=Te}toLinearSpace(p=!1){const _=new ws;return this.toLinearSpaceToRef(_,p),_}toLinearSpaceToRef(p,_=!1){return _?(p.r=un(this.r),p.g=un(this.g),p.b=un(this.b)):(p.r=_n(this.r),p.g=_n(this.g),p.b=_n(this.b)),this}toGammaSpace(p=!1){const _=new ws;return this.toGammaSpaceToRef(_,p),_}toGammaSpaceToRef(p,_=!1){return _?(p.r=ca(this.r),p.g=ca(this.g),p.b=ca(this.b)):(p.r=Un(this.r),p.g=Un(this.g),p.b=Un(this.b)),this}static HSVtoRGBToRef(p,_,E,A){const $=E*_,ne=p/60,xe=$*(1-Math.abs(ne%2-1));let ce=0,Te=0,Re=0;ne>=0&&ne<=1?(ce=$,Te=xe):ne>=1&&ne<=2?(ce=xe,Te=$):ne>=2&&ne<=3?(Te=$,Re=xe):ne>=3&&ne<=4?(Te=xe,Re=$):ne>=4&&ne<=5?(ce=xe,Re=$):ne>=5&&ne<=6&&(ce=$,Re=xe);const ke=E-$;A.set(ce+ke,Te+ke,Re+ke)}static FromHSV(p,_,E){const A=new ws(0,0,0);return ws.HSVtoRGBToRef(p,_,E,A),A}static FromHexString(p){if(p.substring(0,1)!=="#"||p.length!==7)return new ws(0,0,0);const _=parseInt(p.substring(1,3),16),E=parseInt(p.substring(3,5),16),A=parseInt(p.substring(5,7),16);return ws.FromInts(_,E,A)}static FromArray(p,_=0){return new ws(p[_],p[_+1],p[_+2])}static FromArrayToRef(p,_=0,E){E.r=p[_],E.g=p[_+1],E.b=p[_+2]}static FromInts(p,_,E){return new ws(p/255,_/255,E/255)}static Lerp(p,_,E){const A=new ws(0,0,0);return ws.LerpToRef(p,_,E,A),A}static LerpToRef(p,_,E,A){A.r=p.r+(_.r-p.r)*E,A.g=p.g+(_.g-p.g)*E,A.b=p.b+(_.b-p.b)*E}static Hermite(p,_,E,A,$){const ne=$*$,xe=$*ne,ce=2*xe-3*ne+1,Te=-2*xe+3*ne,Re=xe-2*ne+$,ke=xe-ne,We=p.r*ce+E.r*Te+_.r*Re+A.r*ke,Xe=p.g*ce+E.g*Te+_.g*Re+A.g*ke,xt=p.b*ce+E.b*Te+_.b*Re+A.b*ke;return new ws(We,Xe,xt)}static Hermite1stDerivative(p,_,E,A,$){const ne=ws.Black();return this.Hermite1stDerivativeToRef(p,_,E,A,$,ne),ne}static Hermite1stDerivativeToRef(p,_,E,A,$,ne){const xe=$*$;ne.r=(xe-$)*6*p.r+(3*xe-4*$+1)*_.r+(-xe+$)*6*E.r+(3*xe-2*$)*A.r,ne.g=(xe-$)*6*p.g+(3*xe-4*$+1)*_.g+(-xe+$)*6*E.g+(3*xe-2*$)*A.g,ne.b=(xe-$)*6*p.b+(3*xe-4*$+1)*_.b+(-xe+$)*6*E.b+(3*xe-2*$)*A.b}static Red(){return new ws(1,0,0)}static Green(){return new ws(0,1,0)}static Blue(){return new ws(0,0,1)}static Black(){return new ws(0,0,0)}static get BlackReadOnly(){return ws._BlackReadOnly}static White(){return new ws(1,1,1)}static Purple(){return new ws(.5,0,.5)}static Magenta(){return new ws(1,0,1)}static Yellow(){return new ws(1,1,0)}static Gray(){return new ws(.5,.5,.5)}static Teal(){return new ws(0,1,1)}static Random(){return new ws(Math.random(),Math.random(),Math.random())}}ws._BlackReadOnly=ws.Black();class vr{constructor(p=0,_=0,E=0,A=1){this.r=p,this.g=_,this.b=E,this.a=A}addInPlace(p){return this.r+=p.r,this.g+=p.g,this.b+=p.b,this.a+=p.a,this}asArray(){return[this.r,this.g,this.b,this.a]}toArray(p,_=0){return p[_]=this.r,p[_+1]=this.g,p[_+2]=this.b,p[_+3]=this.a,this}fromArray(p,_=0){return vr.FromArrayToRef(p,_,this),this}equals(p){return p&&this.r===p.r&&this.g===p.g&&this.b===p.b&&this.a===p.a}add(p){return new vr(this.r+p.r,this.g+p.g,this.b+p.b,this.a+p.a)}subtract(p){return new vr(this.r-p.r,this.g-p.g,this.b-p.b,this.a-p.a)}subtractToRef(p,_){return _.r=this.r-p.r,_.g=this.g-p.g,_.b=this.b-p.b,_.a=this.a-p.a,this}scale(p){return new vr(this.r*p,this.g*p,this.b*p,this.a*p)}scaleInPlace(p){return this.r*=p,this.g*=p,this.b*=p,this.a*=p,this}scaleToRef(p,_){return _.r=this.r*p,_.g=this.g*p,_.b=this.b*p,_.a=this.a*p,this}scaleAndAddToRef(p,_){return _.r+=this.r*p,_.g+=this.g*p,_.b+=this.b*p,_.a+=this.a*p,this}clampToRef(p=0,_=1,E){return E.r=ri.Clamp(this.r,p,_),E.g=ri.Clamp(this.g,p,_),E.b=ri.Clamp(this.b,p,_),E.a=ri.Clamp(this.a,p,_),this}multiply(p){return new vr(this.r*p.r,this.g*p.g,this.b*p.b,this.a*p.a)}multiplyToRef(p,_){return _.r=this.r*p.r,_.g=this.g*p.g,_.b=this.b*p.b,_.a=this.a*p.a,_}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Color4"}getHashCode(){let p=this.r*255|0;return p=p*397^(this.g*255|0),p=p*397^(this.b*255|0),p=p*397^(this.a*255|0),p}clone(){return new vr(this.r,this.g,this.b,this.a)}copyFrom(p){return this.r=p.r,this.g=p.g,this.b=p.b,this.a=p.a,this}copyFromFloats(p,_,E,A){return this.r=p,this.g=_,this.b=E,this.a=A,this}set(p,_,E,A){return this.copyFromFloats(p,_,E,A)}toHexString(p=!1){const _=Math.round(this.r*255),E=Math.round(this.g*255),A=Math.round(this.b*255);if(p)return"#"+ri.ToHex(_)+ri.ToHex(E)+ri.ToHex(A);const $=Math.round(this.a*255);return"#"+ri.ToHex(_)+ri.ToHex(E)+ri.ToHex(A)+ri.ToHex($)}toLinearSpace(p=!1){const _=new vr;return this.toLinearSpaceToRef(_,p),_}toLinearSpaceToRef(p,_=!1){return _?(p.r=un(this.r),p.g=un(this.g),p.b=un(this.b)):(p.r=_n(this.r),p.g=_n(this.g),p.b=_n(this.b)),p.a=this.a,this}toGammaSpace(p=!1){const _=new vr;return this.toGammaSpaceToRef(_,p),_}toGammaSpaceToRef(p,_=!1){return _?(p.r=ca(this.r),p.g=ca(this.g),p.b=ca(this.b)):(p.r=Un(this.r),p.g=Un(this.g),p.b=Un(this.b)),p.a=this.a,this}static FromHexString(p){if(p.substring(0,1)!=="#"||p.length!==9&&p.length!==7)return new vr(0,0,0,0);const _=parseInt(p.substring(1,3),16),E=parseInt(p.substring(3,5),16),A=parseInt(p.substring(5,7),16),$=p.length===9?parseInt(p.substring(7,9),16):255;return vr.FromInts(_,E,A,$)}static Lerp(p,_,E){const A=new vr(0,0,0,0);return vr.LerpToRef(p,_,E,A),A}static LerpToRef(p,_,E,A){A.r=p.r+(_.r-p.r)*E,A.g=p.g+(_.g-p.g)*E,A.b=p.b+(_.b-p.b)*E,A.a=p.a+(_.a-p.a)*E}static Hermite(p,_,E,A,$){const ne=$*$,xe=$*ne,ce=2*xe-3*ne+1,Te=-2*xe+3*ne,Re=xe-2*ne+$,ke=xe-ne,We=p.r*ce+E.r*Te+_.r*Re+A.r*ke,Xe=p.g*ce+E.g*Te+_.g*Re+A.g*ke,xt=p.b*ce+E.b*Te+_.b*Re+A.b*ke,qe=p.a*ce+E.a*Te+_.a*Re+A.a*ke;return new vr(We,Xe,xt,qe)}static Hermite1stDerivative(p,_,E,A,$){const ne=new vr;return this.Hermite1stDerivativeToRef(p,_,E,A,$,ne),ne}static Hermite1stDerivativeToRef(p,_,E,A,$,ne){const xe=$*$;ne.r=(xe-$)*6*p.r+(3*xe-4*$+1)*_.r+(-xe+$)*6*E.r+(3*xe-2*$)*A.r,ne.g=(xe-$)*6*p.g+(3*xe-4*$+1)*_.g+(-xe+$)*6*E.g+(3*xe-2*$)*A.g,ne.b=(xe-$)*6*p.b+(3*xe-4*$+1)*_.b+(-xe+$)*6*E.b+(3*xe-2*$)*A.b,ne.a=(xe-$)*6*p.a+(3*xe-4*$+1)*_.a+(-xe+$)*6*E.a+(3*xe-2*$)*A.a}static FromColor3(p,_=1){return new vr(p.r,p.g,p.b,_)}static FromArray(p,_=0){return new vr(p[_],p[_+1],p[_+2],p[_+3])}static FromArrayToRef(p,_=0,E){E.r=p[_],E.g=p[_+1],E.b=p[_+2],E.a=p[_+3]}static FromInts(p,_,E,A){return new vr(p/255,_/255,E/255,A/255)}static CheckColors4(p,_){if(p.length===_*3){const E=[];for(let A=0;A<p.length;A+=3){const $=A/3*4;E[$]=p[A],E[$+1]=p[A+1],E[$+2]=p[A+2],E[$+3]=1}return E}return p}}class na{}na.Color3=Ms.BuildArray(3,ws.Black),na.Color4=Ms.BuildArray(3,()=>new vr(0,0,0,0)),zs("BABYLON.Color3",ws),zs("BABYLON.Color4",vr);const Hs={},rn={},ua=function(_e,p,_,E={}){const A=_e();ni&&ni.HasTags(p)&&ni.AddTagsTo(A,ni.GetTags(p,!0));const $=nn(A),ne={};for(const xe in $){const ce=$[xe],Te=p[xe],Re=ce.type;if(Te!=null&&(xe!=="uniqueId"||Xr.AllowLoadingUniqueId))switch(Re){case 0:case 6:case 11:A[xe]=Te;break;case 1:E.cloneTexturesOnlyOnce&&ne[Te.uniqueId]?A[xe]=ne[Te.uniqueId]:(A[xe]=_||Te.isRenderTarget?Te:Te.clone(),ne[Te.uniqueId]=A[xe]);break;case 2:case 3:case 4:case 5:case 7:case 10:case 12:A[xe]=_?Te:Te.clone();break}}return A};function ka(_e){const p=_e.getClassName();return Hs[p]||(Hs[p]={}),Hs[p]}function nn(_e){const p=_e.getClassName();if(rn[p])return rn[p];rn[p]={};const _=rn[p];let E=_e,A=p;for(;A;){const $=Hs[A];for(const ce in $)_[ce]=$[ce];let ne,xe=!1;do{if(ne=Object.getPrototypeOf(E),!ne.getClassName){xe=!0;break}if(ne.getClassName()!==A)break;E=ne}while(ne);if(xe)break;A=ne.getClassName(),E=ne}return _}function R0(_e,p){return(_,E)=>{const A=ka(_);A[E]||(A[E]={type:_e,sourceName:p})}}function Gl(_e,p=null){return(_,E)=>{const A=p||"_"+E;Object.defineProperty(_,E,{get:function(){return this[A]},set:function($){typeof this.equals=="function"&&this.equals($)||this[A]!==$&&(this[A]=$,_[_e].apply(this))},enumerable:!0,configurable:!0})}}function ks(_e,p=null){return Gl(_e,p)}function Gt(_e){return R0(0,_e)}function Kn(_e){return R0(1,_e)}function ja(_e){return R0(2,_e)}function jm(_e){return R0(3,_e)}function jc(_e){return R0(4,_e)}function jn(_e){return R0(5,_e)}function Hx(_e){return R0(6,_e)}function ll(_e){return R0(7,_e)}function xb(_e){return R0(8,_e)}function XO(_e){return R0(9,_e)}function KO(_e){return R0(10,_e)}function lb(_e){return R0(12,_e)}function uk(_e){return R0(11,_e)}class Xr{static AppendSerializedAnimations(p,_){if(p.animations){_.animations=[];for(let E=0;E<p.animations.length;E++){const A=p.animations[E];_.animations.push(A.serialize())}}}static Serialize(p,_){_||(_={}),ni&&(_.tags=ni.GetTags(p));const E=nn(p);for(const A in E){const $=E[A],ne=$.sourceName||A,xe=$.type,ce=p[A];if(ce!=null&&(A!=="uniqueId"||Xr.AllowLoadingUniqueId))switch(xe){case 0:_[ne]=ce;break;case 1:_[ne]=ce.serialize();break;case 2:_[ne]=ce.asArray();break;case 3:_[ne]=ce.serialize();break;case 4:_[ne]=ce.asArray();break;case 5:_[ne]=ce.asArray();break;case 6:_[ne]=ce.id;break;case 7:_[ne]=ce.serialize();break;case 8:_[ne]=ce.asArray();break;case 9:_[ne]=ce.serialize();break;case 10:_[ne]=ce.asArray();break;case 11:_[ne]=ce.id;break;case 12:_[ne]=ce.asArray();break}}return _}static ParseProperties(p,_,E,A){A||(A="");const $=nn(_);for(const ne in $){const xe=$[ne],ce=p[xe.sourceName||ne],Te=xe.type;if(ce!=null&&(ne!=="uniqueId"||Xr.AllowLoadingUniqueId)){const Re=_;switch(Te){case 0:Re[ne]=ce;break;case 1:E&&(Re[ne]=Xr._TextureParser(ce,E,A));break;case 2:Re[ne]=ws.FromArray(ce);break;case 3:Re[ne]=Xr._FresnelParametersParser(ce);break;case 4:Re[ne]=xr.FromArray(ce);break;case 5:Re[ne]=nt.FromArray(ce);break;case 6:E&&(Re[ne]=E.getLastMeshById(ce));break;case 7:Re[ne]=Xr._ColorCurvesParser(ce);break;case 8:Re[ne]=vr.FromArray(ce);break;case 9:Re[ne]=Xr._ImageProcessingConfigurationParser(ce);break;case 10:Re[ne]=_s.FromArray(ce);break;case 11:E&&(Re[ne]=E.getCameraById(ce));break;case 12:Re[ne]=Yt.FromArray(ce);break}}}}static Parse(p,_,E,A=null){const $=p();return ni&&ni.AddTagsTo($,_.tags),Xr.ParseProperties(_,$,E,A),$}static Clone(p,_,E={}){return ua(p,_,!1,E)}static Instanciate(p,_){return ua(p,_,!0)}}Xr.AllowLoadingUniqueId=!1,Xr._ImageProcessingConfigurationParser=_e=>{throw Tr("ImageProcessingConfiguration")},Xr._FresnelParametersParser=_e=>{throw Tr("FresnelParameters")},Xr._ColorCurvesParser=_e=>{throw Tr("ColorCurves")},Xr._TextureParser=(_e,p,_)=>{throw Tr("Texture")};function jh(_e,p,_,E){const A=_.value;_.value=(...$)=>{let ne=A;if(typeof _native<"u"&&_native[p]){const xe=_native[p];E?ne=(...ce)=>E(...ce)?xe(...ce):A(...ce):ne=xe}return _e[p]=ne,ne(...$)}}jh.filter=function(_e){return(p,_,E)=>jh(p,_,E,_e)};class qh{constructor(p){if(this._keys=[],this._isDirty=!0,this._areLightsDirty=!0,this._areLightsDisposed=!1,this._areAttributesDirty=!0,this._areTexturesDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._arePrePassDirty=!0,this._areImageProcessingDirty=!0,this._normals=!1,this._uvs=!1,this._needNormals=!1,this._needUVs=!1,this._externalProperties=p,p)for(const _ in p)Object.prototype.hasOwnProperty.call(p,_)&&this._setDefaultValue(_)}get isDirty(){return this._isDirty}markAsProcessed(){this._isDirty=!1,this._areAttributesDirty=!1,this._areTexturesDirty=!1,this._areFresnelDirty=!1,this._areLightsDirty=!1,this._areLightsDisposed=!1,this._areMiscDirty=!1,this._arePrePassDirty=!1,this._areImageProcessingDirty=!1}markAsUnprocessed(){this._isDirty=!0}markAllAsDirty(){this._areTexturesDirty=!0,this._areAttributesDirty=!0,this._areLightsDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._arePrePassDirty=!1,this._areImageProcessingDirty=!0,this._isDirty=!0}markAsImageProcessingDirty(){this._areImageProcessingDirty=!0,this._isDirty=!0}markAsLightDirty(p=!1){this._areLightsDirty=!0,this._areLightsDisposed=this._areLightsDisposed||p,this._isDirty=!0}markAsAttributesDirty(){this._areAttributesDirty=!0,this._isDirty=!0}markAsTexturesDirty(){this._areTexturesDirty=!0,this._isDirty=!0}markAsFresnelDirty(){this._areFresnelDirty=!0,this._isDirty=!0}markAsMiscDirty(){this._areMiscDirty=!0,this._isDirty=!0}markAsPrePassDirty(){this._arePrePassDirty=!0,this._isDirty=!0}rebuild(){this._keys.length=0;for(const p of Object.keys(this))p[0]!=="_"&&this._keys.push(p);if(this._externalProperties)for(const p in this._externalProperties)this._keys.indexOf(p)===-1&&this._keys.push(p)}isEqual(p){if(this._keys.length!==p._keys.length)return!1;for(let _=0;_<this._keys.length;_++){const E=this._keys[_];if(this[E]!==p[E])return!1}return!0}cloneTo(p){this._keys.length!==p._keys.length&&(p._keys=this._keys.slice(0));for(let _=0;_<this._keys.length;_++){const E=this._keys[_];p[E]=this[E]}}reset(){this._keys.forEach(p=>this._setDefaultValue(p))}_setDefaultValue(p){const _=this._externalProperties?.[p]?.type??typeof this[p],E=this._externalProperties?.[p]?.default;switch(_){case"number":this[p]=E??0;break;case"string":this[p]=E??"";break;default:this[p]=E??!1;break}}toString(){let p="";for(let _=0;_<this._keys.length;_++){const E=this._keys[_],A=this[E];switch(typeof A){case"number":case"string":p+="#define "+E+" "+A+`
`;break;default:A&&(p+="#define "+E+`
`);break}}return p}}class Ua{constructor(){this._dirty=!0,this._tempColor=new vr(0,0,0,0),this._globalCurve=new vr(0,0,0,0),this._highlightsCurve=new vr(0,0,0,0),this._midtonesCurve=new vr(0,0,0,0),this._shadowsCurve=new vr(0,0,0,0),this._positiveCurve=new vr(0,0,0,0),this._negativeCurve=new vr(0,0,0,0),this._globalHue=30,this._globalDensity=0,this._globalSaturation=0,this._globalExposure=0,this._highlightsHue=30,this._highlightsDensity=0,this._highlightsSaturation=0,this._highlightsExposure=0,this._midtonesHue=30,this._midtonesDensity=0,this._midtonesSaturation=0,this._midtonesExposure=0,this._shadowsHue=30,this._shadowsDensity=0,this._shadowsSaturation=0,this._shadowsExposure=0}get globalHue(){return this._globalHue}set globalHue(p){this._globalHue=p,this._dirty=!0}get globalDensity(){return this._globalDensity}set globalDensity(p){this._globalDensity=p,this._dirty=!0}get globalSaturation(){return this._globalSaturation}set globalSaturation(p){this._globalSaturation=p,this._dirty=!0}get globalExposure(){return this._globalExposure}set globalExposure(p){this._globalExposure=p,this._dirty=!0}get highlightsHue(){return this._highlightsHue}set highlightsHue(p){this._highlightsHue=p,this._dirty=!0}get highlightsDensity(){return this._highlightsDensity}set highlightsDensity(p){this._highlightsDensity=p,this._dirty=!0}get highlightsSaturation(){return this._highlightsSaturation}set highlightsSaturation(p){this._highlightsSaturation=p,this._dirty=!0}get highlightsExposure(){return this._highlightsExposure}set highlightsExposure(p){this._highlightsExposure=p,this._dirty=!0}get midtonesHue(){return this._midtonesHue}set midtonesHue(p){this._midtonesHue=p,this._dirty=!0}get midtonesDensity(){return this._midtonesDensity}set midtonesDensity(p){this._midtonesDensity=p,this._dirty=!0}get midtonesSaturation(){return this._midtonesSaturation}set midtonesSaturation(p){this._midtonesSaturation=p,this._dirty=!0}get midtonesExposure(){return this._midtonesExposure}set midtonesExposure(p){this._midtonesExposure=p,this._dirty=!0}get shadowsHue(){return this._shadowsHue}set shadowsHue(p){this._shadowsHue=p,this._dirty=!0}get shadowsDensity(){return this._shadowsDensity}set shadowsDensity(p){this._shadowsDensity=p,this._dirty=!0}get shadowsSaturation(){return this._shadowsSaturation}set shadowsSaturation(p){this._shadowsSaturation=p,this._dirty=!0}get shadowsExposure(){return this._shadowsExposure}set shadowsExposure(p){this._shadowsExposure=p,this._dirty=!0}getClassName(){return"ColorCurves"}static Bind(p,_,E="vCameraColorCurvePositive",A="vCameraColorCurveNeutral",$="vCameraColorCurveNegative"){p._dirty&&(p._dirty=!1,p._getColorGradingDataToRef(p._globalHue,p._globalDensity,p._globalSaturation,p._globalExposure,p._globalCurve),p._getColorGradingDataToRef(p._highlightsHue,p._highlightsDensity,p._highlightsSaturation,p._highlightsExposure,p._tempColor),p._tempColor.multiplyToRef(p._globalCurve,p._highlightsCurve),p._getColorGradingDataToRef(p._midtonesHue,p._midtonesDensity,p._midtonesSaturation,p._midtonesExposure,p._tempColor),p._tempColor.multiplyToRef(p._globalCurve,p._midtonesCurve),p._getColorGradingDataToRef(p._shadowsHue,p._shadowsDensity,p._shadowsSaturation,p._shadowsExposure,p._tempColor),p._tempColor.multiplyToRef(p._globalCurve,p._shadowsCurve),p._highlightsCurve.subtractToRef(p._midtonesCurve,p._positiveCurve),p._midtonesCurve.subtractToRef(p._shadowsCurve,p._negativeCurve)),_&&(_.setFloat4(E,p._positiveCurve.r,p._positiveCurve.g,p._positiveCurve.b,p._positiveCurve.a),_.setFloat4(A,p._midtonesCurve.r,p._midtonesCurve.g,p._midtonesCurve.b,p._midtonesCurve.a),_.setFloat4($,p._negativeCurve.r,p._negativeCurve.g,p._negativeCurve.b,p._negativeCurve.a))}static PrepareUniforms(p){p.push("vCameraColorCurveNeutral","vCameraColorCurvePositive","vCameraColorCurveNegative")}_getColorGradingDataToRef(p,_,E,A,$){p!=null&&(p=Ua._Clamp(p,0,360),_=Ua._Clamp(_,-100,100),E=Ua._Clamp(E,-100,100),A=Ua._Clamp(A,-100,100),_=Ua._ApplyColorGradingSliderNonlinear(_),_*=.5,A=Ua._ApplyColorGradingSliderNonlinear(A),_<0&&(_*=-1,p=(p+180)%360),Ua._FromHSBToRef(p,_,50+.25*A,$),$.scaleToRef(2,$),$.a=1+.01*E)}static _ApplyColorGradingSliderNonlinear(p){p/=100;let _=Math.abs(p);return _=Math.pow(_,2),p<0&&(_*=-1),_*=100,_}static _FromHSBToRef(p,_,E,A){let $=Ua._Clamp(p,0,360);const ne=Ua._Clamp(_/100,0,1),xe=Ua._Clamp(E/100,0,1);if(ne===0)A.r=xe,A.g=xe,A.b=xe;else{$/=60;const ce=Math.floor($),Te=$-ce,Re=xe*(1-ne),ke=xe*(1-ne*Te),We=xe*(1-ne*(1-Te));switch(ce){case 0:A.r=xe,A.g=We,A.b=Re;break;case 1:A.r=ke,A.g=xe,A.b=Re;break;case 2:A.r=Re,A.g=xe,A.b=We;break;case 3:A.r=Re,A.g=ke,A.b=xe;break;case 4:A.r=We,A.g=Re,A.b=xe;break;default:A.r=xe,A.g=Re,A.b=ke;break}}A.a=1}static _Clamp(p,_,E){return Math.min(Math.max(p,_),E)}clone(){return Xr.Clone(()=>new Ua,this)}serialize(){return Xr.Serialize(this)}static Parse(p){return Xr.Parse(()=>new Ua,p,null,null)}}Mt([Gt()],Ua.prototype,"_globalHue",void 0),Mt([Gt()],Ua.prototype,"_globalDensity",void 0),Mt([Gt()],Ua.prototype,"_globalSaturation",void 0),Mt([Gt()],Ua.prototype,"_globalExposure",void 0),Mt([Gt()],Ua.prototype,"_highlightsHue",void 0),Mt([Gt()],Ua.prototype,"_highlightsDensity",void 0),Mt([Gt()],Ua.prototype,"_highlightsSaturation",void 0),Mt([Gt()],Ua.prototype,"_highlightsExposure",void 0),Mt([Gt()],Ua.prototype,"_midtonesHue",void 0),Mt([Gt()],Ua.prototype,"_midtonesDensity",void 0),Mt([Gt()],Ua.prototype,"_midtonesSaturation",void 0),Mt([Gt()],Ua.prototype,"_midtonesExposure",void 0),Xr._ColorCurvesParser=Ua.Parse;class pk extends null{constructor(){super(),this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=!1,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.EXPOSURE=!1,this.SKIPFINALCOLORCLAMP=!1,this.rebuild()}}class Hn{constructor(){this.colorCurves=new Ua,this._colorCurvesEnabled=!1,this._colorGradingEnabled=!1,this._colorGradingWithGreenDepth=!0,this._colorGradingBGR=!0,this._exposure=1,this._toneMappingEnabled=!1,this._toneMappingType=Hn.TONEMAPPING_STANDARD,this._contrast=1,this.vignetteStretch=0,this.vignetteCenterX=0,this.vignetteCenterY=0,this.vignetteWeight=1.5,this.vignetteColor=new vr(0,0,0,0),this.vignetteCameraFov=.5,this._vignetteBlendMode=Hn.VIGNETTEMODE_MULTIPLY,this._vignetteEnabled=!1,this._ditheringEnabled=!1,this._ditheringIntensity=1/255,this._skipFinalColorClamp=!1,this._applyByPostProcess=!1,this._isEnabled=!0,this.onUpdateParameters=new Mi}get colorCurvesEnabled(){return this._colorCurvesEnabled}set colorCurvesEnabled(p){this._colorCurvesEnabled!==p&&(this._colorCurvesEnabled=p,this._updateParameters())}get colorGradingTexture(){return this._colorGradingTexture}set colorGradingTexture(p){this._colorGradingTexture!==p&&(this._colorGradingTexture=p,this._updateParameters())}get colorGradingEnabled(){return this._colorGradingEnabled}set colorGradingEnabled(p){this._colorGradingEnabled!==p&&(this._colorGradingEnabled=p,this._updateParameters())}get colorGradingWithGreenDepth(){return this._colorGradingWithGreenDepth}set colorGradingWithGreenDepth(p){this._colorGradingWithGreenDepth!==p&&(this._colorGradingWithGreenDepth=p,this._updateParameters())}get colorGradingBGR(){return this._colorGradingBGR}set colorGradingBGR(p){this._colorGradingBGR!==p&&(this._colorGradingBGR=p,this._updateParameters())}get exposure(){return this._exposure}set exposure(p){this._exposure!==p&&(this._exposure=p,this._updateParameters())}get toneMappingEnabled(){return this._toneMappingEnabled}set toneMappingEnabled(p){this._toneMappingEnabled!==p&&(this._toneMappingEnabled=p,this._updateParameters())}get toneMappingType(){return this._toneMappingType}set toneMappingType(p){this._toneMappingType!==p&&(this._toneMappingType=p,this._updateParameters())}get contrast(){return this._contrast}set contrast(p){this._contrast!==p&&(this._contrast=p,this._updateParameters())}get vignetteCentreY(){return this.vignetteCenterY}set vignetteCentreY(p){this.vignetteCenterY=p}get vignetteCentreX(){return this.vignetteCenterX}set vignetteCentreX(p){this.vignetteCenterX=p}get vignetteBlendMode(){return this._vignetteBlendMode}set vignetteBlendMode(p){this._vignetteBlendMode!==p&&(this._vignetteBlendMode=p,this._updateParameters())}get vignetteEnabled(){return this._vignetteEnabled}set vignetteEnabled(p){this._vignetteEnabled!==p&&(this._vignetteEnabled=p,this._updateParameters())}get ditheringEnabled(){return this._ditheringEnabled}set ditheringEnabled(p){this._ditheringEnabled!==p&&(this._ditheringEnabled=p,this._updateParameters())}get ditheringIntensity(){return this._ditheringIntensity}set ditheringIntensity(p){this._ditheringIntensity!==p&&(this._ditheringIntensity=p,this._updateParameters())}get skipFinalColorClamp(){return this._skipFinalColorClamp}set skipFinalColorClamp(p){this._skipFinalColorClamp!==p&&(this._skipFinalColorClamp=p,this._updateParameters())}get applyByPostProcess(){return this._applyByPostProcess}set applyByPostProcess(p){this._applyByPostProcess!==p&&(this._applyByPostProcess=p,this._updateParameters())}get isEnabled(){return this._isEnabled}set isEnabled(p){this._isEnabled!==p&&(this._isEnabled=p,this._updateParameters())}_updateParameters(){this.onUpdateParameters.notifyObservers(this)}getClassName(){return"ImageProcessingConfiguration"}static PrepareUniforms(p,_){_.EXPOSURE&&p.push("exposureLinear"),_.CONTRAST&&p.push("contrast"),_.COLORGRADING&&p.push("colorTransformSettings"),(_.VIGNETTE||_.DITHER)&&p.push("vInverseScreenSize"),_.VIGNETTE&&(p.push("vignetteSettings1"),p.push("vignetteSettings2")),_.COLORCURVES&&Ua.PrepareUniforms(p),_.DITHER&&p.push("ditherIntensity")}static PrepareSamplers(p,_){_.COLORGRADING&&p.push("txColorTransform")}prepareDefines(p,_=!1){if(_!==this.applyByPostProcess||!this._isEnabled){p.VIGNETTE=!1,p.TONEMAPPING=!1,p.TONEMAPPING_ACES=!1,p.CONTRAST=!1,p.EXPOSURE=!1,p.COLORCURVES=!1,p.COLORGRADING=!1,p.COLORGRADING3D=!1,p.DITHER=!1,p.IMAGEPROCESSING=!1,p.SKIPFINALCOLORCLAMP=this.skipFinalColorClamp,p.IMAGEPROCESSINGPOSTPROCESS=this.applyByPostProcess&&this._isEnabled;return}switch(p.VIGNETTE=this.vignetteEnabled,p.VIGNETTEBLENDMODEMULTIPLY=this.vignetteBlendMode===Hn._VIGNETTEMODE_MULTIPLY,p.VIGNETTEBLENDMODEOPAQUE=!p.VIGNETTEBLENDMODEMULTIPLY,p.TONEMAPPING=this.toneMappingEnabled,this._toneMappingType){case Hn.TONEMAPPING_ACES:p.TONEMAPPING_ACES=!0;break;default:p.TONEMAPPING_ACES=!1;break}p.CONTRAST=this.contrast!==1,p.EXPOSURE=this.exposure!==1,p.COLORCURVES=this.colorCurvesEnabled&&!!this.colorCurves,p.COLORGRADING=this.colorGradingEnabled&&!!this.colorGradingTexture,p.COLORGRADING?p.COLORGRADING3D=this.colorGradingTexture.is3D:p.COLORGRADING3D=!1,p.SAMPLER3DGREENDEPTH=this.colorGradingWithGreenDepth,p.SAMPLER3DBGRMAP=this.colorGradingBGR,p.DITHER=this._ditheringEnabled,p.IMAGEPROCESSINGPOSTPROCESS=this.applyByPostProcess,p.SKIPFINALCOLORCLAMP=this.skipFinalColorClamp,p.IMAGEPROCESSING=p.VIGNETTE||p.TONEMAPPING||p.CONTRAST||p.EXPOSURE||p.COLORCURVES||p.COLORGRADING||p.DITHER}isReady(){return!this.colorGradingEnabled||!this.colorGradingTexture||this.colorGradingTexture.isReady()}bind(p,_){if(this._colorCurvesEnabled&&this.colorCurves&&Ua.Bind(this.colorCurves,p),this._vignetteEnabled||this._ditheringEnabled){const E=1/p.getEngine().getRenderWidth(),A=1/p.getEngine().getRenderHeight();if(p.setFloat2("vInverseScreenSize",E,A),this._ditheringEnabled&&p.setFloat("ditherIntensity",.5*this._ditheringIntensity),this._vignetteEnabled){const $=_??A/E;let ne=Math.tan(this.vignetteCameraFov*.5),xe=ne*$;const ce=Math.sqrt(xe*ne);xe=ct.Mix(xe,ce,this.vignetteStretch),ne=ct.Mix(ne,ce,this.vignetteStretch),p.setFloat4("vignetteSettings1",xe,ne,-xe*this.vignetteCenterX,-ne*this.vignetteCenterY);const Te=-2*this.vignetteWeight;p.setFloat4("vignetteSettings2",this.vignetteColor.r,this.vignetteColor.g,this.vignetteColor.b,Te)}}if(p.setFloat("exposureLinear",this.exposure),p.setFloat("contrast",this.contrast),this.colorGradingTexture){p.setTexture("txColorTransform",this.colorGradingTexture);const E=this.colorGradingTexture.getSize().height;p.setFloat4("colorTransformSettings",(E-1)/E,.5/E,E,this.colorGradingTexture.level)}}clone(){return Xr.Clone(()=>new Hn,this)}serialize(){return Xr.Serialize(this)}static Parse(p){const _=Xr.Parse(()=>new Hn,p,null,null);return p.vignetteCentreX!==void 0&&(_.vignetteCenterX=p.vignetteCentreX),p.vignetteCentreY!==void 0&&(_.vignetteCenterY=p.vignetteCentreY),_}static get VIGNETTEMODE_MULTIPLY(){return this._VIGNETTEMODE_MULTIPLY}static get VIGNETTEMODE_OPAQUE(){return this._VIGNETTEMODE_OPAQUE}}Hn.TONEMAPPING_STANDARD=0,Hn.TONEMAPPING_ACES=1,Hn._VIGNETTEMODE_MULTIPLY=0,Hn._VIGNETTEMODE_OPAQUE=1,Mt([ll()],Hn.prototype,"colorCurves",void 0),Mt([Gt()],Hn.prototype,"_colorCurvesEnabled",void 0),Mt([Kn("colorGradingTexture")],Hn.prototype,"_colorGradingTexture",void 0),Mt([Gt()],Hn.prototype,"_colorGradingEnabled",void 0),Mt([Gt()],Hn.prototype,"_colorGradingWithGreenDepth",void 0),Mt([Gt()],Hn.prototype,"_colorGradingBGR",void 0),Mt([Gt()],Hn.prototype,"_exposure",void 0),Mt([Gt()],Hn.prototype,"_toneMappingEnabled",void 0),Mt([Gt()],Hn.prototype,"_toneMappingType",void 0),Mt([Gt()],Hn.prototype,"_contrast",void 0),Mt([Gt()],Hn.prototype,"vignetteStretch",void 0),Mt([Gt()],Hn.prototype,"vignetteCenterX",void 0),Mt([Gt()],Hn.prototype,"vignetteCenterY",void 0),Mt([Gt()],Hn.prototype,"vignetteWeight",void 0),Mt([xb()],Hn.prototype,"vignetteColor",void 0),Mt([Gt()],Hn.prototype,"vignetteCameraFov",void 0),Mt([Gt()],Hn.prototype,"_vignetteBlendMode",void 0),Mt([Gt()],Hn.prototype,"_vignetteEnabled",void 0),Mt([Gt()],Hn.prototype,"_ditheringEnabled",void 0),Mt([Gt()],Hn.prototype,"_ditheringIntensity",void 0),Mt([Gt()],Hn.prototype,"_skipFinalColorClamp",void 0),Mt([Gt()],Hn.prototype,"_applyByPostProcess",void 0),Mt([Gt()],Hn.prototype,"_isEnabled",void 0),Xr._ImageProcessingConfigurationParser=Hn.Parse,rr.prototype.createUniformBuffer=function(_e,p){const _=this._gl.createBuffer();if(!_)throw new Error("Unable to create uniform buffer");const E=new Xo(_);return this.bindUniformBuffer(E),_e instanceof Float32Array?this._gl.bufferData(this._gl.UNIFORM_BUFFER,_e,this._gl.STATIC_DRAW):this._gl.bufferData(this._gl.UNIFORM_BUFFER,new Float32Array(_e),this._gl.STATIC_DRAW),this.bindUniformBuffer(null),E.references=1,E},rr.prototype.createDynamicUniformBuffer=function(_e,p){const _=this._gl.createBuffer();if(!_)throw new Error("Unable to create dynamic uniform buffer");const E=new Xo(_);return this.bindUniformBuffer(E),_e instanceof Float32Array?this._gl.bufferData(this._gl.UNIFORM_BUFFER,_e,this._gl.DYNAMIC_DRAW):this._gl.bufferData(this._gl.UNIFORM_BUFFER,new Float32Array(_e),this._gl.DYNAMIC_DRAW),this.bindUniformBuffer(null),E.references=1,E},rr.prototype.updateUniformBuffer=function(_e,p,_,E){this.bindUniformBuffer(_e),_===void 0&&(_=0),E===void 0?p instanceof Float32Array?this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,_,p):this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,_,new Float32Array(p)):p instanceof Float32Array?this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,0,p.subarray(_,_+E)):this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,0,new Float32Array(p).subarray(_,_+E)),this.bindUniformBuffer(null)},rr.prototype.bindUniformBuffer=function(_e){this._gl.bindBuffer(this._gl.UNIFORM_BUFFER,_e?_e.underlyingResource:null)},rr.prototype.bindUniformBufferBase=function(_e,p,_){this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER,p,_e?_e.underlyingResource:null)},rr.prototype.bindUniformBlock=function(_e,p,_){const E=_e.program,A=this._gl.getUniformBlockIndex(E,p);A!==4294967295&&this._gl.uniformBlockBinding(E,A,_)};class $s{constructor(p,_,E,A,$=!1){this._valueCache={},this._engine=p,this._noUBO=!p.supportsUniformBuffers||$,this._dynamic=E,this._name=A??"no-name",this._data=_||[],this._uniformLocations={},this._uniformSizes={},this._uniformArraySizes={},this._uniformLocationPointer=0,this._needSync=!1,this._engine._features.trackUbosInFrame&&(this._buffers=[],this._bufferIndex=-1,this._createBufferOnWrite=!1,this._currentFrameId=0),this._noUBO?(this.updateMatrix3x3=this._updateMatrix3x3ForEffect,this.updateMatrix2x2=this._updateMatrix2x2ForEffect,this.updateFloat=this._updateFloatForEffect,this.updateFloat2=this._updateFloat2ForEffect,this.updateFloat3=this._updateFloat3ForEffect,this.updateFloat4=this._updateFloat4ForEffect,this.updateFloatArray=this._updateFloatArrayForEffect,this.updateArray=this._updateArrayForEffect,this.updateIntArray=this._updateIntArrayForEffect,this.updateUIntArray=this._updateUIntArrayForEffect,this.updateMatrix=this._updateMatrixForEffect,this.updateMatrices=this._updateMatricesForEffect,this.updateVector3=this._updateVector3ForEffect,this.updateVector4=this._updateVector4ForEffect,this.updateColor3=this._updateColor3ForEffect,this.updateColor4=this._updateColor4ForEffect,this.updateDirectColor4=this._updateDirectColor4ForEffect,this.updateInt=this._updateIntForEffect,this.updateInt2=this._updateInt2ForEffect,this.updateInt3=this._updateInt3ForEffect,this.updateInt4=this._updateInt4ForEffect,this.updateUInt=this._updateUIntForEffect,this.updateUInt2=this._updateUInt2ForEffect,this.updateUInt3=this._updateUInt3ForEffect,this.updateUInt4=this._updateUInt4ForEffect):(this._engine._uniformBuffers.push(this),this.updateMatrix3x3=this._updateMatrix3x3ForUniform,this.updateMatrix2x2=this._updateMatrix2x2ForUniform,this.updateFloat=this._updateFloatForUniform,this.updateFloat2=this._updateFloat2ForUniform,this.updateFloat3=this._updateFloat3ForUniform,this.updateFloat4=this._updateFloat4ForUniform,this.updateFloatArray=this._updateFloatArrayForUniform,this.updateArray=this._updateArrayForUniform,this.updateIntArray=this._updateIntArrayForUniform,this.updateUIntArray=this._updateUIntArrayForUniform,this.updateMatrix=this._updateMatrixForUniform,this.updateMatrices=this._updateMatricesForUniform,this.updateVector3=this._updateVector3ForUniform,this.updateVector4=this._updateVector4ForUniform,this.updateColor3=this._updateColor3ForUniform,this.updateColor4=this._updateColor4ForUniform,this.updateDirectColor4=this._updateDirectColor4ForUniform,this.updateInt=this._updateIntForUniform,this.updateInt2=this._updateInt2ForUniform,this.updateInt3=this._updateInt3ForUniform,this.updateInt4=this._updateInt4ForUniform,this.updateUInt=this._updateUIntForUniform,this.updateUInt2=this._updateUInt2ForUniform,this.updateUInt3=this._updateUInt3ForUniform,this.updateUInt4=this._updateUInt4ForUniform)}get useUbo(){return!this._noUBO}get isSync(){return!this._needSync}isDynamic(){return this._dynamic!==void 0}getData(){return this._bufferData}getBuffer(){return this._buffer}_fillAlignment(p){let _;if(p<=2?_=p:_=4,this._uniformLocationPointer%_!==0){const E=this._uniformLocationPointer;this._uniformLocationPointer+=_-this._uniformLocationPointer%_;const A=this._uniformLocationPointer-E;for(let $=0;$<A;$++)this._data.push(0)}}addUniform(p,_,E=0){if(this._noUBO||this._uniformLocations[p]!==void 0)return;let A;if(E>0){if(_ instanceof Array)throw"addUniform should not be use with Array in UBO: "+p;if(this._fillAlignment(4),this._uniformArraySizes[p]={strideSize:_,arraySize:E},_==16)_=_*E;else{const ne=(4-_)*E;_=_*E+ne}A=[];for(let $=0;$<_;$++)A.push(0)}else{if(_ instanceof Array)A=_,_=A.length;else{_=_,A=[];for(let $=0;$<_;$++)A.push(0)}this._fillAlignment(_)}this._uniformSizes[p]=_,this._uniformLocations[p]=this._uniformLocationPointer,this._uniformLocationPointer+=_;for(let $=0;$<_;$++)this._data.push(A[$]);this._needSync=!0}addMatrix(p,_){this.addUniform(p,Array.prototype.slice.call(_.toArray()))}addFloat2(p,_,E){const A=[_,E];this.addUniform(p,A)}addFloat3(p,_,E,A){const $=[_,E,A];this.addUniform(p,$)}addColor3(p,_){const E=[_.r,_.g,_.b];this.addUniform(p,E)}addColor4(p,_,E){const A=[_.r,_.g,_.b,E];this.addUniform(p,A)}addVector3(p,_){const E=[_.x,_.y,_.z];this.addUniform(p,E)}addMatrix3x3(p){this.addUniform(p,12)}addMatrix2x2(p){this.addUniform(p,8)}create(){this._noUBO||this._buffer||(this._fillAlignment(4),this._bufferData=new Float32Array(this._data),this._rebuild(),this._needSync=!0)}_getNames(){const p=[];let _=0;for(const E in this._uniformLocations)if(p.push(E),++_===10)break;return p.join(",")}_rebuild(){this._noUBO||!this._bufferData||(this._dynamic?this._buffer=this._engine.createDynamicUniformBuffer(this._bufferData,this._name+"_UniformList:"+this._getNames()):this._buffer=this._engine.createUniformBuffer(this._bufferData,this._name+"_UniformList:"+this._getNames()),this._engine._features.trackUbosInFrame&&(this._buffers.push([this._buffer,this._engine._features.checkUbosContentBeforeUpload?this._bufferData.slice():void 0]),this._bufferIndex=this._buffers.length-1,this._createBufferOnWrite=!1))}_rebuildAfterContextLost(){this._engine._features.trackUbosInFrame&&(this._buffers=[],this._currentFrameId=0),this._rebuild()}get _numBuffers(){return this._buffers.length}get _indexBuffer(){return this._bufferIndex}get name(){return this._name}get currentEffect(){return this._currentEffect}_buffersEqual(p,_){for(let E=0;E<p.length;++E)if(p[E]!==_[E])return!1;return!0}_copyBuffer(p,_){for(let E=0;E<p.length;++E)_[E]=p[E]}update(){if(!this._noUBO){if(this.bindUniformBuffer(),!this._buffer){this.create();return}if(!this._dynamic&&!this._needSync){this._createBufferOnWrite=this._engine._features.trackUbosInFrame;return}if(this._buffers&&this._buffers.length>1&&this._buffers[this._bufferIndex][1])if(this._buffersEqual(this._bufferData,this._buffers[this._bufferIndex][1])){this._needSync=!1,this._createBufferOnWrite=this._engine._features.trackUbosInFrame;return}else this._copyBuffer(this._bufferData,this._buffers[this._bufferIndex][1]);this._engine.updateUniformBuffer(this._buffer,this._bufferData),this._engine._features._collectUbosUpdatedInFrame&&($s._UpdatedUbosInFrame[this._name]||($s._UpdatedUbosInFrame[this._name]=0),$s._UpdatedUbosInFrame[this._name]++),this._needSync=!1,this._createBufferOnWrite=this._engine._features.trackUbosInFrame}}_createNewBuffer(){this._bufferIndex+1<this._buffers.length?(this._bufferIndex++,this._buffer=this._buffers[this._bufferIndex][0],this._createBufferOnWrite=!1,this._needSync=!0):this._rebuild()}_checkNewFrame(){this._engine._features.trackUbosInFrame&&this._currentFrameId!==this._engine.frameId&&(this._currentFrameId=this._engine.frameId,this._createBufferOnWrite=!1,this._buffers&&this._buffers.length>0?(this._needSync=this._bufferIndex!==0,this._bufferIndex=0,this._buffer=this._buffers[this._bufferIndex][0]):this._bufferIndex=-1)}updateUniform(p,_,E){this._checkNewFrame();let A=this._uniformLocations[p];if(A===void 0){if(this._buffer){vi.Error("Cannot add an uniform after UBO has been created. uniformName="+p);return}this.addUniform(p,E),A=this._uniformLocations[p]}if(this._buffer||this.create(),this._dynamic)for(let $=0;$<E;$++)this._bufferData[A+$]=_[$];else{let $=!1;for(let ne=0;ne<E;ne++)(E===16&&!this._engine._features.uniformBufferHardCheckMatrix||this._bufferData[A+ne]!==Math.fround(_[ne]))&&($=!0,this._createBufferOnWrite&&this._createNewBuffer(),this._bufferData[A+ne]=_[ne]);this._needSync=this._needSync||$}}updateUniformArray(p,_,E){this._checkNewFrame();const A=this._uniformLocations[p];if(A===void 0){vi.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");return}this._buffer||this.create();const $=this._uniformArraySizes[p];if(this._dynamic)for(let ne=0;ne<E;ne++)this._bufferData[A+ne]=_[ne];else{let ne=!1,xe=0,ce=0;for(let Te=0;Te<E;Te++)if(this._bufferData[A+ce*4+xe]!==ct.FloatRound(_[Te])&&(ne=!0,this._createBufferOnWrite&&this._createNewBuffer(),this._bufferData[A+ce*4+xe]=_[Te]),xe++,xe===$.strideSize){for(;xe<4;xe++)this._bufferData[A+ce*4+xe]=0;xe=0,ce++}this._needSync=this._needSync||ne}}_cacheMatrix(p,_){this._checkNewFrame();const E=this._valueCache[p],A=_.updateFlag;return E!==void 0&&E===A?!1:(this._valueCache[p]=A,!0)}_updateMatrix3x3ForUniform(p,_){for(let E=0;E<3;E++)$s._TempBuffer[E*4]=_[E*3],$s._TempBuffer[E*4+1]=_[E*3+1],$s._TempBuffer[E*4+2]=_[E*3+2],$s._TempBuffer[E*4+3]=0;this.updateUniform(p,$s._TempBuffer,12)}_updateMatrix3x3ForEffect(p,_){this._currentEffect.setMatrix3x3(p,_)}_updateMatrix2x2ForEffect(p,_){this._currentEffect.setMatrix2x2(p,_)}_updateMatrix2x2ForUniform(p,_){for(let E=0;E<2;E++)$s._TempBuffer[E*4]=_[E*2],$s._TempBuffer[E*4+1]=_[E*2+1],$s._TempBuffer[E*4+2]=0,$s._TempBuffer[E*4+3]=0;this.updateUniform(p,$s._TempBuffer,8)}_updateFloatForEffect(p,_){this._currentEffect.setFloat(p,_)}_updateFloatForUniform(p,_){$s._TempBuffer[0]=_,this.updateUniform(p,$s._TempBuffer,1)}_updateFloat2ForEffect(p,_,E,A=""){this._currentEffect.setFloat2(p+A,_,E)}_updateFloat2ForUniform(p,_,E){$s._TempBuffer[0]=_,$s._TempBuffer[1]=E,this.updateUniform(p,$s._TempBuffer,2)}_updateFloat3ForEffect(p,_,E,A,$=""){this._currentEffect.setFloat3(p+$,_,E,A)}_updateFloat3ForUniform(p,_,E,A){$s._TempBuffer[0]=_,$s._TempBuffer[1]=E,$s._TempBuffer[2]=A,this.updateUniform(p,$s._TempBuffer,3)}_updateFloat4ForEffect(p,_,E,A,$,ne=""){this._currentEffect.setFloat4(p+ne,_,E,A,$)}_updateFloat4ForUniform(p,_,E,A,$){$s._TempBuffer[0]=_,$s._TempBuffer[1]=E,$s._TempBuffer[2]=A,$s._TempBuffer[3]=$,this.updateUniform(p,$s._TempBuffer,4)}_updateFloatArrayForEffect(p,_){this._currentEffect.setFloatArray(p,_)}_updateFloatArrayForUniform(p,_){this.updateUniformArray(p,_,_.length)}_updateArrayForEffect(p,_){this._currentEffect.setArray(p,_)}_updateArrayForUniform(p,_){this.updateUniformArray(p,_,_.length)}_updateIntArrayForEffect(p,_){this._currentEffect.setIntArray(p,_)}_updateIntArrayForUniform(p,_){$s._TempBufferInt32View.set(_),this.updateUniformArray(p,$s._TempBuffer,_.length)}_updateUIntArrayForEffect(p,_){this._currentEffect.setUIntArray(p,_)}_updateUIntArrayForUniform(p,_){$s._TempBufferUInt32View.set(_),this.updateUniformArray(p,$s._TempBuffer,_.length)}_updateMatrixForEffect(p,_){this._currentEffect.setMatrix(p,_)}_updateMatrixForUniform(p,_){this._cacheMatrix(p,_)&&this.updateUniform(p,_.toArray(),16)}_updateMatricesForEffect(p,_){this._currentEffect.setMatrices(p,_)}_updateMatricesForUniform(p,_){this.updateUniform(p,_,_.length)}_updateVector3ForEffect(p,_){this._currentEffect.setVector3(p,_)}_updateVector3ForUniform(p,_){$s._TempBuffer[0]=_.x,$s._TempBuffer[1]=_.y,$s._TempBuffer[2]=_.z,this.updateUniform(p,$s._TempBuffer,3)}_updateVector4ForEffect(p,_){this._currentEffect.setVector4(p,_)}_updateVector4ForUniform(p,_){$s._TempBuffer[0]=_.x,$s._TempBuffer[1]=_.y,$s._TempBuffer[2]=_.z,$s._TempBuffer[3]=_.w,this.updateUniform(p,$s._TempBuffer,4)}_updateColor3ForEffect(p,_,E=""){this._currentEffect.setColor3(p+E,_)}_updateColor3ForUniform(p,_){$s._TempBuffer[0]=_.r,$s._TempBuffer[1]=_.g,$s._TempBuffer[2]=_.b,this.updateUniform(p,$s._TempBuffer,3)}_updateColor4ForEffect(p,_,E,A=""){this._currentEffect.setColor4(p+A,_,E)}_updateDirectColor4ForEffect(p,_,E=""){this._currentEffect.setDirectColor4(p+E,_)}_updateColor4ForUniform(p,_,E){$s._TempBuffer[0]=_.r,$s._TempBuffer[1]=_.g,$s._TempBuffer[2]=_.b,$s._TempBuffer[3]=E,this.updateUniform(p,$s._TempBuffer,4)}_updateDirectColor4ForUniform(p,_){$s._TempBuffer[0]=_.r,$s._TempBuffer[1]=_.g,$s._TempBuffer[2]=_.b,$s._TempBuffer[3]=_.a,this.updateUniform(p,$s._TempBuffer,4)}_updateIntForEffect(p,_,E=""){this._currentEffect.setInt(p+E,_)}_updateIntForUniform(p,_){$s._TempBufferInt32View[0]=_,this.updateUniform(p,$s._TempBuffer,1)}_updateInt2ForEffect(p,_,E,A=""){this._currentEffect.setInt2(p+A,_,E)}_updateInt2ForUniform(p,_,E){$s._TempBufferInt32View[0]=_,$s._TempBufferInt32View[1]=E,this.updateUniform(p,$s._TempBuffer,2)}_updateInt3ForEffect(p,_,E,A,$=""){this._currentEffect.setInt3(p+$,_,E,A)}_updateInt3ForUniform(p,_,E,A){$s._TempBufferInt32View[0]=_,$s._TempBufferInt32View[1]=E,$s._TempBufferInt32View[2]=A,this.updateUniform(p,$s._TempBuffer,3)}_updateInt4ForEffect(p,_,E,A,$,ne=""){this._currentEffect.setInt4(p+ne,_,E,A,$)}_updateInt4ForUniform(p,_,E,A,$){$s._TempBufferInt32View[0]=_,$s._TempBufferInt32View[1]=E,$s._TempBufferInt32View[2]=A,$s._TempBufferInt32View[3]=$,this.updateUniform(p,$s._TempBuffer,4)}_updateUIntForEffect(p,_,E=""){this._currentEffect.setUInt(p+E,_)}_updateUIntForUniform(p,_){$s._TempBufferUInt32View[0]=_,this.updateUniform(p,$s._TempBuffer,1)}_updateUInt2ForEffect(p,_,E,A=""){this._currentEffect.setUInt2(p+A,_,E)}_updateUInt2ForUniform(p,_,E){$s._TempBufferUInt32View[0]=_,$s._TempBufferUInt32View[1]=E,this.updateUniform(p,$s._TempBuffer,2)}_updateUInt3ForEffect(p,_,E,A,$=""){this._currentEffect.setUInt3(p+$,_,E,A)}_updateUInt3ForUniform(p,_,E,A){$s._TempBufferUInt32View[0]=_,$s._TempBufferUInt32View[1]=E,$s._TempBufferUInt32View[2]=A,this.updateUniform(p,$s._TempBuffer,3)}_updateUInt4ForEffect(p,_,E,A,$,ne=""){this._currentEffect.setUInt4(p+ne,_,E,A,$)}_updateUInt4ForUniform(p,_,E,A,$){$s._TempBufferUInt32View[0]=_,$s._TempBufferUInt32View[1]=E,$s._TempBufferUInt32View[2]=A,$s._TempBufferUInt32View[3]=$,this.updateUniform(p,$s._TempBuffer,4)}setTexture(p,_){this._currentEffect.setTexture(p,_)}bindTexture(p,_){this._currentEffect._bindTexture(p,_)}updateUniformDirectly(p,_){this.updateUniform(p,_,_.length),this.update()}bindToEffect(p,_){this._currentEffect=p,this._currentEffectName=_}bindUniformBuffer(){!this._noUBO&&this._buffer&&this._currentEffect&&this._currentEffect.bindUniformBuffer(this._buffer,this._currentEffectName)}unbindEffect(){this._currentEffect=void 0,this._currentEffectName=void 0}setDataBuffer(p){if(!this._buffers)return this._buffer===p;for(let _=0;_<this._buffers.length;++_)if(this._buffers[_][0]===p)return this._bufferIndex=_,this._buffer=p,this._createBufferOnWrite=!1,this._currentEffect=void 0,!0;return!1}dispose(){if(this._noUBO)return;const p=this._engine._uniformBuffers,_=p.indexOf(this);if(_!==-1&&(p[_]=p[p.length-1],p.pop()),this._engine._features.trackUbosInFrame&&this._buffers)for(let E=0;E<this._buffers.length;++E){const A=this._buffers[E][0];this._engine._releaseBuffer(A)}else this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._buffer=null)}}$s._UpdatedUbosInFrame={},$s._MAX_UNIFORM_SIZE=256,$s._TempBuffer=new Float32Array($s._MAX_UNIFORM_SIZE),$s._TempBufferInt32View=new Int32Array($s._TempBuffer.buffer),$s._TempBufferUInt32View=new Uint32Array($s._TempBuffer.buffer);class vu{get isDisposed(){return this._isDisposed}constructor(p,_,E,A=0,$=!1,ne=!1,xe=!1,ce,Te){this._isAlreadyOwned=!1,this._isDisposed=!1,p&&p.getScene?this._engine=p.getScene().getEngine():this._engine=p,this._updatable=E,this._instanced=ne,this._divisor=ce||1,this._label=Te,_ instanceof To?(this._data=null,this._buffer=_):(this._data=_,this._buffer=null),this.byteStride=xe?A:A*Float32Array.BYTES_PER_ELEMENT,$||this.create()}createVertexBuffer(p,_,E,A,$,ne=!1,xe){const ce=ne?_:_*Float32Array.BYTES_PER_ELEMENT,Te=A?ne?A:A*Float32Array.BYTES_PER_ELEMENT:this.byteStride;return new ut(this._engine,this,p,this._updatable,!0,Te,$===void 0?this._instanced:$,ce,E,void 0,void 0,!0,this._divisor||xe)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(p=null){!p&&this._buffer||(p=p||this._data,p&&(this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,p),this._data=p):this._updatable?(this._buffer=this._engine.createDynamicVertexBuffer(p,this._label),this._data=p):this._buffer=this._engine.createVertexBuffer(p,void 0,this._label)))}_rebuild(){if(this._data)this._buffer=null,this.create(this._data);else{if(!this._buffer)return;if(this._buffer.capacity>0){this._updatable?this._buffer=this._engine.createDynamicVertexBuffer(this._buffer.capacity,this._label):this._buffer=this._engine.createVertexBuffer(this._buffer.capacity,void 0,this._label);return}vi.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.uniqueId+")":""}. Buffer reconstruction failed.`),this._buffer=null}}update(p){this.create(p)}updateDirectly(p,_,E,A=!1){this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,p,A?_:_*Float32Array.BYTES_PER_ELEMENT,E?E*this.byteStride:void 0),_===0&&E===void 0?this._data=p:this._data=null)}_increaseReferences(){if(this._buffer){if(!this._isAlreadyOwned){this._isAlreadyOwned=!0;return}this._buffer.references++}}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._isDisposed=!0,this._data=null,this._buffer=null)}}class ut{get isDisposed(){return this._isDisposed}get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(p){const _=p!=0;this._instanceDivisor=p,_!==this._instanced&&(this._instanced=_,this._computeHashCode())}get _maxVerticesCount(){const p=this.getData();return p?Array.isArray(p)?p.length/(this.byteStride/4)-this.byteOffset/4:(p.byteLength-this.byteOffset)/this.byteStride:0}constructor(p,_,E,A,$,ne,xe,ce,Te,Re,ke=!1,We=!1,Xe=1,xt=!1){this._isDisposed=!1;let qe=!1;if(this.engine=p,typeof A=="object"&&A!==null?(qe=A.updatable??!1,$=A.postponeInternalCreation,ne=A.stride,xe=A.instanced,ce=A.offset,Te=A.size,Re=A.type,ke=A.normalized??!1,We=A.useBytes??!1,Xe=A.divisor??1,xt=A.takeBufferOwnership??!1,this._label=A.label):qe=!!A,_ instanceof vu?(this._buffer=_,this._ownsBuffer=xt):(this._buffer=new vu(p,_,qe,ne,$,xe,We,Xe,this._label),this._ownsBuffer=!0),this.uniqueId=ut._Counter++,this._kind=E,Re===void 0){const Nt=this.getData();this.type=Nt?ut.GetDataType(Nt):ut.FLOAT}else this.type=Re;const ht=ut.GetTypeByteLength(this.type);We?(this._size=Te||(ne?ne/ht:ut.DeduceStride(E)),this.byteStride=ne||this._buffer.byteStride||this._size*ht,this.byteOffset=ce||0):(this._size=Te||ne||ut.DeduceStride(E),this.byteStride=ne?ne*ht:this._buffer.byteStride||this._size*ht,this.byteOffset=(ce||0)*ht),this.normalized=ke,this._instanced=xe!==void 0?xe:!1,this._instanceDivisor=xe?Xe:0,this._alignBuffer(),this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120<<0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){this._buffer?._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(p,_){const E=this.getData();return E?ut.GetFloatData(E,this._size,this.type,this.byteOffset,this.byteStride,this.normalized,p,_):null}getBuffer(){return this._buffer.getBuffer()}getWrapperBuffer(){return this._buffer}getStrideSize(){return this.byteStride/ut.GetTypeByteLength(this.type)}getOffset(){return this.byteOffset/ut.GetTypeByteLength(this.type)}getSize(p=!1){return p?this._size*ut.GetTypeByteLength(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(p){this._buffer.create(p),this._alignBuffer()}update(p){this._buffer.update(p),this._alignBuffer()}updateDirectly(p,_,E=!1){this._buffer.updateDirectly(p,_,void 0,E),this._alignBuffer()}dispose(){this._ownsBuffer&&this._buffer.dispose(),this._isDisposed=!0}forEach(p,_){ut.ForEach(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,p,this.normalized,_)}_alignBuffer(){}static DeduceStride(p){switch(p){case ut.UVKind:case ut.UV2Kind:case ut.UV3Kind:case ut.UV4Kind:case ut.UV5Kind:case ut.UV6Kind:return 2;case ut.NormalKind:case ut.PositionKind:return 3;case ut.ColorKind:case ut.ColorInstanceKind:case ut.MatricesIndicesKind:case ut.MatricesIndicesExtraKind:case ut.MatricesWeightsKind:case ut.MatricesWeightsExtraKind:case ut.TangentKind:return 4;default:throw new Error("Invalid kind '"+p+"'")}}static GetDataType(p){return p instanceof Int8Array?ut.BYTE:p instanceof Uint8Array?ut.UNSIGNED_BYTE:p instanceof Int16Array?ut.SHORT:p instanceof Uint16Array?ut.UNSIGNED_SHORT:p instanceof Int32Array?ut.INT:p instanceof Uint32Array?ut.UNSIGNED_INT:ut.FLOAT}static GetTypeByteLength(p){switch(p){case ut.BYTE:case ut.UNSIGNED_BYTE:return 1;case ut.SHORT:case ut.UNSIGNED_SHORT:return 2;case ut.INT:case ut.UNSIGNED_INT:case ut.FLOAT:return 4;default:throw new Error(`Invalid type '${p}'`)}}static ForEach(p,_,E,A,$,ne,xe,ce){if(p instanceof Array){let Te=_/4;const Re=E/4;for(let ke=0;ke<ne;ke+=A){for(let We=0;We<A;We++)ce(p[Te+We],ke+We);Te+=Re}}else{const Te=p instanceof ArrayBuffer?new DataView(p):new DataView(p.buffer,p.byteOffset,p.byteLength),Re=ut.GetTypeByteLength($);for(let ke=0;ke<ne;ke+=A){let We=_;for(let Xe=0;Xe<A;Xe++){const xt=ut._GetFloatValue(Te,$,We,xe);ce(xt,ke+Xe),We+=Re}_+=E}}}static _GetFloatValue(p,_,E,A){switch(_){case ut.BYTE:{let $=p.getInt8(E);return A&&($=Math.max($/127,-1)),$}case ut.UNSIGNED_BYTE:{let $=p.getUint8(E);return A&&($=$/255),$}case ut.SHORT:{let $=p.getInt16(E,!0);return A&&($=Math.max($/32767,-1)),$}case ut.UNSIGNED_SHORT:{let $=p.getUint16(E,!0);return A&&($=$/65535),$}case ut.INT:return p.getInt32(E,!0);case ut.UNSIGNED_INT:return p.getUint32(E,!0);case ut.FLOAT:return p.getFloat32(E,!0);default:throw new Error(`Invalid component type ${_}`)}}static GetFloatData(p,_,E,A,$,ne,xe,ce){const Te=_*ut.GetTypeByteLength(E),Re=xe*_;if(E!==ut.FLOAT||$!==Te){const ke=new Float32Array(Re);return ut.ForEach(p,A,$,_,E,Re,ne,(We,Xe)=>ke[Xe]=We),ke}if(!(p instanceof Array||p instanceof Float32Array)||A!==0||p.length!==Re)if(p instanceof Array){const ke=A/4;return p.slice(ke,ke+Re)}else{if(p instanceof ArrayBuffer)return new Float32Array(p,A,Re);{let ke=p.byteOffset+A;if(ce){const Xe=new Float32Array(Re),xt=new Float32Array(p.buffer,ke,Re);return Xe.set(xt),Xe}const We=ke%4;return We&&(ke=Math.max(0,ke-We)),new Float32Array(p.buffer,ke,Re)}}return ce?p.slice():p}}ut._Counter=0,ut.BYTE=5120,ut.UNSIGNED_BYTE=5121,ut.SHORT=5122,ut.UNSIGNED_SHORT=5123,ut.INT=5124,ut.UNSIGNED_INT=5125,ut.FLOAT=5126,ut.PositionKind="position",ut.NormalKind="normal",ut.TangentKind="tangent",ut.UVKind="uv",ut.UV2Kind="uv2",ut.UV3Kind="uv3",ut.UV4Kind="uv4",ut.UV5Kind="uv5",ut.UV6Kind="uv6",ut.ColorKind="color",ut.ColorInstanceKind="instanceColor",ut.MatricesIndicesKind="matricesIndices",ut.MatricesWeightsKind="matricesWeights",ut.MatricesIndicesExtraKind="matricesIndicesExtra",ut.MatricesWeightsExtraKind="matricesWeightsExtra";class nm{constructor(){this.hit=!1,this.distance=0,this.pickedPoint=null,this.pickedMesh=null,this.bu=0,this.bv=0,this.faceId=-1,this.subMeshFaceId=-1,this.subMeshId=0,this.pickedSprite=null,this.thinInstanceIndex=-1,this.ray=null,this.originMesh=null,this.aimTransform=null,this.gripTransform=null}getNormal(p=!1,_=!0){if(!this.pickedMesh||_&&!this.pickedMesh.isVerticesDataPresent(ut.NormalKind))return null;let E=this.pickedMesh.getIndices();E?.length===0&&(E=null);let A;const $=pi.Vector3[0],ne=pi.Vector3[1],xe=pi.Vector3[2];if(_){const Te=this.pickedMesh.getVerticesData(ut.NormalKind);let Re=E?nt.FromArrayToRef(Te,E[this.faceId*3]*3,$):$.copyFromFloats(Te[this.faceId*3*3],Te[this.faceId*3*3+1],Te[this.faceId*3*3+2]),ke=E?nt.FromArrayToRef(Te,E[this.faceId*3+1]*3,ne):ne.copyFromFloats(Te[(this.faceId*3+1)*3],Te[(this.faceId*3+1)*3+1],Te[(this.faceId*3+1)*3+2]),We=E?nt.FromArrayToRef(Te,E[this.faceId*3+2]*3,xe):xe.copyFromFloats(Te[(this.faceId*3+2)*3],Te[(this.faceId*3+2)*3+1],Te[(this.faceId*3+2)*3+2]);Re=Re.scale(this.bu),ke=ke.scale(this.bv),We=We.scale(1-this.bu-this.bv),A=new nt(Re.x+ke.x+We.x,Re.y+ke.y+We.y,Re.z+ke.z+We.z)}else{const Te=this.pickedMesh.getVerticesData(ut.PositionKind),Re=E?nt.FromArrayToRef(Te,E[this.faceId*3]*3,$):$.copyFromFloats(Te[this.faceId*3*3],Te[this.faceId*3*3+1],Te[this.faceId*3*3+2]),ke=E?nt.FromArrayToRef(Te,E[this.faceId*3+1]*3,ne):ne.copyFromFloats(Te[(this.faceId*3+1)*3],Te[(this.faceId*3+1)*3+1],Te[(this.faceId*3+1)*3+2]),We=E?nt.FromArrayToRef(Te,E[this.faceId*3+2]*3,xe):xe.copyFromFloats(Te[(this.faceId*3+2)*3],Te[(this.faceId*3+2)*3+1],Te[(this.faceId*3+2)*3+2]),Xe=Re.subtract(ke),xt=We.subtract(ke);A=nt.Cross(Xe,xt)}const ce=(Te,Re)=>{let ke=Te.getWorldMatrix();Te.nonUniformScaling&&(pi.Matrix[0].copyFrom(ke),ke=pi.Matrix[0],ke.setTranslationFromFloats(0,0,0),ke.invert(),ke.transposeToRef(pi.Matrix[1]),ke=pi.Matrix[1]),nt.TransformNormalToRef(Re,ke,Re)};if(p&&ce(this.pickedMesh,A),this.ray){const Te=pi.Vector3[0].copyFrom(A);p||ce(this.pickedMesh,Te),nt.Dot(Te,this.ray.direction)>0&&A.negateInPlace()}return A.normalize(),A}getTextureCoordinates(p=ut.UVKind){if(!this.pickedMesh||!this.pickedMesh.isVerticesDataPresent(p))return null;const _=this.pickedMesh.getIndices();if(!_)return null;const E=this.pickedMesh.getVerticesData(p);if(!E)return null;let A=xr.FromArray(E,_[this.faceId*3]*2),$=xr.FromArray(E,_[this.faceId*3+1]*2),ne=xr.FromArray(E,_[this.faceId*3+2]*2);return A=A.scale(this.bu),$=$.scale(this.bv),ne=ne.scale(1-this.bu-this.bv),new xr(A.x+$.x+ne.x,A.y+$.y+ne.y)}}class no{constructor(p,_,E,A,$,ne){this.source=p,this.pointerX=_,this.pointerY=E,this.meshUnderPointer=A,this.sourceEvent=$,this.additionalData=ne}static CreateNew(p,_,E){const A=p.getScene();return new no(p,A.pointerX,A.pointerY,A.meshUnderPointer||p,_,E)}static CreateNewFromSprite(p,_,E,A){return new no(p,_.pointerX,_.pointerY,_.meshUnderPointer,E,A)}static CreateNewFromScene(p,_){return new no(null,p.pointerX,p.pointerY,p.meshUnderPointer,_)}static CreateNewFromPrimitive(p,_,E,A){return new no(p,_.x,_.y,null,E,A)}}class qm{constructor(p){this._vertexBuffers={},this._scene=p}_prepareBuffers(){if(this._vertexBuffers[ut.PositionKind])return;const p=[];p.push(1,1),p.push(-1,1),p.push(-1,-1),p.push(1,-1),this._vertexBuffers[ut.PositionKind]=new ut(this._scene.getEngine(),p,ut.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const p=[];p.push(0),p.push(1),p.push(2),p.push(0),p.push(2),p.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(p)}_rebuild(){const p=this._vertexBuffers[ut.PositionKind];p&&(p._rebuild(),this._buildIndexBuffer())}_prepareFrame(p=null,_=null){const E=this._scene.activeCamera;return!E||(_=_||E._postProcesses.filter(A=>A!=null),!_||_.length===0||!this._scene.postProcessesEnabled)?!1:(_[0].activate(E,p,_!=null),!0)}directRender(p,_=null,E=!1,A=0,$=0,ne=!1){const xe=this._scene.getEngine();for(let ce=0;ce<p.length;ce++){ce<p.length-1?p[ce+1].activate(this._scene.activeCamera,_?.texture):(_?xe.bindFramebuffer(_,A,void 0,void 0,E,$):ne||xe.restoreDefaultFramebuffer(),xe._debugInsertMarker?.(`post process ${p[ce].name} output`));const Te=p[ce],Re=Te.apply();Re&&(Te.onBeforeRenderObservable.notifyObservers(Re),this._prepareBuffers(),xe.bindBuffers(this._vertexBuffers,this._indexBuffer,Re),xe.drawElementsType(0,0,6),Te.onAfterRenderObservable.notifyObservers(Re))}xe.setDepthBuffer(!0),xe.setDepthWrite(!0)}_finalizeFrame(p,_,E,A,$=!1){const ne=this._scene.activeCamera;if(!ne||(A=A||ne._postProcesses.filter(ce=>ce!=null),A.length===0||!this._scene.postProcessesEnabled))return;const xe=this._scene.getEngine();for(let ce=0,Te=A.length;ce<Te;ce++){const Re=A[ce];if(ce<Te-1?Re._outputTexture=A[ce+1].activate(ne,_?.texture):(_?(xe.bindFramebuffer(_,E,void 0,void 0,$),Re._outputTexture=_):(xe.restoreDefaultFramebuffer(),Re._outputTexture=null),xe._debugInsertMarker?.(`post process ${A[ce].name} output`)),p)break;const ke=Re.apply();ke&&(Re.onBeforeRenderObservable.notifyObservers(ke),this._prepareBuffers(),xe.bindBuffers(this._vertexBuffers,this._indexBuffer,ke),xe.drawElementsType(0,0,6),Re.onAfterRenderObservable.notifyObservers(ke))}xe.setDepthBuffer(!0),xe.setDepthWrite(!0),xe.setAlphaMode(0)}dispose(){const p=this._vertexBuffers[ut.PositionKind];p&&(p.dispose(),this._vertexBuffers[ut.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}class zl{set opaqueSortCompareFn(p){p?this._opaqueSortCompareFn=p:this._opaqueSortCompareFn=zl.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(p){p?this._alphaTestSortCompareFn=p:this._alphaTestSortCompareFn=zl.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(p){p?this._transparentSortCompareFn=p:this._transparentSortCompareFn=zl.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(p,_,E=null,A=null,$=null){this.index=p,this._opaqueSubMeshes=new _t(256),this._transparentSubMeshes=new _t(256),this._alphaTestSubMeshes=new _t(256),this._depthOnlySubMeshes=new _t(256),this._particleSystems=new _t(256),this._spriteManagers=new _t(256),this._empty=!0,this._edgesRenderers=new vt(16),this._scene=_,this.opaqueSortCompareFn=E,this.alphaTestSortCompareFn=A,this.transparentSortCompareFn=$}render(p,_,E,A){if(p){p(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);return}const $=this._scene.getEngine();this._depthOnlySubMeshes.length!==0&&($.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),$.setColorWrite(!0)),this._opaqueSubMeshes.length!==0&&this._renderOpaque(this._opaqueSubMeshes),this._alphaTestSubMeshes.length!==0&&this._renderAlphaTest(this._alphaTestSubMeshes);const ne=$.getStencilBuffer();if($.setStencilBuffer(!1),_&&this._renderSprites(),E&&this._renderParticles(A),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),this._transparentSubMeshes.length!==0||this._scene.useOrderIndependentTransparency){if($.setStencilBuffer(ne),this._scene.useOrderIndependentTransparency){const xe=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);xe.length&&this._renderTransparent(xe)}else this._renderTransparent(this._transparentSubMeshes);$.setAlphaMode(0)}if($.setStencilBuffer(!1),this._edgesRenderers.length){for(let xe=0;xe<this._edgesRenderers.length;xe++)this._edgesRenderers.data[xe].render();$.setAlphaMode(0)}$.setStencilBuffer(ne)}_renderOpaqueSorted(p){zl._RenderSorted(p,this._opaqueSortCompareFn,this._scene.activeCamera,!1)}_renderAlphaTestSorted(p){zl._RenderSorted(p,this._alphaTestSortCompareFn,this._scene.activeCamera,!1)}_renderTransparentSorted(p){zl._RenderSorted(p,this._transparentSortCompareFn,this._scene.activeCamera,!0)}static _RenderSorted(p,_,E,A){let $=0,ne;const xe=E?E.globalPosition:zl._ZeroVector;if(A)for(;$<p.length;$++)ne=p.data[$],ne._alphaIndex=ne.getMesh().alphaIndex,ne._distanceToCamera=nt.Distance(ne.getBoundingInfo().boundingSphere.centerWorld,xe);const ce=p.length===p.data.length?p.data:p.data.slice(0,p.length);_&&ce.sort(_);const Te=ce[0].getMesh().getScene();for($=0;$<ce.length;$++)if(ne=ce[$],!(Te._activeMeshesFrozenButKeepClipping&&!ne.isInFrustum(Te._frustumPlanes))){if(A){const Re=ne.getMaterial();if(Re&&Re.needDepthPrePass){const ke=Re.getScene().getEngine();ke.setColorWrite(!1),ke.setAlphaMode(0),ne.render(!1),ke.setColorWrite(!0)}}ne.render(A)}}static defaultTransparentSortCompare(p,_){return p._alphaIndex>_._alphaIndex?1:p._alphaIndex<_._alphaIndex?-1:zl.backToFrontSortCompare(p,_)}static backToFrontSortCompare(p,_){return p._distanceToCamera<_._distanceToCamera?1:p._distanceToCamera>_._distanceToCamera?-1:0}static frontToBackSortCompare(p,_){return p._distanceToCamera<_._distanceToCamera?-1:p._distanceToCamera>_._distanceToCamera?1:0}static PainterSortCompare(p,_){const E=p.getMesh(),A=_.getMesh();return E.material&&A.material?E.material.uniqueId-A.material.uniqueId:E.uniqueId-A.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(p,_,E){_===void 0&&(_=p.getMesh()),E===void 0&&(E=p.getMaterial()),E!=null&&(E.needAlphaBlendingForMesh(_)?this._transparentSubMeshes.push(p):E.needAlphaTesting()?(E.needDepthPrePass&&this._depthOnlySubMeshes.push(p),this._alphaTestSubMeshes.push(p)):(E.needDepthPrePass&&this._depthOnlySubMeshes.push(p),this._opaqueSubMeshes.push(p)),_._renderingGroup=this,_._edgesRenderer&&_._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(_._edgesRenderer),this._empty=!1)}dispatchSprites(p){this._spriteManagers.push(p),this._empty=!1}dispatchParticles(p){this._particleSystems.push(p),this._empty=!1}_renderParticles(p){if(this._particleSystems.length===0)return;const _=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let E=0;E<this._particleSystems.length;E++){const A=this._particleSystems.data[E];if((_&&_.layerMask&A.layerMask)===0)continue;const $=A.emitter;(!$.position||!p||p.indexOf($)!==-1)&&this._scene._activeParticles.addCount(A.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||this._spriteManagers.length===0)return;const p=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let _=0;_<this._spriteManagers.length;_++){const E=this._spriteManagers.data[_];(p&&p.layerMask&E.layerMask)!==0&&E.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}zl._ZeroVector=nt.Zero();class YO{}class ao{get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(p){p!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=p,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const p of this._scene.meshes)if(p.subMeshes)for(const _ of p.subMeshes)_._wasDispatched=!1;if(this._scene.spriteManagers)for(const p of this._scene.spriteManagers)p._wasDispatched=!1;for(const p of this._scene.particleSystems)p._wasDispatched=!1}constructor(p){this._useSceneAutoClearSetup=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new YO,this._maintainStateBetweenFrames=!1,this._scene=p;for(let _=ao.MIN_RENDERINGGROUPS;_<ao.MAX_RENDERINGGROUPS;_++)this._autoClearDepthStencil[_]={autoClear:!0,depth:!0,stencil:!0}}getRenderingGroup(p){const _=p||0;return this._prepareRenderingGroup(_),this._renderingGroups[_]}_clearDepthStencilBuffer(p=!0,_=!0){this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,p,_),this._depthStencilBufferAlreadyCleaned=!0)}render(p,_,E,A){const $=this._renderingGroupInfo;if($.scene=this._scene,$.camera=this._scene.activeCamera,this._scene.spriteManagers&&A)for(let ne=0;ne<this._scene.spriteManagers.length;ne++){const xe=this._scene.spriteManagers[ne];this.dispatchSprites(xe)}for(let ne=ao.MIN_RENDERINGGROUPS;ne<ao.MAX_RENDERINGGROUPS;ne++){this._depthStencilBufferAlreadyCleaned=ne===ao.MIN_RENDERINGGROUPS;const xe=this._renderingGroups[ne];if(!xe||xe._empty)continue;const ce=1<<ne;if($.renderingGroupId=ne,this._scene.onBeforeRenderingGroupObservable.notifyObservers($,ce),ao.AUTOCLEAR){const Te=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(ne):this._autoClearDepthStencil[ne];Te&&Te.autoClear&&this._clearDepthStencilBuffer(Te.depth,Te.stencil)}for(const Te of this._scene._beforeRenderingGroupDrawStage)Te.action(ne);xe.render(p,A,E,_);for(const Te of this._scene._afterRenderingGroupDrawStage)Te.action(ne);this._scene.onAfterRenderingGroupObservable.notifyObservers($,ce)}}reset(){if(!this.maintainStateBetweenFrames)for(let p=ao.MIN_RENDERINGGROUPS;p<ao.MAX_RENDERINGGROUPS;p++){const _=this._renderingGroups[p];_&&_.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let p=ao.MIN_RENDERINGGROUPS;p<ao.MAX_RENDERINGGROUPS;p++){const _=this._renderingGroups[p];_&&_.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let p=ao.MIN_RENDERINGGROUPS;p<ao.MAX_RENDERINGGROUPS;p++){const _=this._renderingGroups[p];_&&_.dispose()}}_prepareRenderingGroup(p){this._renderingGroups[p]===void 0&&(this._renderingGroups[p]=new zl(p,this._scene,this._customOpaqueSortCompareFn[p],this._customAlphaTestSortCompareFn[p],this._customTransparentSortCompareFn[p]))}dispatchSprites(p){this.maintainStateBetweenFrames&&p._wasDispatched||(p._wasDispatched=!0,this.getRenderingGroup(p.renderingGroupId).dispatchSprites(p))}dispatchParticles(p){this.maintainStateBetweenFrames&&p._wasDispatched||(p._wasDispatched=!0,this.getRenderingGroup(p.renderingGroupId).dispatchParticles(p))}dispatch(p,_,E){_===void 0&&(_=p.getMesh()),!(this.maintainStateBetweenFrames&&p._wasDispatched)&&(p._wasDispatched=!0,this.getRenderingGroup(_.renderingGroupId).dispatch(p,_,E))}setRenderingOrder(p,_=null,E=null,A=null){if(this._customOpaqueSortCompareFn[p]=_,this._customAlphaTestSortCompareFn[p]=E,this._customTransparentSortCompareFn[p]=A,this._renderingGroups[p]){const $=this._renderingGroups[p];$.opaqueSortCompareFn=this._customOpaqueSortCompareFn[p],$.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[p],$.transparentSortCompareFn=this._customTransparentSortCompareFn[p]}}setRenderingAutoClearDepthStencil(p,_,E=!0,A=!0){this._autoClearDepthStencil[p]={autoClear:_,depth:E,stencil:A}}getAutoClearDepthStencilSetup(p){return this._autoClearDepthStencil[p]}}ao.MAX_RENDERINGGROUPS=4,ao.MIN_RENDERINGGROUPS=0,ao.AUTOCLEAR=!0;class _r{}_r.NAME_EFFECTLAYER="EffectLayer",_r.NAME_LAYER="Layer",_r.NAME_LENSFLARESYSTEM="LensFlareSystem",_r.NAME_BOUNDINGBOXRENDERER="BoundingBoxRenderer",_r.NAME_PARTICLESYSTEM="ParticleSystem",_r.NAME_GAMEPAD="Gamepad",_r.NAME_SIMPLIFICATIONQUEUE="SimplificationQueue",_r.NAME_GEOMETRYBUFFERRENDERER="GeometryBufferRenderer",_r.NAME_PREPASSRENDERER="PrePassRenderer",_r.NAME_DEPTHRENDERER="DepthRenderer",_r.NAME_DEPTHPEELINGRENDERER="DepthPeelingRenderer",_r.NAME_POSTPROCESSRENDERPIPELINEMANAGER="PostProcessRenderPipelineManager",_r.NAME_SPRITE="Sprite",_r.NAME_SUBSURFACE="SubSurface",_r.NAME_OUTLINERENDERER="Outline",_r.NAME_PROCEDURALTEXTURE="ProceduralTexture",_r.NAME_SHADOWGENERATOR="ShadowGenerator",_r.NAME_OCTREE="Octree",_r.NAME_PHYSICSENGINE="PhysicsEngine",_r.NAME_AUDIO="Audio",_r.NAME_FLUIDRENDERER="FluidRenderer",_r.STEP_ISREADYFORMESH_EFFECTLAYER=0,_r.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER=0,_r.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER=0,_r.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER=0,_r.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER=1,_r.STEP_BEFORECAMERADRAW_PREPASS=0,_r.STEP_BEFORECAMERADRAW_EFFECTLAYER=1,_r.STEP_BEFORECAMERADRAW_LAYER=2,_r.STEP_BEFORERENDERTARGETDRAW_PREPASS=0,_r.STEP_BEFORERENDERTARGETDRAW_LAYER=1,_r.STEP_BEFORERENDERINGMESH_PREPASS=0,_r.STEP_BEFORERENDERINGMESH_OUTLINE=1,_r.STEP_AFTERRENDERINGMESH_PREPASS=0,_r.STEP_AFTERRENDERINGMESH_OUTLINE=1,_r.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW=0,_r.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER=1,_r.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE=0,_r.STEP_BEFORECAMERAUPDATE_GAMEPAD=1,_r.STEP_BEFORECLEAR_PROCEDURALTEXTURE=0,_r.STEP_BEFORECLEAR_PREPASS=1,_r.STEP_BEFORERENDERTARGETCLEAR_PREPASS=0,_r.STEP_AFTERRENDERTARGETDRAW_PREPASS=0,_r.STEP_AFTERRENDERTARGETDRAW_LAYER=1,_r.STEP_AFTERCAMERADRAW_PREPASS=0,_r.STEP_AFTERCAMERADRAW_EFFECTLAYER=1,_r.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM=2,_r.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW=3,_r.STEP_AFTERCAMERADRAW_LAYER=4,_r.STEP_AFTERCAMERADRAW_FLUIDRENDERER=5,_r.STEP_AFTERCAMERAPOSTPROCESS_LAYER=0,_r.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER=0,_r.STEP_AFTERRENDER_AUDIO=0,_r.STEP_GATHERRENDERTARGETS_DEPTHRENDERER=0,_r.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER=1,_r.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR=2,_r.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER=3,_r.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER=0,_r.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER=1,_r.STEP_POINTERMOVE_SPRITE=0,_r.STEP_POINTERDOWN_SPRITE=0,_r.STEP_POINTERUP_SPRITE=0;class qa extends Array{constructor(p){super(...p)}static Create(){return Object.create(qa.prototype)}registerStep(p,_,E){let A=0,$=Number.MAX_VALUE;for(;A<this.length&&($=this[A].index,!(p<$));A++);this.splice(A,0,{index:p,component:_,action:E.bind(_)})}clear(){this.length=0}}class Kr{}Kr.POINTERDOWN=1,Kr.POINTERUP=2,Kr.POINTERMOVE=4,Kr.POINTERWHEEL=8,Kr.POINTERPICK=16,Kr.POINTERTAP=32,Kr.POINTERDOUBLETAP=64;class hb{constructor(p,_){this.type=p,this.event=_}}class jO extends hb{constructor(p,_,E,A){super(p,_),this.ray=null,this.originalPickingInfo=null,this.skipOnPointerObservable=!1,this.localPosition=new xr(E,A)}}class nh extends hb{get pickInfo(){return this._pickInfo||this._generatePickInfo(),this._pickInfo}constructor(p,_,E,A=null){super(p,_),this._pickInfo=E,this._inputManager=A}_generatePickInfo(){this._inputManager&&(this._pickInfo=this._inputManager._pickMove(this.event),this._inputManager._setRayOnPointerInfo(this._pickInfo,this.event),this._inputManager=null)}}class Xx{constructor(){this.hoverCursor="",this.actions=[],this.isRecursive=!1}static get HasTriggers(){for(const p in Xx.Triggers)if(Object.prototype.hasOwnProperty.call(Xx.Triggers,p))return!0;return!1}static get HasPickTriggers(){for(const p in Xx.Triggers)if(Object.prototype.hasOwnProperty.call(Xx.Triggers,p)){const _=parseInt(p);if(_>=1&&_<=7)return!0}return!1}static HasSpecificTrigger(p){for(const _ in Xx.Triggers)if(Object.prototype.hasOwnProperty.call(Xx.Triggers,_)&&parseInt(_)===p)return!0;return!1}}Xx.Triggers={};class Ru{}Ru.KEYDOWN=1,Ru.KEYUP=2;class n_{constructor(p,_){this.type=p,this.event=_}}class cb extends n_{get skipOnPointerObservable(){return this.skipOnKeyboardObservable}set skipOnPointerObservable(p){this.skipOnKeyboardObservable=p}constructor(p,_){super(p,_),this.type=p,this.event=_,this.skipOnKeyboardObservable=!1}}var ar;(function(_e){_e[_e.Generic=0]="Generic",_e[_e.Keyboard=1]="Keyboard",_e[_e.Mouse=2]="Mouse",_e[_e.Touch=3]="Touch",_e[_e.DualShock=4]="DualShock",_e[_e.Xbox=5]="Xbox",_e[_e.Switch=6]="Switch",_e[_e.DualSense=7]="DualSense"})(ar||(ar={}));var Ur;(function(_e){_e[_e.Horizontal=0]="Horizontal",_e[_e.Vertical=1]="Vertical",_e[_e.LeftClick=2]="LeftClick",_e[_e.MiddleClick=3]="MiddleClick",_e[_e.RightClick=4]="RightClick",_e[_e.BrowserBack=5]="BrowserBack",_e[_e.BrowserForward=6]="BrowserForward",_e[_e.MouseWheelX=7]="MouseWheelX",_e[_e.MouseWheelY=8]="MouseWheelY",_e[_e.MouseWheelZ=9]="MouseWheelZ",_e[_e.Move=12]="Move"})(Ur||(Ur={}));var $m;(function(_e){_e[_e.Horizontal=0]="Horizontal",_e[_e.Vertical=1]="Vertical",_e[_e.LeftClick=2]="LeftClick",_e[_e.MiddleClick=3]="MiddleClick",_e[_e.RightClick=4]="RightClick",_e[_e.BrowserBack=5]="BrowserBack",_e[_e.BrowserForward=6]="BrowserForward",_e[_e.MouseWheelX=7]="MouseWheelX",_e[_e.MouseWheelY=8]="MouseWheelY",_e[_e.MouseWheelZ=9]="MouseWheelZ",_e[_e.DeltaHorizontal=10]="DeltaHorizontal",_e[_e.DeltaVertical=11]="DeltaVertical"})($m||($m={}));var ub;(function(_e){_e[_e.Cross=0]="Cross",_e[_e.Circle=1]="Circle",_e[_e.Square=2]="Square",_e[_e.Triangle=3]="Triangle",_e[_e.L1=4]="L1",_e[_e.R1=5]="R1",_e[_e.L2=6]="L2",_e[_e.R2=7]="R2",_e[_e.Share=8]="Share",_e[_e.Options=9]="Options",_e[_e.L3=10]="L3",_e[_e.R3=11]="R3",_e[_e.DPadUp=12]="DPadUp",_e[_e.DPadDown=13]="DPadDown",_e[_e.DPadLeft=14]="DPadLeft",_e[_e.DPadRight=15]="DPadRight",_e[_e.Home=16]="Home",_e[_e.TouchPad=17]="TouchPad",_e[_e.LStickXAxis=18]="LStickXAxis",_e[_e.LStickYAxis=19]="LStickYAxis",_e[_e.RStickXAxis=20]="RStickXAxis",_e[_e.RStickYAxis=21]="RStickYAxis"})(ub||(ub={}));var pb;(function(_e){_e[_e.Cross=0]="Cross",_e[_e.Circle=1]="Circle",_e[_e.Square=2]="Square",_e[_e.Triangle=3]="Triangle",_e[_e.L1=4]="L1",_e[_e.R1=5]="R1",_e[_e.L2=6]="L2",_e[_e.R2=7]="R2",_e[_e.Create=8]="Create",_e[_e.Options=9]="Options",_e[_e.L3=10]="L3",_e[_e.R3=11]="R3",_e[_e.DPadUp=12]="DPadUp",_e[_e.DPadDown=13]="DPadDown",_e[_e.DPadLeft=14]="DPadLeft",_e[_e.DPadRight=15]="DPadRight",_e[_e.Home=16]="Home",_e[_e.TouchPad=17]="TouchPad",_e[_e.LStickXAxis=18]="LStickXAxis",_e[_e.LStickYAxis=19]="LStickYAxis",_e[_e.RStickXAxis=20]="RStickXAxis",_e[_e.RStickYAxis=21]="RStickYAxis"})(pb||(pb={}));var _b;(function(_e){_e[_e.A=0]="A",_e[_e.B=1]="B",_e[_e.X=2]="X",_e[_e.Y=3]="Y",_e[_e.LB=4]="LB",_e[_e.RB=5]="RB",_e[_e.LT=6]="LT",_e[_e.RT=7]="RT",_e[_e.Back=8]="Back",_e[_e.Start=9]="Start",_e[_e.LS=10]="LS",_e[_e.RS=11]="RS",_e[_e.DPadUp=12]="DPadUp",_e[_e.DPadDown=13]="DPadDown",_e[_e.DPadLeft=14]="DPadLeft",_e[_e.DPadRight=15]="DPadRight",_e[_e.Home=16]="Home",_e[_e.LStickXAxis=17]="LStickXAxis",_e[_e.LStickYAxis=18]="LStickYAxis",_e[_e.RStickXAxis=19]="RStickXAxis",_e[_e.RStickYAxis=20]="RStickYAxis"})(_b||(_b={}));var Tb;(function(_e){_e[_e.B=0]="B",_e[_e.A=1]="A",_e[_e.Y=2]="Y",_e[_e.X=3]="X",_e[_e.L=4]="L",_e[_e.R=5]="R",_e[_e.ZL=6]="ZL",_e[_e.ZR=7]="ZR",_e[_e.Minus=8]="Minus",_e[_e.Plus=9]="Plus",_e[_e.LS=10]="LS",_e[_e.RS=11]="RS",_e[_e.DPadUp=12]="DPadUp",_e[_e.DPadDown=13]="DPadDown",_e[_e.DPadLeft=14]="DPadLeft",_e[_e.DPadRight=15]="DPadRight",_e[_e.Home=16]="Home",_e[_e.Capture=17]="Capture",_e[_e.LStickXAxis=18]="LStickXAxis",_e[_e.LStickYAxis=19]="LStickYAxis",_e[_e.RStickXAxis=20]="RStickXAxis",_e[_e.RStickYAxis=21]="RStickYAxis"})(Tb||(Tb={}));var vb;(function(_e){_e[_e.PointerMove=0]="PointerMove",_e[_e.PointerDown=1]="PointerDown",_e[_e.PointerUp=2]="PointerUp"})(vb||(vb={}));class Mu{}Mu.DOM_DELTA_PIXEL=0,Mu.DOM_DELTA_LINE=1,Mu.DOM_DELTA_PAGE=2;class qc{static CreateDeviceEvent(p,_,E,A,$,ne,xe){switch(p){case ar.Keyboard:return this._CreateKeyboardEvent(E,A,$,ne);case ar.Mouse:if(E===Ur.MouseWheelX||E===Ur.MouseWheelY||E===Ur.MouseWheelZ)return this._CreateWheelEvent(p,_,E,A,$,ne);case ar.Touch:return this._CreatePointerEvent(p,_,E,A,$,ne,xe);default:throw`Unable to generate event for device ${ar[p]}`}}static _CreatePointerEvent(p,_,E,A,$,ne,xe){const ce=this._CreateMouseEvent(p,_,E,A,$,ne);p===ar.Mouse?(ce.deviceType=ar.Mouse,ce.pointerId=1,ce.pointerType="mouse"):(ce.deviceType=ar.Touch,ce.pointerId=xe??_,ce.pointerType="touch");let Te=0;return Te+=$.pollInput(p,_,Ur.LeftClick),Te+=$.pollInput(p,_,Ur.RightClick)*2,Te+=$.pollInput(p,_,Ur.MiddleClick)*4,ce.buttons=Te,E===Ur.Move?ce.type="pointermove":E>=Ur.LeftClick&&E<=Ur.RightClick&&(ce.type=A===1?"pointerdown":"pointerup",ce.button=E-2),ce}static _CreateWheelEvent(p,_,E,A,$,ne){const xe=this._CreateMouseEvent(p,_,E,A,$,ne);switch(xe.pointerId=1,xe.type="wheel",xe.deltaMode=Mu.DOM_DELTA_PIXEL,xe.deltaX=0,xe.deltaY=0,xe.deltaZ=0,E){case Ur.MouseWheelX:xe.deltaX=A;break;case Ur.MouseWheelY:xe.deltaY=A;break;case Ur.MouseWheelZ:xe.deltaZ=A;break}return xe}static _CreateMouseEvent(p,_,E,A,$,ne){const xe=this._CreateEvent(ne),ce=$.pollInput(p,_,Ur.Horizontal),Te=$.pollInput(p,_,Ur.Vertical);return ne?(xe.movementX=0,xe.movementY=0,xe.offsetX=xe.movementX-ne.getBoundingClientRect().x,xe.offsetY=xe.movementY-ne.getBoundingClientRect().y):(xe.movementX=$.pollInput(p,_,$m.DeltaHorizontal),xe.movementY=$.pollInput(p,_,$m.DeltaVertical),xe.offsetX=0,xe.offsetY=0),this._CheckNonCharacterKeys(xe,$),xe.clientX=ce,xe.clientY=Te,xe.x=ce,xe.y=Te,xe.deviceType=p,xe.deviceSlot=_,xe.inputIndex=E,xe}static _CreateKeyboardEvent(p,_,E,A){const $=this._CreateEvent(A);return this._CheckNonCharacterKeys($,E),$.deviceType=ar.Keyboard,$.deviceSlot=0,$.inputIndex=p,$.type=_===1?"keydown":"keyup",$.key=String.fromCharCode(p),$.keyCode=p,$}static _CheckNonCharacterKeys(p,_){const E=_.isDeviceAvailable(ar.Keyboard),A=E&&_.pollInput(ar.Keyboard,0,18)===1,$=E&&_.pollInput(ar.Keyboard,0,17)===1,ne=E&&(_.pollInput(ar.Keyboard,0,91)===1||_.pollInput(ar.Keyboard,0,92)===1||_.pollInput(ar.Keyboard,0,93)===1),xe=E&&_.pollInput(ar.Keyboard,0,16)===1;p.altKey=A,p.ctrlKey=$,p.metaKey=ne,p.shiftKey=xe}static _CreateEvent(p){const _={};return _.preventDefault=()=>{},_.target=p,_}}class qO{constructor(p,_,E){this._nativeInput=_native.DeviceInputSystem?new _native.DeviceInputSystem(p,_,(A,$,ne,xe)=>{const ce=qc.CreateDeviceEvent(A,$,ne,xe,this);E(A,$,ce)}):this._createDummyNativeInput()}pollInput(p,_,E){return this._nativeInput.pollInput(p,_,E)}isDeviceAvailable(p){return p===ar.Mouse||p===ar.Touch}dispose(){this._nativeInput.dispose()}_createDummyNativeInput(){return{pollInput:()=>0,isDeviceAvailable:()=>!1,dispose:()=>{}}}}const Rb=255,Mb=Object.keys(Ur).length/2;class $O{constructor(p,_,E,A){this._inputs=[],this._keyboardActive=!1,this._pointerActive=!1,this._usingSafari=ct.IsSafari(),this._usingMacOS=Ho()&&/(Mac|iPhone|iPod|iPad)/i.test(navigator.platform),this._keyboardDownEvent=$=>{},this._keyboardUpEvent=$=>{},this._keyboardBlurEvent=$=>{},this._pointerMoveEvent=$=>{},this._pointerDownEvent=$=>{},this._pointerUpEvent=$=>{},this._pointerCancelEvent=$=>{},this._pointerWheelEvent=$=>{},this._pointerBlurEvent=$=>{},this._pointerMacOSChromeOutEvent=$=>{},this._eventsAttached=!1,this._mouseId=-1,this._isUsingFirefox=Ho()&&navigator.userAgent&&navigator.userAgent.indexOf("Firefox")!==-1,this._isUsingChromium=Ho()&&navigator.userAgent&&navigator.userAgent.indexOf("Chrome")!==-1,this._maxTouchPoints=0,this._pointerInputClearObserver=null,this._gamepadConnectedEvent=$=>{},this._gamepadDisconnectedEvent=$=>{},this._eventPrefix=ct.GetPointerPrefix(p),this._engine=p,this._onDeviceConnected=_,this._onDeviceDisconnected=E,this._onInputChanged=A,this._mouseId=this._isUsingFirefox?0:1,this._enableEvents(),this._usingMacOS&&(this._metaKeys=[]),this._engine._onEngineViewChanged||(this._engine._onEngineViewChanged=()=>{this._enableEvents()})}pollInput(p,_,E){const A=this._inputs[p][_];if(!A)throw`Unable to find device ${ar[p]}`;p>=ar.DualShock&&p<=ar.DualSense&&this._updateDevice(p,_,E);const $=A[E];if($===void 0)throw`Unable to find input ${E} for device ${ar[p]} in slot ${_}`;return E===Ur.Move&&ct.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."),$}isDeviceAvailable(p){return this._inputs[p]!==void 0}dispose(){this._onDeviceConnected=()=>{},this._onDeviceDisconnected=()=>{},this._onInputChanged=()=>{},delete this._engine._onEngineViewChanged,this._elementToAttachTo&&this._disableEvents()}_enableEvents(){const p=this?._engine.getInputElement();if(p&&(!this._eventsAttached||this._elementToAttachTo!==p)){if(this._disableEvents(),this._inputs){for(const _ of this._inputs)if(_)for(const E in _){const A=+E,$=_[A];if($)for(let ne=0;ne<$.length;ne++)$[ne]=0}}this._elementToAttachTo=p,this._elementToAttachTo.tabIndex=this._elementToAttachTo.tabIndex!==-1?this._elementToAttachTo.tabIndex:this._engine.canvasTabIndex,this._handleKeyActions(),this._handlePointerActions(),this._handleGamepadActions(),this._eventsAttached=!0,this._checkForConnectedDevices()}}_disableEvents(){this._elementToAttachTo&&(this._elementToAttachTo.removeEventListener("blur",this._keyboardBlurEvent),this._elementToAttachTo.removeEventListener("blur",this._pointerBlurEvent),this._elementToAttachTo.removeEventListener("keydown",this._keyboardDownEvent),this._elementToAttachTo.removeEventListener("keyup",this._keyboardUpEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"move",this._pointerMoveEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"down",this._pointerDownEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"up",this._pointerUpEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"cancel",this._pointerCancelEvent),this._elementToAttachTo.removeEventListener(this._wheelEventName,this._pointerWheelEvent),this._usingMacOS&&this._isUsingChromium&&this._elementToAttachTo.removeEventListener("lostpointercapture",this._pointerMacOSChromeOutEvent),window.removeEventListener("gamepadconnected",this._gamepadConnectedEvent),window.removeEventListener("gamepaddisconnected",this._gamepadDisconnectedEvent)),this._pointerInputClearObserver&&this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver),this._eventsAttached=!1}_checkForConnectedDevices(){if(navigator.getGamepads){const p=navigator.getGamepads();for(const _ of p)_&&this._addGamePad(_)}typeof matchMedia=="function"&&matchMedia("(pointer:fine)").matches&&this._addPointerDevice(ar.Mouse,0,0,0)}_addGamePad(p){const _=this._getGamepadDeviceType(p.id),E=p.index;this._gamepads=this._gamepads||new Array(p.index+1),this._registerDevice(_,E,p.buttons.length+p.axes.length),this._gamepads[E]=_}_addPointerDevice(p,_,E,A){this._pointerActive||(this._pointerActive=!0),this._registerDevice(p,_,Mb);const $=this._inputs[p][_];$[0]=E,$[1]=A}_registerDevice(p,_,E){if(_===void 0)throw`Unable to register device ${ar[p]} to undefined slot.`;if(this._inputs[p]||(this._inputs[p]={}),!this._inputs[p][_]){const A=new Array(E);A.fill(0),this._inputs[p][_]=A,this._onDeviceConnected(p,_)}}_unregisterDevice(p,_){this._inputs[p][_]&&(delete this._inputs[p][_],this._onDeviceDisconnected(p,_))}_handleKeyActions(){this._keyboardDownEvent=p=>{this._keyboardActive||(this._keyboardActive=!0,this._registerDevice(ar.Keyboard,0,Rb));const _=this._inputs[ar.Keyboard][0];if(_){_[p.keyCode]=1;const E=p;E.inputIndex=p.keyCode,this._usingMacOS&&p.metaKey&&p.key!=="Meta"&&(this._metaKeys.includes(p.keyCode)||this._metaKeys.push(p.keyCode)),this._onInputChanged(ar.Keyboard,0,E)}},this._keyboardUpEvent=p=>{this._keyboardActive||(this._keyboardActive=!0,this._registerDevice(ar.Keyboard,0,Rb));const _=this._inputs[ar.Keyboard][0];if(_){_[p.keyCode]=0;const E=p;if(E.inputIndex=p.keyCode,this._usingMacOS&&p.key==="Meta"&&this._metaKeys.length>0){for(const A of this._metaKeys){const $=qc.CreateDeviceEvent(ar.Keyboard,0,A,0,this,this._elementToAttachTo);_[A]=0,this._onInputChanged(ar.Keyboard,0,$)}this._metaKeys.splice(0,this._metaKeys.length)}this._onInputChanged(ar.Keyboard,0,E)}},this._keyboardBlurEvent=()=>{if(this._keyboardActive){const p=this._inputs[ar.Keyboard][0];for(let _=0;_<p.length;_++)if(p[_]!==0){p[_]=0;const E=qc.CreateDeviceEvent(ar.Keyboard,0,_,0,this,this._elementToAttachTo);this._onInputChanged(ar.Keyboard,0,E)}this._usingMacOS&&this._metaKeys.splice(0,this._metaKeys.length)}},this._elementToAttachTo.addEventListener("keydown",this._keyboardDownEvent),this._elementToAttachTo.addEventListener("keyup",this._keyboardUpEvent),this._elementToAttachTo.addEventListener("blur",this._keyboardBlurEvent)}_handlePointerActions(){this._maxTouchPoints=Ho()&&navigator.maxTouchPoints||2,this._activeTouchIds||(this._activeTouchIds=new Array(this._maxTouchPoints));for(let E=0;E<this._maxTouchPoints;E++)this._activeTouchIds[E]=-1;this._pointerMoveEvent=E=>{const A=this._getPointerType(E);let $=A===ar.Mouse?0:this._activeTouchIds.indexOf(E.pointerId);if(A===ar.Touch&&$===-1){const xe=this._activeTouchIds.indexOf(-1);if(xe>=0)$=xe,this._activeTouchIds[xe]=E.pointerId,this._onDeviceConnected(A,$);else{ct.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);return}}this._inputs[A]||(this._inputs[A]={}),this._inputs[A][$]||this._addPointerDevice(A,$,E.clientX,E.clientY);const ne=this._inputs[A][$];if(ne){const xe=E;xe.inputIndex=Ur.Move,ne[Ur.Horizontal]=E.clientX,ne[Ur.Vertical]=E.clientY,A===ar.Touch&&ne[Ur.LeftClick]===0&&(ne[Ur.LeftClick]=1),E.pointerId===void 0&&(E.pointerId=this._mouseId),this._onInputChanged(A,$,xe),!this._usingSafari&&E.button!==-1&&(xe.inputIndex=E.button+2,ne[E.button+2]=ne[E.button+2]?0:1,this._onInputChanged(A,$,xe))}},this._pointerDownEvent=E=>{const A=this._getPointerType(E);let $=A===ar.Mouse?0:E.pointerId;if(A===ar.Touch){const xe=this._activeTouchIds.indexOf(-1);if(xe>=0)$=xe,this._activeTouchIds[xe]=E.pointerId;else{ct.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);return}}this._inputs[A]||(this._inputs[A]={}),this._inputs[A][$]?A===ar.Touch&&this._onDeviceConnected(A,$):this._addPointerDevice(A,$,E.clientX,E.clientY);const ne=this._inputs[A][$];if(ne){const xe=ne[Ur.Horizontal],ce=ne[Ur.Vertical];if(A===ar.Mouse){if(E.pointerId===void 0&&(E.pointerId=this._mouseId),!document.pointerLockElement)try{this._elementToAttachTo.setPointerCapture(this._mouseId)}catch{}}else if(E.pointerId&&!document.pointerLockElement)try{this._elementToAttachTo.setPointerCapture(E.pointerId)}catch{}ne[Ur.Horizontal]=E.clientX,ne[Ur.Vertical]=E.clientY,ne[E.button+2]=1;const Te=E;Te.inputIndex=E.button+2,this._onInputChanged(A,$,Te),(xe!==E.clientX||ce!==E.clientY)&&(Te.inputIndex=Ur.Move,this._onInputChanged(A,$,Te))}},this._pointerUpEvent=E=>{const A=this._getPointerType(E),$=A===ar.Mouse?0:this._activeTouchIds.indexOf(E.pointerId);if(A===ar.Touch){if($===-1)return;this._activeTouchIds[$]=-1}const ne=this._inputs[A]?.[$];if(ne&&ne[E.button+2]!==0){const xe=ne[Ur.Horizontal],ce=ne[Ur.Vertical];ne[Ur.Horizontal]=E.clientX,ne[Ur.Vertical]=E.clientY,ne[E.button+2]=0;const Te=E;E.pointerId===void 0&&(E.pointerId=this._mouseId),(xe!==E.clientX||ce!==E.clientY)&&(Te.inputIndex=Ur.Move,this._onInputChanged(A,$,Te)),Te.inputIndex=E.button+2,A===ar.Mouse&&this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)?this._elementToAttachTo.releasePointerCapture(this._mouseId):E.pointerId&&this._elementToAttachTo.hasPointerCapture?.(E.pointerId)&&this._elementToAttachTo.releasePointerCapture(E.pointerId),this._onInputChanged(A,$,Te),A===ar.Touch&&this._onDeviceDisconnected(A,$)}},this._pointerCancelEvent=E=>{if(E.pointerType==="mouse"){const A=this._inputs[ar.Mouse][0];this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)&&this._elementToAttachTo.releasePointerCapture(this._mouseId);for(let $=Ur.LeftClick;$<=Ur.BrowserForward;$++)if(A[$]===1){A[$]=0;const ne=qc.CreateDeviceEvent(ar.Mouse,0,$,0,this,this._elementToAttachTo);this._onInputChanged(ar.Mouse,0,ne)}}else{const A=this._activeTouchIds.indexOf(E.pointerId);if(A===-1)return;this._elementToAttachTo.hasPointerCapture?.(E.pointerId)&&this._elementToAttachTo.releasePointerCapture(E.pointerId),this._inputs[ar.Touch][A][Ur.LeftClick]=0;const $=qc.CreateDeviceEvent(ar.Touch,A,Ur.LeftClick,0,this,this._elementToAttachTo,E.pointerId);this._onInputChanged(ar.Touch,A,$),this._activeTouchIds[A]=-1,this._onDeviceDisconnected(ar.Touch,A)}},this._wheelEventName="onwheel"in document.createElement("div")?"wheel":document.onmousewheel!==void 0?"mousewheel":"DOMMouseScroll";let p=!1;const _=function(){};try{const E=Object.defineProperty({},"passive",{get:function(){p=!0}});this._elementToAttachTo.addEventListener("test",_,E),this._elementToAttachTo.removeEventListener("test",_,E)}catch{}this._pointerBlurEvent=()=>{if(this.isDeviceAvailable(ar.Mouse)){const E=this._inputs[ar.Mouse][0];this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)&&this._elementToAttachTo.releasePointerCapture(this._mouseId);for(let A=Ur.LeftClick;A<=Ur.BrowserForward;A++)if(E[A]===1){E[A]=0;const $=qc.CreateDeviceEvent(ar.Mouse,0,A,0,this,this._elementToAttachTo);this._onInputChanged(ar.Mouse,0,$)}}if(this.isDeviceAvailable(ar.Touch)){const E=this._inputs[ar.Touch];for(let A=0;A<this._activeTouchIds.length;A++){const $=this._activeTouchIds[A];if(this._elementToAttachTo.hasPointerCapture?.($)&&this._elementToAttachTo.releasePointerCapture($),$!==-1&&E[A]?.[Ur.LeftClick]===1){E[A][Ur.LeftClick]=0;const ne=qc.CreateDeviceEvent(ar.Touch,A,Ur.LeftClick,0,this,this._elementToAttachTo,$);this._onInputChanged(ar.Touch,A,ne),this._activeTouchIds[A]=-1,this._onDeviceDisconnected(ar.Touch,A)}}}},this._pointerWheelEvent=E=>{const A=ar.Mouse,$=0;this._inputs[A]||(this._inputs[A]=[]),this._inputs[A][$]||(this._pointerActive=!0,this._registerDevice(A,$,Mb));const ne=this._inputs[A][$];if(ne){ne[Ur.MouseWheelX]=E.deltaX||0,ne[Ur.MouseWheelY]=E.deltaY||E.wheelDelta||0,ne[Ur.MouseWheelZ]=E.deltaZ||0;const xe=E;E.pointerId===void 0&&(E.pointerId=this._mouseId),ne[Ur.MouseWheelX]!==0&&(xe.inputIndex=Ur.MouseWheelX,this._onInputChanged(A,$,xe)),ne[Ur.MouseWheelY]!==0&&(xe.inputIndex=Ur.MouseWheelY,this._onInputChanged(A,$,xe)),ne[Ur.MouseWheelZ]!==0&&(xe.inputIndex=Ur.MouseWheelZ,this._onInputChanged(A,$,xe))}},this._usingMacOS&&this._isUsingChromium&&(this._pointerMacOSChromeOutEvent=E=>{E.buttons>1&&this._pointerCancelEvent(E)},this._elementToAttachTo.addEventListener("lostpointercapture",this._pointerMacOSChromeOutEvent)),this._elementToAttachTo.addEventListener(this._eventPrefix+"move",this._pointerMoveEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"down",this._pointerDownEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"up",this._pointerUpEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"cancel",this._pointerCancelEvent),this._elementToAttachTo.addEventListener("blur",this._pointerBlurEvent),this._elementToAttachTo.addEventListener(this._wheelEventName,this._pointerWheelEvent,p?{passive:!1}:!1),this._pointerInputClearObserver=this._engine.onEndFrameObservable.add(()=>{if(this.isDeviceAvailable(ar.Mouse)){const E=this._inputs[ar.Mouse][0];E[Ur.MouseWheelX]=0,E[Ur.MouseWheelY]=0,E[Ur.MouseWheelZ]=0}})}_handleGamepadActions(){this._gamepadConnectedEvent=p=>{this._addGamePad(p.gamepad)},this._gamepadDisconnectedEvent=p=>{if(this._gamepads){const _=this._getGamepadDeviceType(p.gamepad.id),E=p.gamepad.index;this._unregisterDevice(_,E),delete this._gamepads[E]}},window.addEventListener("gamepadconnected",this._gamepadConnectedEvent),window.addEventListener("gamepaddisconnected",this._gamepadDisconnectedEvent)}_updateDevice(p,_,E){const A=navigator.getGamepads()[_];if(A&&p===this._gamepads[_]){const $=this._inputs[p][_];E>=A.buttons.length?$[E]=A.axes[E-A.buttons.length].valueOf():$[E]=A.buttons[E].value}}_getGamepadDeviceType(p){return p.indexOf("054c")!==-1?p.indexOf("0ce6")!==-1?ar.DualSense:ar.DualShock:p.indexOf("Xbox One")!==-1||p.search("Xbox 360")!==-1||p.search("xinput")!==-1?ar.Xbox:p.indexOf("057e")!==-1?ar.Switch:ar.Generic}_getPointerType(p){let _=ar.Mouse;return(p.pointerType==="touch"||p.pointerType==="pen"||p.touches)&&(_=ar.Touch),_}}class wb{constructor(p,_,E=0){this.deviceType=_,this.deviceSlot=E,this.onInputChangedObservable=new Mi,this._deviceInputSystem=p}getInput(p){return this._deviceInputSystem.pollInput(this.deviceType,this.deviceSlot,p)}}class rw{constructor(p){this._registeredManagers=new Array,this._refCount=0,this.registerManager=ne=>{for(let xe=0;xe<this._devices.length;xe++){const ce=this._devices[xe];for(const Te in ce){const Re=+Te;ne._addDevice(new wb(this._deviceInputSystem,xe,Re))}}this._registeredManagers.push(ne)},this.unregisterManager=ne=>{const xe=this._registeredManagers.indexOf(ne);xe>-1&&this._registeredManagers.splice(xe,1)};const _=Object.keys(ar).length/2;this._devices=new Array(_);const E=(ne,xe)=>{this._devices[ne]||(this._devices[ne]=new Array),this._devices[ne][xe]||(this._devices[ne][xe]=xe);for(const ce of this._registeredManagers){const Te=new wb(this._deviceInputSystem,ne,xe);ce._addDevice(Te)}},A=(ne,xe)=>{this._devices[ne]?.[xe]&&delete this._devices[ne][xe];for(const ce of this._registeredManagers)ce._removeDevice(ne,xe)},$=(ne,xe,ce)=>{if(ce)for(const Te of this._registeredManagers)Te._onInputChanged(ne,xe,ce)};typeof _native<"u"?this._deviceInputSystem=new qO(E,A,$):this._deviceInputSystem=new $O(p,E,A,$)}dispose(){this._deviceInputSystem.dispose()}}class nw{getDeviceSource(p,_){if(_===void 0){if(this._firstDevice[p]===void 0)return null;_=this._firstDevice[p]}return!this._devices[p]||this._devices[p][_]===void 0?null:this._devices[p][_]}getDeviceSources(p){return this._devices[p]?this._devices[p].filter(_=>!!_):[]}constructor(p){const _=Object.keys(ar).length/2;this._devices=new Array(_),this._firstDevice=new Array(_),this._engine=p,this._engine._deviceSourceManager||(this._engine._deviceSourceManager=new rw(p)),this._engine._deviceSourceManager._refCount++,this.onDeviceConnectedObservable=new Mi(E=>{for(const A of this._devices)if(A)for(const $ of A)$&&this.onDeviceConnectedObservable.notifyObserver(E,$)}),this.onDeviceDisconnectedObservable=new Mi,this._engine._deviceSourceManager.registerManager(this),this._onDisposeObserver=p.onDisposeObservable.add(()=>{this.dispose()})}dispose(){this.onDeviceConnectedObservable.clear(),this.onDeviceDisconnectedObservable.clear(),this._engine._deviceSourceManager&&(this._engine._deviceSourceManager.unregisterManager(this),--this._engine._deviceSourceManager._refCount<1&&(this._engine._deviceSourceManager.dispose(),delete this._engine._deviceSourceManager)),this._engine.onDisposeObservable.remove(this._onDisposeObserver)}_addDevice(p){this._devices[p.deviceType]||(this._devices[p.deviceType]=new Array),this._devices[p.deviceType][p.deviceSlot]||(this._devices[p.deviceType][p.deviceSlot]=p,this._updateFirstDevices(p.deviceType)),this.onDeviceConnectedObservable.notifyObservers(p)}_removeDevice(p,_){const E=this._devices[p]?.[_];this.onDeviceDisconnectedObservable.notifyObservers(E),this._devices[p]?.[_]&&delete this._devices[p][_],this._updateFirstDevices(p)}_onInputChanged(p,_,E){this._devices[p]?.[_]?.onInputChangedObservable.notifyObservers(E)}_updateFirstDevices(p){switch(p){case ar.Keyboard:case ar.Mouse:this._firstDevice[p]=0;break;case ar.Touch:case ar.DualSense:case ar.DualShock:case ar.Xbox:case ar.Switch:case ar.Generic:{delete this._firstDevice[p];const _=this._devices[p];if(_){for(let E=0;E<_.length;E++)if(_[E]){this._firstDevice[p]=E;break}}break}}}}class Lb{constructor(){this._singleClick=!1,this._doubleClick=!1,this._hasSwiped=!1,this._ignore=!1}get singleClick(){return this._singleClick}get doubleClick(){return this._doubleClick}get hasSwiped(){return this._hasSwiped}get ignore(){return this._ignore}set singleClick(p){this._singleClick=p}set doubleClick(p){this._doubleClick=p}set hasSwiped(p){this._hasSwiped=p}set ignore(p){this._ignore=p}}class $a{constructor(p){this._alreadyAttached=!1,this._meshPickProceed=!1,this._currentPickResult=null,this._previousPickResult=null,this._totalPointersPressed=0,this._doubleClickOccured=!1,this._isSwiping=!1,this._swipeButtonPressed=-1,this._skipPointerTap=!1,this._isMultiTouchGesture=!1,this._pointerX=0,this._pointerY=0,this._startingPointerPosition=new xr(0,0),this._previousStartingPointerPosition=new xr(0,0),this._startingPointerTime=0,this._previousStartingPointerTime=0,this._pointerCaptures={},this._meshUnderPointerId={},this._movePointerInfo=null,this._cameraObserverCount=0,this._delayedClicks=[null,null,null,null,null],this._deviceSourceManager=null,this._scene=p||wr.LastCreatedScene,this._scene}get meshUnderPointer(){return this._movePointerInfo&&(this._movePointerInfo._generatePickInfo(),this._movePointerInfo=null),this._pointerOverMesh}getMeshUnderPointerByPointerId(p){return this._meshUnderPointerId[p]||null}get unTranslatedPointer(){return new xr(this._unTranslatedPointerX,this._unTranslatedPointerY)}get pointerX(){return this._pointerX}set pointerX(p){this._pointerX=p}get pointerY(){return this._pointerY}set pointerY(p){this._pointerY=p}_updatePointerPosition(p){const _=this._scene.getEngine().getInputElementClientRect();_&&(this._pointerX=p.clientX-_.left,this._pointerY=p.clientY-_.top,this._unTranslatedPointerX=this._pointerX,this._unTranslatedPointerY=this._pointerY)}_processPointerMove(p,_){const E=this._scene,A=E.getEngine(),$=A.getInputElement();$&&($.tabIndex=A.canvasTabIndex,E.doNotHandleCursors||($.style.cursor=E.defaultCursor)),this._setCursorAndPointerOverMesh(p,_,E);for(const ce of E._pointerMoveStage){p=p||this._pickMove(_);const Te=!!p?.pickedMesh;p=ce.action(this._unTranslatedPointerX,this._unTranslatedPointerY,p,Te,$)}const ne=_.inputIndex>=Ur.MouseWheelX&&_.inputIndex<=Ur.MouseWheelZ?Kr.POINTERWHEEL:Kr.POINTERMOVE;E.onPointerMove&&(p=p||this._pickMove(_),E.onPointerMove(_,p,ne));let xe;p?(xe=new nh(ne,_,p),this._setRayOnPointerInfo(p,_)):(xe=new nh(ne,_,null,this),this._movePointerInfo=xe),E.onPointerObservable.hasObservers()&&E.onPointerObservable.notifyObservers(xe,ne)}_setRayOnPointerInfo(p,_){const E=this._scene;p&&E._pickingAvailable&&(p.ray||(p.ray=E.createPickingRay(_.offsetX,_.offsetY,Yt.Identity(),E.activeCamera)))}_addCameraPointerObserver(p,_){return this._cameraObserverCount++,this._scene.onPointerObservable.add(p,_)}_removeCameraPointerObserver(p){return this._cameraObserverCount--,this._scene.onPointerObservable.remove(p)}_checkForPicking(){return!!(this._scene.onPointerObservable.observers.length>this._cameraObserverCount||this._scene.onPointerPick)}_checkPrePointerObservable(p,_,E){const A=this._scene,$=new jO(E,_,this._unTranslatedPointerX,this._unTranslatedPointerY);return p&&($.originalPickingInfo=p,$.ray=p.ray,_.pointerType==="xr-near"&&p.originMesh&&($.nearInteractionPickingInfo=p)),A.onPrePointerObservable.notifyObservers($,E),!!$.skipOnPointerObservable}_pickMove(p){const _=this._scene,E=_.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,_.pointerMovePredicate,_.pointerMoveFastCheck,_.cameraToUseForPointers,_.pointerMoveTrianglePredicate);return this._setCursorAndPointerOverMesh(E,p,_),E}_setCursorAndPointerOverMesh(p,_,E){const $=E.getEngine().getInputElement();if(p?.pickedMesh){if(this.setPointerOverMesh(p.pickedMesh,_.pointerId,p,_),!E.doNotHandleCursors&&$&&this._pointerOverMesh){const ne=this._pointerOverMesh._getActionManagerForTrigger();ne&&ne.hasPointerTriggers&&($.style.cursor=ne.hoverCursor||E.hoverCursor)}}else this.setPointerOverMesh(null,_.pointerId,p,_)}simulatePointerMove(p,_){const E=new PointerEvent("pointermove",_);E.inputIndex=Ur.Move,!this._checkPrePointerObservable(p,E,Kr.POINTERMOVE)&&this._processPointerMove(p,E)}simulatePointerDown(p,_){const E=new PointerEvent("pointerdown",_);E.inputIndex=E.button+2,!this._checkPrePointerObservable(p,E,Kr.POINTERDOWN)&&this._processPointerDown(p,E)}_processPointerDown(p,_){const E=this._scene;if(p?.pickedMesh){this._pickedDownMesh=p.pickedMesh;const ne=p.pickedMesh._getActionManagerForTrigger();if(ne){if(ne.hasPickTriggers)switch(ne.processTrigger(5,no.CreateNew(p.pickedMesh,_,p)),_.button){case 0:ne.processTrigger(2,no.CreateNew(p.pickedMesh,_,p));break;case 1:ne.processTrigger(4,no.CreateNew(p.pickedMesh,_,p));break;case 2:ne.processTrigger(3,no.CreateNew(p.pickedMesh,_,p));break}ne.hasSpecificTrigger(8)&&window.setTimeout(()=>{const xe=E.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,ce=>ce.isPickable&&ce.isVisible&&ce.isReady()&&ce.actionManager&&ce.actionManager.hasSpecificTrigger(8)&&ce===this._pickedDownMesh,!1,E.cameraToUseForPointers);xe?.pickedMesh&&ne&&this._totalPointersPressed!==0&&Date.now()-this._startingPointerTime>$a.LongPressDelay&&!this._isPointerSwiping()&&(this._startingPointerTime=0,ne.processTrigger(8,no.CreateNew(xe.pickedMesh,_)))},$a.LongPressDelay)}}else for(const ne of E._pointerDownStage)p=ne.action(this._unTranslatedPointerX,this._unTranslatedPointerY,p,_,!1);let A;const $=Kr.POINTERDOWN;p?(E.onPointerDown&&E.onPointerDown(_,p,$),A=new nh($,_,p),this._setRayOnPointerInfo(p,_)):A=new nh($,_,null,this),E.onPointerObservable.hasObservers()&&E.onPointerObservable.notifyObservers(A,$)}_isPointerSwiping(){return this._isSwiping}simulatePointerUp(p,_,E){const A=new PointerEvent("pointerup",_);A.inputIndex=Ur.Move;const $=new Lb;E?$.doubleClick=!0:$.singleClick=!0,!this._checkPrePointerObservable(p,A,Kr.POINTERUP)&&this._processPointerUp(p,A,$)}_processPointerUp(p,_,E){const A=this._scene;if(p?.pickedMesh){if(this._pickedUpMesh=p.pickedMesh,this._pickedDownMesh===this._pickedUpMesh&&(A.onPointerPick&&A.onPointerPick(_,p),E.singleClick&&!E.ignore&&A.onPointerObservable.observers.length>this._cameraObserverCount)){const ne=Kr.POINTERPICK,xe=new nh(ne,_,p);this._setRayOnPointerInfo(p,_),A.onPointerObservable.notifyObservers(xe,ne)}const $=p.pickedMesh._getActionManagerForTrigger();if($&&!E.ignore){$.processTrigger(7,no.CreateNew(p.pickedMesh,_,p)),!E.hasSwiped&&E.singleClick&&$.processTrigger(1,no.CreateNew(p.pickedMesh,_,p));const ne=p.pickedMesh._getActionManagerForTrigger(6);E.doubleClick&&ne&&ne.processTrigger(6,no.CreateNew(p.pickedMesh,_,p))}}else if(!E.ignore)for(const $ of A._pointerUpStage)p=$.action(this._unTranslatedPointerX,this._unTranslatedPointerY,p,_,E.doubleClick);if(this._pickedDownMesh&&this._pickedDownMesh!==this._pickedUpMesh){const $=this._pickedDownMesh._getActionManagerForTrigger(16);$&&$.processTrigger(16,no.CreateNew(this._pickedDownMesh,_))}if(!E.ignore){const $=new nh(Kr.POINTERUP,_,p);if(this._setRayOnPointerInfo(p,_),A.onPointerObservable.notifyObservers($,Kr.POINTERUP),A.onPointerUp&&A.onPointerUp(_,p,Kr.POINTERUP),!E.hasSwiped&&!this._skipPointerTap&&!this._isMultiTouchGesture){let ne=0;if(E.singleClick?ne=Kr.POINTERTAP:E.doubleClick&&(ne=Kr.POINTERDOUBLETAP),ne){const xe=new nh(ne,_,p);A.onPointerObservable.hasObservers()&&A.onPointerObservable.hasSpecificMask(ne)&&A.onPointerObservable.notifyObservers(xe,ne)}}}}isPointerCaptured(p=0){return this._pointerCaptures[p]}attachControl(p=!0,_=!0,E=!0,A=null){const $=this._scene,ne=$.getEngine();A||(A=ne.getInputElement()),this._alreadyAttached&&this.detachControl(),A&&(this._alreadyAttachedTo=A),this._deviceSourceManager=new nw(ne),this._initActionManager=xe=>{if(!this._meshPickProceed){const ce=$.skipPointerUpPicking||$._registeredActions===0&&!this._checkForPicking()&&!$.onPointerUp?null:$.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,$.pointerUpPredicate,$.pointerUpFastCheck,$.cameraToUseForPointers);this._currentPickResult=ce,ce&&(xe=ce.hit&&ce.pickedMesh?ce.pickedMesh._getActionManagerForTrigger():null),this._meshPickProceed=!0}return xe},this._delayedSimpleClick=(xe,ce,Te)=>{if((Date.now()-this._previousStartingPointerTime>$a.DoubleClickDelay&&!this._doubleClickOccured||xe!==this._previousButtonPressed)&&(this._doubleClickOccured=!1,ce.singleClick=!0,ce.ignore=!1,this._delayedClicks[xe])){const Re=this._delayedClicks[xe].evt,ke=Kr.POINTERTAP,We=new nh(ke,Re,this._currentPickResult);$.onPointerObservable.hasObservers()&&$.onPointerObservable.hasSpecificMask(ke)&&$.onPointerObservable.notifyObservers(We,ke),this._delayedClicks[xe]=null}},this._initClickEvent=(xe,ce,Te,Re)=>{const ke=new Lb;this._currentPickResult=null;let We=null,Xe=xe.hasSpecificMask(Kr.POINTERPICK)||ce.hasSpecificMask(Kr.POINTERPICK)||xe.hasSpecificMask(Kr.POINTERTAP)||ce.hasSpecificMask(Kr.POINTERTAP)||xe.hasSpecificMask(Kr.POINTERDOUBLETAP)||ce.hasSpecificMask(Kr.POINTERDOUBLETAP);!Xe&&Xx&&(We=this._initActionManager(We,ke),We&&(Xe=We.hasPickTriggers));let xt=!1;if(Xe){const qe=Te.button;if(ke.hasSwiped=this._isPointerSwiping(),!ke.hasSwiped){let ht=!$a.ExclusiveDoubleClickMode;if(ht||(ht=!xe.hasSpecificMask(Kr.POINTERDOUBLETAP)&&!ce.hasSpecificMask(Kr.POINTERDOUBLETAP),ht&&!Xx.HasSpecificTrigger(6)&&(We=this._initActionManager(We,ke),We&&(ht=!We.hasSpecificTrigger(6)))),ht)(Date.now()-this._previousStartingPointerTime>$a.DoubleClickDelay||qe!==this._previousButtonPressed)&&(ke.singleClick=!0,Re(ke,this._currentPickResult),xt=!0);else{const wt={evt:Te,clickInfo:ke,timeoutId:window.setTimeout(this._delayedSimpleClick.bind(this,qe,ke,Re),$a.DoubleClickDelay)};this._delayedClicks[qe]=wt}let Nt=xe.hasSpecificMask(Kr.POINTERDOUBLETAP)||ce.hasSpecificMask(Kr.POINTERDOUBLETAP);!Nt&&Xx.HasSpecificTrigger(6)&&(We=this._initActionManager(We,ke),We&&(Nt=We.hasSpecificTrigger(6))),Nt&&(qe===this._previousButtonPressed&&Date.now()-this._previousStartingPointerTime<$a.DoubleClickDelay&&!this._doubleClickOccured?(!ke.hasSwiped&&!this._isPointerSwiping()?(this._previousStartingPointerTime=0,this._doubleClickOccured=!0,ke.doubleClick=!0,ke.ignore=!1,$a.ExclusiveDoubleClickMode&&this._delayedClicks[qe]&&(clearTimeout(this._delayedClicks[qe]?.timeoutId),this._delayedClicks[qe]=null),Re(ke,this._currentPickResult)):(this._doubleClickOccured=!1,this._previousStartingPointerTime=this._startingPointerTime,this._previousStartingPointerPosition.x=this._startingPointerPosition.x,this._previousStartingPointerPosition.y=this._startingPointerPosition.y,this._previousButtonPressed=qe,$a.ExclusiveDoubleClickMode?(this._delayedClicks[qe]&&(clearTimeout(this._delayedClicks[qe]?.timeoutId),this._delayedClicks[qe]=null),Re(ke,this._previousPickResult)):Re(ke,this._currentPickResult)),xt=!0):(this._doubleClickOccured=!1,this._previousStartingPointerTime=this._startingPointerTime,this._previousStartingPointerPosition.x=this._startingPointerPosition.x,this._previousStartingPointerPosition.y=this._startingPointerPosition.y,this._previousButtonPressed=qe))}}xt||Re(ke,this._currentPickResult)},this._onPointerMove=xe=>{if(this._updatePointerPosition(xe),!this._isSwiping&&this._swipeButtonPressed!==-1&&(this._isSwiping=Math.abs(this._startingPointerPosition.x-this._pointerX)>$a.DragMovementThreshold||Math.abs(this._startingPointerPosition.y-this._pointerY)>$a.DragMovementThreshold),ne.isPointerLock&&ne._verifyPointerLock(),this._checkPrePointerObservable(null,xe,xe.inputIndex>=Ur.MouseWheelX&&xe.inputIndex<=Ur.MouseWheelZ?Kr.POINTERWHEEL:Kr.POINTERMOVE)||!$.cameraToUseForPointers&&!$.activeCamera)return;if($.skipPointerMovePicking){this._processPointerMove(new nm,xe);return}$.pointerMovePredicate||($.pointerMovePredicate=Te=>Te.isPickable&&Te.isVisible&&Te.isReady()&&Te.isEnabled()&&(Te.enablePointerMoveEvents||$.constantlyUpdateMeshUnderPointer||Te._getActionManagerForTrigger()!==null)&&(!$.cameraToUseForPointers||($.cameraToUseForPointers.layerMask&Te.layerMask)!==0));const ce=$._registeredActions>0||$.constantlyUpdateMeshUnderPointer?this._pickMove(xe):null;this._processPointerMove(ce,xe)},this._onPointerDown=xe=>{if(this._totalPointersPressed++,this._pickedDownMesh=null,this._meshPickProceed=!1,$a.ExclusiveDoubleClickMode){for(let Te=0;Te<this._delayedClicks.length;Te++)if(this._delayedClicks[Te])if(xe.button===Te)clearTimeout(this._delayedClicks[Te]?.timeoutId);else{const Re=this._delayedClicks[Te].clickInfo;this._doubleClickOccured=!1,Re.singleClick=!0,Re.ignore=!1;const ke=this._delayedClicks[Te].evt,We=Kr.POINTERTAP,Xe=new nh(We,ke,this._currentPickResult);$.onPointerObservable.hasObservers()&&$.onPointerObservable.hasSpecificMask(We)&&$.onPointerObservable.notifyObservers(Xe,We),this._delayedClicks[Te]=null}}if(this._updatePointerPosition(xe),this._swipeButtonPressed===-1&&(this._swipeButtonPressed=xe.button),$.preventDefaultOnPointerDown&&A&&(xe.preventDefault(),A.focus()),this._startingPointerPosition.x=this._pointerX,this._startingPointerPosition.y=this._pointerY,this._startingPointerTime=Date.now(),this._checkPrePointerObservable(null,xe,Kr.POINTERDOWN)||!$.cameraToUseForPointers&&!$.activeCamera)return;this._pointerCaptures[xe.pointerId]=!0,$.pointerDownPredicate||($.pointerDownPredicate=Te=>Te.isPickable&&Te.isVisible&&Te.isReady()&&Te.isEnabled()&&(!$.cameraToUseForPointers||($.cameraToUseForPointers.layerMask&Te.layerMask)!==0)),this._pickedDownMesh=null;let ce;$.skipPointerDownPicking||$._registeredActions===0&&!this._checkForPicking()&&!$.onPointerDown?ce=new nm:ce=$.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,$.pointerDownPredicate,$.pointerDownFastCheck,$.cameraToUseForPointers),this._processPointerDown(ce,xe)},this._onPointerUp=xe=>{this._totalPointersPressed!==0&&(this._totalPointersPressed--,this._pickedUpMesh=null,this._meshPickProceed=!1,this._updatePointerPosition(xe),$.preventDefaultOnPointerUp&&A&&(xe.preventDefault(),A.focus()),this._initClickEvent($.onPrePointerObservable,$.onPointerObservable,xe,(ce,Te)=>{if($.onPrePointerObservable.hasObservers()&&(this._skipPointerTap=!1,!ce.ignore)){if(this._checkPrePointerObservable(null,xe,Kr.POINTERUP)){this._swipeButtonPressed===xe.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1),xe.buttons===0&&(this._pointerCaptures[xe.pointerId]=!1);return}ce.hasSwiped||(ce.singleClick&&$.onPrePointerObservable.hasSpecificMask(Kr.POINTERTAP)&&this._checkPrePointerObservable(null,xe,Kr.POINTERTAP)&&(this._skipPointerTap=!0),ce.doubleClick&&$.onPrePointerObservable.hasSpecificMask(Kr.POINTERDOUBLETAP)&&this._checkPrePointerObservable(null,xe,Kr.POINTERDOUBLETAP)&&(this._skipPointerTap=!0))}if(!this._pointerCaptures[xe.pointerId]){this._swipeButtonPressed===xe.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1);return}xe.buttons===0&&(this._pointerCaptures[xe.pointerId]=!1),!(!$.cameraToUseForPointers&&!$.activeCamera)&&($.pointerUpPredicate||($.pointerUpPredicate=Re=>Re.isPickable&&Re.isVisible&&Re.isReady()&&Re.isEnabled()&&(!$.cameraToUseForPointers||($.cameraToUseForPointers.layerMask&Re.layerMask)!==0)),!this._meshPickProceed&&(Xx&&Xx.HasTriggers||this._checkForPicking()||$.onPointerUp)&&this._initActionManager(null,ce),Te||(Te=this._currentPickResult),this._processPointerUp(Te,xe,ce),this._previousPickResult=this._currentPickResult,this._swipeButtonPressed===xe.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1))}))},this._onKeyDown=xe=>{const ce=Ru.KEYDOWN;if($.onPreKeyboardObservable.hasObservers()){const Te=new cb(ce,xe);if($.onPreKeyboardObservable.notifyObservers(Te,ce),Te.skipOnKeyboardObservable)return}if($.onKeyboardObservable.hasObservers()){const Te=new n_(ce,xe);$.onKeyboardObservable.notifyObservers(Te,ce)}$.actionManager&&$.actionManager.processTrigger(14,no.CreateNewFromScene($,xe))},this._onKeyUp=xe=>{const ce=Ru.KEYUP;if($.onPreKeyboardObservable.hasObservers()){const Te=new cb(ce,xe);if($.onPreKeyboardObservable.notifyObservers(Te,ce),Te.skipOnKeyboardObservable)return}if($.onKeyboardObservable.hasObservers()){const Te=new n_(ce,xe);$.onKeyboardObservable.notifyObservers(Te,ce)}$.actionManager&&$.actionManager.processTrigger(15,no.CreateNewFromScene($,xe))},this._deviceSourceManager.onDeviceConnectedObservable.add(xe=>{xe.deviceType===ar.Mouse?xe.onInputChangedObservable.add(ce=>{ce.inputIndex===Ur.LeftClick||ce.inputIndex===Ur.MiddleClick||ce.inputIndex===Ur.RightClick||ce.inputIndex===Ur.BrowserBack||ce.inputIndex===Ur.BrowserForward?_&&xe.getInput(ce.inputIndex)===1?this._onPointerDown(ce):p&&xe.getInput(ce.inputIndex)===0&&this._onPointerUp(ce):E&&(ce.inputIndex===Ur.Move?this._onPointerMove(ce):(ce.inputIndex===Ur.MouseWheelX||ce.inputIndex===Ur.MouseWheelY||ce.inputIndex===Ur.MouseWheelZ)&&this._onPointerMove(ce))}):xe.deviceType===ar.Touch?xe.onInputChangedObservable.add(ce=>{ce.inputIndex===Ur.LeftClick&&(_&&xe.getInput(ce.inputIndex)===1?(this._onPointerDown(ce),this._totalPointersPressed>1&&(this._isMultiTouchGesture=!0)):p&&xe.getInput(ce.inputIndex)===0&&(this._onPointerUp(ce),this._totalPointersPressed===0&&(this._isMultiTouchGesture=!1))),E&&ce.inputIndex===Ur.Move&&this._onPointerMove(ce)}):xe.deviceType===ar.Keyboard&&xe.onInputChangedObservable.add(ce=>{ce.type==="keydown"?this._onKeyDown(ce):ce.type==="keyup"&&this._onKeyUp(ce)})}),this._alreadyAttached=!0}detachControl(){this._alreadyAttached&&(this._deviceSourceManager.dispose(),this._deviceSourceManager=null,this._alreadyAttachedTo&&!this._scene.doNotHandleCursors&&(this._alreadyAttachedTo.style.cursor=this._scene.defaultCursor),this._alreadyAttached=!1,this._alreadyAttachedTo=null)}setPointerOverMesh(p,_=0,E,A){if(this._meshUnderPointerId[_]===p&&(!p||!p._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting))return;const $=this._meshUnderPointerId[_];let ne;$&&(ne=$._getActionManagerForTrigger(10),ne&&ne.processTrigger(10,no.CreateNew($,A,{pointerId:_}))),p?(this._meshUnderPointerId[_]=p,this._pointerOverMesh=p,ne=p._getActionManagerForTrigger(9),ne&&ne.processTrigger(9,no.CreateNew(p,A,{pointerId:_,pickResult:E}))):(delete this._meshUnderPointerId[_],this._pointerOverMesh=null)}getPointerOverMesh(){return this.meshUnderPointer}_invalidateMesh(p){this._pointerOverMesh===p&&(this._pointerOverMesh=null),this._pickedDownMesh===p&&(this._pickedDownMesh=null),this._pickedUpMesh===p&&(this._pickedUpMesh=null);for(const _ in this._meshUnderPointerId)this._meshUnderPointerId[_]===p&&delete this._meshUnderPointerId[_]}}$a.DragMovementThreshold=10,$a.LongPressDelay=500,$a.DoubleClickDelay=300,$a.ExclusiveDoubleClickMode=!1;class hl{constructor(p,_,E,A){this.normal=new nt(p,_,E),this.d=A}asArray(){return[this.normal.x,this.normal.y,this.normal.z,this.d]}clone(){return new hl(this.normal.x,this.normal.y,this.normal.z,this.d)}getClassName(){return"Plane"}getHashCode(){let p=this.normal.getHashCode();return p=p*397^(this.d|0),p}normalize(){const p=Math.sqrt(this.normal.x*this.normal.x+this.normal.y*this.normal.y+this.normal.z*this.normal.z);let _=0;return p!==0&&(_=1/p),this.normal.x*=_,this.normal.y*=_,this.normal.z*=_,this.d*=_,this}transform(p){const _=hl._TmpMatrix;p.invertToRef(_);const E=_.m,A=this.normal.x,$=this.normal.y,ne=this.normal.z,xe=this.d,ce=A*E[0]+$*E[1]+ne*E[2]+xe*E[3],Te=A*E[4]+$*E[5]+ne*E[6]+xe*E[7],Re=A*E[8]+$*E[9]+ne*E[10]+xe*E[11],ke=A*E[12]+$*E[13]+ne*E[14]+xe*E[15];return new hl(ce,Te,Re,ke)}dotCoordinate(p){return this.normal.x*p.x+this.normal.y*p.y+this.normal.z*p.z+this.d}copyFromPoints(p,_,E){const A=_.x-p.x,$=_.y-p.y,ne=_.z-p.z,xe=E.x-p.x,ce=E.y-p.y,Te=E.z-p.z,Re=$*Te-ne*ce,ke=ne*xe-A*Te,We=A*ce-$*xe,Xe=Math.sqrt(Re*Re+ke*ke+We*We);let xt;return Xe!==0?xt=1/Xe:xt=0,this.normal.x=Re*xt,this.normal.y=ke*xt,this.normal.z=We*xt,this.d=-(this.normal.x*p.x+this.normal.y*p.y+this.normal.z*p.z),this}isFrontFacingTo(p,_){return nt.Dot(this.normal,p)<=_}signedDistanceTo(p){return nt.Dot(p,this.normal)+this.d}static FromArray(p){return new hl(p[0],p[1],p[2],p[3])}static FromPoints(p,_,E){const A=new hl(0,0,0,0);return A.copyFromPoints(p,_,E),A}static FromPositionAndNormal(p,_){const E=new hl(0,0,0,0);return this.FromPositionAndNormalToRef(p,_,E)}static FromPositionAndNormalToRef(p,_,E){return E.normal.copyFrom(_),E.normal.normalize(),E.d=-p.dot(E.normal),E}static SignedDistanceToPlaneFromPositionAndNormal(p,_,E){const A=-(_.x*p.x+_.y*p.y+_.z*p.z);return nt.Dot(E,_)+A}}hl._TmpMatrix=Yt.Identity();class cl{static GetPlanes(p){const _=[];for(let E=0;E<6;E++)_.push(new hl(0,0,0,0));return cl.GetPlanesToRef(p,_),_}static GetNearPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]+E[2],_.normal.y=E[7]+E[6],_.normal.z=E[11]+E[10],_.d=E[15]+E[14],_.normalize()}static GetFarPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]-E[2],_.normal.y=E[7]-E[6],_.normal.z=E[11]-E[10],_.d=E[15]-E[14],_.normalize()}static GetLeftPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]+E[0],_.normal.y=E[7]+E[4],_.normal.z=E[11]+E[8],_.d=E[15]+E[12],_.normalize()}static GetRightPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]-E[0],_.normal.y=E[7]-E[4],_.normal.z=E[11]-E[8],_.d=E[15]-E[12],_.normalize()}static GetTopPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]-E[1],_.normal.y=E[7]-E[5],_.normal.z=E[11]-E[9],_.d=E[15]-E[13],_.normalize()}static GetBottomPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]+E[1],_.normal.y=E[7]+E[5],_.normal.z=E[11]+E[9],_.d=E[15]+E[13],_.normalize()}static GetPlanesToRef(p,_){cl.GetNearPlaneToRef(p,_[0]),cl.GetFarPlaneToRef(p,_[1]),cl.GetLeftPlaneToRef(p,_[2]),cl.GetRightPlaneToRef(p,_[3]),cl.GetTopPlaneToRef(p,_[4]),cl.GetBottomPlaneToRef(p,_[5])}static IsPointInFrustum(p,_){for(let E=0;E<6;E++)if(_[E].dotCoordinate(p)<0)return!1;return!0}}class kb{static get UniqueId(){const p=this._UniqueIdCounter;return this._UniqueIdCounter++,p}}kb._UniqueIdCounter=1;class qn{static CompareLightsPriority(p,_){return p.shadowEnabled!==_.shadowEnabled?(_.shadowEnabled?1:0)-(p.shadowEnabled?1:0):_.renderPriority-p.renderPriority}}qn.FALLOFF_DEFAULT=0,qn.FALLOFF_PHYSICAL=1,qn.FALLOFF_GLTF=2,qn.FALLOFF_STANDARD=3,qn.LIGHTMAP_DEFAULT=0,qn.LIGHTMAP_SPECULAR=1,qn.LIGHTMAP_SHADOWSONLY=2,qn.INTENSITYMODE_AUTOMATIC=0,qn.INTENSITYMODE_LUMINOUSPOWER=1,qn.INTENSITYMODE_LUMINOUSINTENSITY=2,qn.INTENSITYMODE_ILLUMINANCE=3,qn.INTENSITYMODE_LUMINANCE=4,qn.LIGHTTYPEID_POINTLIGHT=0,qn.LIGHTTYPEID_DIRECTIONALLIGHT=1,qn.LIGHTTYPEID_SPOTLIGHT=2,qn.LIGHTTYPEID_HEMISPHERICLIGHT=3;class aw{constructor(){this.pointerDownFastCheck=!1,this.pointerUpFastCheck=!1,this.pointerMoveFastCheck=!1,this.skipPointerMovePicking=!1,this.skipPointerDownPicking=!1,this.skipPointerUpPicking=!1}}var R2;(function(_e){_e[_e.BackwardCompatible=0]="BackwardCompatible",_e[_e.Intermediate=1]="Intermediate",_e[_e.Aggressive=2]="Aggressive"})(R2||(R2={}));class W0 extends Mx{static DefaultMaterialFactory(p){throw Tr("StandardMaterial")}static CollisionCoordinatorFactory(){throw Tr("DefaultCollisionCoordinator")}get environmentTexture(){return this._environmentTexture}set environmentTexture(p){this._environmentTexture!==p&&(this._environmentTexture=p,this.markAllMaterialsAsDirty(1))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}get performancePriority(){return this._performancePriority}set performancePriority(p){if(p!==this._performancePriority){switch(this._performancePriority=p,p){case R2.BackwardCompatible:this.skipFrustumClipping=!1,this._renderingManager.maintainStateBetweenFrames=!1,this.skipPointerMovePicking=!1,this.autoClear=!0;break;case R2.Intermediate:this.skipFrustumClipping=!1,this._renderingManager.maintainStateBetweenFrames=!1,this.skipPointerMovePicking=!0,this.autoClear=!1;break;case R2.Aggressive:this.skipFrustumClipping=!0,this._renderingManager.maintainStateBetweenFrames=!0,this.skipPointerMovePicking=!0,this.autoClear=!1;break}this.onScenePerformancePriorityChangedObservable.notifyObservers(p)}}set forceWireframe(p){this._forceWireframe!==p&&(this._forceWireframe=p,this.markAllMaterialsAsDirty(16))}get forceWireframe(){return this._forceWireframe}set skipFrustumClipping(p){this._skipFrustumClipping!==p&&(this._skipFrustumClipping=p)}get skipFrustumClipping(){return this._skipFrustumClipping}set forcePointsCloud(p){this._forcePointsCloud!==p&&(this._forcePointsCloud=p,this.markAllMaterialsAsDirty(16))}get forcePointsCloud(){return this._forcePointsCloud}get animationPropertiesOverride(){return this._animationPropertiesOverride}set animationPropertiesOverride(p){this._animationPropertiesOverride=p}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}set beforeRender(p){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),p&&(this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(p))}set afterRender(p){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),p&&(this._onAfterRenderObserver=this.onAfterRenderObservable.add(p))}set beforeCameraRender(p){this._onBeforeCameraRenderObserver&&this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver),this._onBeforeCameraRenderObserver=this.onBeforeCameraRenderObservable.add(p)}set afterCameraRender(p){this._onAfterCameraRenderObserver&&this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver),this._onAfterCameraRenderObserver=this.onAfterCameraRenderObservable.add(p)}get pointerDownPredicate(){return this._pointerPickingConfiguration.pointerDownPredicate}set pointerDownPredicate(p){this._pointerPickingConfiguration.pointerDownPredicate=p}get pointerUpPredicate(){return this._pointerPickingConfiguration.pointerUpPredicate}set pointerUpPredicate(p){this._pointerPickingConfiguration.pointerUpPredicate=p}get pointerMovePredicate(){return this._pointerPickingConfiguration.pointerMovePredicate}set pointerMovePredicate(p){this._pointerPickingConfiguration.pointerMovePredicate=p}get pointerDownFastCheck(){return this._pointerPickingConfiguration.pointerDownFastCheck}set pointerDownFastCheck(p){this._pointerPickingConfiguration.pointerDownFastCheck=p}get pointerUpFastCheck(){return this._pointerPickingConfiguration.pointerUpFastCheck}set pointerUpFastCheck(p){this._pointerPickingConfiguration.pointerUpFastCheck=p}get pointerMoveFastCheck(){return this._pointerPickingConfiguration.pointerMoveFastCheck}set pointerMoveFastCheck(p){this._pointerPickingConfiguration.pointerMoveFastCheck=p}get skipPointerMovePicking(){return this._pointerPickingConfiguration.skipPointerMovePicking}set skipPointerMovePicking(p){this._pointerPickingConfiguration.skipPointerMovePicking=p}get skipPointerDownPicking(){return this._pointerPickingConfiguration.skipPointerDownPicking}set skipPointerDownPicking(p){this._pointerPickingConfiguration.skipPointerDownPicking=p}get skipPointerUpPicking(){return this._pointerPickingConfiguration.skipPointerUpPicking}set skipPointerUpPicking(p){this._pointerPickingConfiguration.skipPointerUpPicking=p}get unTranslatedPointer(){return this._inputManager.unTranslatedPointer}static get DragMovementThreshold(){return $a.DragMovementThreshold}static set DragMovementThreshold(p){$a.DragMovementThreshold=p}static get LongPressDelay(){return $a.LongPressDelay}static set LongPressDelay(p){$a.LongPressDelay=p}static get DoubleClickDelay(){return $a.DoubleClickDelay}static set DoubleClickDelay(p){$a.DoubleClickDelay=p}static get ExclusiveDoubleClickMode(){return $a.ExclusiveDoubleClickMode}static set ExclusiveDoubleClickMode(p){$a.ExclusiveDoubleClickMode=p}bindEyePosition(p,_="vEyePosition",E=!1){const A=this._forcedViewPosition?this._forcedViewPosition:this._mirroredCameraPosition?this._mirroredCameraPosition:this.activeCamera.globalPosition,$=this.useRightHandedSystem===(this._mirroredCameraPosition!=null);return pi.Vector4[0].set(A.x,A.y,A.z,$?-1:1),p&&(E?p.setFloat3(_,pi.Vector4[0].x,pi.Vector4[0].y,pi.Vector4[0].z):p.setVector4(_,pi.Vector4[0])),pi.Vector4[0]}finalizeSceneUbo(){const p=this.getSceneUniformBuffer(),_=this.bindEyePosition(null);return p.updateFloat4("vEyePosition",_.x,_.y,_.z,_.w),p.update(),p}set useRightHandedSystem(p){this._useRightHandedSystem!==p&&(this._useRightHandedSystem=p,this.markAllMaterialsAsDirty(16))}get useRightHandedSystem(){return this._useRightHandedSystem}setStepId(p){this._currentStepId=p}getStepId(){return this._currentStepId}getInternalStep(){return this._currentInternalStep}set fogEnabled(p){this._fogEnabled!==p&&(this._fogEnabled=p,this.markAllMaterialsAsDirty(16))}get fogEnabled(){return this._fogEnabled}set fogMode(p){this._fogMode!==p&&(this._fogMode=p,this.markAllMaterialsAsDirty(16))}get fogMode(){return this._fogMode}get prePass(){return!!this.prePassRenderer&&this.prePassRenderer.defaultRT.enabled}set shadowsEnabled(p){this._shadowsEnabled!==p&&(this._shadowsEnabled=p,this.markAllMaterialsAsDirty(2))}get shadowsEnabled(){return this._shadowsEnabled}set lightsEnabled(p){this._lightsEnabled!==p&&(this._lightsEnabled=p,this.markAllMaterialsAsDirty(2))}get lightsEnabled(){return this._lightsEnabled}get activeCameras(){return this._activeCameras}set activeCameras(p){this._unObserveActiveCameras&&(this._unObserveActiveCameras(),this._unObserveActiveCameras=null),p&&(this._unObserveActiveCameras=Mn(p,()=>{this.onActiveCamerasChanged.notifyObservers(this)})),this._activeCameras=p}get activeCamera(){return this._activeCamera}set activeCamera(p){p!==this._activeCamera&&(this._activeCamera=p,this.onActiveCameraChanged.notifyObservers(this))}get defaultMaterial(){return this._defaultMaterial||(this._defaultMaterial=W0.DefaultMaterialFactory(this)),this._defaultMaterial}set defaultMaterial(p){this._defaultMaterial=p}set texturesEnabled(p){this._texturesEnabled!==p&&(this._texturesEnabled=p,this.markAllMaterialsAsDirty(1))}get texturesEnabled(){return this._texturesEnabled}set skeletonsEnabled(p){this._skeletonsEnabled!==p&&(this._skeletonsEnabled=p,this.markAllMaterialsAsDirty(8))}get skeletonsEnabled(){return this._skeletonsEnabled}get collisionCoordinator(){return this._collisionCoordinator||(this._collisionCoordinator=W0.CollisionCoordinatorFactory(),this._collisionCoordinator.init(this)),this._collisionCoordinator}get renderingManager(){return this._renderingManager}get frustumPlanes(){return this._frustumPlanes}_registerTransientComponents(){if(this._transientComponents.length>0){for(const p of this._transientComponents)p.register();this._transientComponents.length=0}}_addComponent(p){this._components.push(p),this._transientComponents.push(p);const _=p;_.addFromContainer&&_.serialize&&this._serializableComponents.push(_)}_getComponent(p){for(const _ of this._components)if(_.name===p)return _;return null}constructor(p,_){super(),this._inputManager=new $a(this),this.cameraToUseForPointers=null,this._isScene=!0,this._blockEntityCollection=!1,this.autoClear=!0,this.autoClearDepthAndStencil=!0,this.clearColor=new vr(.2,.2,.3,1),this.ambientColor=new ws(0,0,0),this.environmentIntensity=1,this._performancePriority=R2.BackwardCompatible,this.onScenePerformancePriorityChangedObservable=new Mi,this._forceWireframe=!1,this._skipFrustumClipping=!1,this._forcePointsCloud=!1,this.animationsEnabled=!0,this._animationPropertiesOverride=null,this.useConstantAnimationDeltaTime=!1,this.constantlyUpdateMeshUnderPointer=!1,this.hoverCursor="pointer",this.defaultCursor="",this.doNotHandleCursors=!1,this.preventDefaultOnPointerDown=!0,this.preventDefaultOnPointerUp=!0,this.metadata=null,this.reservedDataStore=null,this.disableOfflineSupportExceptionRules=[],this.onDisposeObservable=new Mi,this._onDisposeObserver=null,this.onBeforeRenderObservable=new Mi,this._onBeforeRenderObserver=null,this.onAfterRenderObservable=new Mi,this.onAfterRenderCameraObservable=new Mi,this._onAfterRenderObserver=null,this.onBeforeAnimationsObservable=new Mi,this.onAfterAnimationsObservable=new Mi,this.onBeforeDrawPhaseObservable=new Mi,this.onAfterDrawPhaseObservable=new Mi,this.onReadyObservable=new Mi,this.onBeforeCameraRenderObservable=new Mi,this._onBeforeCameraRenderObserver=null,this.onAfterCameraRenderObservable=new Mi,this._onAfterCameraRenderObserver=null,this.onBeforeActiveMeshesEvaluationObservable=new Mi,this.onAfterActiveMeshesEvaluationObservable=new Mi,this.onBeforeParticlesRenderingObservable=new Mi,this.onAfterParticlesRenderingObservable=new Mi,this.onDataLoadedObservable=new Mi,this.onNewCameraAddedObservable=new Mi,this.onCameraRemovedObservable=new Mi,this.onNewLightAddedObservable=new Mi,this.onLightRemovedObservable=new Mi,this.onNewGeometryAddedObservable=new Mi,this.onGeometryRemovedObservable=new Mi,this.onNewTransformNodeAddedObservable=new Mi,this.onTransformNodeRemovedObservable=new Mi,this.onNewMeshAddedObservable=new Mi,this.onMeshRemovedObservable=new Mi,this.onNewSkeletonAddedObservable=new Mi,this.onSkeletonRemovedObservable=new Mi,this.onNewMaterialAddedObservable=new Mi,this.onNewMultiMaterialAddedObservable=new Mi,this.onMaterialRemovedObservable=new Mi,this.onMultiMaterialRemovedObservable=new Mi,this.onNewTextureAddedObservable=new Mi,this.onTextureRemovedObservable=new Mi,this.onBeforeRenderTargetsRenderObservable=new Mi,this.onAfterRenderTargetsRenderObservable=new Mi,this.onBeforeStepObservable=new Mi,this.onAfterStepObservable=new Mi,this.onActiveCameraChanged=new Mi,this.onActiveCamerasChanged=new Mi,this.onBeforeRenderingGroupObservable=new Mi,this.onAfterRenderingGroupObservable=new Mi,this.onMeshImportedObservable=new Mi,this.onAnimationFileImportedObservable=new Mi,this._registeredForLateAnimationBindings=new vt(256),this._pointerPickingConfiguration=new aw,this.onPrePointerObservable=new Mi,this.onPointerObservable=new Mi,this.onPreKeyboardObservable=new Mi,this.onKeyboardObservable=new Mi,this._useRightHandedSystem=!1,this._timeAccumulator=0,this._currentStepId=0,this._currentInternalStep=0,this._fogEnabled=!0,this._fogMode=W0.FOGMODE_NONE,this.fogColor=new ws(.2,.2,.3),this.fogDensity=.1,this.fogStart=0,this.fogEnd=1e3,this.needsPreviousWorldMatrices=!1,this._shadowsEnabled=!0,this._lightsEnabled=!0,this._unObserveActiveCameras=null,this._texturesEnabled=!0,this.physicsEnabled=!0,this.particlesEnabled=!0,this.spritesEnabled=!0,this._skeletonsEnabled=!0,this.lensFlaresEnabled=!0,this.collisionsEnabled=!0,this.gravity=new nt(0,-9.807,0),this.postProcessesEnabled=!0,this.renderTargetsEnabled=!0,this.dumpNextRenderTargets=!1,this.customRenderTargets=[],this.importedMeshesFiles=[],this.probesEnabled=!0,this._meshesForIntersections=new vt(256),this.proceduralTexturesEnabled=!0,this._totalVertices=new T0,this._activeIndices=new T0,this._activeParticles=new T0,this._activeBones=new T0,this._animationTime=0,this.animationTimeScale=1,this._renderId=0,this._frameId=0,this._executeWhenReadyTimeoutId=null,this._intermediateRendering=!1,this._defaultFrameBufferCleared=!1,this._viewUpdateFlag=-1,this._projectionUpdateFlag=-1,this._toBeDisposed=new Array(256),this._activeRequests=new Array,this._pendingData=new Array,this._isDisposed=!1,this.dispatchAllSubMeshesOfActiveMeshes=!1,this._activeMeshes=new _t(256),this._processedMaterials=new _t(256),this._renderTargets=new vt(256),this._materialsRenderTargets=new vt(256),this._activeParticleSystems=new _t(256),this._activeSkeletons=new vt(32),this._softwareSkinnedMeshes=new vt(32),this._activeAnimatables=new Array,this._transformMatrix=Yt.Zero(),this.requireLightSorting=!1,this._components=[],this._serializableComponents=[],this._transientComponents=[],this._beforeCameraUpdateStage=qa.Create(),this._beforeClearStage=qa.Create(),this._beforeRenderTargetClearStage=qa.Create(),this._gatherRenderTargetsStage=qa.Create(),this._gatherActiveCameraRenderTargetsStage=qa.Create(),this._isReadyForMeshStage=qa.Create(),this._beforeEvaluateActiveMeshStage=qa.Create(),this._evaluateSubMeshStage=qa.Create(),this._preActiveMeshStage=qa.Create(),this._cameraDrawRenderTargetStage=qa.Create(),this._beforeCameraDrawStage=qa.Create(),this._beforeRenderTargetDrawStage=qa.Create(),this._beforeRenderingGroupDrawStage=qa.Create(),this._beforeRenderingMeshStage=qa.Create(),this._afterRenderingMeshStage=qa.Create(),this._afterRenderingGroupDrawStage=qa.Create(),this._afterCameraDrawStage=qa.Create(),this._afterCameraPostProcessStage=qa.Create(),this._afterRenderTargetDrawStage=qa.Create(),this._afterRenderTargetPostProcessStage=qa.Create(),this._afterRenderStage=qa.Create(),this._pointerMoveStage=qa.Create(),this._pointerDownStage=qa.Create(),this._pointerUpStage=qa.Create(),this._geometriesByUniqueId=null,this._defaultMeshCandidates={data:[],length:0},this._defaultSubMeshCandidates={data:[],length:0},this._preventFreeActiveMeshesAndRenderingGroups=!1,this._activeMeshesFrozen=!1,this._activeMeshesFrozenButKeepClipping=!1,this._skipEvaluateActiveMeshesCompletely=!1,this._allowPostProcessClearColor=!0,this.getDeterministicFrameTime=()=>this._engine.getTimeStep(),this._registeredActions=0,this._blockMaterialDirtyMechanism=!1,this._perfCollector=null,this.activeCameras=[];const E={useGeometryUniqueIdsMap:!0,useMaterialMeshMap:!0,useClonedMeshMap:!0,virtual:!1,..._};p=this._engine=p||wr.LastCreatedEngine,E.virtual?p._virtualScenes.push(this):(wr._LastCreatedScene=this,p.scenes.push(this)),this._uid=null,this._renderingManager=new ao(this),qm&&(this.postProcessManager=new qm(this)),wa()&&this.attachControl(),this._createUbo(),Hn&&(this._imageProcessingConfiguration=new Hn),this.setDefaultCandidateProviders(),E.useGeometryUniqueIdsMap&&(this._geometriesByUniqueId={}),this.useMaterialMeshMap=E.useMaterialMeshMap,this.useClonedMeshMap=E.useClonedMeshMap,(!_||!_.virtual)&&p.onNewSceneAddedObservable.notifyObservers(this)}getClassName(){return"Scene"}_getDefaultMeshCandidates(){return this._defaultMeshCandidates.data=this.meshes,this._defaultMeshCandidates.length=this.meshes.length,this._defaultMeshCandidates}_getDefaultSubMeshCandidates(p){return this._defaultSubMeshCandidates.data=p.subMeshes,this._defaultSubMeshCandidates.length=p.subMeshes.length,this._defaultSubMeshCandidates}setDefaultCandidateProviders(){this.getActiveMeshCandidates=()=>this._getDefaultMeshCandidates(),this.getActiveSubMeshCandidates=p=>this._getDefaultSubMeshCandidates(p),this.getIntersectingSubMeshCandidates=(p,_)=>this._getDefaultSubMeshCandidates(p),this.getCollidingSubMeshCandidates=(p,_)=>this._getDefaultSubMeshCandidates(p)}get meshUnderPointer(){return this._inputManager.meshUnderPointer}get pointerX(){return this._inputManager.pointerX}set pointerX(p){this._inputManager.pointerX=p}get pointerY(){return this._inputManager.pointerY}set pointerY(p){this._inputManager.pointerY=p}getCachedMaterial(){return this._cachedMaterial}getCachedEffect(){return this._cachedEffect}getCachedVisibility(){return this._cachedVisibility}isCachedMaterialInvalid(p,_,E=1){return this._cachedEffect!==_||this._cachedMaterial!==p||this._cachedVisibility!==E}getEngine(){return this._engine}getTotalVertices(){return this._totalVertices.current}get totalVerticesPerfCounter(){return this._totalVertices}getActiveIndices(){return this._activeIndices.current}get totalActiveIndicesPerfCounter(){return this._activeIndices}getActiveParticles(){return this._activeParticles.current}get activeParticlesPerfCounter(){return this._activeParticles}getActiveBones(){return this._activeBones.current}get activeBonesPerfCounter(){return this._activeBones}getActiveMeshes(){return this._activeMeshes}getAnimationRatio(){return this._animationRatio!==void 0?this._animationRatio:1}getRenderId(){return this._renderId}getFrameId(){return this._frameId}incrementRenderId(){this._renderId++}_createUbo(){this.setSceneUniformBuffer(this.createSceneUniformBuffer())}simulatePointerMove(p,_){return this._inputManager.simulatePointerMove(p,_),this}simulatePointerDown(p,_){return this._inputManager.simulatePointerDown(p,_),this}simulatePointerUp(p,_,E){return this._inputManager.simulatePointerUp(p,_,E),this}isPointerCaptured(p=0){return this._inputManager.isPointerCaptured(p)}attachControl(p=!0,_=!0,E=!0){this._inputManager.attachControl(p,_,E)}detachControl(){this._inputManager.detachControl()}isReady(p=!0){if(this._isDisposed)return!1;let _;const E=this.getEngine(),A=E.currentRenderPassId;E.currentRenderPassId=this.activeCamera?.renderPassId??A;let $=!0;for(this._pendingData.length>0&&($=!1),this.prePassRenderer?.update(),this.useOrderIndependentTransparency&&this.depthPeelingRenderer&&$&&($=this.depthPeelingRenderer.isReady()),p&&(this._processedMaterials.reset(),this._materialsRenderTargets.reset()),_=0;_<this.meshes.length;_++){const ne=this.meshes[_];if(!ne.subMeshes||ne.subMeshes.length===0)continue;if(!ne.isReady(!0)){$=!1;continue}const xe=ne.hasThinInstances||ne.getClassName()==="InstancedMesh"||ne.getClassName()==="InstancedLinesMesh"||E.getCaps().instancedArrays&&ne.instances.length>0;for(const Te of this._isReadyForMeshStage)Te.action(ne,xe)||($=!1);if(!p)continue;const ce=ne.material||this.defaultMaterial;if(ce)if(ce._storeEffectOnSubMeshes)for(const Te of ne.subMeshes){const Re=Te.getMaterial();Re&&Re.hasRenderTargetTextures&&Re.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(Re)===-1&&(this._processedMaterials.push(Re),this._materialsRenderTargets.concatWithNoDuplicate(Re.getRenderTargetTextures()))}else ce.hasRenderTargetTextures&&ce.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(ce)===-1&&(this._processedMaterials.push(ce),this._materialsRenderTargets.concatWithNoDuplicate(ce.getRenderTargetTextures()))}if(p)for(_=0;_<this._materialsRenderTargets.length;++_)this._materialsRenderTargets.data[_].isReadyForRendering()||($=!1);for(_=0;_<this.geometries.length;_++)this.geometries[_].delayLoadState===2&&($=!1);if(this.activeCameras&&this.activeCameras.length>0)for(const ne of this.activeCameras)ne.isReady(!0)||($=!1);else this.activeCamera&&(this.activeCamera.isReady(!0)||($=!1));for(const ne of this.particleSystems)ne.isReady()||($=!1);if(this.layers)for(const ne of this.layers)ne.isReady()||($=!1);return E.areAllEffectsReady()||($=!1),E.currentRenderPassId=A,$}resetCachedMaterial(){this._cachedMaterial=null,this._cachedEffect=null,this._cachedVisibility=null}registerBeforeRender(p){this.onBeforeRenderObservable.add(p)}unregisterBeforeRender(p){this.onBeforeRenderObservable.removeCallback(p)}registerAfterRender(p){this.onAfterRenderObservable.add(p)}unregisterAfterRender(p){this.onAfterRenderObservable.removeCallback(p)}_executeOnceBeforeRender(p){const _=()=>{p(),setTimeout(()=>{this.unregisterBeforeRender(_)})};this.registerBeforeRender(_)}executeOnceBeforeRender(p,_){_!==void 0?setTimeout(()=>{this._executeOnceBeforeRender(p)},_):this._executeOnceBeforeRender(p)}addPendingData(p){this._pendingData.push(p)}removePendingData(p){const _=this.isLoading,E=this._pendingData.indexOf(p);E!==-1&&this._pendingData.splice(E,1),_&&!this.isLoading&&this.onDataLoadedObservable.notifyObservers(this)}getWaitingItemsCount(){return this._pendingData.length}get isLoading(){return this._pendingData.length>0}executeWhenReady(p,_=!1){this.onReadyObservable.addOnce(p),this._executeWhenReadyTimeoutId===null&&this._checkIsReady(_)}whenReadyAsync(p=!1){return new Promise(_=>{this.executeWhenReady(()=>{_()},p)})}_checkIsReady(p=!1){if(this._registerTransientComponents(),this.isReady(p)){this.onReadyObservable.notifyObservers(this),this.onReadyObservable.clear(),this._executeWhenReadyTimeoutId=null;return}if(this._isDisposed){this.onReadyObservable.clear(),this._executeWhenReadyTimeoutId=null;return}this._executeWhenReadyTimeoutId=setTimeout(()=>{this.incrementRenderId(),this._checkIsReady(p)},100)}get animatables(){return this._activeAnimatables}resetLastAnimationTimeFrame(){this._animationTimeLast=Ko.Now}getViewMatrix(){return this._viewMatrix}getProjectionMatrix(){return this._projectionMatrix}getTransformMatrix(){return this._transformMatrix}setTransformMatrix(p,_,E,A){!E&&!A&&this._multiviewSceneUbo&&(this._multiviewSceneUbo.dispose(),this._multiviewSceneUbo=null),!(this._viewUpdateFlag===p.updateFlag&&this._projectionUpdateFlag===_.updateFlag)&&(this._viewUpdateFlag=p.updateFlag,this._projectionUpdateFlag=_.updateFlag,this._viewMatrix=p,this._projectionMatrix=_,this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix),this._frustumPlanes?cl.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=cl.GetPlanes(this._transformMatrix),this._multiviewSceneUbo&&this._multiviewSceneUbo.useUbo?this._updateMultiviewUbo(E,A):this._sceneUbo.useUbo&&(this._sceneUbo.updateMatrix("viewProjection",this._transformMatrix),this._sceneUbo.updateMatrix("view",this._viewMatrix),this._sceneUbo.updateMatrix("projection",this._projectionMatrix)))}getSceneUniformBuffer(){return this._multiviewSceneUbo?this._multiviewSceneUbo:this._sceneUbo}createSceneUniformBuffer(p){const _=new $s(this._engine,void 0,!1,p??"scene");return _.addUniform("viewProjection",16),_.addUniform("view",16),_.addUniform("projection",16),_.addUniform("vEyePosition",4),_}setSceneUniformBuffer(p){this._sceneUbo=p,this._viewUpdateFlag=-1,this._projectionUpdateFlag=-1}getUniqueId(){return kb.UniqueId}addMesh(p,_=!1){this._blockEntityCollection||(this.meshes.push(p),p._resyncLightSources(),p.parent||p._addToSceneRootNodes(),this.onNewMeshAddedObservable.notifyObservers(p),_&&p.getChildMeshes().forEach(E=>{this.addMesh(E)}))}removeMesh(p,_=!1){const E=this.meshes.indexOf(p);return E!==-1&&(this.meshes[E]=this.meshes[this.meshes.length-1],this.meshes.pop(),p.parent||p._removeFromSceneRootNodes()),this._inputManager._invalidateMesh(p),this.onMeshRemovedObservable.notifyObservers(p),_&&p.getChildMeshes().forEach(A=>{this.removeMesh(A)}),E}addTransformNode(p){this._blockEntityCollection||p.getScene()===this&&p._indexInSceneTransformNodesArray!==-1||(p._indexInSceneTransformNodesArray=this.transformNodes.length,this.transformNodes.push(p),p.parent||p._addToSceneRootNodes(),this.onNewTransformNodeAddedObservable.notifyObservers(p))}removeTransformNode(p){const _=p._indexInSceneTransformNodesArray;if(_!==-1){if(_!==this.transformNodes.length-1){const E=this.transformNodes[this.transformNodes.length-1];this.transformNodes[_]=E,E._indexInSceneTransformNodesArray=_}p._indexInSceneTransformNodesArray=-1,this.transformNodes.pop(),p.parent||p._removeFromSceneRootNodes()}return this.onTransformNodeRemovedObservable.notifyObservers(p),_}removeSkeleton(p){const _=this.skeletons.indexOf(p);return _!==-1&&(this.skeletons.splice(_,1),this.onSkeletonRemovedObservable.notifyObservers(p),this._executeActiveContainerCleanup(this._activeSkeletons)),_}removeMorphTargetManager(p){const _=this.morphTargetManagers.indexOf(p);return _!==-1&&this.morphTargetManagers.splice(_,1),_}removeLight(p){const _=this.lights.indexOf(p);if(_!==-1){for(const E of this.meshes)E._removeLightSource(p,!1);this.lights.splice(_,1),this.sortLightsByPriority(),p.parent||p._removeFromSceneRootNodes()}return this.onLightRemovedObservable.notifyObservers(p),_}removeCamera(p){const _=this.cameras.indexOf(p);if(_!==-1&&(this.cameras.splice(_,1),p.parent||p._removeFromSceneRootNodes()),this.activeCameras){const E=this.activeCameras.indexOf(p);E!==-1&&this.activeCameras.splice(E,1)}return this.activeCamera===p&&(this.cameras.length>0?this.activeCamera=this.cameras[0]:this.activeCamera=null),this.onCameraRemovedObservable.notifyObservers(p),_}removeParticleSystem(p){const _=this.particleSystems.indexOf(p);return _!==-1&&(this.particleSystems.splice(_,1),this._executeActiveContainerCleanup(this._activeParticleSystems)),_}removeAnimation(p){const _=this.animations.indexOf(p);return _!==-1&&this.animations.splice(_,1),_}stopAnimation(p,_,E){}removeAnimationGroup(p){const _=this.animationGroups.indexOf(p);return _!==-1&&this.animationGroups.splice(_,1),_}removeMultiMaterial(p){const _=this.multiMaterials.indexOf(p);return _!==-1&&this.multiMaterials.splice(_,1),this.onMultiMaterialRemovedObservable.notifyObservers(p),_}removeMaterial(p){const _=p._indexInSceneMaterialArray;if(_!==-1&&_<this.materials.length){if(_!==this.materials.length-1){const E=this.materials[this.materials.length-1];this.materials[_]=E,E._indexInSceneMaterialArray=_}p._indexInSceneMaterialArray=-1,this.materials.pop()}return this.onMaterialRemovedObservable.notifyObservers(p),_}removeActionManager(p){const _=this.actionManagers.indexOf(p);return _!==-1&&this.actionManagers.splice(_,1),_}removeTexture(p){const _=this.textures.indexOf(p);return _!==-1&&this.textures.splice(_,1),this.onTextureRemovedObservable.notifyObservers(p),_}addLight(p){if(!this._blockEntityCollection){this.lights.push(p),this.sortLightsByPriority(),p.parent||p._addToSceneRootNodes();for(const _ of this.meshes)_.lightSources.indexOf(p)===-1&&(_.lightSources.push(p),_._resyncLightSources());this.onNewLightAddedObservable.notifyObservers(p)}}sortLightsByPriority(){this.requireLightSorting&&this.lights.sort(qn.CompareLightsPriority)}addCamera(p){this._blockEntityCollection||(this.cameras.push(p),this.onNewCameraAddedObservable.notifyObservers(p),p.parent||p._addToSceneRootNodes())}addSkeleton(p){this._blockEntityCollection||(this.skeletons.push(p),this.onNewSkeletonAddedObservable.notifyObservers(p))}addParticleSystem(p){this._blockEntityCollection||this.particleSystems.push(p)}addAnimation(p){this._blockEntityCollection||this.animations.push(p)}addAnimationGroup(p){this._blockEntityCollection||this.animationGroups.push(p)}addMultiMaterial(p){this._blockEntityCollection||(this.multiMaterials.push(p),this.onNewMultiMaterialAddedObservable.notifyObservers(p))}addMaterial(p){this._blockEntityCollection||p.getScene()===this&&p._indexInSceneMaterialArray!==-1||(p._indexInSceneMaterialArray=this.materials.length,this.materials.push(p),this.onNewMaterialAddedObservable.notifyObservers(p))}addMorphTargetManager(p){this._blockEntityCollection||this.morphTargetManagers.push(p)}addGeometry(p){this._blockEntityCollection||(this._geometriesByUniqueId&&(this._geometriesByUniqueId[p.uniqueId]=this.geometries.length),this.geometries.push(p))}addActionManager(p){this.actionManagers.push(p)}addTexture(p){this._blockEntityCollection||(this.textures.push(p),this.onNewTextureAddedObservable.notifyObservers(p))}switchActiveCamera(p,_=!0){this._engine.getInputElement()&&(this.activeCamera&&this.activeCamera.detachControl(),this.activeCamera=p,_&&p.attachControl())}setActiveCameraById(p){const _=this.getCameraById(p);return _?(this.activeCamera=_,_):null}setActiveCameraByName(p){const _=this.getCameraByName(p);return _?(this.activeCamera=_,_):null}getAnimationGroupByName(p){for(let _=0;_<this.animationGroups.length;_++)if(this.animationGroups[_].name===p)return this.animationGroups[_];return null}_getMaterial(p,_){for(let E=0;E<this.materials.length;E++){const A=this.materials[E];if(_(A))return A}if(p)for(let E=0;E<this.multiMaterials.length;E++){const A=this.multiMaterials[E];if(_(A))return A}return null}getMaterialByUniqueID(p,_=!1){return this._getMaterial(_,E=>E.uniqueId===p)}getMaterialById(p,_=!1){return this._getMaterial(_,E=>E.id===p)}getMaterialByName(p,_=!1){return this._getMaterial(_,E=>E.name===p)}getLastMaterialById(p,_=!1){for(let E=this.materials.length-1;E>=0;E--)if(this.materials[E].id===p)return this.materials[E];if(_){for(let E=this.multiMaterials.length-1;E>=0;E--)if(this.multiMaterials[E].id===p)return this.multiMaterials[E]}return null}getTextureByUniqueId(p){for(let _=0;_<this.textures.length;_++)if(this.textures[_].uniqueId===p)return this.textures[_];return null}getTextureByName(p){for(let _=0;_<this.textures.length;_++)if(this.textures[_].name===p)return this.textures[_];return null}getCameraById(p){for(let _=0;_<this.cameras.length;_++)if(this.cameras[_].id===p)return this.cameras[_];return null}getCameraByUniqueId(p){for(let _=0;_<this.cameras.length;_++)if(this.cameras[_].uniqueId===p)return this.cameras[_];return null}getCameraByName(p){for(let _=0;_<this.cameras.length;_++)if(this.cameras[_].name===p)return this.cameras[_];return null}getBoneById(p){for(let _=0;_<this.skeletons.length;_++){const E=this.skeletons[_];for(let A=0;A<E.bones.length;A++)if(E.bones[A].id===p)return E.bones[A]}return null}getBoneByName(p){for(let _=0;_<this.skeletons.length;_++){const E=this.skeletons[_];for(let A=0;A<E.bones.length;A++)if(E.bones[A].name===p)return E.bones[A]}return null}getLightByName(p){for(let _=0;_<this.lights.length;_++)if(this.lights[_].name===p)return this.lights[_];return null}getLightById(p){for(let _=0;_<this.lights.length;_++)if(this.lights[_].id===p)return this.lights[_];return null}getLightByUniqueId(p){for(let _=0;_<this.lights.length;_++)if(this.lights[_].uniqueId===p)return this.lights[_];return null}getParticleSystemById(p){for(let _=0;_<this.particleSystems.length;_++)if(this.particleSystems[_].id===p)return this.particleSystems[_];return null}getGeometryById(p){for(let _=0;_<this.geometries.length;_++)if(this.geometries[_].id===p)return this.geometries[_];return null}_getGeometryByUniqueId(p){if(this._geometriesByUniqueId){const _=this._geometriesByUniqueId[p];if(_!==void 0)return this.geometries[_]}else for(let _=0;_<this.geometries.length;_++)if(this.geometries[_].uniqueId===p)return this.geometries[_];return null}pushGeometry(p,_){return!_&&this._getGeometryByUniqueId(p.uniqueId)?!1:(this.addGeometry(p),this.onNewGeometryAddedObservable.notifyObservers(p),!0)}removeGeometry(p){let _;if(this._geometriesByUniqueId){if(_=this._geometriesByUniqueId[p.uniqueId],_===void 0)return!1}else if(_=this.geometries.indexOf(p),_<0)return!1;if(_!==this.geometries.length-1){const E=this.geometries[this.geometries.length-1];E&&(this.geometries[_]=E,this._geometriesByUniqueId&&(this._geometriesByUniqueId[E.uniqueId]=_))}return this._geometriesByUniqueId&&(this._geometriesByUniqueId[p.uniqueId]=void 0),this.geometries.pop(),this.onGeometryRemovedObservable.notifyObservers(p),!0}getGeometries(){return this.geometries}getMeshById(p){for(let _=0;_<this.meshes.length;_++)if(this.meshes[_].id===p)return this.meshes[_];return null}getMeshesById(p){return this.meshes.filter(function(_){return _.id===p})}getTransformNodeById(p){for(let _=0;_<this.transformNodes.length;_++)if(this.transformNodes[_].id===p)return this.transformNodes[_];return null}getTransformNodeByUniqueId(p){for(let _=0;_<this.transformNodes.length;_++)if(this.transformNodes[_].uniqueId===p)return this.transformNodes[_];return null}getTransformNodesById(p){return this.transformNodes.filter(function(_){return _.id===p})}getMeshByUniqueId(p){for(let _=0;_<this.meshes.length;_++)if(this.meshes[_].uniqueId===p)return this.meshes[_];return null}getLastMeshById(p){for(let _=this.meshes.length-1;_>=0;_--)if(this.meshes[_].id===p)return this.meshes[_];return null}getLastTransformNodeById(p){for(let _=this.transformNodes.length-1;_>=0;_--)if(this.transformNodes[_].id===p)return this.transformNodes[_];return null}getLastEntryById(p){let _;for(_=this.meshes.length-1;_>=0;_--)if(this.meshes[_].id===p)return this.meshes[_];for(_=this.transformNodes.length-1;_>=0;_--)if(this.transformNodes[_].id===p)return this.transformNodes[_];for(_=this.cameras.length-1;_>=0;_--)if(this.cameras[_].id===p)return this.cameras[_];for(_=this.lights.length-1;_>=0;_--)if(this.lights[_].id===p)return this.lights[_];return null}getNodeById(p){const _=this.getMeshById(p);if(_)return _;const E=this.getTransformNodeById(p);if(E)return E;const A=this.getLightById(p);if(A)return A;const $=this.getCameraById(p);if($)return $;const ne=this.getBoneById(p);return ne||null}getNodeByName(p){const _=this.getMeshByName(p);if(_)return _;const E=this.getTransformNodeByName(p);if(E)return E;const A=this.getLightByName(p);if(A)return A;const $=this.getCameraByName(p);if($)return $;const ne=this.getBoneByName(p);return ne||null}getMeshByName(p){for(let _=0;_<this.meshes.length;_++)if(this.meshes[_].name===p)return this.meshes[_];return null}getTransformNodeByName(p){for(let _=0;_<this.transformNodes.length;_++)if(this.transformNodes[_].name===p)return this.transformNodes[_];return null}getLastSkeletonById(p){for(let _=this.skeletons.length-1;_>=0;_--)if(this.skeletons[_].id===p)return this.skeletons[_];return null}getSkeletonByUniqueId(p){for(let _=0;_<this.skeletons.length;_++)if(this.skeletons[_].uniqueId===p)return this.skeletons[_];return null}getSkeletonById(p){for(let _=0;_<this.skeletons.length;_++)if(this.skeletons[_].id===p)return this.skeletons[_];return null}getSkeletonByName(p){for(let _=0;_<this.skeletons.length;_++)if(this.skeletons[_].name===p)return this.skeletons[_];return null}getMorphTargetManagerById(p){for(let _=0;_<this.morphTargetManagers.length;_++)if(this.morphTargetManagers[_].uniqueId===p)return this.morphTargetManagers[_];return null}getMorphTargetById(p){for(let _=0;_<this.morphTargetManagers.length;++_){const E=this.morphTargetManagers[_];for(let A=0;A<E.numTargets;++A){const $=E.getTarget(A);if($.id===p)return $}}return null}getMorphTargetByName(p){for(let _=0;_<this.morphTargetManagers.length;++_){const E=this.morphTargetManagers[_];for(let A=0;A<E.numTargets;++A){const $=E.getTarget(A);if($.name===p)return $}}return null}getPostProcessByName(p){for(let _=0;_<this.postProcesses.length;++_){const E=this.postProcesses[_];if(E.name===p)return E}return null}isActiveMesh(p){return this._activeMeshes.indexOf(p)!==-1}get uid(){return this._uid||(this._uid=ct.RandomId()),this._uid}addExternalData(p,_){return this._externalData||(this._externalData=new Ut),this._externalData.add(p,_)}getExternalData(p){return this._externalData?this._externalData.get(p):null}getOrAddExternalDataWithFactory(p,_){return this._externalData||(this._externalData=new Ut),this._externalData.getOrAddWithFactory(p,_)}removeExternalData(p){return this._externalData.remove(p)}_evaluateSubMesh(p,_,E,A){if(A||p.isInFrustum(this._frustumPlanes)){for(const ne of this._evaluateSubMeshStage)ne.action(_,p);const $=p.getMaterial();$!=null&&($.hasRenderTargetTextures&&$.getRenderTargetTextures!=null&&this._processedMaterials.indexOf($)===-1&&(this._processedMaterials.push($),this._materialsRenderTargets.concatWithNoDuplicate($.getRenderTargetTextures())),this._renderingManager.dispatch(p,_,$))}}freeProcessedMaterials(){this._processedMaterials.dispose()}get blockfreeActiveMeshesAndRenderingGroups(){return this._preventFreeActiveMeshesAndRenderingGroups}set blockfreeActiveMeshesAndRenderingGroups(p){this._preventFreeActiveMeshesAndRenderingGroups!==p&&(p&&(this.freeActiveMeshes(),this.freeRenderingGroups()),this._preventFreeActiveMeshesAndRenderingGroups=p)}freeActiveMeshes(){if(!this.blockfreeActiveMeshesAndRenderingGroups&&(this._activeMeshes.dispose(),this.activeCamera&&this.activeCamera._activeMeshes&&this.activeCamera._activeMeshes.dispose(),this.activeCameras))for(let p=0;p<this.activeCameras.length;p++){const _=this.activeCameras[p];_&&_._activeMeshes&&_._activeMeshes.dispose()}}freeRenderingGroups(){if(!this.blockfreeActiveMeshesAndRenderingGroups&&(this._renderingManager&&this._renderingManager.freeRenderingGroups(),this.textures))for(let p=0;p<this.textures.length;p++){const _=this.textures[p];_&&_.renderList&&_.freeRenderingGroups()}}_isInIntermediateRendering(){return this._intermediateRendering}freezeActiveMeshes(p=!1,_,E,A=!0,$=!1){return this.executeWhenReady(()=>{if(!this.activeCamera){E&&E("No active camera found");return}if(this._frustumPlanes||this.updateTransformMatrix(),this._evaluateActiveMeshes(),this._activeMeshesFrozen=!0,this._activeMeshesFrozenButKeepClipping=$,this._skipEvaluateActiveMeshesCompletely=p,A)for(let ne=0;ne<this._activeMeshes.length;ne++)this._activeMeshes.data[ne]._freeze();_&&_()}),this}unfreezeActiveMeshes(){for(let p=0;p<this.meshes.length;p++){const _=this.meshes[p];_._internalAbstractMeshDataInfo&&(_._internalAbstractMeshDataInfo._isActive=!1)}for(let p=0;p<this._activeMeshes.length;p++)this._activeMeshes.data[p]._unFreeze();return this._activeMeshesFrozen=!1,this}_executeActiveContainerCleanup(p){!(this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1)&&this._activeMeshesFrozen&&this._activeMeshes.length||this.onBeforeRenderObservable.addOnce(()=>p.dispose())}_evaluateActiveMeshes(){if(this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1){this._activeMeshes.length>0&&(this.activeCamera?._activeMeshes.reset(),this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset());return}if(this._activeMeshesFrozen&&this._activeMeshes.length){if(!this._skipEvaluateActiveMeshesCompletely){const E=this._activeMeshes.length;for(let A=0;A<E;A++)this._activeMeshes.data[A].computeWorldMatrix()}if(this._activeParticleSystems){const E=this._activeParticleSystems.length;for(let A=0;A<E;A++)this._activeParticleSystems.data[A].animate()}this._renderingManager.resetSprites();return}if(!this.activeCamera)return;this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this),this.activeCamera._activeMeshes.reset(),this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset(),this._materialsRenderTargets.reset();for(const E of this._beforeEvaluateActiveMeshStage)E.action();const p=this.getActiveMeshCandidates(),_=p.length;for(let E=0;E<_;E++){const A=p.data[E];if(A._internalAbstractMeshDataInfo._currentLODIsUpToDate=!1,A.isBlocked||(this._totalVertices.addCount(A.getTotalVertices(),!1),!A.isReady()||!A.isEnabled()||A.scaling.hasAZeroComponent))continue;A.computeWorldMatrix(),A.actionManager&&A.actionManager.hasSpecificTriggers2(12,13)&&this._meshesForIntersections.pushNoDuplicate(A);let $=this.customLODSelector?this.customLODSelector(A,this.activeCamera):A.getLOD(this.activeCamera);if(A._internalAbstractMeshDataInfo._currentLOD=$,A._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0,$!=null&&($!==A&&$.billboardMode!==0&&$.computeWorldMatrix(),A._preActivate(),A.isVisible&&A.visibility>0&&A.layerMask&this.activeCamera.layerMask&&(this._skipFrustumClipping||A.alwaysSelectAsActiveMesh||A.isInFrustum(this._frustumPlanes)))){this._activeMeshes.push(A),this.activeCamera._activeMeshes.push(A),$!==A&&$._activate(this._renderId,!1);for(const ne of this._preActiveMeshStage)ne.action(A);A._activate(this._renderId,!1)&&(A.isAnInstance?A._internalAbstractMeshDataInfo._actAsRegularMesh&&($=A):$._internalAbstractMeshDataInfo._onlyForInstances=!1,$._internalAbstractMeshDataInfo._isActive=!0,this._activeMesh(A,$)),A._postActivate()}}if(this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this),this.particlesEnabled){this.onBeforeParticlesRenderingObservable.notifyObservers(this);for(let E=0;E<this.particleSystems.length;E++){const A=this.particleSystems[E];if(!A.isStarted()||!A.emitter)continue;const $=A.emitter;(!$.position||$.isEnabled())&&(this._activeParticleSystems.push(A),A.animate(),this._renderingManager.dispatchParticles(A))}this.onAfterParticlesRenderingObservable.notifyObservers(this)}}_activeMesh(p,_){this._skeletonsEnabled&&_.skeleton!==null&&_.skeleton!==void 0&&(this._activeSkeletons.pushNoDuplicate(_.skeleton)&&(_.skeleton.prepare(),this._activeBones.addCount(_.skeleton.bones.length,!1)),_.computeBonesUsingShaders||this._softwareSkinnedMeshes.pushNoDuplicate(_));let E=p.hasInstances||p.isAnInstance||this.dispatchAllSubMeshesOfActiveMeshes||this._skipFrustumClipping||_.alwaysSelectAsActiveMesh;if(_&&_.subMeshes&&_.subMeshes.length>0){const A=this.getActiveSubMeshCandidates(_),$=A.length;E=E||$===1;for(let ne=0;ne<$;ne++){const xe=A.data[ne];this._evaluateSubMesh(xe,_,p,E)}}}updateTransformMatrix(p){const _=this.activeCamera;if(_)if(_._renderingMultiview){const E=_._rigCameras[0],A=_._rigCameras[1];this.setTransformMatrix(E.getViewMatrix(),E.getProjectionMatrix(p),A.getViewMatrix(),A.getProjectionMatrix(p))}else this.setTransformMatrix(_.getViewMatrix(),_.getProjectionMatrix(p))}_bindFrameBuffer(p,_=!0){p&&p._multiviewTexture?p._multiviewTexture._bindFrameBuffer():p&&p.outputRenderTarget?p.outputRenderTarget._bindFrameBuffer():this._engine._currentFrameBufferIsDefaultFrameBuffer()||this._engine.restoreDefaultFramebuffer(),_&&this._clearFrameBuffer(p)}_clearFrameBuffer(p){if(!(p&&p._multiviewTexture))if(p&&p.outputRenderTarget&&!p._renderingMultiview){const _=p.outputRenderTarget;_.onClearObservable.hasObservers()?_.onClearObservable.notifyObservers(this._engine):_.skipInitialClear||(this.autoClear&&this._engine.clear(_.clearColor||this.clearColor,!_._cleared,!0,!0),_._cleared=!0)}else this._defaultFrameBufferCleared?this._engine.clear(null,!1,!0,!0):(this._defaultFrameBufferCleared=!0,this._clear())}_renderForCamera(p,_,E=!0){if(p&&p._skipRendering)return;const A=this._engine;if(this._activeCamera=p,!this.activeCamera)throw new Error("Active camera not set");if(A.setViewport(this.activeCamera.viewport),this.resetCachedMaterial(),this._renderId++,!this.prePass&&E){let ne=!0;p._renderingMultiview&&p.outputRenderTarget&&(ne=p.outputRenderTarget.skipInitialClear,this.autoClear&&(this._defaultFrameBufferCleared=!1,p.outputRenderTarget.skipInitialClear=!1)),this._bindFrameBuffer(this._activeCamera),p._renderingMultiview&&p.outputRenderTarget&&(p.outputRenderTarget.skipInitialClear=ne)}this.updateTransformMatrix(),this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera),this._evaluateActiveMeshes();for(let ne=0;ne<this._softwareSkinnedMeshes.length;ne++){const xe=this._softwareSkinnedMeshes.data[ne];xe.applySkeleton(xe.skeleton)}this.onBeforeRenderTargetsRenderObservable.notifyObservers(this),this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets),p.customRenderTargets&&p.customRenderTargets.length>0&&this._renderTargets.concatWithNoDuplicate(p.customRenderTargets),_&&_.customRenderTargets&&_.customRenderTargets.length>0&&this._renderTargets.concatWithNoDuplicate(_.customRenderTargets),this.environmentTexture&&this.environmentTexture.isRenderTarget&&this._renderTargets.pushNoDuplicate(this.environmentTexture);for(const ne of this._gatherActiveCameraRenderTargetsStage)ne.action(this._renderTargets);let $=!1;if(this.renderTargetsEnabled){if(this._intermediateRendering=!0,this._renderTargets.length>0){ct.StartPerformanceCounter("Render targets",this._renderTargets.length>0);for(let ne=0;ne<this._renderTargets.length;ne++){const xe=this._renderTargets.data[ne];if(xe._shouldRender()){this._renderId++;const ce=xe.activeCamera&&xe.activeCamera!==this.activeCamera;xe.render(ce,this.dumpNextRenderTargets),$=!0}}ct.EndPerformanceCounter("Render targets",this._renderTargets.length>0),this._renderId++}for(const ne of this._cameraDrawRenderTargetStage)$=ne.action(this.activeCamera)||$;this._intermediateRendering=!1}this._engine.currentRenderPassId=p.outputRenderTarget?.renderPassId??p.renderPassId??0,$&&!this.prePass&&(this._bindFrameBuffer(this._activeCamera,!1),this.updateTransformMatrix()),this.onAfterRenderTargetsRenderObservable.notifyObservers(this),this.postProcessManager&&!p._multiviewTexture&&!this.prePass&&this.postProcessManager._prepareFrame();for(const ne of this._beforeCameraDrawStage)ne.action(this.activeCamera);this.onBeforeDrawPhaseObservable.notifyObservers(this),A.snapshotRendering&&A.snapshotRenderingMode===1&&this.finalizeSceneUbo(),this._renderingManager.render(null,null,!0,!0),this.onAfterDrawPhaseObservable.notifyObservers(this);for(const ne of this._afterCameraDrawStage)ne.action(this.activeCamera);if(this.postProcessManager&&!p._multiviewTexture){const ne=p.outputRenderTarget?p.outputRenderTarget.renderTarget:void 0;this.postProcessManager._finalizeFrame(p.isIntermediate,ne)}for(const ne of this._afterCameraPostProcessStage)ne.action(this.activeCamera);this._renderTargets.reset(),this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera)}_processSubCameras(p,_=!0){if(p.cameraRigMode===0||p._renderingMultiview){p._renderingMultiview&&!this._multiviewSceneUbo&&this._createMultiviewUbo(),this._renderForCamera(p,void 0,_),this.onAfterRenderCameraObservable.notifyObservers(p);return}if(p._useMultiviewToSingleView)this._renderMultiviewToSingleView(p);else{this.onBeforeCameraRenderObservable.notifyObservers(p);for(let E=0;E<p._rigCameras.length;E++)this._renderForCamera(p._rigCameras[E],p)}this._activeCamera=p,this.updateTransformMatrix(),this.onAfterRenderCameraObservable.notifyObservers(p)}_checkIntersections(){for(let p=0;p<this._meshesForIntersections.length;p++){const _=this._meshesForIntersections.data[p];if(_.actionManager)for(let E=0;_.actionManager&&E<_.actionManager.actions.length;E++){const A=_.actionManager.actions[E];if(A.trigger===12||A.trigger===13){const $=A.getTriggerParameter(),ne=$.mesh?$.mesh:$,xe=ne.intersectsMesh(_,$.usePreciseIntersection),ce=_._intersectionsInProgress.indexOf(ne);xe&&ce===-1?A.trigger===12?(A._executeCurrent(no.CreateNew(_,void 0,ne)),_._intersectionsInProgress.push(ne)):A.trigger===13&&_._intersectionsInProgress.push(ne):!xe&&ce>-1&&(A.trigger===13&&A._executeCurrent(no.CreateNew(_,void 0,ne)),(!_.actionManager.hasSpecificTrigger(13,Te=>{const Re=Te.mesh?Te.mesh:Te;return ne===Re})||A.trigger===13)&&_._intersectionsInProgress.splice(ce,1))}}}}_advancePhysicsEngineStep(p){}_animate(){}animate(){if(this._engine.isDeterministicLockStep()){let p=Math.max(W0.MinDeltaTime,Math.min(this._engine.getDeltaTime(),W0.MaxDeltaTime))+this._timeAccumulator;const _=this._engine.getTimeStep(),E=1e3/_/1e3;let A=0;const $=this._engine.getLockstepMaxSteps();let ne=Math.floor(p/_);for(ne=Math.min(ne,$);p>0&&A<ne;)this.onBeforeStepObservable.notifyObservers(this),this._animationRatio=_*E,this._animate(),this.onAfterAnimationsObservable.notifyObservers(this),this.physicsEnabled&&this._advancePhysicsEngineStep(_),this.onAfterStepObservable.notifyObservers(this),this._currentStepId++,A++,p-=_;this._timeAccumulator=p<0?0:p}else{const p=this.useConstantAnimationDeltaTime?16:Math.max(W0.MinDeltaTime,Math.min(this._engine.getDeltaTime(),W0.MaxDeltaTime));this._animationRatio=p*(60/1e3),this._animate(),this.onAfterAnimationsObservable.notifyObservers(this),this.physicsEnabled&&this._advancePhysicsEngineStep(p)}}_clear(){(this.autoClearDepthAndStencil||this.autoClear)&&this._engine.clear(this.clearColor,this.autoClear||this.forceWireframe||this.forcePointsCloud,this.autoClearDepthAndStencil,this.autoClearDepthAndStencil)}_checkCameraRenderTarget(p){if(p?.outputRenderTarget&&!p?.isRigCamera&&(p.outputRenderTarget._cleared=!1),p?.rigCameras?.length)for(let _=0;_<p.rigCameras.length;++_){const E=p.rigCameras[_].outputRenderTarget;E&&(E._cleared=!1)}}resetDrawCache(p){if(this.meshes)for(const _ of this.meshes)_.resetDrawCache(p)}render(p=!0,_=!1){if(this.isDisposed)return;this.onReadyObservable.hasObservers()&&this._executeWhenReadyTimeoutId===null&&this._checkIsReady(),this._frameId++,this._defaultFrameBufferCleared=!1,this._checkCameraRenderTarget(this.activeCamera),this.activeCameras?.length&&this.activeCameras.forEach(this._checkCameraRenderTarget),this._registerTransientComponents(),this._activeParticles.fetchNewFrame(),this._totalVertices.fetchNewFrame(),this._activeIndices.fetchNewFrame(),this._activeBones.fetchNewFrame(),this._meshesForIntersections.reset(),this.resetCachedMaterial(),this.onBeforeAnimationsObservable.notifyObservers(this),this.actionManager&&this.actionManager.processTrigger(11),_||this.animate();for(const $ of this._beforeCameraUpdateStage)$.action();if(p){if(this.activeCameras&&this.activeCameras.length>0)for(let $=0;$<this.activeCameras.length;$++){const ne=this.activeCameras[$];if(ne.update(),ne.cameraRigMode!==0)for(let xe=0;xe<ne._rigCameras.length;xe++)ne._rigCameras[xe].update()}else if(this.activeCamera&&(this.activeCamera.update(),this.activeCamera.cameraRigMode!==0))for(let $=0;$<this.activeCamera._rigCameras.length;$++)this.activeCamera._rigCameras[$].update()}this.onBeforeRenderObservable.notifyObservers(this);const E=this.getEngine();this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);const A=this.activeCameras?.length?this.activeCameras[0]:this.activeCamera;if(this.renderTargetsEnabled){ct.StartPerformanceCounter("Custom render targets",this.customRenderTargets.length>0),this._intermediateRendering=!0;for(let $=0;$<this.customRenderTargets.length;$++){const ne=this.customRenderTargets[$];if(ne._shouldRender()){if(this._renderId++,this.activeCamera=ne.activeCamera||this.activeCamera,!this.activeCamera)throw new Error("Active camera not set");E.setViewport(this.activeCamera.viewport),this.updateTransformMatrix(),ne.render(A!==this.activeCamera,this.dumpNextRenderTargets)}}ct.EndPerformanceCounter("Custom render targets",this.customRenderTargets.length>0),this._intermediateRendering=!1,this._renderId++}this._engine.currentRenderPassId=A?.renderPassId??0,this.activeCamera=A,this._activeCamera&&this._activeCamera.cameraRigMode!==22&&!this.prePass&&this._bindFrameBuffer(this._activeCamera,!1),this.onAfterRenderTargetsRenderObservable.notifyObservers(this);for(const $ of this._beforeClearStage)$.action();this._clearFrameBuffer(this.activeCamera);for(const $ of this._gatherRenderTargetsStage)$.action(this._renderTargets);if(this.activeCameras&&this.activeCameras.length>0)for(let $=0;$<this.activeCameras.length;$++)this._processSubCameras(this.activeCameras[$],$>0);else{if(!this.activeCamera)throw new Error("No camera defined");this._processSubCameras(this.activeCamera,!!this.activeCamera.outputRenderTarget)}this._checkIntersections();for(const $ of this._afterRenderStage)$.action();if(this.afterRender&&this.afterRender(),this.onAfterRenderObservable.notifyObservers(this),this._toBeDisposed.length){for(let $=0;$<this._toBeDisposed.length;$++){const ne=this._toBeDisposed[$];ne&&ne.dispose()}this._toBeDisposed.length=0}this.dumpNextRenderTargets&&(this.dumpNextRenderTargets=!1),this._activeBones.addCount(0,!0),this._activeIndices.addCount(0,!0),this._activeParticles.addCount(0,!0),this._engine.restoreDefaultFramebuffer()}freezeMaterials(){for(let p=0;p<this.materials.length;p++)this.materials[p].freeze()}unfreezeMaterials(){for(let p=0;p<this.materials.length;p++)this.materials[p].unfreeze()}dispose(){if(this.isDisposed)return;this.beforeRender=null,this.afterRender=null,this.metadata=null,this.skeletons.length=0,this.morphTargetManagers.length=0,this._transientComponents.length=0,this._isReadyForMeshStage.clear(),this._beforeEvaluateActiveMeshStage.clear(),this._evaluateSubMeshStage.clear(),this._preActiveMeshStage.clear(),this._cameraDrawRenderTargetStage.clear(),this._beforeCameraDrawStage.clear(),this._beforeRenderTargetDrawStage.clear(),this._beforeRenderingGroupDrawStage.clear(),this._beforeRenderingMeshStage.clear(),this._afterRenderingMeshStage.clear(),this._afterRenderingGroupDrawStage.clear(),this._afterCameraDrawStage.clear(),this._afterRenderTargetDrawStage.clear(),this._afterRenderStage.clear(),this._beforeCameraUpdateStage.clear(),this._beforeClearStage.clear(),this._gatherRenderTargetsStage.clear(),this._gatherActiveCameraRenderTargetsStage.clear(),this._pointerMoveStage.clear(),this._pointerDownStage.clear(),this._pointerUpStage.clear(),this.importedMeshesFiles=[],this.stopAllAnimations&&(this._activeAnimatables.forEach($=>{$.onAnimationEndObservable.clear(),$.onAnimationEnd=null}),this.stopAllAnimations()),this.resetCachedMaterial(),this.activeCamera&&(this.activeCamera._activeMeshes.dispose(),this.activeCamera=null),this.activeCameras=null,this._activeMeshes.dispose(),this._renderingManager.dispose(),this._processedMaterials.dispose(),this._activeParticleSystems.dispose(),this._activeSkeletons.dispose(),this._softwareSkinnedMeshes.dispose(),this._renderTargets.dispose(),this._materialsRenderTargets.dispose(),this._registeredForLateAnimationBindings.dispose(),this._meshesForIntersections.dispose(),this._toBeDisposed.length=0;const p=this._activeRequests.slice();for(const $ of p)$.abort();this._activeRequests.length=0;try{this.onDisposeObservable.notifyObservers(this)}catch($){vi.Error("An error occurred while calling onDisposeObservable!",$)}if(this.detachControl(),this._engine.getInputElement())for(let $=0;$<this.cameras.length;$++)this.cameras[$].detachControl();this._disposeList(this.animationGroups),this._disposeList(this.lights),this._disposeList(this.meshes,$=>$.dispose(!0)),this._disposeList(this.transformNodes,$=>$.dispose(!0));const E=this.cameras;this._disposeList(E),this._defaultMaterial&&this._defaultMaterial.dispose(),this._disposeList(this.multiMaterials),this._disposeList(this.materials),this._disposeList(this.particleSystems),this._disposeList(this.postProcesses),this._disposeList(this.textures),this._disposeList(this.morphTargetManagers),this._sceneUbo.dispose(),this._multiviewSceneUbo&&this._multiviewSceneUbo.dispose(),this.postProcessManager.dispose(),this._disposeList(this._components);let A=this._engine.scenes.indexOf(this);A>-1&&this._engine.scenes.splice(A,1),wr._LastCreatedScene===this&&(this._engine.scenes.length>0?wr._LastCreatedScene=this._engine.scenes[this._engine.scenes.length-1]:wr._LastCreatedScene=null),A=this._engine._virtualScenes.indexOf(this),A>-1&&this._engine._virtualScenes.splice(A,1),this._engine.wipeCaches(!0),this.onDisposeObservable.clear(),this.onBeforeRenderObservable.clear(),this.onAfterRenderObservable.clear(),this.onBeforeRenderTargetsRenderObservable.clear(),this.onAfterRenderTargetsRenderObservable.clear(),this.onAfterStepObservable.clear(),this.onBeforeStepObservable.clear(),this.onBeforeActiveMeshesEvaluationObservable.clear(),this.onAfterActiveMeshesEvaluationObservable.clear(),this.onBeforeParticlesRenderingObservable.clear(),this.onAfterParticlesRenderingObservable.clear(),this.onBeforeDrawPhaseObservable.clear(),this.onAfterDrawPhaseObservable.clear(),this.onBeforeAnimationsObservable.clear(),this.onAfterAnimationsObservable.clear(),this.onDataLoadedObservable.clear(),this.onBeforeRenderingGroupObservable.clear(),this.onAfterRenderingGroupObservable.clear(),this.onMeshImportedObservable.clear(),this.onBeforeCameraRenderObservable.clear(),this.onAfterCameraRenderObservable.clear(),this.onAfterRenderCameraObservable.clear(),this.onReadyObservable.clear(),this.onNewCameraAddedObservable.clear(),this.onCameraRemovedObservable.clear(),this.onNewLightAddedObservable.clear(),this.onLightRemovedObservable.clear(),this.onNewGeometryAddedObservable.clear(),this.onGeometryRemovedObservable.clear(),this.onNewTransformNodeAddedObservable.clear(),this.onTransformNodeRemovedObservable.clear(),this.onNewMeshAddedObservable.clear(),this.onMeshRemovedObservable.clear(),this.onNewSkeletonAddedObservable.clear(),this.onSkeletonRemovedObservable.clear(),this.onNewMaterialAddedObservable.clear(),this.onNewMultiMaterialAddedObservable.clear(),this.onMaterialRemovedObservable.clear(),this.onMultiMaterialRemovedObservable.clear(),this.onNewTextureAddedObservable.clear(),this.onTextureRemovedObservable.clear(),this.onPrePointerObservable.clear(),this.onPointerObservable.clear(),this.onPreKeyboardObservable.clear(),this.onKeyboardObservable.clear(),this.onActiveCameraChanged.clear(),this.onScenePerformancePriorityChangedObservable.clear(),this._isDisposed=!0}_disposeList(p,_){const E=p.slice(0);_=_??(A=>A.dispose());for(const A of E)_(A);p.length=0}get isDisposed(){return this._isDisposed}clearCachedVertexData(){for(let p=0;p<this.meshes.length;p++){const E=this.meshes[p].geometry;E&&E.clearCachedData()}}cleanCachedTextureBuffer(){for(const p of this.textures)p._buffer&&(p._buffer=null)}getWorldExtends(p){const _=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),E=new nt(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return p=p||(()=>!0),this.meshes.filter(p).forEach(A=>{if(A.computeWorldMatrix(!0),!A.subMeshes||A.subMeshes.length===0||A.infiniteDistance)return;const $=A.getBoundingInfo(),ne=$.boundingBox.minimumWorld,xe=$.boundingBox.maximumWorld;nt.CheckExtends(ne,_,E),nt.CheckExtends(xe,_,E)}),{min:_,max:E}}createPickingRay(p,_,E,A,$=!1){throw Tr("Ray")}createPickingRayToRef(p,_,E,A,$,ne=!1,xe=!1){throw Tr("Ray")}createPickingRayInCameraSpace(p,_,E){throw Tr("Ray")}createPickingRayInCameraSpaceToRef(p,_,E,A){throw Tr("Ray")}get _pickingAvailable(){return!1}pick(p,_,E,A,$,ne){const xe=Tr("Ray",!0);return xe&&vi.Warn(xe),new nm}pickWithBoundingInfo(p,_,E,A,$){const ne=Tr("Ray",!0);return ne&&vi.Warn(ne),new nm}pickWithRay(p,_,E,A){throw Tr("Ray")}multiPick(p,_,E,A,$){throw Tr("Ray")}multiPickWithRay(p,_,E){throw Tr("Ray")}setPointerOverMesh(p,_,E){this._inputManager.setPointerOverMesh(p,_,E)}getPointerOverMesh(){return this._inputManager.getPointerOverMesh()}_rebuildGeometries(){for(const p of this.geometries)p._rebuild();for(const p of this.meshes)p._rebuild();this.postProcessManager&&this.postProcessManager._rebuild();for(const p of this._components)p.rebuild();for(const p of this.particleSystems)p.rebuild();if(this.spriteManagers)for(const p of this.spriteManagers)p.rebuild()}_rebuildTextures(){for(const p of this.textures)p._rebuild(!0);this.markAllMaterialsAsDirty(1)}_getByTags(p,_,E){if(_===void 0)return p;const A=[];for(const $ in p){const ne=p[$];ni&&ni.MatchesQuery(ne,_)&&(!E||E(ne))&&A.push(ne)}return A}getMeshesByTags(p,_){return this._getByTags(this.meshes,p,_)}getCamerasByTags(p,_){return this._getByTags(this.cameras,p,_)}getLightsByTags(p,_){return this._getByTags(this.lights,p,_)}getMaterialByTags(p,_){return this._getByTags(this.materials,p,_).concat(this._getByTags(this.multiMaterials,p,_))}getTransformNodesByTags(p,_){return this._getByTags(this.transformNodes,p,_)}setRenderingOrder(p,_=null,E=null,A=null){this._renderingManager.setRenderingOrder(p,_,E,A)}setRenderingAutoClearDepthStencil(p,_,E=!0,A=!0){this._renderingManager.setRenderingAutoClearDepthStencil(p,_,E,A)}getAutoClearDepthStencilSetup(p){return this._renderingManager.getAutoClearDepthStencilSetup(p)}_forceBlockMaterialDirtyMechanism(p){this._blockMaterialDirtyMechanism=p}get blockMaterialDirtyMechanism(){return this._blockMaterialDirtyMechanism}set blockMaterialDirtyMechanism(p){this._blockMaterialDirtyMechanism!==p&&(this._blockMaterialDirtyMechanism=p,p||this.markAllMaterialsAsDirty(63))}markAllMaterialsAsDirty(p,_){if(!this._blockMaterialDirtyMechanism)for(const E of this.materials)_&&!_(E)||E.markAsDirty(p)}_loadFile(p,_,E,A,$,ne,xe){const ce=Tx(p,_,E,A?this.offlineProvider:void 0,$,ne,xe);return this._activeRequests.push(ce),ce.onCompleteObservable.add(Te=>{this._activeRequests.splice(this._activeRequests.indexOf(Te),1)}),ce}_loadFileAsync(p,_,E,A,$){return new Promise((ne,xe)=>{this._loadFile(p,ce=>{ne(ce)},_,E,A,(ce,Te)=>{xe(Te)},$)})}_requestFile(p,_,E,A,$,ne,xe){const ce=$2(p,_,E,A?this.offlineProvider:void 0,$,ne,xe);return this._activeRequests.push(ce),ce.onCompleteObservable.add(Te=>{this._activeRequests.splice(this._activeRequests.indexOf(Te),1)}),ce}_requestFileAsync(p,_,E,A,$){return new Promise((ne,xe)=>{this._requestFile(p,ce=>{ne(ce)},_,E,A,ce=>{xe(ce)},$)})}_readFile(p,_,E,A,$){const ne=Ll(p,_,E,A,$);return this._activeRequests.push(ne),ne.onCompleteObservable.add(xe=>{this._activeRequests.splice(this._activeRequests.indexOf(xe),1)}),ne}_readFileAsync(p,_,E){return new Promise((A,$)=>{this._readFile(p,ne=>{A(ne)},_,E,ne=>{$(ne)})})}getPerfCollector(){throw Tr("performanceViewerSceneExtension")}setActiveCameraByID(p){return this.setActiveCameraById(p)}getMaterialByID(p){return this.getMaterialById(p)}getLastMaterialByID(p){return this.getLastMaterialById(p)}getTextureByUniqueID(p){return this.getTextureByUniqueId(p)}getCameraByID(p){return this.getCameraById(p)}getCameraByUniqueID(p){return this.getCameraByUniqueId(p)}getBoneByID(p){return this.getBoneById(p)}getLightByID(p){return this.getLightById(p)}getLightByUniqueID(p){return this.getLightByUniqueId(p)}getParticleSystemByID(p){return this.getParticleSystemById(p)}getGeometryByID(p){return this.getGeometryById(p)}getMeshByID(p){return this.getMeshById(p)}getMeshByUniqueID(p){return this.getMeshByUniqueId(p)}getLastMeshByID(p){return this.getLastMeshById(p)}getMeshesByID(p){return this.getMeshesById(p)}getTransformNodeByID(p){return this.getTransformNodeById(p)}getTransformNodeByUniqueID(p){return this.getTransformNodeByUniqueId(p)}getTransformNodesByID(p){return this.getTransformNodesById(p)}getNodeByID(p){return this.getNodeById(p)}getLastEntryByID(p){return this.getLastEntryById(p)}getLastSkeletonByID(p){return this.getLastSkeletonById(p)}}W0.FOGMODE_NONE=0,W0.FOGMODE_EXP=1,W0.FOGMODE_EXP2=2,W0.FOGMODE_LINEAR=3,W0.MinDeltaTime=1,W0.MaxDeltaTime=1e3;class xw{constructor(){this._doNotSerialize=!1,this._isDisposed=!1,this._sceneRootNodesIndex=-1,this._isEnabled=!0,this._isParentEnabled=!0,this._isReady=!0,this._onEnabledStateChangedObservable=new Mi,this._onClonedObservable=new Mi}}class Ka{static AddNodeConstructor(p,_){this._NodeConstructors[p]=_}static Construct(p,_,E,A){const $=this._NodeConstructors[p];return $?$(_,E,A):null}set accessibilityTag(p){this._accessibilityTag=p,this.onAccessibilityTagChangedObservable.notifyObservers(p)}get accessibilityTag(){return this._accessibilityTag}get doNotSerialize(){return this._nodeDataStorage._doNotSerialize?!0:this._parentNode?this._parentNode.doNotSerialize:!1}set doNotSerialize(p){this._nodeDataStorage._doNotSerialize=p}isDisposed(){return this._nodeDataStorage._isDisposed}set parent(p){if(this._parentNode===p)return;const _=this._parentNode;if(this._parentNode&&this._parentNode._children!==void 0&&this._parentNode._children!==null){const E=this._parentNode._children.indexOf(this);E!==-1&&this._parentNode._children.splice(E,1),!p&&!this._nodeDataStorage._isDisposed&&this._addToSceneRootNodes()}this._parentNode=p,this._parentNode&&((this._parentNode._children===void 0||this._parentNode._children===null)&&(this._parentNode._children=new Array),this._parentNode._children.push(this),_||this._removeFromSceneRootNodes()),this._syncParentEnabledState()}get parent(){return this._parentNode}_serializeAsParent(p){p.parentId=this.uniqueId}_addToSceneRootNodes(){this._nodeDataStorage._sceneRootNodesIndex===-1&&(this._nodeDataStorage._sceneRootNodesIndex=this._scene.rootNodes.length,this._scene.rootNodes.push(this))}_removeFromSceneRootNodes(){if(this._nodeDataStorage._sceneRootNodesIndex!==-1){const p=this._scene.rootNodes,_=p.length-1;p[this._nodeDataStorage._sceneRootNodesIndex]=p[_],p[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex=this._nodeDataStorage._sceneRootNodesIndex,this._scene.rootNodes.pop(),this._nodeDataStorage._sceneRootNodesIndex=-1}}get animationPropertiesOverride(){return this._animationPropertiesOverride?this._animationPropertiesOverride:this._scene.animationPropertiesOverride}set animationPropertiesOverride(p){this._animationPropertiesOverride=p}getClassName(){return"Node"}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}get onEnabledStateChangedObservable(){return this._nodeDataStorage._onEnabledStateChangedObservable}get onClonedObservable(){return this._nodeDataStorage._onClonedObservable}constructor(p,_=null){this._isDirty=!1,this._nodeDataStorage=new xw,this.state="",this.metadata=null,this.reservedDataStore=null,this._accessibilityTag=null,this.onAccessibilityTagChangedObservable=new Mi,this._parentContainer=null,this.animations=[],this._ranges={},this.onReady=null,this._currentRenderId=-1,this._parentUpdateId=-1,this._childUpdateId=-1,this._waitingParentId=null,this._waitingParentInstanceIndex=null,this._waitingParsedUniqueId=null,this._cache={},this._parentNode=null,this._children=null,this._worldMatrix=Yt.Identity(),this._worldMatrixDeterminant=0,this._worldMatrixDeterminantIsDirty=!0,this._animationPropertiesOverride=null,this._isNode=!0,this.onDisposeObservable=new Mi,this._onDisposeObserver=null,this._behaviors=new Array,this.name=p,this.id=p,this._scene=_||wr.LastCreatedScene,this.uniqueId=this._scene.getUniqueId(),this._initCache()}getScene(){return this._scene}getEngine(){return this._scene.getEngine()}addBehavior(p,_=!1){return this._behaviors.indexOf(p)!==-1?this:(p.init(),this._scene.isLoading&&!_?this._scene.onDataLoadedObservable.addOnce(()=>{p.attach(this)}):p.attach(this),this._behaviors.push(p),this)}removeBehavior(p){const _=this._behaviors.indexOf(p);return _===-1?this:(this._behaviors[_].detach(),this._behaviors.splice(_,1),this)}get behaviors(){return this._behaviors}getBehaviorByName(p){for(const _ of this._behaviors)if(_.name===p)return _;return null}getWorldMatrix(){return this._currentRenderId!==this._scene.getRenderId()&&this.computeWorldMatrix(),this._worldMatrix}_getWorldMatrixDeterminant(){return this._worldMatrixDeterminantIsDirty&&(this._worldMatrixDeterminantIsDirty=!1,this._worldMatrixDeterminant=this._worldMatrix.determinant()),this._worldMatrixDeterminant}get worldMatrixFromCache(){return this._worldMatrix}_initCache(){this._cache={},this._cache.parent=void 0}updateCache(p){!p&&this.isSynchronized()||(this._cache.parent=this.parent,this._updateCache())}_getActionManagerForTrigger(p,_=!0){return this.parent?this.parent._getActionManagerForTrigger(p,!1):null}_updateCache(p){}_isSynchronized(){return!0}_markSyncedWithParent(){this._parentNode&&(this._parentUpdateId=this._parentNode._childUpdateId)}isSynchronizedWithParent(){return this._parentNode?this._parentNode._isDirty||this._parentUpdateId!==this._parentNode._childUpdateId?!1:this._parentNode.isSynchronized():!0}isSynchronized(){return this._cache.parent!==this._parentNode?(this._cache.parent=this._parentNode,!1):this._parentNode&&!this.isSynchronizedWithParent()?!1:this._isSynchronized()}isReady(p=!1){return this._nodeDataStorage._isReady}markAsDirty(p){return this._currentRenderId=Number.MAX_VALUE,this._isDirty=!0,this}isEnabled(p=!0){return p===!1?this._nodeDataStorage._isEnabled:this._nodeDataStorage._isEnabled?this._nodeDataStorage._isParentEnabled:!1}_syncParentEnabledState(){this._nodeDataStorage._isParentEnabled=this._parentNode?this._parentNode.isEnabled():!0,this._children&&this._children.forEach(p=>{p._syncParentEnabledState()})}setEnabled(p){this._nodeDataStorage._isEnabled!==p&&(this._nodeDataStorage._isEnabled=p,this._syncParentEnabledState(),this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(p))}isDescendantOf(p){return this.parent?this.parent===p?!0:this.parent.isDescendantOf(p):!1}_getDescendants(p,_=!1,E){if(this._children)for(let A=0;A<this._children.length;A++){const $=this._children[A];(!E||E($))&&p.push($),_||$._getDescendants(p,!1,E)}}getDescendants(p,_){const E=[];return this._getDescendants(E,p,_),E}getChildMeshes(p,_){const E=[];return this._getDescendants(E,p,A=>(!_||_(A))&&A.cullingStrategy!==void 0),E}getChildren(p,_=!0){return this.getDescendants(_,p)}_setReady(p){if(p!==this._nodeDataStorage._isReady){if(!p){this._nodeDataStorage._isReady=!1;return}this.onReady&&this.onReady(this),this._nodeDataStorage._isReady=!0}}getAnimationByName(p){for(let _=0;_<this.animations.length;_++){const E=this.animations[_];if(E.name===p)return E}return null}createAnimationRange(p,_,E){if(!this._ranges[p]){this._ranges[p]=Ka._AnimationRangeFactory(p,_,E);for(let A=0,$=this.animations.length;A<$;A++)this.animations[A]&&this.animations[A].createRange(p,_,E)}}deleteAnimationRange(p,_=!0){for(let E=0,A=this.animations.length;E<A;E++)this.animations[E]&&this.animations[E].deleteRange(p,_);this._ranges[p]=null}getAnimationRange(p){return this._ranges[p]||null}clone(p,_,E){const A=Xr.Clone(()=>new Ka(p,this.getScene()),this);if(_&&(A.parent=_),!E){const $=this.getDescendants(!0);for(let ne=0;ne<$.length;ne++){const xe=$[ne];xe.clone(p+"."+xe.name,A)}}return A}getAnimationRanges(){const p=[];let _;for(_ in this._ranges)p.push(this._ranges[_]);return p}beginAnimation(p,_,E,A){const $=this.getAnimationRange(p);return $?this._scene.beginAnimation(this,$.from,$.to,_,E,A):null}serializeAnimationRanges(){const p=[];for(const _ in this._ranges){const E=this._ranges[_];if(!E)continue;const A={};A.name=_,A.from=E.from,A.to=E.to,p.push(A)}return p}computeWorldMatrix(p){return this._worldMatrix||(this._worldMatrix=Yt.Identity()),this._worldMatrix}dispose(p,_=!1){if(this._nodeDataStorage._isDisposed=!0,!p){const E=this.getDescendants(!0);for(const A of E)A.dispose(p,_)}this.parent?this.parent=null:this._removeFromSceneRootNodes(),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onEnabledStateChangedObservable.clear(),this.onClonedObservable.clear();for(const E of this._behaviors)E.detach();this._behaviors.length=0,this.metadata=null}static ParseAnimationRanges(p,_,E){if(_.ranges)for(let A=0;A<_.ranges.length;A++){const $=_.ranges[A];p.createAnimationRange($.name,$.from,$.to)}}getHierarchyBoundingVectors(p=!0,_=null){this.getScene().incrementRenderId(),this.computeWorldMatrix(!0);let E,A;const $=this;if($.getBoundingInfo&&$.subMeshes){const ne=$.getBoundingInfo();E=ne.boundingBox.minimumWorld.clone(),A=ne.boundingBox.maximumWorld.clone()}else E=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),A=new nt(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);if(p){const ne=this.getDescendants(!1);for(const xe of ne){const ce=xe;if(ce.computeWorldMatrix(!0),_&&!_(ce)||!ce.getBoundingInfo||ce.getTotalVertices()===0)continue;const Re=ce.getBoundingInfo().boundingBox,ke=Re.minimumWorld,We=Re.maximumWorld;nt.CheckExtends(ke,E,A),nt.CheckExtends(We,E,A)}}return{min:E,max:A}}}Ka._AnimationRangeFactory=(_e,p,_)=>{throw Tr("AnimationRange")},Ka._NodeConstructors={},Mt([Gt()],Ka.prototype,"name",void 0),Mt([Gt()],Ka.prototype,"id",void 0),Mt([Gt()],Ka.prototype,"uniqueId",void 0),Mt([Gt()],Ka.prototype,"state",void 0),Mt([Gt()],Ka.prototype,"metadata",void 0);class am{constructor(p,_,E,A){this.x=p,this.y=_,this.width=E,this.height=A}toGlobal(p,_){return new am(this.x*p,this.y*_,this.width*p,this.height*_)}toGlobalToRef(p,_,E){return E.x=this.x*p,E.y=this.y*_,E.width=this.width*p,E.height=this.height*_,this}clone(){return new am(this.x,this.y,this.width,this.height)}}class Hr extends Ka{get position(){return this._position}set position(p){this._position=p}set upVector(p){this._upVector=p}get upVector(){return this._upVector}get screenArea(){let p=0,_=0;if(this.mode===Hr.PERSPECTIVE_CAMERA)this.fovMode===Hr.FOVMODE_VERTICAL_FIXED?(_=this.minZ*2*Math.tan(this.fov/2),p=this.getEngine().getAspectRatio(this)*_):(p=this.minZ*2*Math.tan(this.fov/2),_=p/this.getEngine().getAspectRatio(this));else{const E=this.getEngine().getRenderWidth()/2,A=this.getEngine().getRenderHeight()/2;p=(this.orthoRight??E)-(this.orthoLeft??-E),_=(this.orthoTop??A)-(this.orthoBottom??-A)}return p*_}set orthoLeft(p){this._orthoLeft=p;for(const _ of this._rigCameras)_.orthoLeft=p}get orthoLeft(){return this._orthoLeft}set orthoRight(p){this._orthoRight=p;for(const _ of this._rigCameras)_.orthoRight=p}get orthoRight(){return this._orthoRight}set orthoBottom(p){this._orthoBottom=p;for(const _ of this._rigCameras)_.orthoBottom=p}get orthoBottom(){return this._orthoBottom}set orthoTop(p){this._orthoTop=p;for(const _ of this._rigCameras)_.orthoTop=p}get orthoTop(){return this._orthoTop}set mode(p){this._mode=p;for(const _ of this._rigCameras)_.mode=p}get mode(){return this._mode}get hasMoved(){return this._hasMoved}constructor(p,_,E,A=!0){super(p,E),this._position=nt.Zero(),this._upVector=nt.Up(),this.oblique=null,this._orthoLeft=null,this._orthoRight=null,this._orthoBottom=null,this._orthoTop=null,this.fov=.8,this.projectionPlaneTilt=0,this.minZ=1,this.maxZ=1e4,this.inertia=.9,this._mode=Hr.PERSPECTIVE_CAMERA,this.isIntermediate=!1,this.viewport=new am(0,0,1,1),this.layerMask=268435455,this.fovMode=Hr.FOVMODE_VERTICAL_FIXED,this.cameraRigMode=Hr.RIG_MODE_NONE,this.customRenderTargets=[],this.outputRenderTarget=null,this.onViewMatrixChangedObservable=new Mi,this.onProjectionMatrixChangedObservable=new Mi,this.onAfterCheckInputsObservable=new Mi,this.onRestoreStateObservable=new Mi,this.isRigCamera=!1,this._hasMoved=!1,this._rigCameras=new Array,this._skipRendering=!1,this._projectionMatrix=new Yt,this._postProcesses=new Array,this._activeMeshes=new _t(256),this._globalPosition=nt.Zero(),this._computedViewMatrix=Yt.Identity(),this._doNotComputeProjectionMatrix=!1,this._transformMatrix=Yt.Zero(),this._refreshFrustumPlanes=!0,this._absoluteRotation=_s.Identity(),this._isCamera=!0,this._isLeftCamera=!1,this._isRightCamera=!1,this.getScene().addCamera(this),A&&!this.getScene().activeCamera&&(this.getScene().activeCamera=this),this.position=_,this.renderPassId=this.getScene().getEngine().createRenderPassId(`Camera ${p}`)}storeState(){return this._stateStored=!0,this._storedFov=this.fov,this}_restoreStateValues(){return this._stateStored?(this.fov=this._storedFov,!0):!1}restoreState(){return this._restoreStateValues()?(this.onRestoreStateObservable.notifyObservers(this),!0):!1}getClassName(){return"Camera"}toString(p){let _="Name: "+this.name;if(_+=", type: "+this.getClassName(),this.animations)for(let E=0;E<this.animations.length;E++)_+=", animation[0]: "+this.animations[E].toString(p);return _}applyVerticalCorrection(){const p=this.absoluteRotation.toEulerAngles();this.projectionPlaneTilt=this._scene.useRightHandedSystem?-p.x:p.x}get globalPosition(){return this._globalPosition}getActiveMeshes(){return this._activeMeshes}isActiveMesh(p){return this._activeMeshes.indexOf(p)!==-1}isReady(p=!1){if(p){for(const _ of this._postProcesses)if(_&&!_.isReady())return!1}return super.isReady(p)}_initCache(){super._initCache(),this._cache.position=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.upVector=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.mode=void 0,this._cache.minZ=void 0,this._cache.maxZ=void 0,this._cache.fov=void 0,this._cache.fovMode=void 0,this._cache.aspectRatio=void 0,this._cache.orthoLeft=void 0,this._cache.orthoRight=void 0,this._cache.orthoBottom=void 0,this._cache.orthoTop=void 0,this._cache.obliqueAngle=void 0,this._cache.obliqueLength=void 0,this._cache.obliqueOffset=void 0,this._cache.renderWidth=void 0,this._cache.renderHeight=void 0}_updateCache(p){p||super._updateCache(),this._cache.position.copyFrom(this.position),this._cache.upVector.copyFrom(this.upVector)}_isSynchronized(){return this._isSynchronizedViewMatrix()&&this._isSynchronizedProjectionMatrix()}_isSynchronizedViewMatrix(){return super._isSynchronized()?this._cache.position.equals(this.position)&&this._cache.upVector.equals(this.upVector)&&this.isSynchronizedWithParent():!1}_isSynchronizedProjectionMatrix(){let p=this._cache.mode===this.mode&&this._cache.minZ===this.minZ&&this._cache.maxZ===this.maxZ;if(!p)return!1;const _=this.getEngine();return this.mode===Hr.PERSPECTIVE_CAMERA?p=this._cache.fov===this.fov&&this._cache.fovMode===this.fovMode&&this._cache.aspectRatio===_.getAspectRatio(this)&&this._cache.projectionPlaneTilt===this.projectionPlaneTilt:(p=this._cache.orthoLeft===this.orthoLeft&&this._cache.orthoRight===this.orthoRight&&this._cache.orthoBottom===this.orthoBottom&&this._cache.orthoTop===this.orthoTop&&this._cache.renderWidth===_.getRenderWidth()&&this._cache.renderHeight===_.getRenderHeight(),this.oblique&&(p=p&&this._cache.obliqueAngle===this.oblique.angle&&this._cache.obliqueLength===this.oblique.length&&this._cache.obliqueOffset===this.oblique.offset)),p}attachControl(p,_){}detachControl(p){}update(){this._hasMoved=!1,this._checkInputs(),this.cameraRigMode!==Hr.RIG_MODE_NONE&&this._updateRigCameras(),this.getViewMatrix(),this.getProjectionMatrix()}_checkInputs(){this.onAfterCheckInputsObservable.notifyObservers(this)}get rigCameras(){return this._rigCameras}get rigPostProcess(){return this._rigPostProcess}_getFirstPostProcess(){for(let p=0;p<this._postProcesses.length;p++)if(this._postProcesses[p]!==null)return this._postProcesses[p];return null}_cascadePostProcessesToRigCams(){const p=this._getFirstPostProcess();p&&p.markTextureDirty();for(let _=0,E=this._rigCameras.length;_<E;_++){const A=this._rigCameras[_],$=A._rigPostProcess;$?($.getEffectName()==="pass"&&(A.isIntermediate=this._postProcesses.length===0),A._postProcesses=this._postProcesses.slice(0).concat($),$.markTextureDirty()):A._postProcesses=this._postProcesses.slice(0)}}attachPostProcess(p,_=null){return!p.isReusable()&&this._postProcesses.indexOf(p)>-1?(vi.Error("You're trying to reuse a post process not defined as reusable."),0):(_==null||_<0?this._postProcesses.push(p):this._postProcesses[_]===null?this._postProcesses[_]=p:this._postProcesses.splice(_,0,p),this._cascadePostProcessesToRigCams(),this._scene.prePassRenderer&&this._scene.prePassRenderer.markAsDirty(),this._postProcesses.indexOf(p))}detachPostProcess(p){const _=this._postProcesses.indexOf(p);_!==-1&&(this._postProcesses[_]=null),this._scene.prePassRenderer&&this._scene.prePassRenderer.markAsDirty(),this._cascadePostProcessesToRigCams()}getWorldMatrix(){return this._isSynchronizedViewMatrix()?this._worldMatrix:(this.getViewMatrix(),this._worldMatrix)}_getViewMatrix(){return Yt.Identity()}getViewMatrix(p){return!p&&this._isSynchronizedViewMatrix()?this._computedViewMatrix:(this._hasMoved=!0,this.updateCache(),this._computedViewMatrix=this._getViewMatrix(),this._currentRenderId=this.getScene().getRenderId(),this._childUpdateId++,this._refreshFrustumPlanes=!0,this._cameraRigParams&&this._cameraRigParams.vrPreViewMatrix&&this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix,this._computedViewMatrix),this.parent&&this.parent.onViewMatrixChangedObservable&&this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent),this.onViewMatrixChangedObservable.notifyObservers(this),this._computedViewMatrix.invertToRef(this._worldMatrix),this._computedViewMatrix)}freezeProjectionMatrix(p){this._doNotComputeProjectionMatrix=!0,p!==void 0&&(this._projectionMatrix=p)}unfreezeProjectionMatrix(){this._doNotComputeProjectionMatrix=!1}getProjectionMatrix(p){if(this._doNotComputeProjectionMatrix||!p&&this._isSynchronizedProjectionMatrix())return this._projectionMatrix;this._cache.mode=this.mode,this._cache.minZ=this.minZ,this._cache.maxZ=this.maxZ,this._refreshFrustumPlanes=!0;const _=this.getEngine(),E=this.getScene(),A=_.useReverseDepthBuffer;if(this.mode===Hr.PERSPECTIVE_CAMERA){this._cache.fov=this.fov,this._cache.fovMode=this.fovMode,this._cache.aspectRatio=_.getAspectRatio(this),this._cache.projectionPlaneTilt=this.projectionPlaneTilt,this.minZ<=0&&(this.minZ=.1);let $;E.useRightHandedSystem?$=Yt.PerspectiveFovRHToRef:$=Yt.PerspectiveFovLHToRef,$(this.fov,_.getAspectRatio(this),A?this.maxZ:this.minZ,A?this.minZ:this.maxZ,this._projectionMatrix,this.fovMode===Hr.FOVMODE_VERTICAL_FIXED,_.isNDCHalfZRange,this.projectionPlaneTilt,A)}else{const $=_.getRenderWidth()/2,ne=_.getRenderHeight()/2;E.useRightHandedSystem?this.oblique?Yt.ObliqueOffCenterRHToRef(this.orthoLeft??-$,this.orthoRight??$,this.orthoBottom??-ne,this.orthoTop??ne,A?this.maxZ:this.minZ,A?this.minZ:this.maxZ,this.oblique.length,this.oblique.angle,this._computeObliqueDistance(this.oblique.offset),this._projectionMatrix,_.isNDCHalfZRange):Yt.OrthoOffCenterRHToRef(this.orthoLeft??-$,this.orthoRight??$,this.orthoBottom??-ne,this.orthoTop??ne,A?this.maxZ:this.minZ,A?this.minZ:this.maxZ,this._projectionMatrix,_.isNDCHalfZRange):this.oblique?Yt.ObliqueOffCenterLHToRef(this.orthoLeft??-$,this.orthoRight??$,this.orthoBottom??-ne,this.orthoTop??ne,A?this.maxZ:this.minZ,A?this.minZ:this.maxZ,this.oblique.length,this.oblique.angle,this._computeObliqueDistance(this.oblique.offset),this._projectionMatrix,_.isNDCHalfZRange):Yt.OrthoOffCenterLHToRef(this.orthoLeft??-$,this.orthoRight??$,this.orthoBottom??-ne,this.orthoTop??ne,A?this.maxZ:this.minZ,A?this.minZ:this.maxZ,this._projectionMatrix,_.isNDCHalfZRange),this._cache.orthoLeft=this.orthoLeft,this._cache.orthoRight=this.orthoRight,this._cache.orthoBottom=this.orthoBottom,this._cache.orthoTop=this.orthoTop,this._cache.obliqueAngle=this.oblique?.angle,this._cache.obliqueLength=this.oblique?.length,this._cache.obliqueOffset=this.oblique?.offset,this._cache.renderWidth=_.getRenderWidth(),this._cache.renderHeight=_.getRenderHeight()}return this.onProjectionMatrixChangedObservable.notifyObservers(this),this._projectionMatrix}getTransformationMatrix(){return this._computedViewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix),this._transformMatrix}_computeObliqueDistance(p){const _=this,E=this;return(_.radius||(E.target?nt.Distance(this.position,E.target):this.position.length()))+p}_updateFrustumPlanes(){this._refreshFrustumPlanes&&(this.getTransformationMatrix(),this._frustumPlanes?cl.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=cl.GetPlanes(this._transformMatrix),this._refreshFrustumPlanes=!1)}isInFrustum(p,_=!1){if(this._updateFrustumPlanes(),_&&this.rigCameras.length>0){let E=!1;return this.rigCameras.forEach(A=>{A._updateFrustumPlanes(),E=E||p.isInFrustum(A._frustumPlanes)}),E}else return p.isInFrustum(this._frustumPlanes)}isCompletelyInFrustum(p){return this._updateFrustumPlanes(),p.isCompletelyInFrustum(this._frustumPlanes)}getForwardRay(p=100,_,E){throw Tr("Ray")}getForwardRayToRef(p,_=100,E,A){throw Tr("Ray")}dispose(p,_=!1){for(this.onViewMatrixChangedObservable.clear(),this.onProjectionMatrixChangedObservable.clear(),this.onAfterCheckInputsObservable.clear(),this.onRestoreStateObservable.clear(),this.inputs&&this.inputs.clear(),this.getScene().stopAnimation(this),this.getScene().removeCamera(this);this._rigCameras.length>0;){const A=this._rigCameras.pop();A&&A.dispose()}if(this._parentContainer){const A=this._parentContainer.cameras.indexOf(this);A>-1&&this._parentContainer.cameras.splice(A,1),this._parentContainer=null}if(this._rigPostProcess)this._rigPostProcess.dispose(this),this._rigPostProcess=null,this._postProcesses.length=0;else if(this.cameraRigMode!==Hr.RIG_MODE_NONE)this._rigPostProcess=null,this._postProcesses.length=0;else{let A=this._postProcesses.length;for(;--A>=0;){const $=this._postProcesses[A];$&&$.dispose(this)}}let E=this.customRenderTargets.length;for(;--E>=0;)this.customRenderTargets[E].dispose();this.customRenderTargets.length=0,this._activeMeshes.dispose(),this.getScene().getEngine().releaseRenderPassId(this.renderPassId),super.dispose(p,_)}get isLeftCamera(){return this._isLeftCamera}get isRightCamera(){return this._isRightCamera}get leftCamera(){return this._rigCameras.length<1?null:this._rigCameras[0]}get rightCamera(){return this._rigCameras.length<2?null:this._rigCameras[1]}getLeftTarget(){return this._rigCameras.length<1?null:this._rigCameras[0].getTarget()}getRightTarget(){return this._rigCameras.length<2?null:this._rigCameras[1].getTarget()}setCameraRigMode(p,_){if(this.cameraRigMode!==p){for(;this._rigCameras.length>0;){const E=this._rigCameras.pop();E&&E.dispose()}if(this.cameraRigMode=p,this._cameraRigParams={},this._cameraRigParams.interaxialDistance=_.interaxialDistance||.0637,this._cameraRigParams.stereoHalfAngle=ct.ToRadians(this._cameraRigParams.interaxialDistance/.0637),this.cameraRigMode!==Hr.RIG_MODE_NONE){const E=this.createRigCamera(this.name+"_L",0);E&&(E._isLeftCamera=!0);const A=this.createRigCamera(this.name+"_R",1);A&&(A._isRightCamera=!0),E&&A&&(this._rigCameras.push(E),this._rigCameras.push(A))}this._setRigMode(_),this._cascadePostProcessesToRigCams(),this.update()}}_setRigMode(p){}_getVRProjectionMatrix(){return Yt.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov,this._cameraRigParams.vrMetrics.aspectRatio,this.minZ,this.maxZ,this._cameraRigParams.vrWorkMatrix,!0,this.getEngine().isNDCHalfZRange),this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix,this._projectionMatrix),this._projectionMatrix}setCameraRigParameter(p,_){this._cameraRigParams||(this._cameraRigParams={}),this._cameraRigParams[p]=_,p==="interaxialDistance"&&(this._cameraRigParams.stereoHalfAngle=ct.ToRadians(_/.0637))}createRigCamera(p,_){return null}_updateRigCameras(){for(let p=0;p<this._rigCameras.length;p++)this._rigCameras[p].minZ=this.minZ,this._rigCameras[p].maxZ=this.maxZ,this._rigCameras[p].fov=this.fov,this._rigCameras[p].upVector.copyFrom(this.upVector);this.cameraRigMode===Hr.RIG_MODE_STEREOSCOPIC_ANAGLYPH&&(this._rigCameras[0].viewport=this._rigCameras[1].viewport=this.viewport)}_setupInputs(){}serialize(){const p=Xr.Serialize(this);return p.uniqueId=this.uniqueId,p.type=this.getClassName(),this.parent&&this.parent._serializeAsParent(p),this.inputs&&this.inputs.serialize(p),Xr.AppendSerializedAnimations(this,p),p.ranges=this.serializeAnimationRanges(),p.isEnabled=this.isEnabled(),p}clone(p,_=null){const E=Xr.Clone(Hr.GetConstructorFromName(this.getClassName(),p,this.getScene(),this.interaxialDistance,this.isStereoscopicSideBySide),this);return E.name=p,E.parent=_,this.onClonedObservable.notifyObservers(E),E}getDirection(p){const _=nt.Zero();return this.getDirectionToRef(p,_),_}get absoluteRotation(){return this.getWorldMatrix().decompose(void 0,this._absoluteRotation),this._absoluteRotation}getDirectionToRef(p,_){nt.TransformNormalToRef(p,this.getWorldMatrix(),_)}static GetConstructorFromName(p,_,E,A=0,$=!0){const ne=Ka.Construct(p,_,E,{interaxial_distance:A,isStereoscopicSideBySide:$});return ne||(()=>Hr._CreateDefaultParsedCamera(_,E))}computeWorldMatrix(){return this.getWorldMatrix()}static Parse(p,_){const E=p.type,A=Hr.GetConstructorFromName(E,p.name,_,p.interaxial_distance,p.isStereoscopicSideBySide),$=Xr.Parse(A,p,_);if(p.parentId!==void 0&&($._waitingParentId=p.parentId),p.parentInstanceIndex!==void 0&&($._waitingParentInstanceIndex=p.parentInstanceIndex),$.inputs&&($.inputs.parse(p),$._setupInputs()),p.upVector&&($.upVector=nt.FromArray(p.upVector)),$.setPosition&&($.position.copyFromFloats(0,0,0),$.setPosition(nt.FromArray(p.position))),p.target&&$.setTarget&&$.setTarget(nt.FromArray(p.target)),p.cameraRigMode){const ne=p.interaxial_distance?{interaxialDistance:p.interaxial_distance}:{};$.setCameraRigMode(p.cameraRigMode,ne)}if(p.animations){for(let ne=0;ne<p.animations.length;ne++){const xe=p.animations[ne],ce=a0("BABYLON.Animation");ce&&$.animations.push(ce.Parse(xe))}Ka.ParseAnimationRanges($,p,_)}return p.autoAnimate&&_.beginAnimation($,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1),p.isEnabled!==void 0&&$.setEnabled(p.isEnabled),$}_calculateHandednessMultiplier(){let p=this.getScene().useRightHandedSystem?-1:1;return this.parent&&this.parent._getWorldMatrixDeterminant()<0&&(p*=-1),p}}Hr._CreateDefaultParsedCamera=(_e,p)=>{throw Tr("UniversalCamera")},Hr.PERSPECTIVE_CAMERA=0,Hr.ORTHOGRAPHIC_CAMERA=1,Hr.FOVMODE_VERTICAL_FIXED=0,Hr.FOVMODE_HORIZONTAL_FIXED=1,Hr.RIG_MODE_NONE=0,Hr.RIG_MODE_STEREOSCOPIC_ANAGLYPH=10,Hr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL=11,Hr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED=12,Hr.RIG_MODE_STEREOSCOPIC_OVERUNDER=13,Hr.RIG_MODE_STEREOSCOPIC_INTERLACED=14,Hr.RIG_MODE_VR=20,Hr.RIG_MODE_CUSTOM=22,Hr.ForceAttachControlToAlwaysPreventDefault=!1,Mt([jn("position")],Hr.prototype,"_position",void 0),Mt([jn("upVector")],Hr.prototype,"_upVector",void 0),Mt([Gt()],Hr.prototype,"orthoLeft",null),Mt([Gt()],Hr.prototype,"orthoRight",null),Mt([Gt()],Hr.prototype,"orthoBottom",null),Mt([Gt()],Hr.prototype,"orthoTop",null),Mt([Gt()],Hr.prototype,"fov",void 0),Mt([Gt()],Hr.prototype,"projectionPlaneTilt",void 0),Mt([Gt()],Hr.prototype,"minZ",void 0),Mt([Gt()],Hr.prototype,"maxZ",void 0),Mt([Gt()],Hr.prototype,"inertia",void 0),Mt([Gt()],Hr.prototype,"mode",null),Mt([Gt()],Hr.prototype,"layerMask",void 0),Mt([Gt()],Hr.prototype,"fovMode",void 0),Mt([Gt()],Hr.prototype,"cameraRigMode",void 0),Mt([Gt()],Hr.prototype,"interaxialDistance",void 0),Mt([Gt()],Hr.prototype,"isStereoscopicSideBySide",void 0);var Xn;(function(_e){_e[_e.LOCAL=0]="LOCAL",_e[_e.WORLD=1]="WORLD",_e[_e.BONE=2]="BONE"})(Xn||(Xn={}));class $c{}$c.X=new nt(1,0,0),$c.Y=new nt(0,1,0),$c.Z=new nt(0,0,1);var ru;(function(_e){_e[_e.X=0]="X",_e[_e.Y=1]="Y",_e[_e.Z=2]="Z"})(ru||(ru={}));class xo extends Hr{constructor(p,_,E,A=!0){super(p,_,E,A),this._tmpUpVector=nt.Zero(),this._tmpTargetVector=nt.Zero(),this.cameraDirection=new nt(0,0,0),this.cameraRotation=new xr(0,0),this.ignoreParentScaling=!1,this.updateUpVectorFromRotation=!1,this._tmpQuaternion=new _s,this.rotation=new nt(0,0,0),this.speed=2,this.noRotationConstraint=!1,this.invertRotation=!1,this.inverseRotationSpeed=.2,this.lockedTarget=null,this._currentTarget=nt.Zero(),this._initialFocalDistance=1,this._viewMatrix=Yt.Zero(),this._camMatrix=Yt.Zero(),this._cameraTransformMatrix=Yt.Zero(),this._cameraRotationMatrix=Yt.Zero(),this._referencePoint=new nt(0,0,1),this._transformedReferencePoint=nt.Zero(),this._deferredPositionUpdate=new nt,this._deferredRotationQuaternionUpdate=new _s,this._deferredRotationUpdate=new nt,this._deferredUpdated=!1,this._deferOnly=!1,this._defaultUp=nt.Up(),this._cachedRotationZ=0,this._cachedQuaternionRotationZ=0}getFrontPosition(p){this.getWorldMatrix();const _=this.getTarget().subtract(this.position);return _.normalize(),_.scaleInPlace(p),this.globalPosition.add(_)}_getLockedTargetPosition(){if(!this.lockedTarget)return null;if(this.lockedTarget.absolutePosition){const p=this.lockedTarget;p.computeWorldMatrix().getTranslationToRef(p.absolutePosition)}return this.lockedTarget.absolutePosition||this.lockedTarget}storeState(){return this._storedPosition=this.position.clone(),this._storedRotation=this.rotation.clone(),this.rotationQuaternion&&(this._storedRotationQuaternion=this.rotationQuaternion.clone()),super.storeState()}_restoreStateValues(){return super._restoreStateValues()?(this.position=this._storedPosition.clone(),this.rotation=this._storedRotation.clone(),this.rotationQuaternion&&(this.rotationQuaternion=this._storedRotationQuaternion.clone()),this.cameraDirection.copyFromFloats(0,0,0),this.cameraRotation.copyFromFloats(0,0),!0):!1}_initCache(){super._initCache(),this._cache.lockedTarget=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotation=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotationQuaternion=new _s(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}_updateCache(p){p||super._updateCache();const _=this._getLockedTargetPosition();_?this._cache.lockedTarget?this._cache.lockedTarget.copyFrom(_):this._cache.lockedTarget=_.clone():this._cache.lockedTarget=null,this._cache.rotation.copyFrom(this.rotation),this.rotationQuaternion&&this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)}_isSynchronizedViewMatrix(){if(!super._isSynchronizedViewMatrix())return!1;const p=this._getLockedTargetPosition();return(this._cache.lockedTarget?this._cache.lockedTarget.equals(p):!p)&&(this.rotationQuaternion?this.rotationQuaternion.equals(this._cache.rotationQuaternion):this._cache.rotation.equals(this.rotation))}_computeLocalCameraSpeed(){const p=this.getEngine();return this.speed*Math.sqrt(p.getDeltaTime()/(p.getFps()*100))}setTarget(p){this.upVector.normalize(),this._initialFocalDistance=p.subtract(this.position).length(),this.position.z===p.z&&(this.position.z+=as),this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance),Yt.LookAtLHToRef(this.position,p,this._defaultUp,this._camMatrix),this._camMatrix.invert(),this.rotation.x=Math.atan(this._camMatrix.m[6]/this._camMatrix.m[10]);const _=p.subtract(this.position);_.x>=0?this.rotation.y=-Math.atan(_.z/_.x)+Math.PI/2:this.rotation.y=-Math.atan(_.z/_.x)-Math.PI/2,this.rotation.z=0,isNaN(this.rotation.x)&&(this.rotation.x=0),isNaN(this.rotation.y)&&(this.rotation.y=0),isNaN(this.rotation.z)&&(this.rotation.z=0),this.rotationQuaternion&&_s.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this.rotationQuaternion)}get target(){return this.getTarget()}set target(p){this.setTarget(p)}getTarget(){return this._currentTarget}_decideIfNeedsToMove(){return Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){if(this.parent){this.parent.getWorldMatrix().invertToRef(pi.Matrix[0]),nt.TransformNormalToRef(this.cameraDirection,pi.Matrix[0],pi.Vector3[0]),this._deferredPositionUpdate.addInPlace(pi.Vector3[0]),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate);return}this._deferredPositionUpdate.addInPlace(this.cameraDirection),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate)}_checkInputs(){const p=this.invertRotation?-this.inverseRotationSpeed:1,_=this._decideIfNeedsToMove(),E=this.cameraRotation.x||this.cameraRotation.y;this._deferredUpdated=!1,this._deferredRotationUpdate.copyFrom(this.rotation),this._deferredPositionUpdate.copyFrom(this.position),this.rotationQuaternion&&this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion),_&&this._updatePosition(),E&&(this.rotationQuaternion&&this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate),this._deferredRotationUpdate.x+=this.cameraRotation.x*p,this._deferredRotationUpdate.y+=this.cameraRotation.y*p,this.noRotationConstraint||(this._deferredRotationUpdate.x>1.570796&&(this._deferredRotationUpdate.x=1.570796),this._deferredRotationUpdate.x<-1.570796&&(this._deferredRotationUpdate.x=-1.570796)),this._deferOnly?this._deferredUpdated=!0:this.rotation.copyFrom(this._deferredRotationUpdate),this.rotationQuaternion&&this._deferredRotationUpdate.lengthSquared()&&(_s.RotationYawPitchRollToRef(this._deferredRotationUpdate.y,this._deferredRotationUpdate.x,this._deferredRotationUpdate.z,this._deferredRotationQuaternionUpdate),this._deferOnly?this._deferredUpdated=!0:this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate))),_&&(Math.abs(this.cameraDirection.x)<this.speed*as&&(this.cameraDirection.x=0),Math.abs(this.cameraDirection.y)<this.speed*as&&(this.cameraDirection.y=0),Math.abs(this.cameraDirection.z)<this.speed*as&&(this.cameraDirection.z=0),this.cameraDirection.scaleInPlace(this.inertia)),E&&(Math.abs(this.cameraRotation.x)<this.speed*as&&(this.cameraRotation.x=0),Math.abs(this.cameraRotation.y)<this.speed*as&&(this.cameraRotation.y=0),this.cameraRotation.scaleInPlace(this.inertia)),super._checkInputs()}_updateCameraRotationMatrix(){this.rotationQuaternion?this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix):Yt.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix)}_rotateUpVectorWithCameraRotationMatrix(){return nt.TransformNormalToRef(this._defaultUp,this._cameraRotationMatrix,this.upVector),this}_getViewMatrix(){return this.lockedTarget&&this.setTarget(this._getLockedTargetPosition()),this._updateCameraRotationMatrix(),this.rotationQuaternion&&this._cachedQuaternionRotationZ!=this.rotationQuaternion.z?(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedQuaternionRotationZ=this.rotationQuaternion.z):this._cachedRotationZ!==this.rotation.z&&(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedRotationZ=this.rotation.z),nt.TransformCoordinatesToRef(this._referencePoint,this._cameraRotationMatrix,this._transformedReferencePoint),this.position.addToRef(this._transformedReferencePoint,this._currentTarget),this.updateUpVectorFromRotation&&(this.rotationQuaternion?$c.Y.rotateByQuaternionToRef(this.rotationQuaternion,this.upVector):(_s.FromEulerVectorToRef(this.rotation,this._tmpQuaternion),$c.Y.rotateByQuaternionToRef(this._tmpQuaternion,this.upVector))),this._computeViewMatrix(this.position,this._currentTarget,this.upVector),this._viewMatrix}_computeViewMatrix(p,_,E){if(this.ignoreParentScaling){if(this.parent){const A=this.parent.getWorldMatrix();nt.TransformCoordinatesToRef(p,A,this._globalPosition),nt.TransformCoordinatesToRef(_,A,this._tmpTargetVector),nt.TransformNormalToRef(E,A,this._tmpUpVector),this._markSyncedWithParent()}else this._globalPosition.copyFrom(p),this._tmpTargetVector.copyFrom(_),this._tmpUpVector.copyFrom(E);this.getScene().useRightHandedSystem?Yt.LookAtRHToRef(this._globalPosition,this._tmpTargetVector,this._tmpUpVector,this._viewMatrix):Yt.LookAtLHToRef(this._globalPosition,this._tmpTargetVector,this._tmpUpVector,this._viewMatrix);return}if(this.getScene().useRightHandedSystem?Yt.LookAtRHToRef(p,_,E,this._viewMatrix):Yt.LookAtLHToRef(p,_,E,this._viewMatrix),this.parent){const A=this.parent.getWorldMatrix();this._viewMatrix.invert(),this._viewMatrix.multiplyToRef(A,this._viewMatrix),this._viewMatrix.getTranslationToRef(this._globalPosition),this._viewMatrix.invert(),this._markSyncedWithParent()}else this._globalPosition.copyFrom(p)}createRigCamera(p,_){if(this.cameraRigMode!==Hr.RIG_MODE_NONE){const E=new xo(p,this.position.clone(),this.getScene());return E.isRigCamera=!0,E.rigParent=this,this.cameraRigMode===Hr.RIG_MODE_VR&&(this.rotationQuaternion||(this.rotationQuaternion=new _s),E._cameraRigParams={},E.rotationQuaternion=new _s),E.mode=this.mode,E.orthoLeft=this.orthoLeft,E.orthoRight=this.orthoRight,E.orthoTop=this.orthoTop,E.orthoBottom=this.orthoBottom,E}return null}_updateRigCameras(){const p=this._rigCameras[0],_=this._rigCameras[1];switch(this.computeWorldMatrix(),this.cameraRigMode){case Hr.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case Hr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case Hr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:case Hr.RIG_MODE_STEREOSCOPIC_OVERUNDER:case Hr.RIG_MODE_STEREOSCOPIC_INTERLACED:{const E=this.cameraRigMode===Hr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?1:-1,A=this.cameraRigMode===Hr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?-1:1;this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*E,p),this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*A,_);break}case Hr.RIG_MODE_VR:p.rotationQuaternion?(p.rotationQuaternion.copyFrom(this.rotationQuaternion),_.rotationQuaternion.copyFrom(this.rotationQuaternion)):(p.rotation.copyFrom(this.rotation),_.rotation.copyFrom(this.rotation)),p.position.copyFrom(this.position),_.position.copyFrom(this.position);break}super._updateRigCameras()}_getRigCamPositionAndTarget(p,_){this.getTarget().subtractToRef(this.position,xo._TargetFocalPoint),xo._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);const A=xo._TargetFocalPoint.addInPlace(this.position);Yt.TranslationToRef(-A.x,-A.y,-A.z,xo._TargetTransformMatrix),xo._TargetTransformMatrix.multiplyToRef(Yt.RotationAxis(_.upVector,p),xo._RigCamTransformMatrix),Yt.TranslationToRef(A.x,A.y,A.z,xo._TargetTransformMatrix),xo._RigCamTransformMatrix.multiplyToRef(xo._TargetTransformMatrix,xo._RigCamTransformMatrix),nt.TransformCoordinatesToRef(this.position,xo._RigCamTransformMatrix,_.position),_.setTarget(A)}getClassName(){return"TargetCamera"}}xo._RigCamTransformMatrix=new Yt,xo._TargetTransformMatrix=new Yt,xo._TargetFocalPoint=new nt,Mt([jn()],xo.prototype,"rotation",void 0),Mt([Gt()],xo.prototype,"speed",void 0),Mt([Hx("lockedTargetId")],xo.prototype,"lockedTarget",void 0);var Wl={};class Ub{constructor(p){this.attachedToElement=!1,this.attached={},this.camera=p,this.checkInputs=()=>{}}add(p){const _=p.getSimpleName();if(this.attached[_]){vi.Warn("camera input of type "+_+" already exists on camera");return}this.attached[_]=p,p.camera=this.camera,p.checkInputs&&(this.checkInputs=this._addCheckInputs(p.checkInputs.bind(p))),this.attachedToElement&&p.attachControl(this.noPreventDefault)}remove(p){for(const _ in this.attached){const E=this.attached[_];if(E===p){E.detachControl(),E.camera=null,delete this.attached[_],this.rebuildInputCheck();return}}}removeByType(p){for(const _ in this.attached){const E=this.attached[_];E.getClassName()===p&&(E.detachControl(),E.camera=null,delete this.attached[_],this.rebuildInputCheck())}}_addCheckInputs(p){const _=this.checkInputs;return()=>{_(),p()}}attachInput(p){this.attachedToElement&&p.attachControl(this.noPreventDefault)}attachElement(p=!1){if(!this.attachedToElement){p=Hr.ForceAttachControlToAlwaysPreventDefault?!1:p,this.attachedToElement=!0,this.noPreventDefault=p;for(const _ in this.attached)this.attached[_].attachControl(p)}}detachElement(p=!1){for(const _ in this.attached)this.attached[_].detachControl(),p&&(this.attached[_].camera=null);this.attachedToElement=!1}rebuildInputCheck(){this.checkInputs=()=>{};for(const p in this.attached){const _=this.attached[p];_.checkInputs&&(this.checkInputs=this._addCheckInputs(_.checkInputs.bind(_)))}}clear(){this.attachedToElement&&this.detachElement(!0),this.attached={},this.attachedToElement=!1,this.checkInputs=()=>{}}serialize(p){const _={};for(const E in this.attached){const A=this.attached[E],$=Xr.Serialize(A);_[A.getClassName()]=$}p.inputsmgr=_}parse(p){const _=p.inputsmgr;if(_){this.clear();for(const E in _){const A=Wl[E];if(A){const $=_[E],ne=Xr.Parse(()=>new A,$,null);this.add(ne)}}}else for(const E in this.attached){const A=Wl[this.attached[E].getClassName()];if(A){const $=Xr.Parse(()=>new A,p,null);this.remove(this.attached[E]),this.add($)}}}}class Kx{constructor(){this.keysUp=[38],this.keysUpward=[33],this.keysDown=[40],this.keysDownward=[34],this.keysLeft=[37],this.keysRight=[39],this.rotationSpeed=.5,this.keysRotateLeft=[],this.keysRotateRight=[],this.keysRotateUp=[],this.keysRotateDown=[],this._keys=new Array}attachControl(p){p=ct.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(_=>{const E=_.event;if(!E.metaKey){if(_.type===Ru.KEYDOWN)(this.keysUp.indexOf(E.keyCode)!==-1||this.keysDown.indexOf(E.keyCode)!==-1||this.keysLeft.indexOf(E.keyCode)!==-1||this.keysRight.indexOf(E.keyCode)!==-1||this.keysUpward.indexOf(E.keyCode)!==-1||this.keysDownward.indexOf(E.keyCode)!==-1||this.keysRotateLeft.indexOf(E.keyCode)!==-1||this.keysRotateRight.indexOf(E.keyCode)!==-1||this.keysRotateUp.indexOf(E.keyCode)!==-1||this.keysRotateDown.indexOf(E.keyCode)!==-1)&&(this._keys.indexOf(E.keyCode)===-1&&this._keys.push(E.keyCode),p||E.preventDefault());else if(this.keysUp.indexOf(E.keyCode)!==-1||this.keysDown.indexOf(E.keyCode)!==-1||this.keysLeft.indexOf(E.keyCode)!==-1||this.keysRight.indexOf(E.keyCode)!==-1||this.keysUpward.indexOf(E.keyCode)!==-1||this.keysDownward.indexOf(E.keyCode)!==-1||this.keysRotateLeft.indexOf(E.keyCode)!==-1||this.keysRotateRight.indexOf(E.keyCode)!==-1||this.keysRotateUp.indexOf(E.keyCode)!==-1||this.keysRotateDown.indexOf(E.keyCode)!==-1){const A=this._keys.indexOf(E.keyCode);A>=0&&this._keys.splice(A,1),p||E.preventDefault()}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const p=this.camera;for(let _=0;_<this._keys.length;_++){const E=this._keys[_],A=p._computeLocalCameraSpeed();this.keysLeft.indexOf(E)!==-1?p._localDirection.copyFromFloats(-A,0,0):this.keysUp.indexOf(E)!==-1?p._localDirection.copyFromFloats(0,0,A):this.keysRight.indexOf(E)!==-1?p._localDirection.copyFromFloats(A,0,0):this.keysDown.indexOf(E)!==-1?p._localDirection.copyFromFloats(0,0,-A):this.keysUpward.indexOf(E)!==-1?p._localDirection.copyFromFloats(0,A,0):this.keysDownward.indexOf(E)!==-1?p._localDirection.copyFromFloats(0,-A,0):this.keysRotateLeft.indexOf(E)!==-1?(p._localDirection.copyFromFloats(0,0,0),p.cameraRotation.y-=this._getLocalRotation()):this.keysRotateRight.indexOf(E)!==-1?(p._localDirection.copyFromFloats(0,0,0),p.cameraRotation.y+=this._getLocalRotation()):this.keysRotateUp.indexOf(E)!==-1?(p._localDirection.copyFromFloats(0,0,0),p.cameraRotation.x-=this._getLocalRotation()):this.keysRotateDown.indexOf(E)!==-1&&(p._localDirection.copyFromFloats(0,0,0),p.cameraRotation.x+=this._getLocalRotation()),p.getScene().useRightHandedSystem&&(p._localDirection.z*=-1),p.getViewMatrix().invertToRef(p._cameraTransformMatrix),nt.TransformNormalToRef(p._localDirection,p._cameraTransformMatrix,p._transformedDirection),p.cameraDirection.addInPlace(p._transformedDirection)}}}getClassName(){return"FreeCameraKeyboardMoveInput"}_onLostFocus(){this._keys.length=0}getSimpleName(){return"keyboard"}_getLocalRotation(){const p=this.camera._calculateHandednessMultiplier();return this.rotationSpeed*this._engine.getDeltaTime()/1e3*p}}Mt([Gt()],Kx.prototype,"keysUp",void 0),Mt([Gt()],Kx.prototype,"keysUpward",void 0),Mt([Gt()],Kx.prototype,"keysDown",void 0),Mt([Gt()],Kx.prototype,"keysDownward",void 0),Mt([Gt()],Kx.prototype,"keysLeft",void 0),Mt([Gt()],Kx.prototype,"keysRight",void 0),Mt([Gt()],Kx.prototype,"rotationSpeed",void 0),Mt([Gt()],Kx.prototype,"keysRotateLeft",void 0),Mt([Gt()],Kx.prototype,"keysRotateRight",void 0),Mt([Gt()],Kx.prototype,"keysRotateUp",void 0),Mt([Gt()],Kx.prototype,"keysRotateDown",void 0),Wl.FreeCameraKeyboardMoveInput=Kx;class rg{constructor(p=!0){this.touchEnabled=p,this.buttons=[0,1,2],this.angularSensibility=2e3,this._previousPosition=null,this.onPointerMovedObservable=new Mi,this._allowCameraRotation=!0,this._currentActiveButton=-1,this._activePointerId=-1}attachControl(p){p=ct.BackCompatCameraNoPreventDefault(arguments);const _=this.camera.getEngine(),E=_.getInputElement();this._pointerInput||(this._pointerInput=A=>{const $=A.event,ne=$.pointerType==="touch";if(!this.touchEnabled&&ne||A.type!==Kr.POINTERMOVE&&this.buttons.indexOf($.button)===-1)return;const xe=$.target;if(A.type===Kr.POINTERDOWN){if(ne&&this._activePointerId!==-1||!ne&&this._currentActiveButton!==-1)return;this._activePointerId=$.pointerId;try{xe?.setPointerCapture($.pointerId)}catch{}this._currentActiveButton===-1&&(this._currentActiveButton=$.button),this._previousPosition={x:$.clientX,y:$.clientY},p||($.preventDefault(),E&&E.focus()),_.isPointerLock&&this._onMouseMove&&this._onMouseMove(A.event)}else if(A.type===Kr.POINTERUP){if(ne&&this._activePointerId!==$.pointerId||!ne&&this._currentActiveButton!==$.button)return;try{xe?.releasePointerCapture($.pointerId)}catch{}this._currentActiveButton=-1,this._previousPosition=null,p||$.preventDefault(),this._activePointerId=-1}else if(A.type===Kr.POINTERMOVE&&(this._activePointerId===$.pointerId||!ne)){if(_.isPointerLock&&this._onMouseMove)this._onMouseMove(A.event);else if(this._previousPosition){const ce=this.camera._calculateHandednessMultiplier(),Te=($.clientX-this._previousPosition.x)*ce,Re=$.clientY-this._previousPosition.y;this._allowCameraRotation&&(this.camera.cameraRotation.y+=Te/this.angularSensibility,this.camera.cameraRotation.x+=Re/this.angularSensibility),this.onPointerMovedObservable.notifyObservers({offsetX:Te,offsetY:Re}),this._previousPosition={x:$.clientX,y:$.clientY},p||$.preventDefault()}}}),this._onMouseMove=A=>{if(!_.isPointerLock)return;const $=this.camera._calculateHandednessMultiplier(),ne=A.movementX*$;this.camera.cameraRotation.y+=ne/this.angularSensibility;const xe=A.movementY;this.camera.cameraRotation.x+=xe/this.angularSensibility,this._previousPosition=null,p||A.preventDefault()},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,Kr.POINTERDOWN|Kr.POINTERUP|Kr.POINTERMOVE),E&&(this._contextMenuBind=A=>this.onContextMenu(A),E.addEventListener("contextmenu",this._contextMenuBind,!1))}onContextMenu(p){p.preventDefault()}detachControl(){if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._contextMenuBind){const _=this.camera.getEngine().getInputElement();_&&_.removeEventListener("contextmenu",this._contextMenuBind)}this.onPointerMovedObservable&&this.onPointerMovedObservable.clear(),this._observer=null,this._onMouseMove=null,this._previousPosition=null}this._activePointerId=-1,this._currentActiveButton=-1}getClassName(){return"FreeCameraMouseInput"}getSimpleName(){return"mouse"}}Mt([Gt()],rg.prototype,"buttons",void 0),Mt([Gt()],rg.prototype,"angularSensibility",void 0),Wl.FreeCameraMouseInput=rg;class ng{constructor(){this.wheelPrecisionX=3,this.wheelPrecisionY=3,this.wheelPrecisionZ=3,this.onChangedObservable=new Mi,this._wheelDeltaX=0,this._wheelDeltaY=0,this._wheelDeltaZ=0,this._ffMultiplier=12,this._normalize=120}attachControl(p){p=ct.BackCompatCameraNoPreventDefault(arguments),this._wheel=_=>{if(_.type!==Kr.POINTERWHEEL)return;const E=_.event,A=E.deltaMode===Mu.DOM_DELTA_LINE?this._ffMultiplier:1;this._wheelDeltaX+=this.wheelPrecisionX*A*E.deltaX/this._normalize,this._wheelDeltaY-=this.wheelPrecisionY*A*E.deltaY/this._normalize,this._wheelDeltaZ+=this.wheelPrecisionZ*A*E.deltaZ/this._normalize,E.preventDefault&&(p||E.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,Kr.POINTERWHEEL)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null),this.onChangedObservable&&this.onChangedObservable.clear()}checkInputs(){this.onChangedObservable.notifyObservers({wheelDeltaX:this._wheelDeltaX,wheelDeltaY:this._wheelDeltaY,wheelDeltaZ:this._wheelDeltaZ}),this._wheelDeltaX=0,this._wheelDeltaY=0,this._wheelDeltaZ=0}getClassName(){return"BaseCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}}Mt([Gt()],ng.prototype,"wheelPrecisionX",void 0),Mt([Gt()],ng.prototype,"wheelPrecisionY",void 0),Mt([Gt()],ng.prototype,"wheelPrecisionZ",void 0);var xa;(function(_e){_e[_e.MoveRelative=0]="MoveRelative",_e[_e.RotateRelative=1]="RotateRelative",_e[_e.MoveScene=2]="MoveScene"})(xa||(xa={}));class Hl extends ng{constructor(){super(...arguments),this._moveRelative=nt.Zero(),this._rotateRelative=nt.Zero(),this._moveScene=nt.Zero(),this._wheelXAction=xa.MoveRelative,this._wheelXActionCoordinate=ru.X,this._wheelYAction=xa.MoveRelative,this._wheelYActionCoordinate=ru.Z,this._wheelZAction=null,this._wheelZActionCoordinate=null}getClassName(){return"FreeCameraMouseWheelInput"}set wheelXMoveRelative(p){p===null&&this._wheelXAction!==xa.MoveRelative||(this._wheelXAction=xa.MoveRelative,this._wheelXActionCoordinate=p)}get wheelXMoveRelative(){return this._wheelXAction!==xa.MoveRelative?null:this._wheelXActionCoordinate}set wheelYMoveRelative(p){p===null&&this._wheelYAction!==xa.MoveRelative||(this._wheelYAction=xa.MoveRelative,this._wheelYActionCoordinate=p)}get wheelYMoveRelative(){return this._wheelYAction!==xa.MoveRelative?null:this._wheelYActionCoordinate}set wheelZMoveRelative(p){p===null&&this._wheelZAction!==xa.MoveRelative||(this._wheelZAction=xa.MoveRelative,this._wheelZActionCoordinate=p)}get wheelZMoveRelative(){return this._wheelZAction!==xa.MoveRelative?null:this._wheelZActionCoordinate}set wheelXRotateRelative(p){p===null&&this._wheelXAction!==xa.RotateRelative||(this._wheelXAction=xa.RotateRelative,this._wheelXActionCoordinate=p)}get wheelXRotateRelative(){return this._wheelXAction!==xa.RotateRelative?null:this._wheelXActionCoordinate}set wheelYRotateRelative(p){p===null&&this._wheelYAction!==xa.RotateRelative||(this._wheelYAction=xa.RotateRelative,this._wheelYActionCoordinate=p)}get wheelYRotateRelative(){return this._wheelYAction!==xa.RotateRelative?null:this._wheelYActionCoordinate}set wheelZRotateRelative(p){p===null&&this._wheelZAction!==xa.RotateRelative||(this._wheelZAction=xa.RotateRelative,this._wheelZActionCoordinate=p)}get wheelZRotateRelative(){return this._wheelZAction!==xa.RotateRelative?null:this._wheelZActionCoordinate}set wheelXMoveScene(p){p===null&&this._wheelXAction!==xa.MoveScene||(this._wheelXAction=xa.MoveScene,this._wheelXActionCoordinate=p)}get wheelXMoveScene(){return this._wheelXAction!==xa.MoveScene?null:this._wheelXActionCoordinate}set wheelYMoveScene(p){p===null&&this._wheelYAction!==xa.MoveScene||(this._wheelYAction=xa.MoveScene,this._wheelYActionCoordinate=p)}get wheelYMoveScene(){return this._wheelYAction!==xa.MoveScene?null:this._wheelYActionCoordinate}set wheelZMoveScene(p){p===null&&this._wheelZAction!==xa.MoveScene||(this._wheelZAction=xa.MoveScene,this._wheelZActionCoordinate=p)}get wheelZMoveScene(){return this._wheelZAction!==xa.MoveScene?null:this._wheelZActionCoordinate}checkInputs(){if(this._wheelDeltaX===0&&this._wheelDeltaY===0&&this._wheelDeltaZ==0)return;this._moveRelative.setAll(0),this._rotateRelative.setAll(0),this._moveScene.setAll(0),this._updateCamera(),this.camera.getScene().useRightHandedSystem&&(this._moveRelative.z*=-1);const p=Yt.Zero();this.camera.getViewMatrix().invertToRef(p);const _=nt.Zero();nt.TransformNormalToRef(this._moveRelative,p,_),this.camera.cameraRotation.x+=this._rotateRelative.x/200,this.camera.cameraRotation.y+=this._rotateRelative.y/200,this.camera.cameraDirection.addInPlace(_),this.camera.cameraDirection.addInPlace(this._moveScene),super.checkInputs()}_updateCamera(){this._updateCameraProperty(this._wheelDeltaX,this._wheelXAction,this._wheelXActionCoordinate),this._updateCameraProperty(this._wheelDeltaY,this._wheelYAction,this._wheelYActionCoordinate),this._updateCameraProperty(this._wheelDeltaZ,this._wheelZAction,this._wheelZActionCoordinate)}_updateCameraProperty(p,_,E){if(p===0||_===null||E===null)return;let A=null;switch(_){case xa.MoveRelative:A=this._moveRelative;break;case xa.RotateRelative:A=this._rotateRelative;break;case xa.MoveScene:A=this._moveScene;break}switch(E){case ru.X:A.set(p,0,0);break;case ru.Y:A.set(0,p,0);break;case ru.Z:A.set(0,0,p);break}}}Mt([Gt()],Hl.prototype,"wheelXMoveRelative",null),Mt([Gt()],Hl.prototype,"wheelYMoveRelative",null),Mt([Gt()],Hl.prototype,"wheelZMoveRelative",null),Mt([Gt()],Hl.prototype,"wheelXRotateRelative",null),Mt([Gt()],Hl.prototype,"wheelYRotateRelative",null),Mt([Gt()],Hl.prototype,"wheelZRotateRelative",null),Mt([Gt()],Hl.prototype,"wheelXMoveScene",null),Mt([Gt()],Hl.prototype,"wheelYMoveScene",null),Mt([Gt()],Hl.prototype,"wheelZMoveScene",null),Wl.FreeCameraMouseWheelInput=Hl;class ag{constructor(p=!1){this.allowMouse=p,this.touchAngularSensibility=2e5,this.touchMoveSensibility=250,this.singleFingerRotate=!1,this._offsetX=null,this._offsetY=null,this._pointerPressed=new Array,this._isSafari=ct.IsSafari()}attachControl(p){p=ct.BackCompatCameraNoPreventDefault(arguments);let _=null;if(this._pointerInput===void 0&&(this._onLostFocus=()=>{this._offsetX=null,this._offsetY=null},this._pointerInput=E=>{const A=E.event,$=A.pointerType==="mouse"||this._isSafari&&typeof A.pointerType>"u";if(!(!this.allowMouse&&$)){if(E.type===Kr.POINTERDOWN){if(p||A.preventDefault(),this._pointerPressed.push(A.pointerId),this._pointerPressed.length!==1)return;_={x:A.clientX,y:A.clientY}}else if(E.type===Kr.POINTERUP){p||A.preventDefault();const ne=this._pointerPressed.indexOf(A.pointerId);if(ne===-1||(this._pointerPressed.splice(ne,1),ne!=0))return;_=null,this._offsetX=null,this._offsetY=null}else if(E.type===Kr.POINTERMOVE){if(p||A.preventDefault(),!_||this._pointerPressed.indexOf(A.pointerId)!=0)return;this._offsetX=A.clientX-_.x,this._offsetY=-(A.clientY-_.y)}}}),this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,Kr.POINTERDOWN|Kr.POINTERUP|Kr.POINTERMOVE),this._onLostFocus){const A=this.camera.getEngine().getInputElement();A&&A.addEventListener("blur",this._onLostFocus)}}detachControl(){if(this._pointerInput){if(this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null),this._onLostFocus){const _=this.camera.getEngine().getInputElement();_&&_.removeEventListener("blur",this._onLostFocus),this._onLostFocus=null}this._pointerPressed.length=0,this._offsetX=null,this._offsetY=null}}checkInputs(){if(this._offsetX===null||this._offsetY===null||this._offsetX===0&&this._offsetY===0)return;const p=this.camera,_=p._calculateHandednessMultiplier();if(p.cameraRotation.y=_*this._offsetX/this.touchAngularSensibility,this.singleFingerRotate&&this._pointerPressed.length===1||!this.singleFingerRotate&&this._pointerPressed.length>1)p.cameraRotation.x=-this._offsetY/this.touchAngularSensibility;else{const A=p._computeLocalCameraSpeed(),$=new nt(0,0,this.touchMoveSensibility!==0?A*this._offsetY/this.touchMoveSensibility:0);Yt.RotationYawPitchRollToRef(p.rotation.y,p.rotation.x,0,p._cameraRotationMatrix),p.cameraDirection.addInPlace(nt.TransformCoordinates($,p._cameraRotationMatrix))}}getClassName(){return"FreeCameraTouchInput"}getSimpleName(){return"touch"}}Mt([Gt()],ag.prototype,"touchAngularSensibility",void 0),Mt([Gt()],ag.prototype,"touchMoveSensibility",void 0),Wl.FreeCameraTouchInput=ag;class Gb extends Ub{constructor(p){super(p),this._mouseInput=null,this._mouseWheelInput=null}addKeyboard(){return this.add(new Kx),this}addMouse(p=!0){return this._mouseInput||(this._mouseInput=new rg(p),this.add(this._mouseInput)),this}removeMouse(){return this._mouseInput&&this.remove(this._mouseInput),this}addMouseWheel(){return this._mouseWheelInput||(this._mouseWheelInput=new Hl,this.add(this._mouseWheelInput)),this}removeMouseWheel(){return this._mouseWheelInput&&this.remove(this._mouseWheelInput),this}addTouch(){return this.add(new ag),this}clear(){super.clear(),this._mouseInput=null}}class wu extends xo{get angularSensibility(){const p=this.inputs.attached.mouse;return p?p.angularSensibility:0}set angularSensibility(p){const _=this.inputs.attached.mouse;_&&(_.angularSensibility=p)}get keysUp(){const p=this.inputs.attached.keyboard;return p?p.keysUp:[]}set keysUp(p){const _=this.inputs.attached.keyboard;_&&(_.keysUp=p)}get keysUpward(){const p=this.inputs.attached.keyboard;return p?p.keysUpward:[]}set keysUpward(p){const _=this.inputs.attached.keyboard;_&&(_.keysUpward=p)}get keysDown(){const p=this.inputs.attached.keyboard;return p?p.keysDown:[]}set keysDown(p){const _=this.inputs.attached.keyboard;_&&(_.keysDown=p)}get keysDownward(){const p=this.inputs.attached.keyboard;return p?p.keysDownward:[]}set keysDownward(p){const _=this.inputs.attached.keyboard;_&&(_.keysDownward=p)}get keysLeft(){const p=this.inputs.attached.keyboard;return p?p.keysLeft:[]}set keysLeft(p){const _=this.inputs.attached.keyboard;_&&(_.keysLeft=p)}get keysRight(){const p=this.inputs.attached.keyboard;return p?p.keysRight:[]}set keysRight(p){const _=this.inputs.attached.keyboard;_&&(_.keysRight=p)}get keysRotateLeft(){const p=this.inputs.attached.keyboard;return p?p.keysRotateLeft:[]}set keysRotateLeft(p){const _=this.inputs.attached.keyboard;_&&(_.keysRotateLeft=p)}get keysRotateRight(){const p=this.inputs.attached.keyboard;return p?p.keysRotateRight:[]}set keysRotateRight(p){const _=this.inputs.attached.keyboard;_&&(_.keysRotateRight=p)}get keysRotateUp(){const p=this.inputs.attached.keyboard;return p?p.keysRotateUp:[]}set keysRotateUp(p){const _=this.inputs.attached.keyboard;_&&(_.keysRotateUp=p)}get keysRotateDown(){const p=this.inputs.attached.keyboard;return p?p.keysRotateDown:[]}set keysRotateDown(p){const _=this.inputs.attached.keyboard;_&&(_.keysRotateDown=p)}constructor(p,_,E,A=!0){super(p,_,E,A),this.ellipsoid=new nt(.5,1,.5),this.ellipsoidOffset=new nt(0,0,0),this.checkCollisions=!1,this.applyGravity=!1,this._needMoveForGravity=!1,this._oldPosition=nt.Zero(),this._diffPosition=nt.Zero(),this._newPosition=nt.Zero(),this._collisionMask=-1,this._onCollisionPositionChange=($,ne,xe=null)=>{this._newPosition.copyFrom(ne),this._newPosition.subtractToRef(this._oldPosition,this._diffPosition),this._diffPosition.length()>ui.CollisionsEpsilon&&(this.position.addToRef(this._diffPosition,this._deferredPositionUpdate),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate),this.onCollide&&xe&&this.onCollide(xe))},this.inputs=new Gb(this),this.inputs.addKeyboard().addMouse()}attachControl(p,_){_=ct.BackCompatCameraNoPreventDefault(arguments),this.inputs.attachElement(_)}detachControl(){this.inputs.detachElement(),this.cameraDirection=new nt(0,0,0),this.cameraRotation=new xr(0,0)}get collisionMask(){return this._collisionMask}set collisionMask(p){this._collisionMask=isNaN(p)?-1:p}_collideWithWorld(p){let _;this.parent?_=nt.TransformCoordinates(this.position,this.parent.getWorldMatrix()):_=this.position,_.subtractFromFloatsToRef(0,this.ellipsoid.y,0,this._oldPosition),this._oldPosition.addInPlace(this.ellipsoidOffset);const E=this.getScene().collisionCoordinator;this._collider||(this._collider=E.createCollider()),this._collider._radius=this.ellipsoid,this._collider.collisionMask=this._collisionMask;let A=p;this.applyGravity&&(A=p.add(this.getScene().gravity)),E.getNewPosition(this._oldPosition,A,this._collider,3,null,this._onCollisionPositionChange,this.uniqueId)}_checkInputs(){this._localDirection||(this._localDirection=nt.Zero(),this._transformedDirection=nt.Zero()),this.inputs.checkInputs(),super._checkInputs()}set needMoveForGravity(p){this._needMoveForGravity=p}get needMoveForGravity(){return this._needMoveForGravity}_decideIfNeedsToMove(){return this._needMoveForGravity||Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){this.checkCollisions&&this.getScene().collisionsEnabled?this._collideWithWorld(this.cameraDirection):super._updatePosition()}dispose(){this.inputs.clear(),super.dispose()}getClassName(){return"FreeCamera"}}Mt([jn()],wu.prototype,"ellipsoid",void 0),Mt([jn()],wu.prototype,"ellipsoidOffset",void 0),Mt([Gt()],wu.prototype,"checkCollisions",void 0),Mt([Gt()],wu.prototype,"applyGravity",void 0),Ka.AddNodeConstructor("TouchCamera",(_e,p)=>()=>new zb(_e,nt.Zero(),p));class zb extends wu{get touchAngularSensibility(){const p=this.inputs.attached.touch;return p?p.touchAngularSensibility:0}set touchAngularSensibility(p){const _=this.inputs.attached.touch;_&&(_.touchAngularSensibility=p)}get touchMoveSensibility(){const p=this.inputs.attached.touch;return p?p.touchMoveSensibility:0}set touchMoveSensibility(p){const _=this.inputs.attached.touch;_&&(_.touchMoveSensibility=p)}constructor(p,_,E){super(p,_,E),this.inputs.addTouch(),this._setupInputs()}getClassName(){return"TouchCamera"}_setupInputs(){const p=this.inputs.attached.touch,_=this.inputs.attached.mouse;_?_.touchEnabled=!1:p.allowMouse=!0}}class _k{constructor(p,_){this.x=p,this.y=_}}class lo{get isConnected(){return this._isConnected}constructor(p,_,E,A=0,$=1,ne=2,xe=3){this.id=p,this.index=_,this.browserGamepad=E,this._leftStick={x:0,y:0},this._rightStick={x:0,y:0},this._isConnected=!0,this._invertLeftStickY=!1,this.type=lo.GAMEPAD,this._leftStickAxisX=A,this._leftStickAxisY=$,this._rightStickAxisX=ne,this._rightStickAxisY=xe,this.browserGamepad.axes.length>=2&&(this._leftStick={x:this.browserGamepad.axes[this._leftStickAxisX],y:this.browserGamepad.axes[this._leftStickAxisY]}),this.browserGamepad.axes.length>=4&&(this._rightStick={x:this.browserGamepad.axes[this._rightStickAxisX],y:this.browserGamepad.axes[this._rightStickAxisY]})}onleftstickchanged(p){this._onleftstickchanged=p}onrightstickchanged(p){this._onrightstickchanged=p}get leftStick(){return this._leftStick}set leftStick(p){this._onleftstickchanged&&(this._leftStick.x!==p.x||this._leftStick.y!==p.y)&&this._onleftstickchanged(p),this._leftStick=p}get rightStick(){return this._rightStick}set rightStick(p){this._onrightstickchanged&&(this._rightStick.x!==p.x||this._rightStick.y!==p.y)&&this._onrightstickchanged(p),this._rightStick=p}update(){this._leftStick&&(this.leftStick={x:this.browserGamepad.axes[this._leftStickAxisX],y:this.browserGamepad.axes[this._leftStickAxisY]},this._invertLeftStickY&&(this.leftStick.y*=-1)),this._rightStick&&(this.rightStick={x:this.browserGamepad.axes[this._rightStickAxisX],y:this.browserGamepad.axes[this._rightStickAxisY]})}dispose(){}}lo.GAMEPAD=0,lo.GENERIC=1,lo.XBOX=2,lo.POSE_ENABLED=3,lo.DUALSHOCK=4;class lw extends lo{onbuttondown(p){this._onbuttondown=p}onbuttonup(p){this._onbuttonup=p}constructor(p,_,E){super(p,_,E),this.onButtonDownObservable=new Mi,this.onButtonUpObservable=new Mi,this.type=lo.GENERIC,this._buttons=new Array(E.buttons.length)}_setButtonValue(p,_,E){return p!==_&&(p===1&&(this._onbuttondown&&this._onbuttondown(E),this.onButtonDownObservable.notifyObservers(E)),p===0&&(this._onbuttonup&&this._onbuttonup(E),this.onButtonUpObservable.notifyObservers(E))),p}update(){super.update();for(let p=0;p<this._buttons.length;p++)this._buttons[p]=this._setButtonValue(this.browserGamepad.buttons[p].value,this._buttons[p],p)}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear()}}var ul;(function(_e){_e[_e.A=0]="A",_e[_e.B=1]="B",_e[_e.X=2]="X",_e[_e.Y=3]="Y",_e[_e.LB=4]="LB",_e[_e.RB=5]="RB",_e[_e.Back=8]="Back",_e[_e.Start=9]="Start",_e[_e.LeftStick=10]="LeftStick",_e[_e.RightStick=11]="RightStick"})(ul||(ul={}));var Lu;(function(_e){_e[_e.Up=12]="Up",_e[_e.Down=13]="Down",_e[_e.Left=14]="Left",_e[_e.Right=15]="Right"})(Lu||(Lu={}));class hw extends lo{constructor(p,_,E,A=!1){super(p,_,E,0,1,2,3),this._leftTrigger=0,this._rightTrigger=0,this.onButtonDownObservable=new Mi,this.onButtonUpObservable=new Mi,this.onPadDownObservable=new Mi,this.onPadUpObservable=new Mi,this._buttonA=0,this._buttonB=0,this._buttonX=0,this._buttonY=0,this._buttonBack=0,this._buttonStart=0,this._buttonLB=0,this._buttonRB=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0,this._isXboxOnePad=!1,this.type=lo.XBOX,this._isXboxOnePad=A}onlefttriggerchanged(p){this._onlefttriggerchanged=p}onrighttriggerchanged(p){this._onrighttriggerchanged=p}get leftTrigger(){return this._leftTrigger}set leftTrigger(p){this._onlefttriggerchanged&&this._leftTrigger!==p&&this._onlefttriggerchanged(p),this._leftTrigger=p}get rightTrigger(){return this._rightTrigger}set rightTrigger(p){this._onrighttriggerchanged&&this._rightTrigger!==p&&this._onrighttriggerchanged(p),this._rightTrigger=p}onbuttondown(p){this._onbuttondown=p}onbuttonup(p){this._onbuttonup=p}ondpaddown(p){this._ondpaddown=p}ondpadup(p){this._ondpadup=p}_setButtonValue(p,_,E){return p!==_&&(p===1&&(this._onbuttondown&&this._onbuttondown(E),this.onButtonDownObservable.notifyObservers(E)),p===0&&(this._onbuttonup&&this._onbuttonup(E),this.onButtonUpObservable.notifyObservers(E))),p}_setDPadValue(p,_,E){return p!==_&&(p===1&&(this._ondpaddown&&this._ondpaddown(E),this.onPadDownObservable.notifyObservers(E)),p===0&&(this._ondpadup&&this._ondpadup(E),this.onPadUpObservable.notifyObservers(E))),p}get buttonA(){return this._buttonA}set buttonA(p){this._buttonA=this._setButtonValue(p,this._buttonA,ul.A)}get buttonB(){return this._buttonB}set buttonB(p){this._buttonB=this._setButtonValue(p,this._buttonB,ul.B)}get buttonX(){return this._buttonX}set buttonX(p){this._buttonX=this._setButtonValue(p,this._buttonX,ul.X)}get buttonY(){return this._buttonY}set buttonY(p){this._buttonY=this._setButtonValue(p,this._buttonY,ul.Y)}get buttonStart(){return this._buttonStart}set buttonStart(p){this._buttonStart=this._setButtonValue(p,this._buttonStart,ul.Start)}get buttonBack(){return this._buttonBack}set buttonBack(p){this._buttonBack=this._setButtonValue(p,this._buttonBack,ul.Back)}get buttonLB(){return this._buttonLB}set buttonLB(p){this._buttonLB=this._setButtonValue(p,this._buttonLB,ul.LB)}get buttonRB(){return this._buttonRB}set buttonRB(p){this._buttonRB=this._setButtonValue(p,this._buttonRB,ul.RB)}get buttonLeftStick(){return this._buttonLeftStick}set buttonLeftStick(p){this._buttonLeftStick=this._setButtonValue(p,this._buttonLeftStick,ul.LeftStick)}get buttonRightStick(){return this._buttonRightStick}set buttonRightStick(p){this._buttonRightStick=this._setButtonValue(p,this._buttonRightStick,ul.RightStick)}get dPadUp(){return this._dPadUp}set dPadUp(p){this._dPadUp=this._setDPadValue(p,this._dPadUp,Lu.Up)}get dPadDown(){return this._dPadDown}set dPadDown(p){this._dPadDown=this._setDPadValue(p,this._dPadDown,Lu.Down)}get dPadLeft(){return this._dPadLeft}set dPadLeft(p){this._dPadLeft=this._setDPadValue(p,this._dPadLeft,Lu.Left)}get dPadRight(){return this._dPadRight}set dPadRight(p){this._dPadRight=this._setDPadValue(p,this._dPadRight,Lu.Right)}update(){super.update(),this._isXboxOnePad?(this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value):(this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value)}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear(),this.onPadDownObservable.clear(),this.onPadUpObservable.clear()}}var pl;(function(_e){_e[_e.Cross=0]="Cross",_e[_e.Circle=1]="Circle",_e[_e.Square=2]="Square",_e[_e.Triangle=3]="Triangle",_e[_e.L1=4]="L1",_e[_e.R1=5]="R1",_e[_e.Share=8]="Share",_e[_e.Options=9]="Options",_e[_e.LeftStick=10]="LeftStick",_e[_e.RightStick=11]="RightStick"})(pl||(pl={}));var ku;(function(_e){_e[_e.Up=12]="Up",_e[_e.Down=13]="Down",_e[_e.Left=14]="Left",_e[_e.Right=15]="Right"})(ku||(ku={}));class cw extends lo{constructor(p,_,E){super(p.replace("STANDARD GAMEPAD","SONY PLAYSTATION DUALSHOCK"),_,E,0,1,2,3),this._leftTrigger=0,this._rightTrigger=0,this.onButtonDownObservable=new Mi,this.onButtonUpObservable=new Mi,this.onPadDownObservable=new Mi,this.onPadUpObservable=new Mi,this._buttonCross=0,this._buttonCircle=0,this._buttonSquare=0,this._buttonTriangle=0,this._buttonShare=0,this._buttonOptions=0,this._buttonL1=0,this._buttonR1=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0,this.type=lo.DUALSHOCK}onlefttriggerchanged(p){this._onlefttriggerchanged=p}onrighttriggerchanged(p){this._onrighttriggerchanged=p}get leftTrigger(){return this._leftTrigger}set leftTrigger(p){this._onlefttriggerchanged&&this._leftTrigger!==p&&this._onlefttriggerchanged(p),this._leftTrigger=p}get rightTrigger(){return this._rightTrigger}set rightTrigger(p){this._onrighttriggerchanged&&this._rightTrigger!==p&&this._onrighttriggerchanged(p),this._rightTrigger=p}onbuttondown(p){this._onbuttondown=p}onbuttonup(p){this._onbuttonup=p}ondpaddown(p){this._ondpaddown=p}ondpadup(p){this._ondpadup=p}_setButtonValue(p,_,E){return p!==_&&(p===1&&(this._onbuttondown&&this._onbuttondown(E),this.onButtonDownObservable.notifyObservers(E)),p===0&&(this._onbuttonup&&this._onbuttonup(E),this.onButtonUpObservable.notifyObservers(E))),p}_setDPadValue(p,_,E){return p!==_&&(p===1&&(this._ondpaddown&&this._ondpaddown(E),this.onPadDownObservable.notifyObservers(E)),p===0&&(this._ondpadup&&this._ondpadup(E),this.onPadUpObservable.notifyObservers(E))),p}get buttonCross(){return this._buttonCross}set buttonCross(p){this._buttonCross=this._setButtonValue(p,this._buttonCross,pl.Cross)}get buttonCircle(){return this._buttonCircle}set buttonCircle(p){this._buttonCircle=this._setButtonValue(p,this._buttonCircle,pl.Circle)}get buttonSquare(){return this._buttonSquare}set buttonSquare(p){this._buttonSquare=this._setButtonValue(p,this._buttonSquare,pl.Square)}get buttonTriangle(){return this._buttonTriangle}set buttonTriangle(p){this._buttonTriangle=this._setButtonValue(p,this._buttonTriangle,pl.Triangle)}get buttonOptions(){return this._buttonOptions}set buttonOptions(p){this._buttonOptions=this._setButtonValue(p,this._buttonOptions,pl.Options)}get buttonShare(){return this._buttonShare}set buttonShare(p){this._buttonShare=this._setButtonValue(p,this._buttonShare,pl.Share)}get buttonL1(){return this._buttonL1}set buttonL1(p){this._buttonL1=this._setButtonValue(p,this._buttonL1,pl.L1)}get buttonR1(){return this._buttonR1}set buttonR1(p){this._buttonR1=this._setButtonValue(p,this._buttonR1,pl.R1)}get buttonLeftStick(){return this._buttonLeftStick}set buttonLeftStick(p){this._buttonLeftStick=this._setButtonValue(p,this._buttonLeftStick,pl.LeftStick)}get buttonRightStick(){return this._buttonRightStick}set buttonRightStick(p){this._buttonRightStick=this._setButtonValue(p,this._buttonRightStick,pl.RightStick)}get dPadUp(){return this._dPadUp}set dPadUp(p){this._dPadUp=this._setDPadValue(p,this._dPadUp,ku.Up)}get dPadDown(){return this._dPadDown}set dPadDown(p){this._dPadDown=this._setDPadValue(p,this._dPadDown,ku.Down)}get dPadLeft(){return this._dPadLeft}set dPadLeft(p){this._dPadLeft=this._setDPadValue(p,this._dPadLeft,ku.Left)}get dPadRight(){return this._dPadRight}set dPadRight(p){this._dPadRight=this._setDPadValue(p,this._dPadRight,ku.Right)}update(){super.update(),this.buttonCross=this.browserGamepad.buttons[0].value,this.buttonCircle=this.browserGamepad.buttons[1].value,this.buttonSquare=this.browserGamepad.buttons[2].value,this.buttonTriangle=this.browserGamepad.buttons[3].value,this.buttonL1=this.browserGamepad.buttons[4].value,this.buttonR1=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonShare=this.browserGamepad.buttons[8].value,this.buttonOptions=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear(),this.onPadDownObservable.clear(),this.onPadUpObservable.clear()}}class uw{constructor(p){if(this._scene=p,this._babylonGamepads=[],this._oneGamepadConnected=!1,this._isMonitoring=!1,this.onGamepadDisconnectedObservable=new Mi,wa()?(this._gamepadEventSupported="GamepadEvent"in window,this._gamepadSupport=navigator&&navigator.getGamepads):this._gamepadEventSupported=!1,this.onGamepadConnectedObservable=new Mi(_=>{for(const E in this._babylonGamepads){const A=this._babylonGamepads[E];A&&A._isConnected&&this.onGamepadConnectedObservable.notifyObserver(_,A)}}),this._onGamepadConnectedEvent=_=>{const E=_.gamepad;if(E.index in this._babylonGamepads&&this._babylonGamepads[E.index].isConnected)return;let A;this._babylonGamepads[E.index]?(A=this._babylonGamepads[E.index],A.browserGamepad=E,A._isConnected=!0):A=this._addNewGamepad(E),this.onGamepadConnectedObservable.notifyObservers(A),this._startMonitoringGamepads()},this._onGamepadDisconnectedEvent=_=>{const E=_.gamepad;for(const A in this._babylonGamepads)if(this._babylonGamepads[A].index===E.index){const $=this._babylonGamepads[A];$._isConnected=!1,this.onGamepadDisconnectedObservable.notifyObservers($),$.dispose&&$.dispose();break}},this._gamepadSupport)if(this._updateGamepadObjects(),this._babylonGamepads.length&&this._startMonitoringGamepads(),this._gamepadEventSupported){const _=this._scene?this._scene.getEngine().getHostWindow():window;_&&(_.addEventListener("gamepadconnected",this._onGamepadConnectedEvent,!1),_.addEventListener("gamepaddisconnected",this._onGamepadDisconnectedEvent,!1))}else this._startMonitoringGamepads()}get gamepads(){return this._babylonGamepads}getGamepadByType(p=lo.XBOX){for(const _ of this._babylonGamepads)if(_&&_.type===p)return _;return null}dispose(){this._gamepadEventSupported&&(this._onGamepadConnectedEvent&&window.removeEventListener("gamepadconnected",this._onGamepadConnectedEvent),this._onGamepadDisconnectedEvent&&window.removeEventListener("gamepaddisconnected",this._onGamepadDisconnectedEvent),this._onGamepadConnectedEvent=null,this._onGamepadDisconnectedEvent=null),this._babylonGamepads.forEach(p=>{p.dispose()}),this.onGamepadConnectedObservable.clear(),this.onGamepadDisconnectedObservable.clear(),this._oneGamepadConnected=!1,this._stopMonitoringGamepads(),this._babylonGamepads=[]}_addNewGamepad(p){this._oneGamepadConnected||(this._oneGamepadConnected=!0);let _;const E=p.id.search("054c")!==-1&&p.id.search("0ce6")===-1,A=p.id.search("Xbox One")!==-1;return A||p.id.search("Xbox 360")!==-1||p.id.search("xinput")!==-1||p.id.search("045e")!==-1&&p.id.search("Surface Dock")===-1?_=new hw(p.id,p.index,p,A):E?_=new cw(p.id,p.index,p):_=new lw(p.id,p.index,p),this._babylonGamepads[_.index]=_,_}_startMonitoringGamepads(){this._isMonitoring||(this._isMonitoring=!0,this._checkGamepadsStatus())}_stopMonitoringGamepads(){this._isMonitoring=!1}_checkGamepadsStatus(){this._updateGamepadObjects();for(const p in this._babylonGamepads){const _=this._babylonGamepads[p];if(!(!_||!_.isConnected))try{_.update()}catch{this._loggedErrors.indexOf(_.index)===-1&&(ct.Warn(`Error updating gamepad ${_.id}`),this._loggedErrors.push(_.index))}}this._isMonitoring&&ui.QueueNewFrame(()=>{this._checkGamepadsStatus()})}_updateGamepadObjects(){const p=navigator.getGamepads?navigator.getGamepads():[];for(let _=0;_<p.length;_++){const E=p[_];if(E)if(this._babylonGamepads[E.index])this._babylonGamepads[_].browserGamepad=E,this._babylonGamepads[_].isConnected||(this._babylonGamepads[_]._isConnected=!0,this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[_]));else{const A=this._addNewGamepad(E);this.onGamepadConnectedObservable.notifyObservers(A)}}}}class xg{constructor(){this.gamepadAngularSensibility=200,this.gamepadMoveSensibility=40,this.deadzoneDelta=.1,this._yAxisScale=1,this._cameraTransform=Yt.Identity(),this._deltaTransform=nt.Zero(),this._vector3=nt.Zero(),this._vector2=xr.Zero()}get invertYAxis(){return this._yAxisScale!==1}set invertYAxis(p){this._yAxisScale=p?-1:1}attachControl(){const p=this.camera.getScene().gamepadManager;this._onGamepadConnectedObserver=p.onGamepadConnectedObservable.add(_=>{_.type!==lo.POSE_ENABLED&&(!this.gamepad||_.type===lo.XBOX)&&(this.gamepad=_)}),this._onGamepadDisconnectedObserver=p.onGamepadDisconnectedObservable.add(_=>{this.gamepad===_&&(this.gamepad=null)}),this.gamepad=p.getGamepadByType(lo.XBOX),!this.gamepad&&p.gamepads.length&&(this.gamepad=p.gamepads[0])}detachControl(){this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver),this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver),this.gamepad=null}checkInputs(){if(this.gamepad&&this.gamepad.leftStick){const p=this.camera,_=this.gamepad.leftStick;this.gamepadMoveSensibility!==0&&(_.x=Math.abs(_.x)>this.deadzoneDelta?_.x/this.gamepadMoveSensibility:0,_.y=Math.abs(_.y)>this.deadzoneDelta?_.y/this.gamepadMoveSensibility:0);let E=this.gamepad.rightStick;E&&this.gamepadAngularSensibility!==0?(E.x=Math.abs(E.x)>this.deadzoneDelta?E.x/this.gamepadAngularSensibility:0,E.y=(Math.abs(E.y)>this.deadzoneDelta?E.y/this.gamepadAngularSensibility:0)*this._yAxisScale):E={x:0,y:0},p.rotationQuaternion?p.rotationQuaternion.toRotationMatrix(this._cameraTransform):Yt.RotationYawPitchRollToRef(p.rotation.y,p.rotation.x,0,this._cameraTransform);const A=p._computeLocalCameraSpeed()*50;this._vector3.copyFromFloats(_.x*A,0,-_.y*A),nt.TransformCoordinatesToRef(this._vector3,this._cameraTransform,this._deltaTransform),p.cameraDirection.addInPlace(this._deltaTransform),this._vector2.copyFromFloats(E.y,E.x),p.cameraRotation.addInPlace(this._vector2)}}getClassName(){return"FreeCameraGamepadInput"}getSimpleName(){return"gamepad"}}Mt([Gt()],xg.prototype,"gamepadAngularSensibility",void 0),Mt([Gt()],xg.prototype,"gamepadMoveSensibility",void 0),Wl.FreeCameraGamepadInput=xg;class Wb{constructor(){this._currentActiveButton=-1,this.buttons=[0,1,2]}attachControl(p){p=ct.BackCompatCameraNoPreventDefault(arguments);const _=this.camera.getEngine(),E=_.getInputElement();let A=0,$=null;this._pointA=null,this._pointB=null,this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._pointerInput=xe=>{const ce=xe.event,Te=ce.pointerType==="touch";if(xe.type!==Kr.POINTERMOVE&&this.buttons.indexOf(ce.button)===-1)return;const Re=ce.target;if(this._altKey=ce.altKey,this._ctrlKey=ce.ctrlKey,this._metaKey=ce.metaKey,this._shiftKey=ce.shiftKey,this._buttonsPressed=ce.buttons,_.isPointerLock){const ke=ce.movementX,We=ce.movementY;this.onTouch(null,ke,We),this._pointA=null,this._pointB=null}else{if(xe.type!==Kr.POINTERDOWN&&Te&&this._pointA?.pointerId!==ce.pointerId&&this._pointB?.pointerId!==ce.pointerId)return;if(xe.type===Kr.POINTERDOWN&&(this._currentActiveButton===-1||Te)){try{Re?.setPointerCapture(ce.pointerId)}catch{}if(this._pointA===null)this._pointA={x:ce.clientX,y:ce.clientY,pointerId:ce.pointerId,type:ce.pointerType};else if(this._pointB===null)this._pointB={x:ce.clientX,y:ce.clientY,pointerId:ce.pointerId,type:ce.pointerType};else return;this._currentActiveButton===-1&&!Te&&(this._currentActiveButton=ce.button),this.onButtonDown(ce),p||(ce.preventDefault(),E&&E.focus())}else if(xe.type===Kr.POINTERDOUBLETAP)this.onDoubleTap(ce.pointerType);else if(xe.type===Kr.POINTERUP&&(this._currentActiveButton===ce.button||Te)){try{Re?.releasePointerCapture(ce.pointerId)}catch{}Te||(this._pointB=null),_._badOS?this._pointA=this._pointB=null:this._pointB&&this._pointA&&this._pointA.pointerId==ce.pointerId?(this._pointA=this._pointB,this._pointB=null):this._pointA&&this._pointB&&this._pointB.pointerId==ce.pointerId?this._pointB=null:this._pointA=this._pointB=null,(A!==0||$)&&(this.onMultiTouch(this._pointA,this._pointB,A,0,$,null),A=0,$=null),this._currentActiveButton=-1,this.onButtonUp(ce),p||ce.preventDefault()}else if(xe.type===Kr.POINTERMOVE){if(p||ce.preventDefault(),this._pointA&&this._pointB===null){const ke=ce.clientX-this._pointA.x,We=ce.clientY-this._pointA.y;this.onTouch(this._pointA,ke,We),this._pointA.x=ce.clientX,this._pointA.y=ce.clientY}else if(this._pointA&&this._pointB){const ke=this._pointA.pointerId===ce.pointerId?this._pointA:this._pointB;ke.x=ce.clientX,ke.y=ce.clientY;const We=this._pointA.x-this._pointB.x,Xe=this._pointA.y-this._pointB.y,xt=We*We+Xe*Xe,qe={x:(this._pointA.x+this._pointB.x)/2,y:(this._pointA.y+this._pointB.y)/2,pointerId:ce.pointerId,type:xe.type};this.onMultiTouch(this._pointA,this._pointB,A,xt,$,qe),$=qe,A=xt}}}},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,Kr.POINTERDOWN|Kr.POINTERUP|Kr.POINTERMOVE|Kr.POINTERDOUBLETAP),this._onLostFocus=()=>{this._pointA=this._pointB=null,A=0,$=null,this.onLostFocus()},this._contextMenuBind=xe=>this.onContextMenu(xe),E&&E.addEventListener("contextmenu",this._contextMenuBind,!1);const ne=this.camera.getScene().getEngine().getHostWindow();ne&&ct.RegisterTopRootEvents(ne,[{name:"blur",handler:this._onLostFocus}])}detachControl(){if(this._onLostFocus){const p=this.camera.getScene().getEngine().getHostWindow();p&&ct.UnregisterTopRootEvents(p,[{name:"blur",handler:this._onLostFocus}])}if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._contextMenuBind){const p=this.camera.getScene().getEngine().getInputElement();p&&p.removeEventListener("contextmenu",this._contextMenuBind)}this._onLostFocus=null}this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._currentActiveButton=-1}getClassName(){return"BaseCameraPointersInput"}getSimpleName(){return"pointers"}onDoubleTap(p){}onTouch(p,_,E){}onMultiTouch(p,_,E,A,$,ne){}onContextMenu(p){p.preventDefault()}onButtonDown(p){}onButtonUp(p){}onLostFocus(){}}Mt([Gt()],Wb.prototype,"buttons",void 0);class ax extends Wb{constructor(){super(...arguments),this.buttons=[0,1,2],this.angularSensibilityX=1e3,this.angularSensibilityY=1e3,this.pinchPrecision=12,this.pinchDeltaPercentage=0,this.useNaturalPinchZoom=!1,this.pinchZoom=!0,this.panningSensibility=1e3,this.multiTouchPanning=!0,this.multiTouchPanAndZoom=!0,this.pinchInwards=!0,this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}getClassName(){return"ArcRotateCameraPointersInput"}_computeMultiTouchPanning(p,_){if(this.panningSensibility!==0&&p&&_){const E=_.x-p.x,A=_.y-p.y;this.camera.inertialPanningX+=-E/this.panningSensibility,this.camera.inertialPanningY+=A/this.panningSensibility}}_computePinchZoom(p,_){const E=this.camera.radius||ax.MinimumRadiusForPinch;this.useNaturalPinchZoom?this.camera.radius=E*Math.sqrt(p)/Math.sqrt(_):this.pinchDeltaPercentage?this.camera.inertialRadiusOffset+=(_-p)*.001*E*this.pinchDeltaPercentage:this.camera.inertialRadiusOffset+=(_-p)/(this.pinchPrecision*(this.pinchInwards?1:-1)*(this.angularSensibilityX+this.angularSensibilityY)/2)}onTouch(p,_,E){this.panningSensibility!==0&&(this._ctrlKey&&this.camera._useCtrlForPanning||this._isPanClick)?(this.camera.inertialPanningX+=-_/this.panningSensibility,this.camera.inertialPanningY+=E/this.panningSensibility):(this.camera.inertialAlphaOffset-=_/this.angularSensibilityX,this.camera.inertialBetaOffset-=E/this.angularSensibilityY)}onDoubleTap(){this.camera.useInputToRestoreState&&this.camera.restoreState()}onMultiTouch(p,_,E,A,$,ne){E===0&&$===null||A===0&&ne===null||(this.multiTouchPanAndZoom?(this._computePinchZoom(E,A),this._computeMultiTouchPanning($,ne)):this.multiTouchPanning&&this.pinchZoom?(this._twoFingerActivityCount++,this._isPinching||this._twoFingerActivityCount<20&&Math.abs(Math.sqrt(A)-Math.sqrt(E))>this.camera.pinchToPanMaxDistance?(this._computePinchZoom(E,A),this._isPinching=!0):this._computeMultiTouchPanning($,ne)):this.multiTouchPanning?this._computeMultiTouchPanning($,ne):this.pinchZoom&&this._computePinchZoom(E,A))}onButtonDown(p){this._isPanClick=p.button===this.camera._panningMouseButton}onButtonUp(p){this._twoFingerActivityCount=0,this._isPinching=!1}onLostFocus(){this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}}ax.MinimumRadiusForPinch=.001,Mt([Gt()],ax.prototype,"buttons",void 0),Mt([Gt()],ax.prototype,"angularSensibilityX",void 0),Mt([Gt()],ax.prototype,"angularSensibilityY",void 0),Mt([Gt()],ax.prototype,"pinchPrecision",void 0),Mt([Gt()],ax.prototype,"pinchDeltaPercentage",void 0),Mt([Gt()],ax.prototype,"useNaturalPinchZoom",void 0),Mt([Gt()],ax.prototype,"pinchZoom",void 0),Mt([Gt()],ax.prototype,"panningSensibility",void 0),Mt([Gt()],ax.prototype,"multiTouchPanning",void 0),Mt([Gt()],ax.prototype,"multiTouchPanAndZoom",void 0),Wl.ArcRotateCameraPointersInput=ax;class Xl{constructor(){this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.keysReset=[220],this.panningSensibility=50,this.zoomingSensibility=25,this.useAltToZoom=!0,this.angularSpeed=.01,this._keys=new Array}attachControl(p){p=ct.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(_=>{const E=_.event;if(!E.metaKey){if(_.type===Ru.KEYDOWN)this._ctrlPressed=E.ctrlKey,this._altPressed=E.altKey,(this.keysUp.indexOf(E.keyCode)!==-1||this.keysDown.indexOf(E.keyCode)!==-1||this.keysLeft.indexOf(E.keyCode)!==-1||this.keysRight.indexOf(E.keyCode)!==-1||this.keysReset.indexOf(E.keyCode)!==-1)&&(this._keys.indexOf(E.keyCode)===-1&&this._keys.push(E.keyCode),E.preventDefault&&(p||E.preventDefault()));else if(this.keysUp.indexOf(E.keyCode)!==-1||this.keysDown.indexOf(E.keyCode)!==-1||this.keysLeft.indexOf(E.keyCode)!==-1||this.keysRight.indexOf(E.keyCode)!==-1||this.keysReset.indexOf(E.keyCode)!==-1){const A=this._keys.indexOf(E.keyCode);A>=0&&this._keys.splice(A,1),E.preventDefault&&(p||E.preventDefault())}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const p=this.camera;for(let _=0;_<this._keys.length;_++){const E=this._keys[_];this.keysLeft.indexOf(E)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?p.inertialPanningX-=1/this.panningSensibility:p.inertialAlphaOffset-=this.angularSpeed:this.keysUp.indexOf(E)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?p.inertialPanningY+=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?p.inertialRadiusOffset+=1/this.zoomingSensibility:p.inertialBetaOffset-=this.angularSpeed:this.keysRight.indexOf(E)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?p.inertialPanningX+=1/this.panningSensibility:p.inertialAlphaOffset+=this.angularSpeed:this.keysDown.indexOf(E)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?p.inertialPanningY-=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?p.inertialRadiusOffset-=1/this.zoomingSensibility:p.inertialBetaOffset+=this.angularSpeed:this.keysReset.indexOf(E)!==-1&&p.useInputToRestoreState&&p.restoreState()}}}getClassName(){return"ArcRotateCameraKeyboardMoveInput"}getSimpleName(){return"keyboard"}}Mt([Gt()],Xl.prototype,"keysUp",void 0),Mt([Gt()],Xl.prototype,"keysDown",void 0),Mt([Gt()],Xl.prototype,"keysLeft",void 0),Mt([Gt()],Xl.prototype,"keysRight",void 0),Mt([Gt()],Xl.prototype,"keysReset",void 0),Mt([Gt()],Xl.prototype,"panningSensibility",void 0),Mt([Gt()],Xl.prototype,"zoomingSensibility",void 0),Mt([Gt()],Xl.prototype,"useAltToZoom",void 0),Mt([Gt()],Xl.prototype,"angularSpeed",void 0),Wl.ArcRotateCameraKeyboardMoveInput=Xl;const pw=40;class xm{constructor(){this.wheelPrecision=3,this.zoomToMouseLocation=!1,this.wheelDeltaPercentage=0,this.customComputeDeltaFromMouseWheel=null,this._viewOffset=new nt(0,0,0),this._globalOffset=new nt(0,0,0),this._inertialPanning=nt.Zero()}_computeDeltaFromMouseWheelLegacyEvent(p,_){let E=0;const A=p*.01*this.wheelDeltaPercentage*_;return p>0?E=A/(1+this.wheelDeltaPercentage):E=A*(1+this.wheelDeltaPercentage),E}attachControl(p){p=ct.BackCompatCameraNoPreventDefault(arguments),this._wheel=_=>{if(_.type!==Kr.POINTERWHEEL)return;const E=_.event;let A=0;const $=E.deltaMode===Mu.DOM_DELTA_LINE?pw:1,ne=-(E.deltaY*$);if(this.customComputeDeltaFromMouseWheel)A=this.customComputeDeltaFromMouseWheel(ne,this,E);else if(this.wheelDeltaPercentage){if(A=this._computeDeltaFromMouseWheelLegacyEvent(ne,this.camera.radius),A>0){let xe=this.camera.radius,ce=this.camera.inertialRadiusOffset+A;for(let Te=0;Te<20&&Math.abs(ce)>.001;Te++)xe-=ce,ce*=this.camera.inertia;xe=ri.Clamp(xe,0,Number.MAX_VALUE),A=this._computeDeltaFromMouseWheelLegacyEvent(ne,xe)}}else A=ne/(this.wheelPrecision*40);A&&(this.zoomToMouseLocation?(this._hitPlane||this._updateHitPlane(),this._zoomToMouse(A)):this.camera.inertialRadiusOffset+=A),E.preventDefault&&(p||E.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,Kr.POINTERWHEEL),this.zoomToMouseLocation&&this._inertialPanning.setAll(0)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null)}checkInputs(){if(!this.zoomToMouseLocation)return;const p=this.camera;0+p.inertialAlphaOffset+p.inertialBetaOffset+p.inertialRadiusOffset&&(this._updateHitPlane(),p.target.addInPlace(this._inertialPanning),this._inertialPanning.scaleInPlace(p.inertia),this._zeroIfClose(this._inertialPanning))}getClassName(){return"ArcRotateCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}_updateHitPlane(){const p=this.camera,_=p.target.subtract(p.position);this._hitPlane=hl.FromPositionAndNormal(p.target,_)}_getPosition(){const p=this.camera,_=p.getScene(),E=_.createPickingRay(_.pointerX,_.pointerY,Yt.Identity(),p,!1);(p.targetScreenOffset.x!==0||p.targetScreenOffset.y!==0)&&(this._viewOffset.set(p.targetScreenOffset.x,p.targetScreenOffset.y,0),p.getViewMatrix().invertToRef(p._cameraTransformMatrix),this._globalOffset=nt.TransformNormal(this._viewOffset,p._cameraTransformMatrix),E.origin.addInPlace(this._globalOffset));let A=0;return this._hitPlane&&(A=E.intersectsPlane(this._hitPlane)??0),E.origin.addInPlace(E.direction.scaleInPlace(A))}_zoomToMouse(p){const _=this.camera,E=1-_.inertia;if(_.lowerRadiusLimit){const ce=_.lowerRadiusLimit??0;_.radius-(_.inertialRadiusOffset+p)/E<ce&&(p=(_.radius-ce)*E-_.inertialRadiusOffset)}if(_.upperRadiusLimit){const ce=_.upperRadiusLimit??0;_.radius-(_.inertialRadiusOffset+p)/E>ce&&(p=(_.radius-ce)*E-_.inertialRadiusOffset)}const $=p/E/_.radius,ne=this._getPosition(),xe=pi.Vector3[6];ne.subtractToRef(_.target,xe),xe.scaleInPlace($),xe.scaleInPlace(E),this._inertialPanning.addInPlace(xe),_.inertialRadiusOffset+=p}_zeroIfClose(p){Math.abs(p.x)<as&&(p.x=0),Math.abs(p.y)<as&&(p.y=0),Math.abs(p.z)<as&&(p.z=0)}}Mt([Gt()],xm.prototype,"wheelPrecision",void 0),Mt([Gt()],xm.prototype,"zoomToMouseLocation",void 0),Mt([Gt()],xm.prototype,"wheelDeltaPercentage",void 0),Wl.ArcRotateCameraMouseWheelInput=xm;class _w extends Ub{constructor(p){super(p)}addMouseWheel(){return this.add(new xm),this}addPointers(){return this.add(new ax),this}addKeyboard(){return this.add(new Xl),this}}class lg{constructor(){this.gamepadRotationSensibility=80,this.gamepadMoveSensibility=40,this._yAxisScale=1}get invertYAxis(){return this._yAxisScale!==1}set invertYAxis(p){this._yAxisScale=p?-1:1}attachControl(){const p=this.camera.getScene().gamepadManager;this._onGamepadConnectedObserver=p.onGamepadConnectedObservable.add(_=>{_.type!==lo.POSE_ENABLED&&(!this.gamepad||_.type===lo.XBOX)&&(this.gamepad=_)}),this._onGamepadDisconnectedObserver=p.onGamepadDisconnectedObservable.add(_=>{this.gamepad===_&&(this.gamepad=null)}),this.gamepad=p.getGamepadByType(lo.XBOX),!this.gamepad&&p.gamepads.length&&(this.gamepad=p.gamepads[0])}detachControl(){this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver),this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver),this.gamepad=null}checkInputs(){if(this.gamepad){const p=this.camera,_=this.gamepad.rightStick;if(_){if(_.x!=0){const A=_.x/this.gamepadRotationSensibility;A!=0&&Math.abs(A)>.005&&(p.inertialAlphaOffset+=A)}if(_.y!=0){const A=_.y/this.gamepadRotationSensibility*this._yAxisScale;A!=0&&Math.abs(A)>.005&&(p.inertialBetaOffset+=A)}}const E=this.gamepad.leftStick;if(E&&E.y!=0){const A=E.y/this.gamepadMoveSensibility;A!=0&&Math.abs(A)>.005&&(this.camera.inertialRadiusOffset-=A)}}}getClassName(){return"ArcRotateCameraGamepadInput"}getSimpleName(){return"gamepad"}}Mt([Gt()],lg.prototype,"gamepadRotationSensibility",void 0),Mt([Gt()],lg.prototype,"gamepadMoveSensibility",void 0),Wl.ArcRotateCameraGamepadInput=lg,Object.defineProperty(W0.prototype,"gamepadManager",{get:function(){if(!this._gamepadManager){this._gamepadManager=new uw(this);let _e=this._getComponent(_r.NAME_GAMEPAD);_e||(_e=new Tw(this),this._addComponent(_e))}return this._gamepadManager},enumerable:!0,configurable:!0}),Gb.prototype.addGamepad=function(){return this.add(new xg),this},_w.prototype.addGamepad=function(){return this.add(new lg),this};class Tw{constructor(p){this.name=_r.NAME_GAMEPAD,this.scene=p}register(){this.scene._beforeCameraUpdateStage.registerStep(_r.STEP_BEFORECAMERAUPDATE_GAMEPAD,this,this._beforeCameraUpdate)}rebuild(){}dispose(){const p=this.scene._gamepadManager;p&&(p.dispose(),this.scene._gamepadManager=null)}_beforeCameraUpdate(){const p=this.scene._gamepadManager;p&&p._isMonitoring&&p._checkGamepadsStatus()}}Ka.AddNodeConstructor("FreeCamera",(_e,p)=>()=>new a_(_e,nt.Zero(),p));class a_ extends zb{get gamepadAngularSensibility(){const p=this.inputs.attached.gamepad;return p?p.gamepadAngularSensibility:0}set gamepadAngularSensibility(p){const _=this.inputs.attached.gamepad;_&&(_.gamepadAngularSensibility=p)}get gamepadMoveSensibility(){const p=this.inputs.attached.gamepad;return p?p.gamepadMoveSensibility:0}set gamepadMoveSensibility(p){const _=this.inputs.attached.gamepad;_&&(_.gamepadMoveSensibility=p)}constructor(p,_,E){super(p,_,E),this.inputs.addGamepad()}getClassName(){return"UniversalCamera"}}Hr._CreateDefaultParsedCamera=(_e,p)=>new a_(_e,nt.Zero(),p);class Hb{constructor(p,_,E){this.bu=p,this.bv=_,this.distance=E,this.faceId=0,this.subMeshId=0}}class ah{constructor(p,_,E){this.vectors=Ms.BuildArray(8,nt.Zero),this.center=nt.Zero(),this.centerWorld=nt.Zero(),this.extendSize=nt.Zero(),this.extendSizeWorld=nt.Zero(),this.directions=Ms.BuildArray(3,nt.Zero),this.vectorsWorld=Ms.BuildArray(8,nt.Zero),this.minimumWorld=nt.Zero(),this.maximumWorld=nt.Zero(),this.minimum=nt.Zero(),this.maximum=nt.Zero(),this._drawWrapperFront=null,this._drawWrapperBack=null,this.reConstruct(p,_,E)}reConstruct(p,_,E){const A=p.x,$=p.y,ne=p.z,xe=_.x,ce=_.y,Te=_.z,Re=this.vectors;this.minimum.copyFromFloats(A,$,ne),this.maximum.copyFromFloats(xe,ce,Te),Re[0].copyFromFloats(A,$,ne),Re[1].copyFromFloats(xe,ce,Te),Re[2].copyFromFloats(xe,$,ne),Re[3].copyFromFloats(A,ce,ne),Re[4].copyFromFloats(A,$,Te),Re[5].copyFromFloats(xe,ce,ne),Re[6].copyFromFloats(A,ce,Te),Re[7].copyFromFloats(xe,$,Te),_.addToRef(p,this.center).scaleInPlace(.5),_.subtractToRef(p,this.extendSize).scaleInPlace(.5),this._worldMatrix=E||Yt.IdentityReadOnly,this._update(this._worldMatrix)}scale(p){const _=ah._TmpVector3,E=this.maximum.subtractToRef(this.minimum,_[0]),A=E.length();E.normalizeFromLength(A);const $=A*p,ne=E.scaleInPlace($*.5),xe=this.center.subtractToRef(ne,_[1]),ce=this.center.addToRef(ne,_[2]);return this.reConstruct(xe,ce,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(p){const _=this.minimumWorld,E=this.maximumWorld,A=this.directions,$=this.vectorsWorld,ne=this.vectors;if(p.isIdentity()){_.copyFrom(this.minimum),E.copyFrom(this.maximum);for(let xe=0;xe<8;++xe)$[xe].copyFrom(ne[xe]);this.extendSizeWorld.copyFrom(this.extendSize),this.centerWorld.copyFrom(this.center)}else{_.setAll(Number.MAX_VALUE),E.setAll(-Number.MAX_VALUE);for(let xe=0;xe<8;++xe){const ce=$[xe];nt.TransformCoordinatesToRef(ne[xe],p,ce),_.minimizeInPlace(ce),E.maximizeInPlace(ce)}E.subtractToRef(_,this.extendSizeWorld).scaleInPlace(.5),E.addToRef(_,this.centerWorld).scaleInPlace(.5)}nt.FromArrayToRef(p.m,0,A[0]),nt.FromArrayToRef(p.m,4,A[1]),nt.FromArrayToRef(p.m,8,A[2]),this._worldMatrix=p}isInFrustum(p){return ah.IsInFrustum(this.vectorsWorld,p)}isCompletelyInFrustum(p){return ah.IsCompletelyInFrustum(this.vectorsWorld,p)}intersectsPoint(p){const _=this.minimumWorld,E=this.maximumWorld,A=_.x,$=_.y,ne=_.z,xe=E.x,ce=E.y,Te=E.z,Re=p.x,ke=p.y,We=p.z,Xe=-as;return!(xe-Re<Xe||Xe>Re-A||ce-ke<Xe||Xe>ke-$||Te-We<Xe||Xe>We-ne)}intersectsSphere(p){return ah.IntersectsSphere(this.minimumWorld,this.maximumWorld,p.centerWorld,p.radiusWorld)}intersectsMinMax(p,_){const E=this.minimumWorld,A=this.maximumWorld,$=E.x,ne=E.y,xe=E.z,ce=A.x,Te=A.y,Re=A.z,ke=p.x,We=p.y,Xe=p.z,xt=_.x,qe=_.y,ht=_.z;return!(ce<ke||$>xt||Te<We||ne>qe||Re<Xe||xe>ht)}dispose(){this._drawWrapperFront?.dispose(),this._drawWrapperBack?.dispose()}static Intersects(p,_){return p.intersectsMinMax(_.minimumWorld,_.maximumWorld)}static IntersectsSphere(p,_,E,A){const $=ah._TmpVector3[0];return nt.ClampToRef(E,p,_,$),nt.DistanceSquared(E,$)<=A*A}static IsCompletelyInFrustum(p,_){for(let E=0;E<6;++E){const A=_[E];for(let $=0;$<8;++$)if(A.dotCoordinate(p[$])<0)return!1}return!0}static IsInFrustum(p,_){for(let E=0;E<6;++E){let A=!0;const $=_[E];for(let ne=0;ne<8;++ne)if($.dotCoordinate(p[ne])>=0){A=!1;break}if(A)return!1}return!0}}ah._TmpVector3=Ms.BuildArray(3,nt.Zero);class nu{constructor(p,_,E){this.center=nt.Zero(),this.centerWorld=nt.Zero(),this.minimum=nt.Zero(),this.maximum=nt.Zero(),this.reConstruct(p,_,E)}reConstruct(p,_,E){this.minimum.copyFrom(p),this.maximum.copyFrom(_);const A=nt.Distance(p,_);_.addToRef(p,this.center).scaleInPlace(.5),this.radius=A*.5,this._update(E||Yt.IdentityReadOnly)}scale(p){const _=this.radius*p,E=nu._TmpVector3,A=E[0].setAll(_),$=this.center.subtractToRef(A,E[1]),ne=this.center.addToRef(A,E[2]);return this.reConstruct($,ne,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(p){if(p.isIdentity())this.centerWorld.copyFrom(this.center),this.radiusWorld=this.radius;else{nt.TransformCoordinatesToRef(this.center,p,this.centerWorld);const _=nu._TmpVector3[0];nt.TransformNormalFromFloatsToRef(1,1,1,p,_),this.radiusWorld=Math.max(Math.abs(_.x),Math.abs(_.y),Math.abs(_.z))*this.radius}}isInFrustum(p){const _=this.centerWorld,E=this.radiusWorld;for(let A=0;A<6;A++)if(p[A].dotCoordinate(_)<=-E)return!1;return!0}isCenterInFrustum(p){const _=this.centerWorld;for(let E=0;E<6;E++)if(p[E].dotCoordinate(_)<0)return!1;return!0}intersectsPoint(p){const _=nt.DistanceSquared(this.centerWorld,p);return!(this.radiusWorld*this.radiusWorld<_)}static Intersects(p,_){const E=nt.DistanceSquared(p.centerWorld,_.centerWorld),A=p.radiusWorld+_.radiusWorld;return!(A*A<E)}static CreateFromCenterAndRadius(p,_,E){this._TmpVector3[0].copyFrom(p),this._TmpVector3[1].copyFromFloats(0,0,_),this._TmpVector3[2].copyFrom(p),this._TmpVector3[0].addInPlace(this._TmpVector3[1]),this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);const A=new nu(this._TmpVector3[0],this._TmpVector3[2]);return E?A._worldMatrix=E:A._worldMatrix=Yt.Identity(),A}}nu._TmpVector3=Ms.BuildArray(3,nt.Zero);const o_={min:0,max:0},x_={min:0,max:0},Xb=(_e,p,_)=>{const E=nt.Dot(p.centerWorld,_e),A=Math.abs(nt.Dot(p.directions[0],_e))*p.extendSize.x,$=Math.abs(nt.Dot(p.directions[1],_e))*p.extendSize.y,ne=Math.abs(nt.Dot(p.directions[2],_e))*p.extendSize.z,xe=A+$+ne;_.min=E-xe,_.max=E+xe},xx=(_e,p,_)=>(Xb(_e,p,o_),Xb(_e,_,x_),!(o_.min>x_.max||x_.min>o_.max));class lx{constructor(p,_,E){this._isLocked=!1,this.boundingBox=new ah(p,_,E),this.boundingSphere=new nu(p,_,E)}reConstruct(p,_,E){this.boundingBox.reConstruct(p,_,E),this.boundingSphere.reConstruct(p,_,E)}get minimum(){return this.boundingBox.minimum}get maximum(){return this.boundingBox.maximum}get isLocked(){return this._isLocked}set isLocked(p){this._isLocked=p}update(p){this._isLocked||(this.boundingBox._update(p),this.boundingSphere._update(p))}centerOn(p,_){const E=lx._TmpVector3[0].copyFrom(p).subtractInPlace(_),A=lx._TmpVector3[1].copyFrom(p).addInPlace(_);return this.boundingBox.reConstruct(E,A,this.boundingBox.getWorldMatrix()),this.boundingSphere.reConstruct(E,A,this.boundingBox.getWorldMatrix()),this}encapsulate(p){const _=nt.Minimize(this.minimum,p),E=nt.Maximize(this.maximum,p);return this.reConstruct(_,E,this.boundingBox.getWorldMatrix()),this}encapsulateBoundingInfo(p){const _=pi.Matrix[0];this.boundingBox.getWorldMatrix().invertToRef(_);const E=pi.Vector3[0];return nt.TransformCoordinatesToRef(p.boundingBox.minimumWorld,_,E),this.encapsulate(E),nt.TransformCoordinatesToRef(p.boundingBox.maximumWorld,_,E),this.encapsulate(E),this}scale(p){return this.boundingBox.scale(p),this.boundingSphere.scale(p),this}isInFrustum(p,_=0){return(_===2||_===3)&&this.boundingSphere.isCenterInFrustum(p)?!0:this.boundingSphere.isInFrustum(p)?_===1||_===3?!0:this.boundingBox.isInFrustum(p):!1}get diagonalLength(){const p=this.boundingBox;return p.maximumWorld.subtractToRef(p.minimumWorld,lx._TmpVector3[0]).length()}isCompletelyInFrustum(p){return this.boundingBox.isCompletelyInFrustum(p)}_checkCollision(p){return p._canDoCollision(this.boundingSphere.centerWorld,this.boundingSphere.radiusWorld,this.boundingBox.minimumWorld,this.boundingBox.maximumWorld)}intersectsPoint(p){return!(!this.boundingSphere.centerWorld||!this.boundingSphere.intersectsPoint(p)||!this.boundingBox.intersectsPoint(p))}intersects(p,_){if(!nu.Intersects(this.boundingSphere,p.boundingSphere)||!ah.Intersects(this.boundingBox,p.boundingBox))return!1;if(!_)return!0;const E=this.boundingBox,A=p.boundingBox;return!(!xx(E.directions[0],E,A)||!xx(E.directions[1],E,A)||!xx(E.directions[2],E,A)||!xx(A.directions[0],E,A)||!xx(A.directions[1],E,A)||!xx(A.directions[2],E,A)||!xx(nt.Cross(E.directions[0],A.directions[0]),E,A)||!xx(nt.Cross(E.directions[0],A.directions[1]),E,A)||!xx(nt.Cross(E.directions[0],A.directions[2]),E,A)||!xx(nt.Cross(E.directions[1],A.directions[0]),E,A)||!xx(nt.Cross(E.directions[1],A.directions[1]),E,A)||!xx(nt.Cross(E.directions[1],A.directions[2]),E,A)||!xx(nt.Cross(E.directions[2],A.directions[0]),E,A)||!xx(nt.Cross(E.directions[2],A.directions[1]),E,A)||!xx(nt.Cross(E.directions[2],A.directions[2]),E,A))}}lx._TmpVector3=Ms.BuildArray(2,nt.Zero);class hg{static extractMinAndMaxIndexed(p,_,E,A,$,ne){for(let xe=E;xe<E+A;xe++){const ce=_[xe]*3,Te=p[ce],Re=p[ce+1],ke=p[ce+2];$.minimizeInPlaceFromFloats(Te,Re,ke),ne.maximizeInPlaceFromFloats(Te,Re,ke)}}static extractMinAndMax(p,_,E,A,$,ne){for(let xe=_,ce=_*A;xe<_+E;xe++,ce+=A){const Te=p[ce],Re=p[ce+1],ke=p[ce+2];$.minimizeInPlaceFromFloats(Te,Re,ke),ne.maximizeInPlaceFromFloats(Te,Re,ke)}}}Mt([jh.filter((...[_e,p])=>!Array.isArray(_e)&&!Array.isArray(p))],hg,"extractMinAndMaxIndexed",null),Mt([jh.filter((...[_e])=>!Array.isArray(_e))],hg,"extractMinAndMax",null);function vw(_e,p,_,E,A=null){const $=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),ne=new nt(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return hg.extractMinAndMaxIndexed(_e,p,_,E,$,ne),A&&($.x-=$.x*A.x+A.y,$.y-=$.y*A.x+A.y,$.z-=$.z*A.x+A.y,ne.x+=ne.x*A.x+A.y,ne.y+=ne.y*A.x+A.y,ne.z+=ne.z*A.x+A.y),{minimum:$,maximum:ne}}function Kb(_e,p,_,E=null,A){const $=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),ne=new nt(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return A||(A=3),hg.extractMinAndMax(_e,p,_,A,$,ne),E&&($.x-=$.x*E.x+E.y,$.y-=$.y*E.x+E.y,$.z-=$.z*E.x+E.y,ne.x+=ne.x*E.x+E.y,ne.y+=ne.y*E.x+E.y,ne.z+=ne.z*E.x+E.y),{minimum:$,maximum:ne}}class _l{get materialDefines(){return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.defines:this._getDrawWrapper()?.defines}set materialDefines(p){const _=this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0);_.defines=p}_getDrawWrapper(p,_=!1){p=p??this._engine.currentRenderPassId;let E=this._drawWrappers[p];return!E&&_&&(this._drawWrappers[p]=E=new nx(this._mesh.getScene().getEngine())),E}_removeDrawWrapper(p,_=!0){_&&this._drawWrappers[p]?.dispose(),this._drawWrappers[p]=void 0}get effect(){return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.effect:this._getDrawWrapper()?.effect??null}get _drawWrapper(){return this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0)}get _drawWrapperOverride(){return this._mainDrawWrapperOverride}_setMainDrawWrapperOverride(p){this._mainDrawWrapperOverride=p}setEffect(p,_=null,E,A=!0){const $=this._drawWrapper;$.setEffect(p,_,A),E!==void 0&&($.materialContext=E),p||($.defines=null,$.materialContext=void 0)}resetDrawCache(p){if(this._drawWrappers)if(p!==void 0){this._removeDrawWrapper(p);return}else for(const _ of this._drawWrappers)_?.dispose();this._drawWrappers=[]}static AddToMesh(p,_,E,A,$,ne,xe,ce=!0){return new _l(p,_,E,A,$,ne,xe,ce)}constructor(p,_,E,A,$,ne,xe,ce=!0,Te=!0){this.materialIndex=p,this.verticesStart=_,this.verticesCount=E,this.indexStart=A,this.indexCount=$,this._mainDrawWrapperOverride=null,this._linesIndexCount=0,this._linesIndexBuffer=null,this._lastColliderWorldVertices=null,this._lastColliderTransformMatrix=null,this._wasDispatched=!1,this._renderId=0,this._alphaIndex=0,this._distanceToCamera=0,this._currentMaterial=null,this._mesh=ne,this._renderingMesh=xe||ne,Te&&ne.subMeshes.push(this),this._engine=this._mesh.getScene().getEngine(),this.resetDrawCache(),this._trianglePlanes=[],this._id=ne.subMeshes.length-1,ce&&(this.refreshBoundingInfo(),ne.computeWorldMatrix(!0))}get IsGlobal(){return this.verticesStart===0&&this.verticesCount===this._mesh.getTotalVertices()&&this.indexStart===0&&this.indexCount===this._mesh.getTotalIndices()}getBoundingInfo(){return this.IsGlobal||this._mesh.hasThinInstances?this._mesh.getBoundingInfo():this._boundingInfo}setBoundingInfo(p){return this._boundingInfo=p,this}getMesh(){return this._mesh}getRenderingMesh(){return this._renderingMesh}getReplacementMesh(){return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null}getEffectiveMesh(){const p=this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null;return p||this._renderingMesh}getMaterial(p=!0){const _=this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)??this._renderingMesh.material;if(_){if(this._isMultiMaterial(_)){const E=_.getSubMaterial(this.materialIndex);return this._currentMaterial!==E&&(this._currentMaterial=E,this.resetDrawCache()),E}}else return p?this._mesh.getScene().defaultMaterial:null;return _}_isMultiMaterial(p){return p.getSubMaterial!==void 0}refreshBoundingInfo(p=null){if(this._lastColliderWorldVertices=null,this.IsGlobal||!this._renderingMesh||!this._renderingMesh.geometry)return this;if(p||(p=this._renderingMesh.getVerticesData(ut.PositionKind)),!p)return this._boundingInfo=this._mesh.getBoundingInfo(),this;const _=this._renderingMesh.getIndices();let E;if(this.indexStart===0&&this.indexCount===_.length){const A=this._renderingMesh.getBoundingInfo();E={minimum:A.minimum.clone(),maximum:A.maximum.clone()}}else E=vw(p,_,this.indexStart,this.indexCount,this._renderingMesh.geometry.boundingBias);return this._boundingInfo?this._boundingInfo.reConstruct(E.minimum,E.maximum):this._boundingInfo=new lx(E.minimum,E.maximum),this}_checkCollision(p){return this.getBoundingInfo()._checkCollision(p)}updateBoundingInfo(p){let _=this.getBoundingInfo();return _||(this.refreshBoundingInfo(),_=this.getBoundingInfo()),_&&_.update(p),this}isInFrustum(p){const _=this.getBoundingInfo();return _?_.isInFrustum(p,this._mesh.cullingStrategy):!1}isCompletelyInFrustum(p){const _=this.getBoundingInfo();return _?_.isCompletelyInFrustum(p):!1}render(p){return this._renderingMesh.render(this,p,this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:void 0),this}_getLinesIndexBuffer(p,_){if(!this._linesIndexBuffer){const E=[];for(let A=this.indexStart;A<this.indexStart+this.indexCount;A+=3)E.push(p[A],p[A+1],p[A+1],p[A+2],p[A+2],p[A]);this._linesIndexBuffer=_.createIndexBuffer(E),this._linesIndexCount=E.length}return this._linesIndexBuffer}canIntersects(p){const _=this.getBoundingInfo();return _?p.intersectsBox(_.boundingBox):!1}intersects(p,_,E,A,$){const ne=this.getMaterial();if(!ne)return null;let xe=3,ce=!1;switch(ne.fillMode){case 3:case 5:case 6:case 8:return null;case 7:xe=1,ce=!0;break;default:break}return ne.fillMode===4?E.length?this._intersectLines(p,_,E,this._mesh.intersectionThreshold,A):this._intersectUnIndexedLines(p,_,E,this._mesh.intersectionThreshold,A):!E.length&&this._mesh._unIndexed?this._intersectUnIndexedTriangles(p,_,E,A,$):this._intersectTriangles(p,_,E,xe,ce,A,$)}_intersectLines(p,_,E,A,$){let ne=null;for(let xe=this.indexStart;xe<this.indexStart+this.indexCount;xe+=2){const ce=_[E[xe]],Te=_[E[xe+1]],Re=p.intersectionSegment(ce,Te,A);if(!(Re<0)&&($||!ne||Re<ne.distance)&&(ne=new Hb(null,null,Re),ne.faceId=xe/2,$))break}return ne}_intersectUnIndexedLines(p,_,E,A,$){let ne=null;for(let xe=this.verticesStart;xe<this.verticesStart+this.verticesCount;xe+=2){const ce=_[xe],Te=_[xe+1],Re=p.intersectionSegment(ce,Te,A);if(!(Re<0)&&($||!ne||Re<ne.distance)&&(ne=new Hb(null,null,Re),ne.faceId=xe/2,$))break}return ne}_intersectTriangles(p,_,E,A,$,ne,xe){let ce=null,Te=-1;for(let Re=this.indexStart;Re<this.indexStart+this.indexCount-(3-A);Re+=A){Te++;const ke=E[Re],We=E[Re+1],Xe=E[Re+2];if($&&Xe===4294967295){Re+=2;continue}const xt=_[ke],qe=_[We],ht=_[Xe];if(!xt||!qe||!ht||xe&&!xe(xt,qe,ht,p,ke,We,Xe))continue;const Nt=p.intersectsTriangle(xt,qe,ht);if(Nt){if(Nt.distance<0)continue;if((ne||!ce||Nt.distance<ce.distance)&&(ce=Nt,ce.faceId=Te,ne))break}}return ce}_intersectUnIndexedTriangles(p,_,E,A,$){let ne=null;for(let xe=this.verticesStart;xe<this.verticesStart+this.verticesCount;xe+=3){const ce=_[xe],Te=_[xe+1],Re=_[xe+2];if($&&!$(ce,Te,Re,p,-1,-1,-1))continue;const ke=p.intersectsTriangle(ce,Te,Re);if(ke){if(ke.distance<0)continue;if((A||!ne||ke.distance<ne.distance)&&(ne=ke,ne.faceId=xe/3,A))break}}return ne}_rebuild(){this._linesIndexBuffer&&(this._linesIndexBuffer=null)}clone(p,_){const E=new _l(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,p,_,!1);if(!this.IsGlobal){const A=this.getBoundingInfo();if(!A)return E;E._boundingInfo=new lx(A.minimum,A.maximum)}return E}dispose(){this._linesIndexBuffer&&(this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null);const p=this._mesh.subMeshes.indexOf(this);this._mesh.subMeshes.splice(p,1),this.resetDrawCache()}getClassName(){return"SubMesh"}static CreateFromIndices(p,_,E,A,$,ne=!0){let xe=Number.MAX_VALUE,ce=-Number.MAX_VALUE;const Re=($||A).getIndices();for(let ke=_;ke<_+E;ke++){const We=Re[ke];We<xe&&(xe=We),We>ce&&(ce=We)}return new _l(p,xe,ce-xe+1,_,E,A,$,ne)}}function cg(_e){_e.indexOf("vClipPlane")===-1&&_e.push("vClipPlane"),_e.indexOf("vClipPlane2")===-1&&_e.push("vClipPlane2"),_e.indexOf("vClipPlane3")===-1&&_e.push("vClipPlane3"),_e.indexOf("vClipPlane4")===-1&&_e.push("vClipPlane4"),_e.indexOf("vClipPlane5")===-1&&_e.push("vClipPlane5"),_e.indexOf("vClipPlane6")===-1&&_e.push("vClipPlane6")}function l_(_e,p,_){const E=!!(_e.clipPlane??p.clipPlane),A=!!(_e.clipPlane2??p.clipPlane2),$=!!(_e.clipPlane3??p.clipPlane3),ne=!!(_e.clipPlane4??p.clipPlane4),xe=!!(_e.clipPlane5??p.clipPlane5),ce=!!(_e.clipPlane6??p.clipPlane6);E&&_.push("#define CLIPPLANE"),A&&_.push("#define CLIPPLANE2"),$&&_.push("#define CLIPPLANE3"),ne&&_.push("#define CLIPPLANE4"),xe&&_.push("#define CLIPPLANE5"),ce&&_.push("#define CLIPPLANE6")}function Rw(_e,p,_){let E=!1;const A=!!(_e.clipPlane??p.clipPlane),$=!!(_e.clipPlane2??p.clipPlane2),ne=!!(_e.clipPlane3??p.clipPlane3),xe=!!(_e.clipPlane4??p.clipPlane4),ce=!!(_e.clipPlane5??p.clipPlane5),Te=!!(_e.clipPlane6??p.clipPlane6);return _.CLIPPLANE!==A&&(_.CLIPPLANE=A,E=!0),_.CLIPPLANE2!==$&&(_.CLIPPLANE2=$,E=!0),_.CLIPPLANE3!==ne&&(_.CLIPPLANE3=ne,E=!0),_.CLIPPLANE4!==xe&&(_.CLIPPLANE4=xe,E=!0),_.CLIPPLANE5!==ce&&(_.CLIPPLANE5=ce,E=!0),_.CLIPPLANE6!==Te&&(_.CLIPPLANE6=Te,E=!0),E}function ug(_e,p,_){let E=p.clipPlane??_.clipPlane;Uu(_e,"vClipPlane",E),E=p.clipPlane2??_.clipPlane2,Uu(_e,"vClipPlane2",E),E=p.clipPlane3??_.clipPlane3,Uu(_e,"vClipPlane3",E),E=p.clipPlane4??_.clipPlane4,Uu(_e,"vClipPlane4",E),E=p.clipPlane5??_.clipPlane5,Uu(_e,"vClipPlane5",E),E=p.clipPlane6??_.clipPlane6,Uu(_e,"vClipPlane6",E)}function Uu(_e,p,_){_&&_e.setFloat4(p,_.normal.x,_.normal.y,_.normal.z,_.d)}class nr{static BindSceneUniformBuffer(p,_){_.bindToEffect(p,"Scene")}static PrepareDefinesForMergedUV(p,_,E){_._needUVs=!0,_[E]=!0,p.optimizeUVAllocation&&p.getTextureMatrix().isIdentityAs3x2()?(_[E+"DIRECTUV"]=p.coordinatesIndex+1,_["MAINUV"+(p.coordinatesIndex+1)]=!0):_[E+"DIRECTUV"]=0}static BindTextureMatrix(p,_,E){const A=p.getTextureMatrix();_.updateMatrix(E+"Matrix",A)}static GetFogState(p,_){return _.fogEnabled&&p.applyFog&&_.fogMode!==W0.FOGMODE_NONE}static PrepareDefinesForMisc(p,_,E,A,$,ne,xe,ce=!1){xe._areMiscDirty&&(xe.LOGARITHMICDEPTH=E,xe.POINTSIZE=A,xe.FOG=$&&this.GetFogState(p,_),xe.NONUNIFORMSCALING=p.nonUniformScaling,xe.ALPHATEST=ne,xe.DECAL_AFTER_DETAIL=ce)}static PrepareDefinesForCamera(p,_){let E=!1;if(p.activeCamera){const A=_.CAMERA_ORTHOGRAPHIC?1:0,$=_.CAMERA_PERSPECTIVE?1:0,ne=p.activeCamera.mode===Hr.ORTHOGRAPHIC_CAMERA?1:0,xe=p.activeCamera.mode===Hr.PERSPECTIVE_CAMERA?1:0;(A^ne||$^xe)&&(_.CAMERA_ORTHOGRAPHIC=ne===1,_.CAMERA_PERSPECTIVE=xe===1,E=!0)}return E}static PrepareDefinesForFrameBoundValues(p,_,E,A,$,ne=null,xe=!1){let ce=nr.PrepareDefinesForCamera(p,A);ne!==!1&&(ce=Rw(E,p,A)),A.DEPTHPREPASS!==!_.getColorWrite()&&(A.DEPTHPREPASS=!A.DEPTHPREPASS,ce=!0),A.INSTANCES!==$&&(A.INSTANCES=$,ce=!0),A.THIN_INSTANCES!==xe&&(A.THIN_INSTANCES=xe,ce=!0),ce&&A.markAsUnprocessed()}static PrepareDefinesForBones(p,_){if(p.useBones&&p.computeBonesUsingShaders&&p.skeleton){_.NUM_BONE_INFLUENCERS=p.numBoneInfluencers;const E=_.BONETEXTURE!==void 0;if(p.skeleton.isUsingTextureForMatrices&&E)_.BONETEXTURE=!0;else{_.BonesPerMesh=p.skeleton.bones.length+1,_.BONETEXTURE=E?!1:void 0;const A=p.getScene().prePassRenderer;if(A&&A.enabled){const $=A.excludedSkinnedMesh.indexOf(p)===-1;_.BONES_VELOCITY_ENABLED=$}}}else _.NUM_BONE_INFLUENCERS=0,_.BonesPerMesh=0,_.BONETEXTURE!==void 0&&(_.BONETEXTURE=!1)}static PrepareDefinesForMorphTargets(p,_){const E=p.morphTargetManager;E?(_.MORPHTARGETS_UV=E.supportsUVs&&_.UV1,_.MORPHTARGETS_TANGENT=E.supportsTangents&&_.TANGENT,_.MORPHTARGETS_NORMAL=E.supportsNormals&&_.NORMAL,_.NUM_MORPH_INFLUENCERS=E.numMaxInfluencers||E.numInfluencers,_.MORPHTARGETS=_.NUM_MORPH_INFLUENCERS>0,_.MORPHTARGETS_TEXTURE=E.isUsingTextureForTargets):(_.MORPHTARGETS_UV=!1,_.MORPHTARGETS_TANGENT=!1,_.MORPHTARGETS_NORMAL=!1,_.MORPHTARGETS=!1,_.NUM_MORPH_INFLUENCERS=0)}static PrepareDefinesForBakedVertexAnimation(p,_){const E=p.bakedVertexAnimationManager;_.BAKED_VERTEX_ANIMATION_TEXTURE=!!(E&&E.isEnabled)}static PrepareDefinesForAttributes(p,_,E,A,$=!1,ne=!0,xe=!0){if(!_._areAttributesDirty&&_._needNormals===_._normals&&_._needUVs===_._uvs)return!1;_._normals=_._needNormals,_._uvs=_._needUVs,_.NORMAL=_._needNormals&&p.isVerticesDataPresent(ut.NormalKind),_._needNormals&&p.isVerticesDataPresent(ut.TangentKind)&&(_.TANGENT=!0);for(let ce=1;ce<=6;++ce)_["UV"+ce]=_._needUVs?p.isVerticesDataPresent(`uv${ce===1?"":ce}`):!1;if(E){const ce=p.useVertexColors&&p.isVerticesDataPresent(ut.ColorKind);_.VERTEXCOLOR=ce,_.VERTEXALPHA=p.hasVertexAlpha&&ce&&ne}return p.isVerticesDataPresent(ut.ColorInstanceKind)&&(p.hasInstances||p.hasThinInstances)&&(_.INSTANCESCOLOR=!0),A&&this.PrepareDefinesForBones(p,_),$&&this.PrepareDefinesForMorphTargets(p,_),xe&&this.PrepareDefinesForBakedVertexAnimation(p,_),!0}static PrepareDefinesForMultiview(p,_){if(p.activeCamera){const E=_.MULTIVIEW;_.MULTIVIEW=p.activeCamera.outputRenderTarget!==null&&p.activeCamera.outputRenderTarget.getViewCount()>1,_.MULTIVIEW!=E&&_.markAsUnprocessed()}}static PrepareDefinesForOIT(p,_,E){const A=_.ORDER_INDEPENDENT_TRANSPARENCY,$=_.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;_.ORDER_INDEPENDENT_TRANSPARENCY=p.useOrderIndependentTransparency&&E,_.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!p.getEngine().getCaps().textureFloatLinearFiltering,(A!==_.ORDER_INDEPENDENT_TRANSPARENCY||$!==_.ORDER_INDEPENDENT_TRANSPARENCY_16BITS)&&_.markAsUnprocessed()}static PrepareDefinesForPrePass(p,_,E){const A=_.PREPASS;if(!_._arePrePassDirty)return;const $=[{type:1,define:"PREPASS_POSITION",index:"PREPASS_POSITION_INDEX"},{type:2,define:"PREPASS_VELOCITY",index:"PREPASS_VELOCITY_INDEX"},{type:3,define:"PREPASS_REFLECTIVITY",index:"PREPASS_REFLECTIVITY_INDEX"},{type:0,define:"PREPASS_IRRADIANCE",index:"PREPASS_IRRADIANCE_INDEX"},{type:7,define:"PREPASS_ALBEDO_SQRT",index:"PREPASS_ALBEDO_SQRT_INDEX"},{type:5,define:"PREPASS_DEPTH",index:"PREPASS_DEPTH_INDEX"},{type:6,define:"PREPASS_NORMAL",index:"PREPASS_NORMAL_INDEX"}];if(p.prePassRenderer&&p.prePassRenderer.enabled&&E){_.PREPASS=!0,_.SCENE_MRT_COUNT=p.prePassRenderer.mrtCount,_.PREPASS_NORMAL_WORLDSPACE=p.prePassRenderer.generateNormalsInWorldSpace;for(let ne=0;ne<$.length;ne++){const xe=p.prePassRenderer.getIndex($[ne].type);xe!==-1?(_[$[ne].define]=!0,_[$[ne].index]=xe):_[$[ne].define]=!1}}else{_.PREPASS=!1;for(let ne=0;ne<$.length;ne++)_[$[ne].define]=!1}_.PREPASS!=A&&(_.markAsUnprocessed(),_.markAsImageProcessingDirty())}static PrepareDefinesForLight(p,_,E,A,$,ne,xe){switch(xe.needNormals=!0,$["LIGHT"+A]===void 0&&(xe.needRebuild=!0),$["LIGHT"+A]=!0,$["SPOTLIGHT"+A]=!1,$["HEMILIGHT"+A]=!1,$["POINTLIGHT"+A]=!1,$["DIRLIGHT"+A]=!1,E.prepareLightSpecificDefines($,A),$["LIGHT_FALLOFF_PHYSICAL"+A]=!1,$["LIGHT_FALLOFF_GLTF"+A]=!1,$["LIGHT_FALLOFF_STANDARD"+A]=!1,E.falloffType){case qn.FALLOFF_GLTF:$["LIGHT_FALLOFF_GLTF"+A]=!0;break;case qn.FALLOFF_PHYSICAL:$["LIGHT_FALLOFF_PHYSICAL"+A]=!0;break;case qn.FALLOFF_STANDARD:$["LIGHT_FALLOFF_STANDARD"+A]=!0;break}if(ne&&!E.specular.equalsFloats(0,0,0)&&(xe.specularEnabled=!0),$["SHADOW"+A]=!1,$["SHADOWCSM"+A]=!1,$["SHADOWCSMDEBUG"+A]=!1,$["SHADOWCSMNUM_CASCADES"+A]=!1,$["SHADOWCSMUSESHADOWMAXZ"+A]=!1,$["SHADOWCSMNOBLEND"+A]=!1,$["SHADOWCSM_RIGHTHANDED"+A]=!1,$["SHADOWPCF"+A]=!1,$["SHADOWPCSS"+A]=!1,$["SHADOWPOISSON"+A]=!1,$["SHADOWESM"+A]=!1,$["SHADOWCLOSEESM"+A]=!1,$["SHADOWCUBE"+A]=!1,$["SHADOWLOWQUALITY"+A]=!1,$["SHADOWMEDIUMQUALITY"+A]=!1,_&&_.receiveShadows&&p.shadowsEnabled&&E.shadowEnabled){const ce=E.getShadowGenerator(p.activeCamera)??E.getShadowGenerator();if(ce){const Te=ce.getShadowMap();Te&&Te.renderList&&Te.renderList.length>0&&(xe.shadowEnabled=!0,ce.prepareDefines($,A))}}E.lightmapMode!=qn.LIGHTMAP_DEFAULT?(xe.lightmapMode=!0,$["LIGHTMAPEXCLUDED"+A]=!0,$["LIGHTMAPNOSPECULAR"+A]=E.lightmapMode==qn.LIGHTMAP_SHADOWSONLY):($["LIGHTMAPEXCLUDED"+A]=!1,$["LIGHTMAPNOSPECULAR"+A]=!1)}static PrepareDefinesForLights(p,_,E,A,$=4,ne=!1){if(!E._areLightsDirty)return E._needNormals;let xe=0;const ce={needNormals:E._needNormals,needRebuild:!1,lightmapMode:!1,shadowEnabled:!1,specularEnabled:!1};if(p.lightsEnabled&&!ne){for(const Re of _.lightSources)if(this.PrepareDefinesForLight(p,_,Re,xe,E,A,ce),xe++,xe===$)break}E.SPECULARTERM=ce.specularEnabled,E.SHADOWS=ce.shadowEnabled;for(let Re=xe;Re<$;Re++)E["LIGHT"+Re]!==void 0&&(E["LIGHT"+Re]=!1,E["HEMILIGHT"+Re]=!1,E["POINTLIGHT"+Re]=!1,E["DIRLIGHT"+Re]=!1,E["SPOTLIGHT"+Re]=!1,E["SHADOW"+Re]=!1,E["SHADOWCSM"+Re]=!1,E["SHADOWCSMDEBUG"+Re]=!1,E["SHADOWCSMNUM_CASCADES"+Re]=!1,E["SHADOWCSMUSESHADOWMAXZ"+Re]=!1,E["SHADOWCSMNOBLEND"+Re]=!1,E["SHADOWCSM_RIGHTHANDED"+Re]=!1,E["SHADOWPCF"+Re]=!1,E["SHADOWPCSS"+Re]=!1,E["SHADOWPOISSON"+Re]=!1,E["SHADOWESM"+Re]=!1,E["SHADOWCLOSEESM"+Re]=!1,E["SHADOWCUBE"+Re]=!1,E["SHADOWLOWQUALITY"+Re]=!1,E["SHADOWMEDIUMQUALITY"+Re]=!1);const Te=p.getEngine().getCaps();return E.SHADOWFLOAT===void 0&&(ce.needRebuild=!0),E.SHADOWFLOAT=ce.shadowEnabled&&(Te.textureFloatRender&&Te.textureFloatLinearFiltering||Te.textureHalfFloatRender&&Te.textureHalfFloatLinearFiltering),E.LIGHTMAPEXCLUDED=ce.lightmapMode,ce.needRebuild&&E.rebuild(),ce.needNormals}static PrepareUniformsAndSamplersForLight(p,_,E,A,$=null,ne=!1){$&&$.push("Light"+p),!ne&&(_.push("vLightData"+p,"vLightDiffuse"+p,"vLightSpecular"+p,"vLightDirection"+p,"vLightFalloff"+p,"vLightGround"+p,"lightMatrix"+p,"shadowsInfo"+p,"depthValues"+p),E.push("shadowSampler"+p),E.push("depthSampler"+p),_.push("viewFrustumZ"+p,"cascadeBlendFactor"+p,"lightSizeUVCorrection"+p,"depthCorrection"+p,"penumbraDarkness"+p,"frustumLengths"+p),A&&(E.push("projectionLightSampler"+p),_.push("textureProjectionMatrix"+p)))}static PrepareUniformsAndSamplersList(p,_,E,A=4){let $,ne=null;if(p.uniformsNames){const xe=p;$=xe.uniformsNames,ne=xe.uniformBuffersNames,_=xe.samplers,E=xe.defines,A=xe.maxSimultaneousLights||0}else $=p,_||(_=[]);for(let xe=0;xe<A&&E["LIGHT"+xe];xe++)this.PrepareUniformsAndSamplersForLight(xe,$,_,E["PROJECTEDLIGHTTEXTURE"+xe],ne);E.NUM_MORPH_INFLUENCERS&&($.push("morphTargetInfluences"),$.push("morphTargetCount")),E.BAKED_VERTEX_ANIMATION_TEXTURE&&($.push("bakedVertexAnimationSettings"),$.push("bakedVertexAnimationTextureSizeInverted"),$.push("bakedVertexAnimationTime"),_.push("bakedVertexAnimationTexture"))}static HandleFallbacksForShadows(p,_,E=4,A=0){let $=0;for(let ne=0;ne<E&&p["LIGHT"+ne];ne++)ne>0&&($=A+ne,_.addFallback($,"LIGHT"+ne)),p.SHADOWS||(p["SHADOW"+ne]&&_.addFallback(A,"SHADOW"+ne),p["SHADOWPCF"+ne]&&_.addFallback(A,"SHADOWPCF"+ne),p["SHADOWPCSS"+ne]&&_.addFallback(A,"SHADOWPCSS"+ne),p["SHADOWPOISSON"+ne]&&_.addFallback(A,"SHADOWPOISSON"+ne),p["SHADOWESM"+ne]&&_.addFallback(A,"SHADOWESM"+ne),p["SHADOWCLOSEESM"+ne]&&_.addFallback(A,"SHADOWCLOSEESM"+ne));return $++}static PrepareAttributesForMorphTargetsInfluencers(p,_,E){this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS=E,this.PrepareAttributesForMorphTargets(p,_,this._TmpMorphInfluencers)}static PrepareAttributesForMorphTargets(p,_,E){const A=E.NUM_MORPH_INFLUENCERS;if(A>0&&wr.LastCreatedEngine){const $=wr.LastCreatedEngine.getCaps().maxVertexAttribs,ne=_.morphTargetManager;if(ne?.isUsingTextureForTargets)return;const xe=ne&&ne.supportsNormals&&E.NORMAL,ce=ne&&ne.supportsTangents&&E.TANGENT,Te=ne&&ne.supportsUVs&&E.UV1;for(let Re=0;Re<A;Re++)p.push(ut.PositionKind+Re),xe&&p.push(ut.NormalKind+Re),ce&&p.push(ut.TangentKind+Re),Te&&p.push(ut.UVKind+"_"+Re),p.length>$&&vi.Error("Cannot add more vertex attributes for mesh "+_.name)}}static PrepareAttributesForBakedVertexAnimation(p,_,E){E.BAKED_VERTEX_ANIMATION_TEXTURE&&E.INSTANCES&&p.push("bakedVertexAnimationSettingsInstanced")}static PrepareAttributesForBones(p,_,E,A){E.NUM_BONE_INFLUENCERS>0&&(A.addCPUSkinningFallback(0,_),p.push(ut.MatricesIndicesKind),p.push(ut.MatricesWeightsKind),E.NUM_BONE_INFLUENCERS>4&&(p.push(ut.MatricesIndicesExtraKind),p.push(ut.MatricesWeightsExtraKind)))}static PrepareAttributesForInstances(p,_){(_.INSTANCES||_.THIN_INSTANCES)&&this.PushAttributesForInstances(p,!!_.PREPASS_VELOCITY),_.INSTANCESCOLOR&&p.push(ut.ColorInstanceKind)}static PushAttributesForInstances(p,_=!1){p.push("world0"),p.push("world1"),p.push("world2"),p.push("world3"),_&&(p.push("previousWorld0"),p.push("previousWorld1"),p.push("previousWorld2"),p.push("previousWorld3"))}static BindLightProperties(p,_,E){p.transferToEffect(_,E+"")}static BindLight(p,_,E,A,$,ne=!0){p._bindLight(_,E,A,$,ne)}static BindLights(p,_,E,A,$=4){const ne=Math.min(_.lightSources.length,$);for(let xe=0;xe<ne;xe++){const ce=_.lightSources[xe];this.BindLight(ce,xe,p,E,typeof A=="boolean"?A:A.SPECULARTERM,_.receiveShadows)}}static BindFogParameters(p,_,E,A=!1){E&&p.fogEnabled&&(!_||_.applyFog)&&p.fogMode!==W0.FOGMODE_NONE&&(E.setFloat4("vFogInfos",p.fogMode,p.fogStart,p.fogEnd,p.fogDensity),A?(p.fogColor.toLinearSpaceToRef(this._TempFogColor,p.getEngine().useExactSrgbConversions),E.setColor3("vFogColor",this._TempFogColor)):E.setColor3("vFogColor",p.fogColor))}static BindBonesParameters(p,_,E){if(!(!_||!p)&&(p.computeBonesUsingShaders&&_._bonesComputationForcedToCPU&&(p.computeBonesUsingShaders=!1),p.useBones&&p.computeBonesUsingShaders&&p.skeleton)){const A=p.skeleton;if(A.isUsingTextureForMatrices&&_.getUniformIndex("boneTextureWidth")>-1){const $=A.getTransformMatrixTexture(p);_.setTexture("boneSampler",$),_.setFloat("boneTextureWidth",4*(A.bones.length+1))}else{const $=A.getTransformMatrices(p);$&&(_.setMatrices("mBones",$),E&&p.getScene().prePassRenderer&&p.getScene().prePassRenderer.getIndex(2)&&(E.previousBones[p.uniqueId]||(E.previousBones[p.uniqueId]=$.slice()),_.setMatrices("mPreviousBones",E.previousBones[p.uniqueId]),nr._CopyBonesTransformationMatrices($,E.previousBones[p.uniqueId])))}}}static _CopyBonesTransformationMatrices(p,_){return _.set(p),_}static BindMorphTargetParameters(p,_){const E=p.morphTargetManager;!p||!E||_.setFloatArray("morphTargetInfluences",E.influences)}static BindLogDepth(p,_,E){if(!p||p.LOGARITHMICDEPTH||p.indexOf&&p.indexOf("LOGARITHMICDEPTH")>=0){const A=E.activeCamera;A.mode===Hr.ORTHOGRAPHIC_CAMERA&&vi.Error("Logarithmic depth is not compatible with orthographic cameras!",20),_.setFloat("logarithmicDepthConstant",2/(Math.log(A.maxZ+1)/Math.LN2))}}}nr._TmpMorphInfluencers={NUM_MORPH_INFLUENCERS:0},nr._TempFogColor=ws.Black();class xh{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.func=519,this.funcRef=1,this.funcMask=255,this.opStencilFail=7680,this.opDepthFail=7680,this.opStencilDepthPass=7681}get func(){return this._func}set func(p){this._func=p}get funcRef(){return this._funcRef}set funcRef(p){this._funcRef=p}get funcMask(){return this._funcMask}set funcMask(p){this._funcMask=p}get opStencilFail(){return this._opStencilFail}set opStencilFail(p){this._opStencilFail=p}get opDepthFail(){return this._opDepthFail}set opDepthFail(p){this._opDepthFail=p}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(p){this._opStencilDepthPass=p}get mask(){return this._mask}set mask(p){this._mask=p}get enabled(){return this._enabled}set enabled(p){this._enabled=p}getClassName(){return"MaterialStencilState"}copyTo(p){Xr.Clone(()=>p,this)}serialize(){return Xr.Serialize(this)}parse(p,_,E){Xr.Parse(()=>this,p,_,E)}}Mt([Gt()],xh.prototype,"func",null),Mt([Gt()],xh.prototype,"funcRef",null),Mt([Gt()],xh.prototype,"funcMask",null),Mt([Gt()],xh.prototype,"opStencilFail",null),Mt([Gt()],xh.prototype,"opDepthFail",null),Mt([Gt()],xh.prototype,"opStencilDepthPass",null),Mt([Gt()],xh.prototype,"mask",null),Mt([Gt()],xh.prototype,"enabled",null);var wo;(function(_e){_e[_e.Created=1]="Created",_e[_e.Disposed=2]="Disposed",_e[_e.GetDefineNames=4]="GetDefineNames",_e[_e.PrepareUniformBuffer=8]="PrepareUniformBuffer",_e[_e.IsReadyForSubMesh=16]="IsReadyForSubMesh",_e[_e.PrepareDefines=32]="PrepareDefines",_e[_e.BindForSubMesh=64]="BindForSubMesh",_e[_e.PrepareEffect=128]="PrepareEffect",_e[_e.GetAnimatables=256]="GetAnimatables",_e[_e.GetActiveTextures=512]="GetActiveTextures",_e[_e.HasTexture=1024]="HasTexture",_e[_e.FillRenderTargetTextures=2048]="FillRenderTargetTextures",_e[_e.HasRenderTargetTextures=4096]="HasRenderTargetTextures",_e[_e.HardBindForSubMesh=8192]="HardBindForSubMesh"})(wo||(wo={}));class Xi{get canRenderToMRT(){return!1}set alpha(p){if(this._alpha===p)return;const _=this._alpha;this._alpha=p,(_===1||p===1)&&this.markAsDirty(Xi.MiscDirtyFlag+Xi.PrePassDirtyFlag)}get alpha(){return this._alpha}set backFaceCulling(p){this._backFaceCulling!==p&&(this._backFaceCulling=p,this.markAsDirty(Xi.TextureDirtyFlag))}get backFaceCulling(){return this._backFaceCulling}set cullBackFaces(p){this._cullBackFaces!==p&&(this._cullBackFaces=p,this.markAsDirty(Xi.TextureDirtyFlag))}get cullBackFaces(){return this._cullBackFaces}get blockDirtyMechanism(){return this._blockDirtyMechanism}set blockDirtyMechanism(p){this._blockDirtyMechanism!==p&&(this._blockDirtyMechanism=p,p||this.markDirty())}atomicMaterialsUpdate(p){this.blockDirtyMechanism=!0;try{p(this)}finally{this.blockDirtyMechanism=!1}}get hasRenderTargetTextures(){return this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._eventInfo.hasRenderTargetTextures}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new Mi),this._onBindObservable}set onBind(p){this._onBindObserver&&this.onBindObservable.remove(this._onBindObserver),this._onBindObserver=this.onBindObservable.add(p)}get onUnBindObservable(){return this._onUnBindObservable||(this._onUnBindObservable=new Mi),this._onUnBindObservable}get onEffectCreatedObservable(){return this._onEffectCreatedObservable||(this._onEffectCreatedObservable=new Mi),this._onEffectCreatedObservable}set alphaMode(p){this._alphaMode!==p&&(this._alphaMode=p,this.markAsDirty(Xi.TextureDirtyFlag))}get alphaMode(){return this._alphaMode}set needDepthPrePass(p){this._needDepthPrePass!==p&&(this._needDepthPrePass=p,this._needDepthPrePass&&(this.checkReadyOnEveryCall=!0))}get needDepthPrePass(){return this._needDepthPrePass}get isPrePassCapable(){return!1}set fogEnabled(p){this._fogEnabled!==p&&(this._fogEnabled=p,this.markAsDirty(Xi.MiscDirtyFlag))}get fogEnabled(){return this._fogEnabled}get wireframe(){switch(this._fillMode){case Xi.WireFrameFillMode:case Xi.LineListDrawMode:case Xi.LineLoopDrawMode:case Xi.LineStripDrawMode:return!0}return this._scene.forceWireframe}set wireframe(p){this.fillMode=p?Xi.WireFrameFillMode:Xi.TriangleFillMode}get pointsCloud(){switch(this._fillMode){case Xi.PointFillMode:case Xi.PointListDrawMode:return!0}return this._scene.forcePointsCloud}set pointsCloud(p){this.fillMode=p?Xi.PointFillMode:Xi.TriangleFillMode}get fillMode(){return this._fillMode}set fillMode(p){this._fillMode!==p&&(this._fillMode=p,this.markAsDirty(Xi.MiscDirtyFlag))}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(p){const _=this.getScene().getEngine().getCaps().fragmentDepthSupported;p&&!_&&vi.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it."),this._useLogarithmicDepth=p&&_,this._markAllSubMeshesAsMiscDirty()}_getDrawWrapper(){return this._drawWrapper}_setDrawWrapper(p){this._drawWrapper=p}constructor(p,_,E){this.shadowDepthWrapper=null,this.allowShaderHotSwapping=!0,this.metadata=null,this.reservedDataStore=null,this.checkReadyOnEveryCall=!1,this.checkReadyOnlyOnce=!1,this.state="",this._alpha=1,this._backFaceCulling=!0,this._cullBackFaces=!0,this._blockDirtyMechanism=!1,this.onCompiled=null,this.onError=null,this.getRenderTargetTextures=null,this.doNotSerialize=!1,this._storeEffectOnSubMeshes=!1,this.animations=null,this.onDisposeObservable=new Mi,this._onDisposeObserver=null,this._onUnBindObservable=null,this._onBindObserver=null,this._alphaMode=2,this._needDepthPrePass=!1,this.disableDepthWrite=!1,this.disableColorWrite=!1,this.forceDepthWrite=!1,this.depthFunction=0,this.separateCullingPass=!1,this._fogEnabled=!0,this.pointSize=1,this.zOffset=0,this.zOffsetUnits=0,this.stencil=new xh,this._useUBO=!1,this._fillMode=Xi.TriangleFillMode,this._cachedDepthWriteState=!1,this._cachedColorWriteState=!1,this._cachedDepthFunctionState=0,this._indexInSceneMaterialArray=-1,this.meshMap=null,this._parentContainer=null,this._uniformBufferLayoutBuilt=!1,this._eventInfo={},this._callbackPluginEventGeneric=()=>{},this._callbackPluginEventIsReadyForSubMesh=()=>{},this._callbackPluginEventPrepareDefines=()=>{},this._callbackPluginEventPrepareDefinesBeforeAttributes=()=>{},this._callbackPluginEventHardBindForSubMesh=()=>{},this._callbackPluginEventBindForSubMesh=()=>{},this._callbackPluginEventHasRenderTargetTextures=()=>{},this._callbackPluginEventFillRenderTargetTextures=()=>{},this._forceAlphaTest=!1,this._transparencyMode=null,this.name=p;const A=_||wr.LastCreatedScene;A&&(this._scene=A,this._dirtyCallbacks={},this._dirtyCallbacks[1]=this._markAllSubMeshesAsTexturesDirty.bind(this),this._dirtyCallbacks[2]=this._markAllSubMeshesAsLightsDirty.bind(this),this._dirtyCallbacks[4]=this._markAllSubMeshesAsFresnelDirty.bind(this),this._dirtyCallbacks[8]=this._markAllSubMeshesAsAttributesDirty.bind(this),this._dirtyCallbacks[16]=this._markAllSubMeshesAsMiscDirty.bind(this),this._dirtyCallbacks[32]=this._markAllSubMeshesAsPrePassDirty.bind(this),this._dirtyCallbacks[63]=this._markAllSubMeshesAsAllDirty.bind(this),this.id=p||ct.RandomId(),this.uniqueId=this._scene.getUniqueId(),this._materialContext=this._scene.getEngine().createMaterialContext(),this._drawWrapper=new nx(this._scene.getEngine(),!1),this._drawWrapper.materialContext=this._materialContext,this._scene.useRightHandedSystem?this.sideOrientation=Xi.ClockWiseSideOrientation:this.sideOrientation=Xi.CounterClockWiseSideOrientation,this._uniformBuffer=new $s(this._scene.getEngine(),void 0,void 0,p),this._useUBO=this.getScene().getEngine().supportsUniformBuffers,E||this._scene.addMaterial(this),this._scene.useMaterialMeshMap&&(this.meshMap={}),Xi.OnEventObservable.notifyObservers(this,wo.Created))}toString(p){return"Name: "+this.name}getClassName(){return"Material"}get _isMaterial(){return!0}get isFrozen(){return this.checkReadyOnlyOnce}freeze(){this.markDirty(),this.checkReadyOnlyOnce=!0}unfreeze(){this.markDirty(),this.checkReadyOnlyOnce=!1}isReady(p,_){return!0}isReadyForSubMesh(p,_,E){const A=_.materialDefines;return A?(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=A,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),this._eventInfo.isReadyForSubMesh):!1}getEffect(){return this._drawWrapper.effect}getScene(){return this._scene}get transparencyMode(){return this._transparencyMode}set transparencyMode(p){this._transparencyMode!==p&&(this._transparencyMode=p,this._forceAlphaTest=p===Xi.MATERIAL_ALPHATESTANDBLEND,this._markAllSubMeshesAsTexturesAndMiscDirty())}get _disableAlphaBlending(){return this._transparencyMode===Xi.MATERIAL_OPAQUE||this._transparencyMode===Xi.MATERIAL_ALPHATEST}needAlphaBlending(){return this._disableAlphaBlending?!1:this.alpha<1}needAlphaBlendingForMesh(p){return p.visibility<1?!0:this._disableAlphaBlending?!1:p.hasVertexAlpha||this.needAlphaBlending()}needAlphaTesting(){return!!this._forceAlphaTest}_shouldTurnAlphaTestOn(p){return!this.needAlphaBlendingForMesh(p)&&this.needAlphaTesting()}getAlphaTestTexture(){return null}markDirty(p=!1){const _=this.getScene().meshes;for(const E of _)if(E.subMeshes){for(const A of E.subMeshes)if(A.getMaterial()===this)for(const $ of A._drawWrappers)$&&this._materialContext===$.materialContext&&($._wasPreviouslyReady=!1,$._wasPreviouslyUsingInstances=null,$._forceRebindOnNextCall=p)}p&&this.markAsDirty(Xi.AllDirtyFlag)}_preBind(p,_=null){const E=this._scene.getEngine(),$=(_??this.sideOrientation)===Xi.ClockWiseSideOrientation;return E.enableEffect(p||this._getDrawWrapper()),E.setState(this.backFaceCulling,this.zOffset,!1,$,this._scene._mirroredCameraPosition?!this.cullBackFaces:this.cullBackFaces,this.stencil,this.zOffsetUnits),$}bind(p,_){}buildUniformLayout(){const p=this._uniformBuffer;this._eventInfo.ubo=p,this._callbackPluginEventGeneric(wo.PrepareUniformBuffer,this._eventInfo),p.create(),this._uniformBufferLayoutBuilt=!0}bindForSubMesh(p,_,E){const A=E._drawWrapper;this._eventInfo.subMesh=E,this._callbackPluginEventBindForSubMesh(this._eventInfo),A._forceRebindOnNextCall=!1}bindOnlyWorldMatrix(p){}bindView(p){this._useUBO?this._needToBindSceneUbo=!0:p.setMatrix("view",this.getScene().getViewMatrix())}bindViewProjection(p){this._useUBO?this._needToBindSceneUbo=!0:(p.setMatrix("viewProjection",this.getScene().getTransformMatrix()),p.setMatrix("projection",this.getScene().getProjectionMatrix()))}bindEyePosition(p,_){this._useUBO?this._needToBindSceneUbo=!0:this._scene.bindEyePosition(p,_)}_afterBind(p,_=null,E){if(this._scene._cachedMaterial=this,this._needToBindSceneUbo&&_&&(this._needToBindSceneUbo=!1,nr.BindSceneUniformBuffer(_,this.getScene().getSceneUniformBuffer()),this._scene.finalizeSceneUbo()),p?this._scene._cachedVisibility=p.visibility:this._scene._cachedVisibility=1,this._onBindObservable&&p&&this._onBindObservable.notifyObservers(p),this.disableDepthWrite){const A=this._scene.getEngine();this._cachedDepthWriteState=A.getDepthWrite(),A.setDepthWrite(!1)}if(this.disableColorWrite){const A=this._scene.getEngine();this._cachedColorWriteState=A.getColorWrite(),A.setColorWrite(!1)}if(this.depthFunction!==0){const A=this._scene.getEngine();this._cachedDepthFunctionState=A.getDepthFunction()||0,A.setDepthFunction(this.depthFunction)}}unbind(){this._onUnBindObservable&&this._onUnBindObservable.notifyObservers(this),this.depthFunction!==0&&this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState),this.disableDepthWrite&&this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState),this.disableColorWrite&&this._scene.getEngine().setColorWrite(this._cachedColorWriteState)}getAnimatables(){return this._eventInfo.animatables=[],this._callbackPluginEventGeneric(wo.GetAnimatables,this._eventInfo),this._eventInfo.animatables}getActiveTextures(){return this._eventInfo.activeTextures=[],this._callbackPluginEventGeneric(wo.GetActiveTextures,this._eventInfo),this._eventInfo.activeTextures}hasTexture(p){return this._eventInfo.hasTexture=!1,this._eventInfo.texture=p,this._callbackPluginEventGeneric(wo.HasTexture,this._eventInfo),this._eventInfo.hasTexture}clone(p){return null}_clonePlugins(p,_){const E={};if(this._serializePlugins(E),Xi._ParsePlugins(E,p,this._scene,_),this.pluginManager)for(const A of this.pluginManager._plugins){const $=p.pluginManager.getPlugin(A.name);$&&A.copyTo($)}}getBindedMeshes(){if(this.meshMap){const p=[];for(const _ in this.meshMap){const E=this.meshMap[_];E&&p.push(E)}return p}else return this._scene.meshes.filter(_=>_.material===this)}forceCompilation(p,_,E,A){const $={clipPlane:!1,useInstances:!1,...E},ne=this.getScene(),xe=this.allowShaderHotSwapping;this.allowShaderHotSwapping=!1;const ce=()=>{if(!this._scene||!this._scene.getEngine())return;const Te=ne.clipPlane;if($.clipPlane&&(ne.clipPlane=new hl(0,0,0,1)),this._storeEffectOnSubMeshes){let Re=!0,ke=null;if(p.subMeshes){const We=new _l(0,0,0,0,0,p,void 0,!1,!1);We.materialDefines&&(We.materialDefines._renderId=-1),this.isReadyForSubMesh(p,We,$.useInstances)||(We.effect&&We.effect.getCompilationError()&&We.effect.allFallbacksProcessed()?ke=We.effect.getCompilationError():(Re=!1,setTimeout(ce,16)))}Re&&(this.allowShaderHotSwapping=xe,ke&&A&&A(ke),_&&_(this))}else this.isReady()?(this.allowShaderHotSwapping=xe,_&&_(this)):setTimeout(ce,16);$.clipPlane&&(ne.clipPlane=Te)};ce()}forceCompilationAsync(p,_){return new Promise((E,A)=>{this.forceCompilation(p,()=>{E()},_,$=>{A($)})})}markAsDirty(p){this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism||(Xi._DirtyCallbackArray.length=0,p&Xi.TextureDirtyFlag&&Xi._DirtyCallbackArray.push(Xi._TextureDirtyCallBack),p&Xi.LightDirtyFlag&&Xi._DirtyCallbackArray.push(Xi._LightsDirtyCallBack),p&Xi.FresnelDirtyFlag&&Xi._DirtyCallbackArray.push(Xi._FresnelDirtyCallBack),p&Xi.AttributesDirtyFlag&&Xi._DirtyCallbackArray.push(Xi._AttributeDirtyCallBack),p&Xi.MiscDirtyFlag&&Xi._DirtyCallbackArray.push(Xi._MiscDirtyCallBack),p&Xi.PrePassDirtyFlag&&Xi._DirtyCallbackArray.push(Xi._PrePassDirtyCallBack),Xi._DirtyCallbackArray.length&&this._markAllSubMeshesAsDirty(Xi._RunDirtyCallBacks),this.getScene().resetCachedMaterial())}resetDrawCache(){const p=this.getScene().meshes;for(const _ of p)if(_.subMeshes)for(const E of _.subMeshes)E.getMaterial()===this&&E.resetDrawCache()}_markAllSubMeshesAsDirty(p){if(this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const _=this.getScene().meshes;for(const E of _)if(E.subMeshes){for(const A of E.subMeshes)if(A.getMaterial(!1)===this)for(const $ of A._drawWrappers)!$||!$.defines||!$.defines.markAllAsDirty||this._materialContext===$.materialContext&&p($.defines)}}_markScenePrePassDirty(){if(this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const p=this.getScene().enablePrePassRenderer();p&&p.markAsDirty()}_markAllSubMeshesAsAllDirty(){this._markAllSubMeshesAsDirty(Xi._AllDirtyCallBack)}_markAllSubMeshesAsImageProcessingDirty(){this._markAllSubMeshesAsDirty(Xi._ImageProcessingDirtyCallBack)}_markAllSubMeshesAsTexturesDirty(){this._markAllSubMeshesAsDirty(Xi._TextureDirtyCallBack)}_markAllSubMeshesAsFresnelDirty(){this._markAllSubMeshesAsDirty(Xi._FresnelDirtyCallBack)}_markAllSubMeshesAsFresnelAndMiscDirty(){this._markAllSubMeshesAsDirty(Xi._FresnelAndMiscDirtyCallBack)}_markAllSubMeshesAsLightsDirty(){this._markAllSubMeshesAsDirty(Xi._LightsDirtyCallBack)}_markAllSubMeshesAsAttributesDirty(){this._markAllSubMeshesAsDirty(Xi._AttributeDirtyCallBack)}_markAllSubMeshesAsMiscDirty(){this._markAllSubMeshesAsDirty(Xi._MiscDirtyCallBack)}_markAllSubMeshesAsPrePassDirty(){this._markAllSubMeshesAsDirty(Xi._MiscDirtyCallBack)}_markAllSubMeshesAsTexturesAndMiscDirty(){this._markAllSubMeshesAsDirty(Xi._TextureAndMiscDirtyCallBack)}_checkScenePerformancePriority(){if(this._scene.performancePriority!==R2.BackwardCompatible){this.checkReadyOnlyOnce=!0;const p=this._scene.onScenePerformancePriorityChangedObservable.addOnce(()=>{this.checkReadyOnlyOnce=!1});this.onDisposeObservable.add(()=>{this._scene.onScenePerformancePriorityChangedObservable.remove(p)})}}setPrePassRenderer(p){return!1}dispose(p,_,E){const A=this.getScene();if(A.stopAnimation(this),A.freeProcessedMaterials(),A.removeMaterial(this),this._eventInfo.forceDisposeTextures=_,this._callbackPluginEventGeneric(wo.Disposed,this._eventInfo),this._parentContainer){const $=this._parentContainer.materials.indexOf(this);$>-1&&this._parentContainer.materials.splice($,1),this._parentContainer=null}if(E!==!0)if(this.meshMap)for(const $ in this.meshMap){const ne=this.meshMap[$];ne&&(ne.material=null,this.releaseVertexArrayObject(ne,p))}else{const $=A.meshes;for(const ne of $)ne.material===this&&!ne.sourceMesh&&(ne.material=null,this.releaseVertexArrayObject(ne,p))}this._uniformBuffer.dispose(),p&&this._drawWrapper.effect&&(this._storeEffectOnSubMeshes||this._drawWrapper.effect.dispose(),this._drawWrapper.effect=null),this.metadata=null,this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this._onBindObservable&&this._onBindObservable.clear(),this._onUnBindObservable&&this._onUnBindObservable.clear(),this._onEffectCreatedObservable&&this._onEffectCreatedObservable.clear(),this._eventInfo&&(this._eventInfo={})}releaseVertexArrayObject(p,_){const E=p.geometry;if(E)if(this._storeEffectOnSubMeshes){if(p.subMeshes)for(const A of p.subMeshes)E._releaseVertexArrayObject(A.effect),_&&A.effect&&A.effect.dispose()}else E._releaseVertexArrayObject(this._drawWrapper.effect)}serialize(){const p=Xr.Serialize(this);return p.stencil=this.stencil.serialize(),p.uniqueId=this.uniqueId,this._serializePlugins(p),p}_serializePlugins(p){if(p.plugins={},this.pluginManager)for(const _ of this.pluginManager._plugins)p.plugins[_.getClassName()]=_.serialize()}static Parse(p,_,E){if(!p.customType)p.customType="BABYLON.StandardMaterial";else if(p.customType==="BABYLON.PBRMaterial"&&p.overloadedAlbedo&&(p.customType="BABYLON.LegacyPBRMaterial",!BABYLON.LegacyPBRMaterial))return vi.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."),null;const $=ct.Instantiate(p.customType).Parse(p,_,E);return $._loadedUniqueId=p.uniqueId,$}static _ParsePlugins(p,_,E,A){if(p.plugins)for(const $ in p.plugins){const ne=p.plugins[$];let xe=_.pluginManager?.getPlugin(ne.name);if(!xe){const ce=ct.Instantiate("BABYLON."+$);ce&&(xe=new ce(_))}xe?.parse(ne,E,A)}}}Xi.TriangleFillMode=0,Xi.WireFrameFillMode=1,Xi.PointFillMode=2,Xi.PointListDrawMode=3,Xi.LineListDrawMode=4,Xi.LineLoopDrawMode=5,Xi.LineStripDrawMode=6,Xi.TriangleStripDrawMode=7,Xi.TriangleFanDrawMode=8,Xi.ClockWiseSideOrientation=0,Xi.CounterClockWiseSideOrientation=1,Xi.TextureDirtyFlag=1,Xi.LightDirtyFlag=2,Xi.FresnelDirtyFlag=4,Xi.AttributesDirtyFlag=8,Xi.MiscDirtyFlag=16,Xi.PrePassDirtyFlag=32,Xi.AllDirtyFlag=63,Xi.MATERIAL_OPAQUE=0,Xi.MATERIAL_ALPHATEST=1,Xi.MATERIAL_ALPHABLEND=2,Xi.MATERIAL_ALPHATESTANDBLEND=3,Xi.MATERIAL_NORMALBLENDMETHOD_WHITEOUT=0,Xi.MATERIAL_NORMALBLENDMETHOD_RNM=1,Xi.OnEventObservable=new Mi,Xi._AllDirtyCallBack=_e=>_e.markAllAsDirty(),Xi._ImageProcessingDirtyCallBack=_e=>_e.markAsImageProcessingDirty(),Xi._TextureDirtyCallBack=_e=>_e.markAsTexturesDirty(),Xi._FresnelDirtyCallBack=_e=>_e.markAsFresnelDirty(),Xi._MiscDirtyCallBack=_e=>_e.markAsMiscDirty(),Xi._PrePassDirtyCallBack=_e=>_e.markAsPrePassDirty(),Xi._LightsDirtyCallBack=_e=>_e.markAsLightDirty(),Xi._AttributeDirtyCallBack=_e=>_e.markAsAttributesDirty(),Xi._FresnelAndMiscDirtyCallBack=_e=>{Xi._FresnelDirtyCallBack(_e),Xi._MiscDirtyCallBack(_e)},Xi._TextureAndMiscDirtyCallBack=_e=>{Xi._TextureDirtyCallBack(_e),Xi._MiscDirtyCallBack(_e)},Xi._DirtyCallbackArray=[],Xi._RunDirtyCallBacks=_e=>{for(const p of Xi._DirtyCallbackArray)p(_e)},Mt([Gt()],Xi.prototype,"id",void 0),Mt([Gt()],Xi.prototype,"uniqueId",void 0),Mt([Gt()],Xi.prototype,"name",void 0),Mt([Gt()],Xi.prototype,"metadata",void 0),Mt([Gt()],Xi.prototype,"checkReadyOnEveryCall",void 0),Mt([Gt()],Xi.prototype,"checkReadyOnlyOnce",void 0),Mt([Gt()],Xi.prototype,"state",void 0),Mt([Gt("alpha")],Xi.prototype,"_alpha",void 0),Mt([Gt("backFaceCulling")],Xi.prototype,"_backFaceCulling",void 0),Mt([Gt("cullBackFaces")],Xi.prototype,"_cullBackFaces",void 0),Mt([Gt()],Xi.prototype,"sideOrientation",void 0),Mt([Gt("alphaMode")],Xi.prototype,"_alphaMode",void 0),Mt([Gt()],Xi.prototype,"_needDepthPrePass",void 0),Mt([Gt()],Xi.prototype,"disableDepthWrite",void 0),Mt([Gt()],Xi.prototype,"disableColorWrite",void 0),Mt([Gt()],Xi.prototype,"forceDepthWrite",void 0),Mt([Gt()],Xi.prototype,"depthFunction",void 0),Mt([Gt()],Xi.prototype,"separateCullingPass",void 0),Mt([Gt("fogEnabled")],Xi.prototype,"_fogEnabled",void 0),Mt([Gt()],Xi.prototype,"pointSize",void 0),Mt([Gt()],Xi.prototype,"zOffset",void 0),Mt([Gt()],Xi.prototype,"zOffsetUnits",void 0),Mt([Gt()],Xi.prototype,"pointsCloud",null),Mt([Gt()],Xi.prototype,"fillMode",null),Mt([Gt()],Xi.prototype,"useLogarithmicDepth",null),Mt([Gt()],Xi.prototype,"transparencyMode",null);class Yx{constructor(p,_){this.width=p,this.height=_}toString(){return`{W: ${this.width}, H: ${this.height}}`}getClassName(){return"Size"}getHashCode(){let p=this.width|0;return p=p*397^(this.height|0),p}copyFrom(p){this.width=p.width,this.height=p.height}copyFromFloats(p,_){return this.width=p,this.height=_,this}set(p,_){return this.copyFromFloats(p,_)}multiplyByFloats(p,_){return new Yx(this.width*p,this.height*_)}clone(){return new Yx(this.width,this.height)}equals(p){return p?this.width===p.width&&this.height===p.height:!1}get surface(){return this.width*this.height}static Zero(){return new Yx(0,0)}add(p){return new Yx(this.width+p.width,this.height+p.height)}subtract(p){return new Yx(this.width-p.width,this.height-p.height)}scale(p){return new Yx(this.width*p,this.height*p)}static Lerp(p,_,E){const A=p.width+(_.width-p.width)*E,$=p.height+(_.height-p.height)*E;return new Yx(A,$)}}class h_{get wrapU(){return this._wrapU}set wrapU(p){this._wrapU=p}get wrapV(){return this._wrapV}set wrapV(p){this._wrapV=p}get coordinatesMode(){return 0}get isCube(){return this._texture?this._texture.isCube:!1}set isCube(p){this._texture&&(this._texture.isCube=p)}get is3D(){return this._texture?this._texture.is3D:!1}set is3D(p){this._texture&&(this._texture.is3D=p)}get is2DArray(){return this._texture?this._texture.is2DArray:!1}set is2DArray(p){this._texture&&(this._texture.is2DArray=p)}getClassName(){return"ThinTexture"}static _IsRenderTargetWrapper(p){return p?._shareDepth!==void 0}constructor(p){this._wrapU=1,this._wrapV=1,this.wrapR=1,this.anisotropicFilteringLevel=4,this.delayLoadState=0,this._texture=null,this._engine=null,this._cachedSize=Yx.Zero(),this._cachedBaseSize=Yx.Zero(),this._initialSamplingMode=2,this._texture=h_._IsRenderTargetWrapper(p)?p.texture:p,this._texture&&(this._engine=this._texture.getEngine())}isReady(){return this.delayLoadState===4?(this.delayLoad(),!1):this._texture?this._texture.isReady:!1}delayLoad(){}getInternalTexture(){return this._texture}getSize(){if(this._texture){if(this._texture.width)return this._cachedSize.width=this._texture.width,this._cachedSize.height=this._texture.height,this._cachedSize;if(this._texture._size)return this._cachedSize.width=this._texture._size,this._cachedSize.height=this._texture._size,this._cachedSize}return this._cachedSize}getBaseSize(){return!this.isReady()||!this._texture?(this._cachedBaseSize.width=0,this._cachedBaseSize.height=0,this._cachedBaseSize):this._texture._size?(this._cachedBaseSize.width=this._texture._size,this._cachedBaseSize.height=this._texture._size,this._cachedBaseSize):(this._cachedBaseSize.width=this._texture.baseWidth,this._cachedBaseSize.height=this._texture.baseHeight,this._cachedBaseSize)}get samplingMode(){return this._texture?this._texture.samplingMode:this._initialSamplingMode}updateSamplingMode(p){this._texture&&this._engine&&this._engine.updateTextureSamplingMode(p,this._texture)}releaseInternalTexture(){this._texture&&(this._texture.dispose(),this._texture=null)}dispose(){this._texture&&(this.releaseInternalTexture(),this._engine=null)}}class la extends h_{set hasAlpha(p){this._hasAlpha!==p&&(this._hasAlpha=p,this._scene&&this._scene.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get hasAlpha(){return this._hasAlpha}set getAlphaFromRGB(p){this._getAlphaFromRGB!==p&&(this._getAlphaFromRGB=p,this._scene&&this._scene.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get getAlphaFromRGB(){return this._getAlphaFromRGB}set coordinatesIndex(p){this._coordinatesIndex!==p&&(this._coordinatesIndex=p,this._scene&&this._scene.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get coordinatesIndex(){return this._coordinatesIndex}set coordinatesMode(p){this._coordinatesMode!==p&&(this._coordinatesMode=p,this._scene&&this._scene.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get coordinatesMode(){return this._coordinatesMode}get wrapU(){return this._wrapU}set wrapU(p){this._wrapU=p}get wrapV(){return this._wrapV}set wrapV(p){this._wrapV=p}get isCube(){return this._texture?this._texture.isCube:this._isCube}set isCube(p){this._texture?this._texture.isCube=p:this._isCube=p}get is3D(){return this._texture?this._texture.is3D:!1}set is3D(p){this._texture&&(this._texture.is3D=p)}get is2DArray(){return this._texture?this._texture.is2DArray:!1}set is2DArray(p){this._texture&&(this._texture.is2DArray=p)}get gammaSpace(){if(this._texture)this._texture._gammaSpace===null&&(this._texture._gammaSpace=this._gammaSpace);else return this._gammaSpace;return this._texture._gammaSpace&&!this._texture._useSRGBBuffer}set gammaSpace(p){if(this._texture){if(this._texture._gammaSpace===p)return;this._texture._gammaSpace=p}else{if(this._gammaSpace===p)return;this._gammaSpace=p}this.getScene()?.markAllMaterialsAsDirty(1,_=>_.hasTexture(this))}get isRGBD(){return this._texture!=null&&this._texture._isRGBD}set isRGBD(p){p!==this.isRGBD&&(this._texture&&(this._texture._isRGBD=p),this.getScene()?.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get noMipmap(){return!1}get lodGenerationOffset(){return this._texture?this._texture._lodGenerationOffset:0}set lodGenerationOffset(p){this._texture&&(this._texture._lodGenerationOffset=p)}get lodGenerationScale(){return this._texture?this._texture._lodGenerationScale:0}set lodGenerationScale(p){this._texture&&(this._texture._lodGenerationScale=p)}get linearSpecularLOD(){return this._texture?this._texture._linearSpecularLOD:!1}set linearSpecularLOD(p){this._texture&&(this._texture._linearSpecularLOD=p)}get irradianceTexture(){return this._texture?this._texture._irradianceTexture:null}set irradianceTexture(p){this._texture&&(this._texture._irradianceTexture=p)}get uid(){return this._uid||(this._uid=q0()),this._uid}toString(){return this.name}getClassName(){return"BaseTexture"}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}get isBlocking(){return!0}get loadingError(){return this._loadingError}get errorObject(){return this._errorObject}constructor(p,_=null){super(null),this.metadata=null,this.reservedDataStore=null,this._hasAlpha=!1,this._getAlphaFromRGB=!1,this.level=1,this._coordinatesIndex=0,this.optimizeUVAllocation=!0,this._coordinatesMode=0,this.wrapR=1,this.anisotropicFilteringLevel=la.DEFAULT_ANISOTROPIC_FILTERING_LEVEL,this._isCube=!1,this._gammaSpace=!0,this.invertZ=!1,this.lodLevelInAlpha=!1,this.isRenderTarget=!1,this._prefiltered=!1,this._forceSerialize=!1,this.animations=[],this.onDisposeObservable=new Mi,this._onDisposeObserver=null,this._scene=null,this._uid=null,this._parentContainer=null,this._loadingError=!1,p?la._IsScene(p)?this._scene=p:this._engine=p:this._scene=wr.LastCreatedScene,this._scene&&(this.uniqueId=this._scene.getUniqueId(),this._scene.addTexture(this),this._engine=this._scene.getEngine()),this._texture=_,this._uid=null}getScene(){return this._scene}_getEngine(){return this._engine}checkTransformsAreIdentical(p){return p!==null}getTextureMatrix(){return Yt.IdentityReadOnly}getReflectionTextureMatrix(){return Yt.IdentityReadOnly}getRefractionTextureMatrix(){return this.getReflectionTextureMatrix()}isReadyOrNotBlocking(){return!this.isBlocking||this.isReady()||this.loadingError}scale(p){}get canRescale(){return!1}_getFromCache(p,_,E,A,$,ne){const xe=this._getEngine();if(!xe)return null;const ce=xe._getUseSRGBBuffer(!!$,_),Te=xe.getLoadedTexturesCache();for(let Re=0;Re<Te.length;Re++){const ke=Te[Re];if(($===void 0||ce===ke._useSRGBBuffer)&&(A===void 0||A===ke.invertY)&&ke.url===p&&ke.generateMipMaps===!_&&(!E||E===ke.samplingMode)&&(ne===void 0||ne===ke.isCube))return ke.incrementReferences(),ke}return null}_rebuild(p=!1){}clone(){return null}get textureType(){return this._texture&&this._texture.type!==void 0?this._texture.type:0}get textureFormat(){return this._texture&&this._texture.format!==void 0?this._texture.format:5}_markAllSubMeshesAsTexturesDirty(){const p=this.getScene();p&&p.markAllMaterialsAsDirty(1)}readPixels(p=0,_=0,E=null,A=!0,$=!1,ne=0,xe=0,ce=Number.MAX_VALUE,Te=Number.MAX_VALUE){if(!this._texture)return null;const Re=this._getEngine();if(!Re)return null;const ke=this.getSize();let We=ke.width,Xe=ke.height;_!==0&&(We=We/Math.pow(2,_),Xe=Xe/Math.pow(2,_),We=Math.round(We),Xe=Math.round(Xe)),ce=Math.min(We,ce),Te=Math.min(Xe,Te);try{return this._texture.isCube?Re._readTexturePixels(this._texture,ce,Te,p,_,E,A,$,ne,xe):Re._readTexturePixels(this._texture,ce,Te,-1,_,E,A,$,ne,xe)}catch{return null}}_readPixelsSync(p=0,_=0,E=null,A=!0,$=!1){if(!this._texture)return null;const ne=this.getSize();let xe=ne.width,ce=ne.height;const Te=this._getEngine();if(!Te)return null;_!=0&&(xe=xe/Math.pow(2,_),ce=ce/Math.pow(2,_),xe=Math.round(xe),ce=Math.round(ce));try{return this._texture.isCube?Te._readTexturePixelsSync(this._texture,xe,ce,p,_,E,A,$):Te._readTexturePixelsSync(this._texture,xe,ce,-1,_,E,A,$)}catch{return null}}get _lodTextureHigh(){return this._texture?this._texture._lodTextureHigh:null}get _lodTextureMid(){return this._texture?this._texture._lodTextureMid:null}get _lodTextureLow(){return this._texture?this._texture._lodTextureLow:null}dispose(){if(this._scene){this._scene.stopAnimation&&this._scene.stopAnimation(this),this._scene.removePendingData(this);const p=this._scene.textures.indexOf(this);if(p>=0&&this._scene.textures.splice(p,1),this._scene.onTextureRemovedObservable.notifyObservers(this),this._scene=null,this._parentContainer){const _=this._parentContainer.textures.indexOf(this);_>-1&&this._parentContainer.textures.splice(_,1),this._parentContainer=null}}this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.metadata=null,super.dispose()}serialize(p=!1){if(!this.name&&!p)return null;const _=Xr.Serialize(this);return Xr.AppendSerializedAnimations(this,_),_}static WhenAllReady(p,_){let E=p.length;if(E===0){_();return}for(let A=0;A<p.length;A++){const $=p[A];if($.isReady())--E===0&&_();else{const ne=$.onLoadObservable;ne?ne.addOnce(()=>{--E===0&&_()}):--E===0&&_()}}}static _IsScene(p){return p.getClassName()==="Scene"}}la.DEFAULT_ANISOTROPIC_FILTERING_LEVEL=4,Mt([Gt()],la.prototype,"uniqueId",void 0),Mt([Gt()],la.prototype,"name",void 0),Mt([Gt()],la.prototype,"metadata",void 0),Mt([Gt("hasAlpha")],la.prototype,"_hasAlpha",void 0),Mt([Gt("getAlphaFromRGB")],la.prototype,"_getAlphaFromRGB",void 0),Mt([Gt()],la.prototype,"level",void 0),Mt([Gt("coordinatesIndex")],la.prototype,"_coordinatesIndex",void 0),Mt([Gt()],la.prototype,"optimizeUVAllocation",void 0),Mt([Gt("coordinatesMode")],la.prototype,"_coordinatesMode",void 0),Mt([Gt()],la.prototype,"wrapU",null),Mt([Gt()],la.prototype,"wrapV",null),Mt([Gt()],la.prototype,"wrapR",void 0),Mt([Gt()],la.prototype,"anisotropicFilteringLevel",void 0),Mt([Gt()],la.prototype,"isCube",null),Mt([Gt()],la.prototype,"is3D",null),Mt([Gt()],la.prototype,"is2DArray",null),Mt([Gt()],la.prototype,"gammaSpace",null),Mt([Gt()],la.prototype,"invertZ",void 0),Mt([Gt()],la.prototype,"lodLevelInAlpha",void 0),Mt([Gt()],la.prototype,"lodGenerationOffset",null),Mt([Gt()],la.prototype,"lodGenerationScale",null),Mt([Gt()],la.prototype,"linearSpecularLOD",null),Mt([Kn()],la.prototype,"irradianceTexture",null),Mt([Gt()],la.prototype,"isRenderTarget",void 0);function c_(_e,p,_=!1){const E=p.width,A=p.height;if(_e instanceof Float32Array){let Te=_e.byteLength/_e.BYTES_PER_ELEMENT;const Re=new Uint8Array(Te);for(;--Te>=0;){let ke=_e[Te];ke<0?ke=0:ke>1&&(ke=1),Re[Te]=ke*255}_e=Re}const $=document.createElement("canvas");$.width=E,$.height=A;const ne=$.getContext("2d");if(!ne)return null;const xe=ne.createImageData(E,A);if(xe.data.set(_e),ne.putImageData(xe,0,0),_){const Te=document.createElement("canvas");Te.width=E,Te.height=A;const Re=Te.getContext("2d");return Re?(Re.translate(0,A),Re.scale(1,-1),Re.drawImage($,0,0),Te.toDataURL("image/png")):null}return $.toDataURL("image/png")}function Yb(_e,p=0,_=0){const E=_e.getInternalTexture();if(!E)return null;const A=_e._readPixelsSync(p,_);return A?c_(A,_e.getSize(),E.invertY):null}async function jb(_e,p=0,_=0){const E=_e.getInternalTexture();if(!E)return null;const A=await _e.readPixels(p,_);return A?c_(A,_e.getSize(),E.invertY):null}const Tk={GenerateBase64StringFromPixelData:c_,GenerateBase64StringFromTexture:Yb,GenerateBase64StringFromTextureAsync:jb};class lh{}lh.UseOpenGLOrientationForUV=!1;class Hi extends la{static _CreateVideoTexture(p,_,E,A=!1,$=!1,ne=Hi.TRILINEAR_SAMPLINGMODE,xe={},ce,Te=5){throw Tr("VideoTexture")}get noMipmap(){return this._noMipmap}get mimeType(){return this._mimeType}set isBlocking(p){this._isBlocking=p}get isBlocking(){return this._isBlocking}get invertY(){return this._invertY}constructor(p,_,E,A,$=Hi.TRILINEAR_SAMPLINGMODE,ne=null,xe=null,ce=null,Te=!1,Re,ke,We,Xe,xt){super(_),this.url=null,this.uOffset=0,this.vOffset=0,this.uScale=1,this.vScale=1,this.uAng=0,this.vAng=0,this.wAng=0,this.uRotationCenter=.5,this.vRotationCenter=.5,this.wRotationCenter=.5,this.homogeneousRotationInUVTransform=!1,this.inspectableCustomProperties=null,this._noMipmap=!1,this._invertY=!1,this._rowGenerationMatrix=null,this._cachedTextureMatrix=null,this._projectionModeMatrix=null,this._t0=null,this._t1=null,this._t2=null,this._cachedUOffset=-1,this._cachedVOffset=-1,this._cachedUScale=0,this._cachedVScale=0,this._cachedUAng=-1,this._cachedVAng=-1,this._cachedWAng=-1,this._cachedReflectionProjectionMatrixId=-1,this._cachedURotationCenter=-1,this._cachedVRotationCenter=-1,this._cachedWRotationCenter=-1,this._cachedHomogeneousRotationInUVTransform=!1,this._cachedReflectionTextureMatrix=null,this._cachedReflectionUOffset=-1,this._cachedReflectionVOffset=-1,this._cachedReflectionUScale=0,this._cachedReflectionVScale=0,this._cachedReflectionCoordinatesMode=-1,this._buffer=null,this._deleteBuffer=!1,this._format=null,this._delayedOnLoad=null,this._delayedOnError=null,this.onLoadObservable=new Mi,this._isBlocking=!0,this.name=p||"",this.url=p;let qe,ht=!1,Nt=null,wt=!0;typeof E=="object"&&E!==null?(qe=E.noMipmap??!1,A=E.invertY??!lh.UseOpenGLOrientationForUV,$=E.samplingMode??Hi.TRILINEAR_SAMPLINGMODE,ne=E.onLoad??null,xe=E.onError??null,ce=E.buffer??null,Te=E.deleteBuffer??!1,Re=E.format,ke=E.mimeType,We=E.loaderOptions,Xe=E.creationFlags,ht=E.useSRGBBuffer??!1,Nt=E.internalTexture??null,wt=E.gammaSpace??wt):qe=!!E,this._gammaSpace=wt,this._noMipmap=qe,this._invertY=A===void 0?!lh.UseOpenGLOrientationForUV:A,this._initialSamplingMode=$,this._buffer=ce,this._deleteBuffer=Te,this._mimeType=ke,this._loaderOptions=We,this._creationFlags=Xe,this._useSRGBBuffer=ht,this._forcedExtension=xt,Re&&(this._format=Re);const Qt=this.getScene(),Ht=this._getEngine();if(!Ht)return;Ht.onBeforeTextureInitObservable.notifyObservers(this);const Wt=()=>{this._texture&&(this._texture._invertVScale&&(this.vScale*=-1,this.vOffset+=1),this._texture._cachedWrapU!==null&&(this.wrapU=this._texture._cachedWrapU,this._texture._cachedWrapU=null),this._texture._cachedWrapV!==null&&(this.wrapV=this._texture._cachedWrapV,this._texture._cachedWrapV=null),this._texture._cachedWrapR!==null&&(this.wrapR=this._texture._cachedWrapR,this._texture._cachedWrapR=null)),this.onLoadObservable.hasObservers()&&this.onLoadObservable.notifyObservers(this),ne&&ne(),!this.isBlocking&&Qt&&Qt.resetCachedMaterial()},zt=(xi,wi)=>{this._loadingError=!0,this._errorObject={message:xi,exception:wi},xe&&xe(xi,wi),Hi.OnTextureLoadErrorObservable.notifyObservers(this)};if(!this.url&&!Nt){this._delayedOnLoad=Wt,this._delayedOnError=zt;return}if(this._texture=Nt??this._getFromCache(this.url,qe,$,this._invertY,ht,this.isCube),this._texture)if(this._texture.isReady)_2.SetImmediate(()=>Wt());else{const xi=this._texture.onLoadedObservable.add(Wt);this._texture.onErrorObservable.add(wi=>{zt(wi.message,wi.exception),this._texture?.onLoadedObservable.remove(xi)})}else if(!Qt||!Qt.useDelayedTextureLoading){try{this._texture=Ht.createTexture(this.url,qe,this._invertY,Qt,$,Wt,zt,this._buffer,void 0,this._format,this._forcedExtension,ke,We,Xe,ht)}catch(xi){throw zt("error loading",xi),xi}Te&&(this._buffer=null)}else this.delayLoadState=4,this._delayedOnLoad=Wt,this._delayedOnError=zt}updateURL(p,_=null,E,A){this.url&&(this.releaseInternalTexture(),this.getScene().markAllMaterialsAsDirty(1,$=>$.hasTexture(this))),(!this.name||this.name.startsWith("data:"))&&(this.name=p),this.url=p,this._buffer=_,this._forcedExtension=A,this.delayLoadState=4,E&&(this._delayedOnLoad=E),this.delayLoad()}delayLoad(){if(this.delayLoadState!==4)return;const p=this.getScene();p&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap,this.samplingMode,this._invertY,this._useSRGBBuffer,this.isCube),this._texture?this._delayedOnLoad&&(this._texture.isReady?_2.SetImmediate(this._delayedOnLoad):this._texture.onLoadedObservable.add(this._delayedOnLoad)):(this._texture=p.getEngine().createTexture(this.url,this._noMipmap,this._invertY,p,this.samplingMode,this._delayedOnLoad,this._delayedOnError,this._buffer,null,this._format,this._forcedExtension,this._mimeType,this._loaderOptions,this._creationFlags,this._useSRGBBuffer),this._deleteBuffer&&(this._buffer=null)),this._delayedOnLoad=null,this._delayedOnError=null)}_prepareRowForTextureGeneration(p,_,E,A){p*=this._cachedUScale,_*=this._cachedVScale,p-=this.uRotationCenter*this._cachedUScale,_-=this.vRotationCenter*this._cachedVScale,E-=this.wRotationCenter,nt.TransformCoordinatesFromFloatsToRef(p,_,E,this._rowGenerationMatrix,A),A.x+=this.uRotationCenter*this._cachedUScale+this._cachedUOffset,A.y+=this.vRotationCenter*this._cachedVScale+this._cachedVOffset,A.z+=this.wRotationCenter}checkTransformsAreIdentical(p){return p!==null&&this.uOffset===p.uOffset&&this.vOffset===p.vOffset&&this.uScale===p.uScale&&this.vScale===p.vScale&&this.uAng===p.uAng&&this.vAng===p.vAng&&this.wAng===p.wAng}getTextureMatrix(p=1){if(this.uOffset===this._cachedUOffset&&this.vOffset===this._cachedVOffset&&this.uScale*p===this._cachedUScale&&this.vScale===this._cachedVScale&&this.uAng===this._cachedUAng&&this.vAng===this._cachedVAng&&this.wAng===this._cachedWAng&&this.uRotationCenter===this._cachedURotationCenter&&this.vRotationCenter===this._cachedVRotationCenter&&this.wRotationCenter===this._cachedWRotationCenter&&this.homogeneousRotationInUVTransform===this._cachedHomogeneousRotationInUVTransform)return this._cachedTextureMatrix;this._cachedUOffset=this.uOffset,this._cachedVOffset=this.vOffset,this._cachedUScale=this.uScale*p,this._cachedVScale=this.vScale,this._cachedUAng=this.uAng,this._cachedVAng=this.vAng,this._cachedWAng=this.wAng,this._cachedURotationCenter=this.uRotationCenter,this._cachedVRotationCenter=this.vRotationCenter,this._cachedWRotationCenter=this.wRotationCenter,this._cachedHomogeneousRotationInUVTransform=this.homogeneousRotationInUVTransform,(!this._cachedTextureMatrix||!this._rowGenerationMatrix)&&(this._cachedTextureMatrix=Yt.Zero(),this._rowGenerationMatrix=new Yt,this._t0=nt.Zero(),this._t1=nt.Zero(),this._t2=nt.Zero()),Yt.RotationYawPitchRollToRef(this.vAng,this.uAng,this.wAng,this._rowGenerationMatrix),this.homogeneousRotationInUVTransform?(Yt.TranslationToRef(-this._cachedURotationCenter,-this._cachedVRotationCenter,-this._cachedWRotationCenter,pi.Matrix[0]),Yt.TranslationToRef(this._cachedURotationCenter,this._cachedVRotationCenter,this._cachedWRotationCenter,pi.Matrix[1]),Yt.ScalingToRef(this._cachedUScale,this._cachedVScale,0,pi.Matrix[2]),Yt.TranslationToRef(this._cachedUOffset,this._cachedVOffset,0,pi.Matrix[3]),pi.Matrix[0].multiplyToRef(this._rowGenerationMatrix,this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(pi.Matrix[1],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(pi.Matrix[2],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(pi.Matrix[3],this._cachedTextureMatrix),this._cachedTextureMatrix.setRowFromFloats(2,this._cachedTextureMatrix.m[12],this._cachedTextureMatrix.m[13],this._cachedTextureMatrix.m[14],1)):(this._prepareRowForTextureGeneration(0,0,0,this._t0),this._prepareRowForTextureGeneration(1,0,0,this._t1),this._prepareRowForTextureGeneration(0,1,0,this._t2),this._t1.subtractInPlace(this._t0),this._t2.subtractInPlace(this._t0),Yt.FromValuesToRef(this._t1.x,this._t1.y,this._t1.z,0,this._t2.x,this._t2.y,this._t2.z,0,this._t0.x,this._t0.y,this._t0.z,0,0,0,0,1,this._cachedTextureMatrix));const _=this.getScene();return _?(this.optimizeUVAllocation&&_.markAllMaterialsAsDirty(1,E=>E.hasTexture(this)),this._cachedTextureMatrix):this._cachedTextureMatrix}getReflectionTextureMatrix(){const p=this.getScene();if(!p)return this._cachedReflectionTextureMatrix;if(this.uOffset===this._cachedReflectionUOffset&&this.vOffset===this._cachedReflectionVOffset&&this.uScale===this._cachedReflectionUScale&&this.vScale===this._cachedReflectionVScale&&this.coordinatesMode===this._cachedReflectionCoordinatesMode)if(this.coordinatesMode===Hi.PROJECTION_MODE){if(this._cachedReflectionProjectionMatrixId===p.getProjectionMatrix().updateFlag)return this._cachedReflectionTextureMatrix}else return this._cachedReflectionTextureMatrix;this._cachedReflectionTextureMatrix||(this._cachedReflectionTextureMatrix=Yt.Zero()),this._projectionModeMatrix||(this._projectionModeMatrix=Yt.Zero());const _=this._cachedReflectionCoordinatesMode!==this.coordinatesMode;switch(this._cachedReflectionUOffset=this.uOffset,this._cachedReflectionVOffset=this.vOffset,this._cachedReflectionUScale=this.uScale,this._cachedReflectionVScale=this.vScale,this._cachedReflectionCoordinatesMode=this.coordinatesMode,this.coordinatesMode){case Hi.PLANAR_MODE:{Yt.IdentityToRef(this._cachedReflectionTextureMatrix),this._cachedReflectionTextureMatrix[0]=this.uScale,this._cachedReflectionTextureMatrix[5]=this.vScale,this._cachedReflectionTextureMatrix[12]=this.uOffset,this._cachedReflectionTextureMatrix[13]=this.vOffset;break}case Hi.PROJECTION_MODE:{Yt.FromValuesToRef(.5,0,0,0,0,-.5,0,0,0,0,0,0,.5,.5,1,1,this._projectionModeMatrix);const E=p.getProjectionMatrix();this._cachedReflectionProjectionMatrixId=E.updateFlag,E.multiplyToRef(this._projectionModeMatrix,this._cachedReflectionTextureMatrix);break}default:Yt.IdentityToRef(this._cachedReflectionTextureMatrix);break}return _&&p.markAllMaterialsAsDirty(1,E=>E.hasTexture(this)),this._cachedReflectionTextureMatrix}clone(){const p={noMipmap:this._noMipmap,invertY:this._invertY,samplingMode:this.samplingMode,onLoad:void 0,onError:void 0,buffer:this._texture?this._texture._buffer:void 0,deleteBuffer:this._deleteBuffer,format:this.textureFormat,mimeType:this.mimeType,loaderOptions:this._loaderOptions,creationFlags:this._creationFlags,useSRGBBuffer:this._useSRGBBuffer};return Xr.Clone(()=>new Hi(this._texture?this._texture.url:null,this.getScene(),p),this)}serialize(){const p=this.name;Hi.SerializeBuffers||this.name.startsWith("data:")&&(this.name=""),this.name.startsWith("data:")&&this.url===this.name&&(this.url="");const _=super.serialize(Hi._SerializeInternalTextureUniqueId);return _?((Hi.SerializeBuffers||Hi.ForceSerializeBuffers)&&(typeof this._buffer=="string"&&this._buffer.substr(0,5)==="data:"?(_.base64String=this._buffer,_.name=_.name.replace("data:","")):this.url&&this.url.startsWith("data:")&&this._buffer instanceof Uint8Array?_.base64String="data:image/png;base64,"+c2(this._buffer):(Hi.ForceSerializeBuffers||this.url&&this.url.startsWith("blob:")||this._forceSerialize)&&(_.base64String=!this._engine||this._engine._features.supportSyncTextureRead?Yb(this):jb(this))),_.invertY=this._invertY,_.samplingMode=this.samplingMode,_._creationFlags=this._creationFlags,_._useSRGBBuffer=this._useSRGBBuffer,Hi._SerializeInternalTextureUniqueId&&(_.internalTextureUniqueId=this._texture?.uniqueId??void 0),_.noMipmap=this._noMipmap,this.name=p,_):null}getClassName(){return"Texture"}dispose(){super.dispose(),this.onLoadObservable.clear(),this._delayedOnLoad=null,this._delayedOnError=null,this._buffer=null}static Parse(p,_,E){if(p.customType){const Te=z0.Instantiate(p.customType).Parse(p,_,E);return p.samplingMode&&Te.updateSamplingMode&&Te._samplingMode&&Te._samplingMode!==p.samplingMode&&Te.updateSamplingMode(p.samplingMode),Te}if(p.isCube&&!p.isRenderTarget)return Hi._CubeTextureParser(p,_,E);const A=p.internalTextureUniqueId!==void 0;if(!p.name&&!p.isRenderTarget&&!A)return null;let $;if(A){const ce=_.getEngine().getLoadedTexturesCache();for(const Te of ce)if(Te.uniqueId===p.internalTextureUniqueId){$=Te;break}}const ne=ce=>{if(ce&&ce._texture&&(ce._texture._cachedWrapU=null,ce._texture._cachedWrapV=null,ce._texture._cachedWrapR=null),p.samplingMode){const Te=p.samplingMode;ce&&ce.samplingMode!==Te&&ce.updateSamplingMode(Te)}if(ce&&p.animations)for(let Te=0;Te<p.animations.length;Te++){const Re=p.animations[Te],ke=a0("BABYLON.Animation");ke&&ce.animations.push(ke.Parse(Re))}A&&!$&&ce?._texture?._setUniqueId(p.internalTextureUniqueId)};return Xr.Parse(()=>{let ce=!0;if(p.noMipmap&&(ce=!1),p.mirrorPlane){const Te=Hi._CreateMirror(p.name,p.renderTargetSize,_,ce);return Te._waitingRenderList=p.renderList,Te.mirrorPlane=hl.FromArray(p.mirrorPlane),ne(Te),Te}else if(p.isRenderTarget){let Te=null;if(p.isCube){if(_.reflectionProbes)for(let Re=0;Re<_.reflectionProbes.length;Re++){const ke=_.reflectionProbes[Re];if(ke.name===p.name)return ke.cubeTexture}}else Te=Hi._CreateRenderTargetTexture(p.name,p.renderTargetSize,_,ce,p._creationFlags??0),Te._waitingRenderList=p.renderList;return ne(Te),Te}else if(p.isVideo){const Te=Hi._CreateVideoTexture(E+(p.url||p.name),E+(p.src||p.url),_,ce,p.invertY,p.samplingMode,p.settings||{});return ne(Te),Te}else{let Te;if(p.base64String&&!$)Te=Hi.CreateFromBase64String(p.base64String,p.base64String,_,!ce,p.invertY,p.samplingMode,()=>{ne(Te)},p._creationFlags??0,p._useSRGBBuffer??!1),Te.name=p.name;else{let Re;p.name&&(p.name.indexOf("://")>0||p.name.startsWith("data:"))?Re=p.name:Re=E+p.name,p.url&&(p.url.startsWith("data:")||Hi.UseSerializedUrlIfAny)&&(Re=p.url);const ke={noMipmap:!ce,invertY:p.invertY,samplingMode:p.samplingMode,onLoad:()=>{ne(Te)},internalTexture:$};Te=new Hi(Re,_,ke)}return Te}},p,_)}static CreateFromBase64String(p,_,E,A,$,ne=Hi.TRILINEAR_SAMPLINGMODE,xe=null,ce=null,Te=5,Re){return new Hi("data:"+_,E,A,$,ne,xe,ce,p,!1,Te,void 0,void 0,Re)}static LoadFromDataString(p,_,E,A=!1,$,ne=!0,xe=Hi.TRILINEAR_SAMPLINGMODE,ce=null,Te=null,Re=5,ke){return p.substr(0,5)!=="data:"&&(p="data:"+p),new Hi(p,E,$,ne,xe,ce,Te,_,A,Re,void 0,void 0,ke)}}Hi.SerializeBuffers=!0,Hi.ForceSerializeBuffers=!1,Hi.OnTextureLoadErrorObservable=new Mi,Hi._SerializeInternalTextureUniqueId=!1,Hi._CubeTextureParser=(_e,p,_)=>{throw Tr("CubeTexture")},Hi._CreateMirror=(_e,p,_,E)=>{throw Tr("MirrorTexture")},Hi._CreateRenderTargetTexture=(_e,p,_,E,A)=>{throw Tr("RenderTargetTexture")},Hi.NEAREST_SAMPLINGMODE=1,Hi.NEAREST_NEAREST_MIPLINEAR=8,Hi.BILINEAR_SAMPLINGMODE=2,Hi.LINEAR_LINEAR_MIPNEAREST=11,Hi.TRILINEAR_SAMPLINGMODE=3,Hi.LINEAR_LINEAR_MIPLINEAR=3,Hi.NEAREST_NEAREST_MIPNEAREST=4,Hi.NEAREST_LINEAR_MIPNEAREST=5,Hi.NEAREST_LINEAR_MIPLINEAR=6,Hi.NEAREST_LINEAR=7,Hi.NEAREST_NEAREST=1,Hi.LINEAR_NEAREST_MIPNEAREST=9,Hi.LINEAR_NEAREST_MIPLINEAR=10,Hi.LINEAR_LINEAR=2,Hi.LINEAR_NEAREST=12,Hi.EXPLICIT_MODE=0,Hi.SPHERICAL_MODE=1,Hi.PLANAR_MODE=2,Hi.CUBIC_MODE=3,Hi.PROJECTION_MODE=4,Hi.SKYBOX_MODE=5,Hi.INVCUBIC_MODE=6,Hi.EQUIRECTANGULAR_MODE=7,Hi.FIXED_EQUIRECTANGULAR_MODE=8,Hi.FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,Hi.CLAMP_ADDRESSMODE=0,Hi.WRAP_ADDRESSMODE=1,Hi.MIRROR_ADDRESSMODE=2,Hi.UseSerializedUrlIfAny=!1,Mt([Gt()],Hi.prototype,"url",void 0),Mt([Gt()],Hi.prototype,"uOffset",void 0),Mt([Gt()],Hi.prototype,"vOffset",void 0),Mt([Gt()],Hi.prototype,"uScale",void 0),Mt([Gt()],Hi.prototype,"vScale",void 0),Mt([Gt()],Hi.prototype,"uAng",void 0),Mt([Gt()],Hi.prototype,"vAng",void 0),Mt([Gt()],Hi.prototype,"wAng",void 0),Mt([Gt()],Hi.prototype,"uRotationCenter",void 0),Mt([Gt()],Hi.prototype,"vRotationCenter",void 0),Mt([Gt()],Hi.prototype,"wRotationCenter",void 0),Mt([Gt()],Hi.prototype,"homogeneousRotationInUVTransform",void 0),Mt([Gt()],Hi.prototype,"isBlocking",null),zs("BABYLON.Texture",Hi),Xr._TextureParser=Hi.Parse;class Mw{constructor(p){this.name=_r.NAME_LAYER,this.scene=p||wr.LastCreatedScene,this.scene&&(this._engine=this.scene.getEngine(),this.scene.layers=[])}register(){this.scene._beforeCameraDrawStage.registerStep(_r.STEP_BEFORECAMERADRAW_LAYER,this,this._drawCameraBackground),this.scene._afterCameraDrawStage.registerStep(_r.STEP_AFTERCAMERADRAW_LAYER,this,this._drawCameraForegroundWithPostProcessing),this.scene._afterCameraPostProcessStage.registerStep(_r.STEP_AFTERCAMERAPOSTPROCESS_LAYER,this,this._drawCameraForegroundWithoutPostProcessing),this.scene._beforeRenderTargetDrawStage.registerStep(_r.STEP_BEFORERENDERTARGETDRAW_LAYER,this,this._drawRenderTargetBackground),this.scene._afterRenderTargetDrawStage.registerStep(_r.STEP_AFTERRENDERTARGETDRAW_LAYER,this,this._drawRenderTargetForegroundWithPostProcessing),this.scene._afterRenderTargetPostProcessStage.registerStep(_r.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER,this,this._drawRenderTargetForegroundWithoutPostProcessing)}rebuild(){const p=this.scene.layers;for(const _ of p)_._rebuild()}dispose(){const p=this.scene.layers;for(;p.length;)p[0].dispose()}_draw(p){const _=this.scene.layers;if(_.length){this._engine.setDepthBuffer(!1);for(const E of _)p(E)&&E.render();this._engine.setDepthBuffer(!0)}}_drawCameraPredicate(p,_,E,A){return!p.renderOnlyInRenderTargetTextures&&p.isBackground===_&&p.applyPostProcess===E&&(p.layerMask&A)!==0}_drawCameraBackground(p){this._draw(_=>this._drawCameraPredicate(_,!0,!0,p.layerMask))}_drawCameraForegroundWithPostProcessing(p){this._draw(_=>this._drawCameraPredicate(_,!1,!0,p.layerMask))}_drawCameraForegroundWithoutPostProcessing(p){this._draw(_=>this._drawCameraPredicate(_,!1,!1,p.layerMask))}_drawRenderTargetPredicate(p,_,E,A,$){return p.renderTargetTextures.length>0&&p.isBackground===_&&p.applyPostProcess===E&&p.renderTargetTextures.indexOf($)>-1&&(p.layerMask&A)!==0}_drawRenderTargetBackground(p){this._draw(_=>this._drawRenderTargetPredicate(_,!0,!0,this.scene.activeCamera.layerMask,p))}_drawRenderTargetForegroundWithPostProcessing(p){this._draw(_=>this._drawRenderTargetPredicate(_,!1,!0,this.scene.activeCamera.layerMask,p))}_drawRenderTargetForegroundWithoutPostProcessing(p){this._draw(_=>this._drawRenderTargetPredicate(_,!1,!1,this.scene.activeCamera.layerMask,p))}addFromContainer(p){p.layers&&p.layers.forEach(_=>{this.scene.layers.push(_)})}removeFromContainer(p,_=!1){p.layers&&p.layers.forEach(E=>{const A=this.scene.layers.indexOf(E);A!==-1&&this.scene.layers.splice(A,1),_&&E.dispose()})}}const qb="helperFunctions",$b=`const float PI=3.1415926535897932384626433832795;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
mat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{return value*value;}
vec3 square(vec3 value)
{return value*value;}
float pow5(float value) {float sq=value*value;return sq*sq*value;}
float getLuminance(vec3 color)
{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}
float getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}
float dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}
const float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }
vec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
`;Gi.IncludesShadersStore[qb]=$b;const vk={name:qb,shader:$b},rE="layerPixelShader",nE=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec4 color;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
#ifdef LINEAR
baseColor.rgb=toGammaSpace(baseColor.rgb);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
gl_FragColor=baseColor*color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;Gi.ShadersStore[rE]=nE;const Rk={name:rE,shader:nE},aE="layerVertexShader",xE=`attribute vec2 position;uniform vec2 scale;uniform vec2 offset;uniform mat4 textureMatrix;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec2 shiftedPosition=position*scale+offset;vUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));gl_Position=vec4(shiftedPosition,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;Gi.ShadersStore[aE]=xE;const Mk={name:aE,shader:xE};class ww{set applyPostProcess(p){this._applyPostProcess=p}get applyPostProcess(){return this.isBackground||this._applyPostProcess}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}set onBeforeRender(p){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(p)}set onAfterRender(p){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(p)}constructor(p,_,E,A,$){this.name=p,this._applyPostProcess=!0,this.scale=new xr(1,1),this.offset=new xr(0,0),this.alphaBlendingMode=2,this.layerMask=268435455,this.renderTargetTextures=[],this.renderOnlyInRenderTargetTextures=!1,this.isEnabled=!0,this._vertexBuffers={},this.onDisposeObservable=new Mi,this.onBeforeRenderObservable=new Mi,this.onAfterRenderObservable=new Mi,this.texture=_?new Hi(_,E,!0):null,this.isBackground=A===void 0?!0:A,this.color=$===void 0?new vr(1,1,1,1):$,this._scene=E||wr.LastCreatedScene;let ne=this._scene._getComponent(_r.NAME_LAYER);ne||(ne=new Mw(this._scene),this._scene._addComponent(ne)),this._scene.layers.push(this);const xe=this._scene.getEngine();this._drawWrapper=new nx(xe);const ce=[];ce.push(1,1),ce.push(-1,1),ce.push(-1,-1),ce.push(1,-1);const Te=new ut(xe,ce,ut.PositionKind,!1,!1,2);this._vertexBuffers[ut.PositionKind]=Te,this._createIndexBuffer()}_createIndexBuffer(){const p=this._scene.getEngine(),_=[];_.push(0),_.push(1),_.push(2),_.push(0),_.push(2),_.push(3),this._indexBuffer=p.createIndexBuffer(_)}_rebuild(){const p=this._vertexBuffers[ut.PositionKind];p&&p._rebuild(),this._createIndexBuffer()}isReady(){const p=this._scene.getEngine();let _="";return this.alphaTest&&(_="#define ALPHATEST"),this.texture&&!this.texture.gammaSpace&&(_+=`
#define LINEAR`),this._previousDefines!==_&&(this._previousDefines=_,this._drawWrapper.effect=p.createEffect("layer",[ut.PositionKind],["textureMatrix","color","scale","offset"],["textureSampler"],_)),this._drawWrapper.effect?.isReady()&&this.texture?.isReady()}render(){if(!this.isEnabled)return;const p=this._scene.getEngine();if(!this.isReady())return;const _=this._drawWrapper.effect;this.onBeforeRenderObservable.notifyObservers(this),p.enableEffect(this._drawWrapper),p.setState(!1),_.setTexture("textureSampler",this.texture),_.setMatrix("textureMatrix",this.texture.getTextureMatrix()),_.setFloat4("color",this.color.r,this.color.g,this.color.b,this.color.a),_.setVector2("offset",this.offset),_.setVector2("scale",this.scale),p.bindBuffers(this._vertexBuffers,this._indexBuffer,_),this.alphaTest?p.drawElementsType(Xi.TriangleFillMode,0,6):(p.setAlphaMode(this.alphaBlendingMode),p.drawElementsType(Xi.TriangleFillMode,0,6),p.setAlphaMode(0)),this.onAfterRenderObservable.notifyObservers(this)}dispose(){const p=this._vertexBuffers[ut.PositionKind];p&&(p.dispose(),this._vertexBuffers[ut.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this.texture&&(this.texture.dispose(),this.texture=null),this.renderTargetTextures=[];const _=this._scene.layers.indexOf(this);this._scene.layers.splice(_,1),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onAfterRenderObservable.clear(),this.onBeforeRenderObservable.clear()}}function u_(_e,p,_){try{const E=_e.next();E.done?p(E):E.value?E.value.then(()=>{E.value=void 0,p(E)},_):p(E)}catch(E){_(E)}}function Lw(_e=25){let p;return(_,E,A)=>{const $=performance.now();p===void 0||$-p>_e?(p=$,setTimeout(()=>{u_(_,E,A)},0)):u_(_,E,A)}}function lE(_e,p,_,E,A){const $=()=>{let ne;const xe=ce=>{ce.done?_(ce.value):ne===void 0?ne=!0:$()};do ne=void 0,!A||!A.aborted?p(_e,xe,E):E(new Error("Aborted")),ne===void 0&&(ne=!1);while(ne)};$()}function d_(_e,p){let _;return lE(_e,u_,E=>_=E,E=>{throw E},p),_}function hE(_e,p,_){return new Promise((E,A)=>{lE(_e,p,E,A,_)})}function kw(_e,p){return(..._)=>d_(_e(..._),p)}function wk(_e,p,_){return(...E)=>hE(_e(...E),p,_)}class f_{}class Yr{constructor(){this.uniqueId=0,this.metadata={},this._applyTo=kw(this._applyToCoroutine.bind(this)),this.uniqueId=Yr._UniqueIDGenerator,Yr._UniqueIDGenerator++}set(p,_){switch(p.length||vi.Warn(`Setting vertex data kind '${_}' with an empty array`),_){case ut.PositionKind:this.positions=p;break;case ut.NormalKind:this.normals=p;break;case ut.TangentKind:this.tangents=p;break;case ut.UVKind:this.uvs=p;break;case ut.UV2Kind:this.uvs2=p;break;case ut.UV3Kind:this.uvs3=p;break;case ut.UV4Kind:this.uvs4=p;break;case ut.UV5Kind:this.uvs5=p;break;case ut.UV6Kind:this.uvs6=p;break;case ut.ColorKind:this.colors=p;break;case ut.MatricesIndicesKind:this.matricesIndices=p;break;case ut.MatricesWeightsKind:this.matricesWeights=p;break;case ut.MatricesIndicesExtraKind:this.matricesIndicesExtra=p;break;case ut.MatricesWeightsExtraKind:this.matricesWeightsExtra=p;break}}applyToMesh(p,_){return this._applyTo(p,_,!1),this}applyToGeometry(p,_){return this._applyTo(p,_,!1),this}updateMesh(p){return this._update(p),this}updateGeometry(p){return this._update(p),this}*_applyToCoroutine(p,_=!1,E){if(this.positions&&(p.setVerticesData(ut.PositionKind,this.positions,_),E&&(yield)),this.normals&&(p.setVerticesData(ut.NormalKind,this.normals,_),E&&(yield)),this.tangents&&(p.setVerticesData(ut.TangentKind,this.tangents,_),E&&(yield)),this.uvs&&(p.setVerticesData(ut.UVKind,this.uvs,_),E&&(yield)),this.uvs2&&(p.setVerticesData(ut.UV2Kind,this.uvs2,_),E&&(yield)),this.uvs3&&(p.setVerticesData(ut.UV3Kind,this.uvs3,_),E&&(yield)),this.uvs4&&(p.setVerticesData(ut.UV4Kind,this.uvs4,_),E&&(yield)),this.uvs5&&(p.setVerticesData(ut.UV5Kind,this.uvs5,_),E&&(yield)),this.uvs6&&(p.setVerticesData(ut.UV6Kind,this.uvs6,_),E&&(yield)),this.colors&&(p.setVerticesData(ut.ColorKind,this.colors,_),E&&(yield)),this.matricesIndices&&(p.setVerticesData(ut.MatricesIndicesKind,this.matricesIndices,_),E&&(yield)),this.matricesWeights&&(p.setVerticesData(ut.MatricesWeightsKind,this.matricesWeights,_),E&&(yield)),this.matricesIndicesExtra&&(p.setVerticesData(ut.MatricesIndicesExtraKind,this.matricesIndicesExtra,_),E&&(yield)),this.matricesWeightsExtra&&(p.setVerticesData(ut.MatricesWeightsExtraKind,this.matricesWeightsExtra,_),E&&(yield)),this.indices?(p.setIndices(this.indices,null,_),E&&(yield)):p.setIndices([],null),p.subMeshes&&this.materialInfos&&this.materialInfos.length>1){const A=p;A.subMeshes=[];for(const $ of this.materialInfos)new _l($.materialIndex,$.verticesStart,$.verticesCount,$.indexStart,$.indexCount,A)}return this}_update(p,_,E){return this.positions&&p.updateVerticesData(ut.PositionKind,this.positions,_,E),this.normals&&p.updateVerticesData(ut.NormalKind,this.normals,_,E),this.tangents&&p.updateVerticesData(ut.TangentKind,this.tangents,_,E),this.uvs&&p.updateVerticesData(ut.UVKind,this.uvs,_,E),this.uvs2&&p.updateVerticesData(ut.UV2Kind,this.uvs2,_,E),this.uvs3&&p.updateVerticesData(ut.UV3Kind,this.uvs3,_,E),this.uvs4&&p.updateVerticesData(ut.UV4Kind,this.uvs4,_,E),this.uvs5&&p.updateVerticesData(ut.UV5Kind,this.uvs5,_,E),this.uvs6&&p.updateVerticesData(ut.UV6Kind,this.uvs6,_,E),this.colors&&p.updateVerticesData(ut.ColorKind,this.colors,_,E),this.matricesIndices&&p.updateVerticesData(ut.MatricesIndicesKind,this.matricesIndices,_,E),this.matricesWeights&&p.updateVerticesData(ut.MatricesWeightsKind,this.matricesWeights,_,E),this.matricesIndicesExtra&&p.updateVerticesData(ut.MatricesIndicesExtraKind,this.matricesIndicesExtra,_,E),this.matricesWeightsExtra&&p.updateVerticesData(ut.MatricesWeightsExtraKind,this.matricesWeightsExtra,_,E),this.indices&&p.setIndices(this.indices,null),this}static _TransformVector3Coordinates(p,_,E=0,A=p.length){const $=pi.Vector3[0],ne=pi.Vector3[1];for(let xe=E;xe<E+A;xe+=3)nt.FromArrayToRef(p,xe,$),nt.TransformCoordinatesToRef($,_,ne),p[xe]=ne.x,p[xe+1]=ne.y,p[xe+2]=ne.z}static _TransformVector3Normals(p,_,E=0,A=p.length){const $=pi.Vector3[0],ne=pi.Vector3[1];for(let xe=E;xe<E+A;xe+=3)nt.FromArrayToRef(p,xe,$),nt.TransformNormalToRef($,_,ne),p[xe]=ne.x,p[xe+1]=ne.y,p[xe+2]=ne.z}static _TransformVector4Normals(p,_,E=0,A=p.length){const $=pi.Vector4[0],ne=pi.Vector4[1];for(let xe=E;xe<E+A;xe+=4)Gr.FromArrayToRef(p,xe,$),Gr.TransformNormalToRef($,_,ne),p[xe]=ne.x,p[xe+1]=ne.y,p[xe+2]=ne.z,p[xe+3]=ne.w}static _FlipFaces(p,_=0,E=p.length){for(let A=_;A<_+E;A+=3){const $=p[A+1];p[A+1]=p[A+2],p[A+2]=$}}transform(p){const _=p.determinant()<0;return this.positions&&Yr._TransformVector3Coordinates(this.positions,p),this.normals&&Yr._TransformVector3Normals(this.normals,p),this.tangents&&Yr._TransformVector4Normals(this.tangents,p),_&&this.indices&&Yr._FlipFaces(this.indices),this}splitBasedOnMaterialID(){if(!this.materialInfos||this.materialInfos.length<2)return[this];const p=[];for(const _ of this.materialInfos){const E=new Yr;if(this.positions&&(E.positions=this.positions.slice(_.verticesStart*3,(_.verticesCount+_.verticesStart)*3)),this.normals&&(E.normals=this.normals.slice(_.verticesStart*3,(_.verticesCount+_.verticesStart)*3)),this.tangents&&(E.tangents=this.tangents.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.colors&&(E.colors=this.colors.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.uvs&&(E.uvs=this.uvs.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs2&&(E.uvs2=this.uvs2.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs3&&(E.uvs3=this.uvs3.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs4&&(E.uvs4=this.uvs4.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs5&&(E.uvs5=this.uvs5.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs6&&(E.uvs6=this.uvs6.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.matricesIndices&&(E.matricesIndices=this.matricesIndices.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.matricesIndicesExtra&&(E.matricesIndicesExtra=this.matricesIndicesExtra.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.matricesWeights&&(E.matricesWeights=this.matricesWeights.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.matricesWeightsExtra&&(E.matricesWeightsExtra=this.matricesWeightsExtra.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.indices){E.indices=[];for(let $=_.indexStart;$<_.indexStart+_.indexCount;$++)E.indices.push(this.indices[$]-_.verticesStart)}const A=new f_;A.indexStart=0,A.indexCount=E.indices?E.indices.length:0,A.materialIndex=_.materialIndex,A.verticesStart=0,A.verticesCount=(E.positions?E.positions.length:0)/3,E.materialInfos=[A],p.push(E)}return p}merge(p,_=!1,E=!1,A=!1,$=!1){const ne=Array.isArray(p)?p.map(xe=>({vertexData:xe})):[{vertexData:p}];return d_(this._mergeCoroutine(void 0,ne,_,!1,E,A,$))}*_mergeCoroutine(p,_,E=!1,A,$,ne=!1,xe=!1){this._validate();let ce=_.map(Xe=>Xe.vertexData),Te=this;if(xe)for(const Xe of ce)Xe&&(Xe._validate(),!this.normals&&Xe.normals&&(this.normals=new Float32Array(this.positions.length)),!this.tangents&&Xe.tangents&&(this.tangents=new Float32Array(this.positions.length/3*4)),!this.uvs&&Xe.uvs&&(this.uvs=new Float32Array(this.positions.length/3*2)),!this.uvs2&&Xe.uvs2&&(this.uvs2=new Float32Array(this.positions.length/3*2)),!this.uvs3&&Xe.uvs3&&(this.uvs3=new Float32Array(this.positions.length/3*2)),!this.uvs4&&Xe.uvs4&&(this.uvs4=new Float32Array(this.positions.length/3*2)),!this.uvs5&&Xe.uvs5&&(this.uvs5=new Float32Array(this.positions.length/3*2)),!this.uvs6&&Xe.uvs6&&(this.uvs6=new Float32Array(this.positions.length/3*2)),!this.colors&&Xe.colors&&(this.colors=new Float32Array(this.positions.length/3*4),this.colors.fill(1)),!this.matricesIndices&&Xe.matricesIndices&&(this.matricesIndices=new Float32Array(this.positions.length/3*4)),!this.matricesWeights&&Xe.matricesWeights&&(this.matricesWeights=new Float32Array(this.positions.length/3*4)),!this.matricesIndicesExtra&&Xe.matricesIndicesExtra&&(this.matricesIndicesExtra=new Float32Array(this.positions.length/3*4)),!this.matricesWeightsExtra&&Xe.matricesWeightsExtra&&(this.matricesWeightsExtra=new Float32Array(this.positions.length/3*4)));for(const Xe of ce)if(Xe){if(xe)this.normals&&!Xe.normals&&(Xe.normals=new Float32Array(Xe.positions.length)),this.tangents&&!Xe.tangents&&(Xe.tangents=new Float32Array(Xe.positions.length/3*4)),this.uvs&&!Xe.uvs&&(Xe.uvs=new Float32Array(Xe.positions.length/3*2)),this.uvs2&&!Xe.uvs2&&(Xe.uvs2=new Float32Array(Xe.positions.length/3*2)),this.uvs3&&!Xe.uvs3&&(Xe.uvs3=new Float32Array(Xe.positions.length/3*2)),this.uvs4&&!Xe.uvs4&&(Xe.uvs4=new Float32Array(Xe.positions.length/3*2)),this.uvs5&&!Xe.uvs5&&(Xe.uvs5=new Float32Array(Xe.positions.length/3*2)),this.uvs6&&!Xe.uvs6&&(Xe.uvs6=new Float32Array(Xe.positions.length/3*2)),this.colors&&!Xe.colors&&(Xe.colors=new Float32Array(Xe.positions.length/3*4),Xe.colors.fill(1)),this.matricesIndices&&!Xe.matricesIndices&&(Xe.matricesIndices=new Float32Array(Xe.positions.length/3*4)),this.matricesWeights&&!Xe.matricesWeights&&(Xe.matricesWeights=new Float32Array(Xe.positions.length/3*4)),this.matricesIndicesExtra&&!Xe.matricesIndicesExtra&&(Xe.matricesIndicesExtra=new Float32Array(Xe.positions.length/3*4)),this.matricesWeightsExtra&&!Xe.matricesWeightsExtra&&(Xe.matricesWeightsExtra=new Float32Array(Xe.positions.length/3*4));else if(Xe._validate(),!this.normals!=!Xe.normals||!this.tangents!=!Xe.tangents||!this.uvs!=!Xe.uvs||!this.uvs2!=!Xe.uvs2||!this.uvs3!=!Xe.uvs3||!this.uvs4!=!Xe.uvs4||!this.uvs5!=!Xe.uvs5||!this.uvs6!=!Xe.uvs6||!this.colors!=!Xe.colors||!this.matricesIndices!=!Xe.matricesIndices||!this.matricesWeights!=!Xe.matricesWeights||!this.matricesIndicesExtra!=!Xe.matricesIndicesExtra||!this.matricesWeightsExtra!=!Xe.matricesWeightsExtra)throw new Error("Cannot merge vertex data that do not have the same set of attributes")}if(ne){let Xe=0,xt=0,qe=0;const ht=[];let Nt=null;const wt=[];for(const Ht of this.splitBasedOnMaterialID())wt.push({vertexData:Ht,transform:p});for(const Ht of _)if(Ht.vertexData)for(const Wt of Ht.vertexData.splitBasedOnMaterialID())wt.push({vertexData:Wt,transform:Ht.transform});wt.sort((Ht,Wt)=>{const zt=Ht.vertexData.materialInfos?Ht.vertexData.materialInfos[0].materialIndex:0,xi=Wt.vertexData.materialInfos?Wt.vertexData.materialInfos[0].materialIndex:0;return zt>xi?1:zt===xi?0:-1});for(const Ht of wt){const Wt=Ht.vertexData;if(Wt.materialInfos?Xe=Wt.materialInfos[0].materialIndex:Xe=0,Nt&&Nt.materialIndex===Xe)Nt.indexCount+=Wt.indices.length,Nt.verticesCount+=Wt.positions.length/3;else{const zt=new f_;zt.materialIndex=Xe,zt.indexStart=xt,zt.indexCount=Wt.indices.length,zt.verticesStart=qe,zt.verticesCount=Wt.positions.length/3,ht.push(zt),Nt=zt}xt+=Wt.indices.length,qe+=Wt.positions.length/3}const Qt=wt.splice(0,1)[0];Te=Qt.vertexData,p=Qt.transform,ce=wt.map(Ht=>Ht.vertexData),_=wt,this.materialInfos=ht}const Re=ce.reduce((Xe,xt)=>Xe+(xt.indices?.length??0),Te.indices?.length??0);let We=$||ce.some(Xe=>Xe.indices===Te.indices)?Te.indices?.slice():Te.indices;if(Re>0){let Xe=We?.length??0;if(We||(We=new Array(Re)),We.length!==Re){if(Array.isArray(We))We.length=Re;else{const qe=E||We instanceof Uint32Array?new Uint32Array(Re):new Uint16Array(Re);qe.set(We),We=qe}p&&p.determinant()<0&&Yr._FlipFaces(We,0,Xe)}let xt=Te.positions?Te.positions.length/3:0;for(const{vertexData:qe,transform:ht}of _)if(qe.indices){for(let Nt=0;Nt<qe.indices.length;Nt++)We[Xe+Nt]=qe.indices[Nt]+xt;ht&&ht.determinant()<0&&Yr._FlipFaces(We,Xe,qe.indices.length),xt+=qe.positions.length/3,Xe+=qe.indices.length,A&&(yield)}}return this.indices=We,this.positions=Yr._MergeElement(ut.PositionKind,Te.positions,p,_.map(Xe=>[Xe.vertexData.positions,Xe.transform])),A&&(yield),Te.normals&&(this.normals=Yr._MergeElement(ut.NormalKind,Te.normals,p,_.map(Xe=>[Xe.vertexData.normals,Xe.transform])),A&&(yield)),Te.tangents&&(this.tangents=Yr._MergeElement(ut.TangentKind,Te.tangents,p,_.map(Xe=>[Xe.vertexData.tangents,Xe.transform])),A&&(yield)),Te.uvs&&(this.uvs=Yr._MergeElement(ut.UVKind,Te.uvs,p,_.map(Xe=>[Xe.vertexData.uvs,Xe.transform])),A&&(yield)),Te.uvs2&&(this.uvs2=Yr._MergeElement(ut.UV2Kind,Te.uvs2,p,_.map(Xe=>[Xe.vertexData.uvs2,Xe.transform])),A&&(yield)),Te.uvs3&&(this.uvs3=Yr._MergeElement(ut.UV3Kind,Te.uvs3,p,_.map(Xe=>[Xe.vertexData.uvs3,Xe.transform])),A&&(yield)),Te.uvs4&&(this.uvs4=Yr._MergeElement(ut.UV4Kind,Te.uvs4,p,_.map(Xe=>[Xe.vertexData.uvs4,Xe.transform])),A&&(yield)),Te.uvs5&&(this.uvs5=Yr._MergeElement(ut.UV5Kind,Te.uvs5,p,_.map(Xe=>[Xe.vertexData.uvs5,Xe.transform])),A&&(yield)),Te.uvs6&&(this.uvs6=Yr._MergeElement(ut.UV6Kind,Te.uvs6,p,_.map(Xe=>[Xe.vertexData.uvs6,Xe.transform])),A&&(yield)),Te.colors&&(this.colors=Yr._MergeElement(ut.ColorKind,Te.colors,p,_.map(Xe=>[Xe.vertexData.colors,Xe.transform])),A&&(yield)),Te.matricesIndices&&(this.matricesIndices=Yr._MergeElement(ut.MatricesIndicesKind,Te.matricesIndices,p,_.map(Xe=>[Xe.vertexData.matricesIndices,Xe.transform])),A&&(yield)),Te.matricesWeights&&(this.matricesWeights=Yr._MergeElement(ut.MatricesWeightsKind,Te.matricesWeights,p,_.map(Xe=>[Xe.vertexData.matricesWeights,Xe.transform])),A&&(yield)),Te.matricesIndicesExtra&&(this.matricesIndicesExtra=Yr._MergeElement(ut.MatricesIndicesExtraKind,Te.matricesIndicesExtra,p,_.map(Xe=>[Xe.vertexData.matricesIndicesExtra,Xe.transform])),A&&(yield)),Te.matricesWeightsExtra&&(this.matricesWeightsExtra=Yr._MergeElement(ut.MatricesWeightsExtraKind,Te.matricesWeightsExtra,p,_.map(Xe=>[Xe.vertexData.matricesWeightsExtra,Xe.transform]))),this}static _MergeElement(p,_,E,A){const $=A.filter(ce=>ce[0]!==null&&ce[0]!==void 0);if(!_&&$.length==0)return _;if(!_)return this._MergeElement(p,$[0][0],$[0][1],$.slice(1));const ne=$.reduce((ce,Te)=>ce+Te[0].length,_.length),xe=p===ut.PositionKind?Yr._TransformVector3Coordinates:p===ut.NormalKind?Yr._TransformVector3Normals:p===ut.TangentKind?Yr._TransformVector4Normals:()=>{};if(_ instanceof Float32Array){const ce=new Float32Array(ne);ce.set(_),E&&xe(ce,E,0,_.length);let Te=_.length;for(const[Re,ke]of $)ce.set(Re,Te),ke&&xe(ce,ke,Te,Re.length),Te+=Re.length;return ce}else{const ce=new Array(ne);for(let Re=0;Re<_.length;Re++)ce[Re]=_[Re];E&&xe(ce,E,0,_.length);let Te=_.length;for(const[Re,ke]of $){for(let We=0;We<Re.length;We++)ce[Te+We]=Re[We];ke&&xe(ce,ke,Te,Re.length),Te+=Re.length}return ce}}_validate(){if(!this.positions)throw new jo("Positions are required",Yo.MeshInvalidPositionsError);const p=(A,$)=>{const ne=ut.DeduceStride(A);if($.length%ne!==0)throw new Error("The "+A+"s array count must be a multiple of "+ne);return $.length/ne},_=p(ut.PositionKind,this.positions),E=(A,$)=>{const ne=p(A,$);if(ne!==_)throw new Error("The "+A+"s element count ("+ne+") does not match the positions count ("+_+")")};this.normals&&E(ut.NormalKind,this.normals),this.tangents&&E(ut.TangentKind,this.tangents),this.uvs&&E(ut.UVKind,this.uvs),this.uvs2&&E(ut.UV2Kind,this.uvs2),this.uvs3&&E(ut.UV3Kind,this.uvs3),this.uvs4&&E(ut.UV4Kind,this.uvs4),this.uvs5&&E(ut.UV5Kind,this.uvs5),this.uvs6&&E(ut.UV6Kind,this.uvs6),this.colors&&E(ut.ColorKind,this.colors),this.matricesIndices&&E(ut.MatricesIndicesKind,this.matricesIndices),this.matricesWeights&&E(ut.MatricesWeightsKind,this.matricesWeights),this.matricesIndicesExtra&&E(ut.MatricesIndicesExtraKind,this.matricesIndicesExtra),this.matricesWeightsExtra&&E(ut.MatricesWeightsExtraKind,this.matricesWeightsExtra)}clone(){const p=this.serialize();return Yr.Parse(p)}serialize(){const p={};if(this.positions&&(p.positions=Array.from(this.positions)),this.normals&&(p.normals=Array.from(this.normals)),this.tangents&&(p.tangents=Array.from(this.tangents)),this.uvs&&(p.uvs=Array.from(this.uvs)),this.uvs2&&(p.uvs2=Array.from(this.uvs2)),this.uvs3&&(p.uvs3=Array.from(this.uvs3)),this.uvs4&&(p.uvs4=Array.from(this.uvs4)),this.uvs5&&(p.uvs5=Array.from(this.uvs5)),this.uvs6&&(p.uvs6=Array.from(this.uvs6)),this.colors&&(p.colors=Array.from(this.colors)),this.matricesIndices&&(p.matricesIndices=Array.from(this.matricesIndices),p.matricesIndices._isExpanded=!0),this.matricesWeights&&(p.matricesWeights=Array.from(this.matricesWeights)),this.matricesIndicesExtra&&(p.matricesIndicesExtra=Array.from(this.matricesIndicesExtra),p.matricesIndicesExtra._isExpanded=!0),this.matricesWeightsExtra&&(p.matricesWeightsExtra=Array.from(this.matricesWeightsExtra)),p.indices=Array.from(this.indices),this.materialInfos){p.materialInfos=[];for(const _ of this.materialInfos){const E={indexStart:_.indexStart,indexCount:_.indexCount,materialIndex:_.materialIndex,verticesStart:_.verticesStart,verticesCount:_.verticesCount};p.materialInfos.push(E)}}return p}static ExtractFromMesh(p,_,E){return Yr._ExtractFrom(p,_,E)}static ExtractFromGeometry(p,_,E){return Yr._ExtractFrom(p,_,E)}static _ExtractFrom(p,_,E){const A=new Yr;return p.isVerticesDataPresent(ut.PositionKind)&&(A.positions=p.getVerticesData(ut.PositionKind,_,E)),p.isVerticesDataPresent(ut.NormalKind)&&(A.normals=p.getVerticesData(ut.NormalKind,_,E)),p.isVerticesDataPresent(ut.TangentKind)&&(A.tangents=p.getVerticesData(ut.TangentKind,_,E)),p.isVerticesDataPresent(ut.UVKind)&&(A.uvs=p.getVerticesData(ut.UVKind,_,E)),p.isVerticesDataPresent(ut.UV2Kind)&&(A.uvs2=p.getVerticesData(ut.UV2Kind,_,E)),p.isVerticesDataPresent(ut.UV3Kind)&&(A.uvs3=p.getVerticesData(ut.UV3Kind,_,E)),p.isVerticesDataPresent(ut.UV4Kind)&&(A.uvs4=p.getVerticesData(ut.UV4Kind,_,E)),p.isVerticesDataPresent(ut.UV5Kind)&&(A.uvs5=p.getVerticesData(ut.UV5Kind,_,E)),p.isVerticesDataPresent(ut.UV6Kind)&&(A.uvs6=p.getVerticesData(ut.UV6Kind,_,E)),p.isVerticesDataPresent(ut.ColorKind)&&(A.colors=p.getVerticesData(ut.ColorKind,_,E)),p.isVerticesDataPresent(ut.MatricesIndicesKind)&&(A.matricesIndices=p.getVerticesData(ut.MatricesIndicesKind,_,E)),p.isVerticesDataPresent(ut.MatricesWeightsKind)&&(A.matricesWeights=p.getVerticesData(ut.MatricesWeightsKind,_,E)),p.isVerticesDataPresent(ut.MatricesIndicesExtraKind)&&(A.matricesIndicesExtra=p.getVerticesData(ut.MatricesIndicesExtraKind,_,E)),p.isVerticesDataPresent(ut.MatricesWeightsExtraKind)&&(A.matricesWeightsExtra=p.getVerticesData(ut.MatricesWeightsExtraKind,_,E)),A.indices=p.getIndices(_,E),A}static CreateRibbon(p){throw Tr("ribbonBuilder")}static CreateBox(p){throw Tr("boxBuilder")}static CreateTiledBox(p){throw Tr("tiledBoxBuilder")}static CreateTiledPlane(p){throw Tr("tiledPlaneBuilder")}static CreateSphere(p){throw Tr("sphereBuilder")}static CreateCylinder(p){throw Tr("cylinderBuilder")}static CreateTorus(p){throw Tr("torusBuilder")}static CreateLineSystem(p){throw Tr("linesBuilder")}static CreateDashedLines(p){throw Tr("linesBuilder")}static CreateGround(p){throw Tr("groundBuilder")}static CreateTiledGround(p){throw Tr("groundBuilder")}static CreateGroundFromHeightMap(p){throw Tr("groundBuilder")}static CreatePlane(p){throw Tr("planeBuilder")}static CreateDisc(p){throw Tr("discBuilder")}static CreatePolygon(p,_,E,A,$,ne,xe){throw Tr("polygonBuilder")}static CreateIcoSphere(p){throw Tr("icoSphereBuilder")}static CreatePolyhedron(p){throw Tr("polyhedronBuilder")}static CreateCapsule(p={orientation:nt.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){throw Tr("capsuleBuilder")}static CreateTorusKnot(p){throw Tr("torusKnotBuilder")}static ComputeNormals(p,_,E,A){let $=0,ne=0,xe=0,ce=0,Te=0,Re=0,ke=0,We=0,Xe=0,xt=0,qe=0,ht=0,Nt=0,wt=0,Qt=0,Ht=0,Wt=0,zt=0,xi=0,wi=0,vs=!1,cs=!1,Mr=!1,xn=!1,qr=1,Tn=0,h0=null;A&&(vs=!!A.facetNormals,cs=!!A.facetPositions,Mr=!!A.facetPartitioning,qr=A.useRightHandedSystem===!0?-1:1,Tn=A.ratio||0,xn=!!A.depthSort,h0=A.distanceTo,xn&&h0===void 0&&(h0=nt.Zero()));let Ra=0,x0=0,X0=0,K0=0;for(Mr&&A&&A.bbSize&&(Ra=A.subDiv.X*Tn/A.bbSize.x,x0=A.subDiv.Y*Tn/A.bbSize.y,X0=A.subDiv.Z*Tn/A.bbSize.z,K0=A.subDiv.max*A.subDiv.max,A.facetPartitioning.length=0),$=0;$<p.length;$++)E[$]=0;const qx=_.length/3|0;for($=0;$<qx;$++){if(ht=_[$*3]*3,Nt=ht+1,wt=ht+2,Qt=_[$*3+1]*3,Ht=Qt+1,Wt=Qt+2,zt=_[$*3+2]*3,xi=zt+1,wi=zt+2,ne=p[ht]-p[Qt],xe=p[Nt]-p[Ht],ce=p[wt]-p[Wt],Te=p[zt]-p[Qt],Re=p[xi]-p[Ht],ke=p[wi]-p[Wt],We=qr*(xe*ke-ce*Re),Xe=qr*(ce*Te-ne*ke),xt=qr*(ne*Re-xe*Te),qe=Math.sqrt(We*We+Xe*Xe+xt*xt),qe=qe===0?1:qe,We/=qe,Xe/=qe,xt/=qe,vs&&A&&(A.facetNormals[$].x=We,A.facetNormals[$].y=Xe,A.facetNormals[$].z=xt),cs&&A&&(A.facetPositions[$].x=(p[ht]+p[Qt]+p[zt])/3,A.facetPositions[$].y=(p[Nt]+p[Ht]+p[xi])/3,A.facetPositions[$].z=(p[wt]+p[Wt]+p[wi])/3),Mr&&A){const Ux=Math.floor((A.facetPositions[$].x-A.bInfo.minimum.x*Tn)*Ra),k2=Math.floor((A.facetPositions[$].y-A.bInfo.minimum.y*Tn)*x0),Tc=Math.floor((A.facetPositions[$].z-A.bInfo.minimum.z*Tn)*X0),e_=Math.floor((p[ht]-A.bInfo.minimum.x*Tn)*Ra),t_=Math.floor((p[Nt]-A.bInfo.minimum.y*Tn)*x0),i_=Math.floor((p[wt]-A.bInfo.minimum.z*Tn)*X0),Wy=Math.floor((p[Qt]-A.bInfo.minimum.x*Tn)*Ra),Hy=Math.floor((p[Ht]-A.bInfo.minimum.y*Tn)*x0),Xy=Math.floor((p[Wt]-A.bInfo.minimum.z*Tn)*X0),Ky=Math.floor((p[zt]-A.bInfo.minimum.x*Tn)*Ra),Yy=Math.floor((p[xi]-A.bInfo.minimum.y*Tn)*x0),jy=Math.floor((p[wi]-A.bInfo.minimum.z*Tn)*X0),Rh=e_+A.subDiv.max*t_+K0*i_,Mh=Wy+A.subDiv.max*Hy+K0*Xy,wh=Ky+A.subDiv.max*Yy+K0*jy,Lh=Ux+A.subDiv.max*k2+K0*Tc;A.facetPartitioning[Lh]=A.facetPartitioning[Lh]?A.facetPartitioning[Lh]:new Array,A.facetPartitioning[Rh]=A.facetPartitioning[Rh]?A.facetPartitioning[Rh]:new Array,A.facetPartitioning[Mh]=A.facetPartitioning[Mh]?A.facetPartitioning[Mh]:new Array,A.facetPartitioning[wh]=A.facetPartitioning[wh]?A.facetPartitioning[wh]:new Array,A.facetPartitioning[Rh].push($),Mh!=Rh&&A.facetPartitioning[Mh].push($),wh==Mh||wh==Rh||A.facetPartitioning[wh].push($),Lh==Rh||Lh==Mh||Lh==wh||A.facetPartitioning[Lh].push($)}if(xn&&A&&A.facetPositions){const Ux=A.depthSortedFacets[$];Ux.ind=$*3,Ux.sqDistance=nt.DistanceSquared(A.facetPositions[$],h0)}E[ht]+=We,E[Nt]+=Xe,E[wt]+=xt,E[Qt]+=We,E[Ht]+=Xe,E[Wt]+=xt,E[zt]+=We,E[xi]+=Xe,E[wi]+=xt}for($=0;$<E.length/3;$++)We=E[$*3],Xe=E[$*3+1],xt=E[$*3+2],qe=Math.sqrt(We*We+Xe*Xe+xt*xt),qe=qe===0?1:qe,We/=qe,Xe/=qe,xt/=qe,E[$*3]=We,E[$*3+1]=Xe,E[$*3+2]=xt}static _ComputeSides(p,_,E,A,$,ne,xe){const ce=E.length,Te=A.length;let Re,ke;switch(p=p||Yr.DEFAULTSIDE,p){case Yr.FRONTSIDE:break;case Yr.BACKSIDE:for(Re=0;Re<ce;Re+=3){const We=E[Re];E[Re]=E[Re+2],E[Re+2]=We}for(ke=0;ke<Te;ke++)A[ke]=-A[ke];break;case Yr.DOUBLESIDE:{const We=_.length,Xe=We/3;for(let ht=0;ht<We;ht++)_[We+ht]=_[ht];for(Re=0;Re<ce;Re+=3)E[Re+ce]=E[Re+2]+Xe,E[Re+1+ce]=E[Re+1]+Xe,E[Re+2+ce]=E[Re]+Xe;for(ke=0;ke<Te;ke++)A[Te+ke]=-A[ke];const xt=$.length;let qe=0;for(qe=0;qe<xt;qe++)$[qe+xt]=$[qe];for(ne=ne||new Gr(0,0,1,1),xe=xe||new Gr(0,0,1,1),qe=0,Re=0;Re<xt/2;Re++)$[qe]=ne.x+(ne.z-ne.x)*$[qe],$[qe+1]=ne.y+(ne.w-ne.y)*$[qe+1],$[qe+xt]=xe.x+(xe.z-xe.x)*$[qe+xt],$[qe+xt+1]=xe.y+(xe.w-xe.y)*$[qe+xt+1],qe+=2;break}}}static Parse(p){const _=new Yr,E=p.positions;E&&_.set(E,ut.PositionKind);const A=p.normals;A&&_.set(A,ut.NormalKind);const $=p.tangents;$&&_.set($,ut.TangentKind);const ne=p.uvs;ne&&_.set(ne,ut.UVKind);const xe=p.uvs2;xe&&_.set(xe,ut.UV2Kind);const ce=p.uvs3;ce&&_.set(ce,ut.UV3Kind);const Te=p.uvs4;Te&&_.set(Te,ut.UV4Kind);const Re=p.uvs5;Re&&_.set(Re,ut.UV5Kind);const ke=p.uvs6;ke&&_.set(ke,ut.UV6Kind);const We=p.colors;We&&_.set(vr.CheckColors4(We,E.length/3),ut.ColorKind);const Xe=p.matricesIndices;Xe&&_.set(Xe,ut.MatricesIndicesKind);const xt=p.matricesWeights;xt&&_.set(xt,ut.MatricesWeightsKind);const qe=p.indices;qe&&(_.indices=qe);const ht=p.materialInfos;if(ht){_.materialInfos=[];for(const Nt of ht){const wt=new f_;wt.indexCount=Nt.indexCount,wt.indexStart=Nt.indexStart,wt.verticesCount=Nt.verticesCount,wt.verticesStart=Nt.verticesStart,wt.materialIndex=Nt.materialIndex,_.materialInfos.push(wt)}}return _}static ImportVertexData(p,_){const E=Yr.Parse(p);_.setAllVerticesData(E,p.updatable)}}Yr.FRONTSIDE=0,Yr.BACKSIDE=1,Yr.DOUBLESIDE=2,Yr.DEFAULTSIDE=0,Yr._UniqueIDGenerator=0,Mt([jh.filter((...[_e])=>!Array.isArray(_e))],Yr,"_TransformVector3Coordinates",null),Mt([jh.filter((...[_e])=>!Array.isArray(_e))],Yr,"_TransformVector3Normals",null),Mt([jh.filter((...[_e])=>!Array.isArray(_e))],Yr,"_TransformVector4Normals",null),Mt([jh.filter((...[_e])=>!Array.isArray(_e))],Yr,"_FlipFaces",null);const Uw=Yt.Compose(nt.One(),_s.FromEulerAngles(0,Math.PI,0),nt.Zero());class zr extends Ka{get billboardMode(){return this._billboardMode}set billboardMode(p){this._billboardMode!==p&&(this._billboardMode=p,this._cache.useBillboardPosition=(this._billboardMode&zr.BILLBOARDMODE_USE_POSITION)!==0,this._computeUseBillboardPath())}get preserveParentRotationForBillboard(){return this._preserveParentRotationForBillboard}set preserveParentRotationForBillboard(p){p!==this._preserveParentRotationForBillboard&&(this._preserveParentRotationForBillboard=p,this._computeUseBillboardPath())}_computeUseBillboardPath(){this._cache.useBillboardPath=this._billboardMode!==zr.BILLBOARDMODE_NONE&&!this.preserveParentRotationForBillboard}get infiniteDistance(){return this._infiniteDistance}set infiniteDistance(p){this._infiniteDistance!==p&&(this._infiniteDistance=p)}constructor(p,_=null,E=!0){super(p,_),this._forward=new nt(0,0,1),this._up=new nt(0,1,0),this._right=new nt(1,0,0),this._position=nt.Zero(),this._rotation=nt.Zero(),this._rotationQuaternion=null,this._scaling=nt.One(),this._transformToBoneReferal=null,this._isAbsoluteSynced=!1,this._billboardMode=zr.BILLBOARDMODE_NONE,this._preserveParentRotationForBillboard=!1,this.scalingDeterminant=1,this._infiniteDistance=!1,this.ignoreNonUniformScaling=!1,this.reIntegrateRotationIntoRotationQuaternion=!1,this._poseMatrix=null,this._localMatrix=Yt.Zero(),this._usePivotMatrix=!1,this._absolutePosition=nt.Zero(),this._absoluteScaling=nt.Zero(),this._absoluteRotationQuaternion=_s.Identity(),this._pivotMatrix=Yt.Identity(),this._postMultiplyPivotMatrix=!1,this._isWorldMatrixFrozen=!1,this._indexInSceneTransformNodesArray=-1,this.onAfterWorldMatrixUpdateObservable=new Mi,this._nonUniformScaling=!1,E&&this.getScene().addTransformNode(this)}getClassName(){return"TransformNode"}get position(){return this._position}set position(p){this._position=p,this._isDirty=!0}isUsingPivotMatrix(){return this._usePivotMatrix}isUsingPostMultiplyPivotMatrix(){return this._postMultiplyPivotMatrix}get rotation(){return this._rotation}set rotation(p){this._rotation=p,this._rotationQuaternion=null,this._isDirty=!0}get scaling(){return this._scaling}set scaling(p){this._scaling=p,this._isDirty=!0}get rotationQuaternion(){return this._rotationQuaternion}set rotationQuaternion(p){this._rotationQuaternion=p,p&&this._rotation.setAll(0),this._isDirty=!0}get forward(){return nt.TransformNormalFromFloatsToRef(0,0,this.getScene().useRightHandedSystem?-1:1,this.getWorldMatrix(),this._forward),this._forward.normalize()}get up(){return nt.TransformNormalFromFloatsToRef(0,1,0,this.getWorldMatrix(),this._up),this._up.normalize()}get right(){return nt.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem?-1:1,0,0,this.getWorldMatrix(),this._right),this._right.normalize()}updatePoseMatrix(p){return this._poseMatrix?(this._poseMatrix.copyFrom(p),this):(this._poseMatrix=p.clone(),this)}getPoseMatrix(){return this._poseMatrix||(this._poseMatrix=Yt.Identity()),this._poseMatrix}_isSynchronized(){const p=this._cache;return!(this._billboardMode!==p.billboardMode||this._billboardMode!==zr.BILLBOARDMODE_NONE||p.pivotMatrixUpdated||this._infiniteDistance||this._position._isDirty||this._scaling._isDirty||this._rotationQuaternion&&this._rotationQuaternion._isDirty||this._rotation._isDirty)}_initCache(){super._initCache();const p=this._cache;p.localMatrixUpdated=!1,p.billboardMode=-1,p.infiniteDistance=!1,p.useBillboardPosition=!1,p.useBillboardPath=!1}get absolutePosition(){return this.getAbsolutePosition()}get absoluteScaling(){return this._syncAbsoluteScalingAndRotation(),this._absoluteScaling}get absoluteRotationQuaternion(){return this._syncAbsoluteScalingAndRotation(),this._absoluteRotationQuaternion}setPreTransformMatrix(p){return this.setPivotMatrix(p,!1)}setPivotMatrix(p,_=!0){return this._pivotMatrix.copyFrom(p),this._usePivotMatrix=!this._pivotMatrix.isIdentity(),this._cache.pivotMatrixUpdated=!0,this._postMultiplyPivotMatrix=_,this._postMultiplyPivotMatrix&&(this._pivotMatrixInverse?this._pivotMatrix.invertToRef(this._pivotMatrixInverse):this._pivotMatrixInverse=Yt.Invert(this._pivotMatrix)),this}getPivotMatrix(){return this._pivotMatrix}instantiateHierarchy(p=null,_,E){const A=this.clone("Clone of "+(this.name||this.id),p||this.parent,!0);A&&E&&E(this,A);for(const $ of this.getChildTransformNodes(!0))$.instantiateHierarchy(A,_,E);return A}freezeWorldMatrix(p=null,_=!1){return p?_?(this._rotation.setAll(0),this._rotationQuaternion=this._rotationQuaternion||_s.Identity(),p.decompose(this._scaling,this._rotationQuaternion,this._position),this.computeWorldMatrix(!0)):(this._worldMatrix=p,this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._afterComputeWorldMatrix()):(this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0)),this._isDirty=!1,this._isWorldMatrixFrozen=!0,this}unfreezeWorldMatrix(){return this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0),this}get isWorldMatrixFrozen(){return this._isWorldMatrixFrozen}getAbsolutePosition(){return this.computeWorldMatrix(),this._absolutePosition}setAbsolutePosition(p){if(!p)return this;let _,E,A;if(p.x===void 0){if(arguments.length<3)return this;_=arguments[0],E=arguments[1],A=arguments[2]}else _=p.x,E=p.y,A=p.z;if(this.parent){const $=pi.Matrix[0];this.parent.getWorldMatrix().invertToRef($),nt.TransformCoordinatesFromFloatsToRef(_,E,A,$,this.position)}else this.position.x=_,this.position.y=E,this.position.z=A;return this._absolutePosition.copyFrom(p),this}setPositionWithLocalVector(p){return this.computeWorldMatrix(),this.position=nt.TransformNormal(p,this._localMatrix),this}getPositionExpressedInLocalSpace(){this.computeWorldMatrix();const p=pi.Matrix[0];return this._localMatrix.invertToRef(p),nt.TransformNormal(this.position,p)}locallyTranslate(p){return this.computeWorldMatrix(!0),this.position=nt.TransformCoordinates(p,this._localMatrix),this}lookAt(p,_=0,E=0,A=0,$=Xn.LOCAL){const ne=zr._LookAtVectorCache,xe=$===Xn.LOCAL?this.position:this.getAbsolutePosition();if(p.subtractToRef(xe,ne),this.setDirection(ne,_,E,A),$===Xn.WORLD&&this.parent)if(this.rotationQuaternion){const ce=pi.Matrix[0];this.rotationQuaternion.toRotationMatrix(ce);const Te=pi.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(Te),Te.invert(),ce.multiplyToRef(Te,ce),this.rotationQuaternion.fromRotationMatrix(ce)}else{const ce=pi.Quaternion[0];_s.FromEulerVectorToRef(this.rotation,ce);const Te=pi.Matrix[0];ce.toRotationMatrix(Te);const Re=pi.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(Re),Re.invert(),Te.multiplyToRef(Re,Te),ce.fromRotationMatrix(Te),ce.toEulerAnglesToRef(this.rotation)}return this}getDirection(p){const _=nt.Zero();return this.getDirectionToRef(p,_),_}getDirectionToRef(p,_){return nt.TransformNormalToRef(p,this.getWorldMatrix(),_),this}setDirection(p,_=0,E=0,A=0){const $=-Math.atan2(p.z,p.x)+Math.PI/2,ne=Math.sqrt(p.x*p.x+p.z*p.z),xe=-Math.atan2(p.y,ne);return this.rotationQuaternion?_s.RotationYawPitchRollToRef($+_,xe+E,A,this.rotationQuaternion):(this.rotation.x=xe+E,this.rotation.y=$+_,this.rotation.z=A),this}setPivotPoint(p,_=Xn.LOCAL){this.getScene().getRenderId()==0&&this.computeWorldMatrix(!0);const E=this.getWorldMatrix();if(_==Xn.WORLD){const A=pi.Matrix[0];E.invertToRef(A),p=nt.TransformCoordinates(p,A)}return this.setPivotMatrix(Yt.Translation(-p.x,-p.y,-p.z),!0)}getPivotPoint(){const p=nt.Zero();return this.getPivotPointToRef(p),p}getPivotPointToRef(p){return p.x=-this._pivotMatrix.m[12],p.y=-this._pivotMatrix.m[13],p.z=-this._pivotMatrix.m[14],this}getAbsolutePivotPoint(){const p=nt.Zero();return this.getAbsolutePivotPointToRef(p),p}getAbsolutePivotPointToRef(p){return this.getPivotPointToRef(p),nt.TransformCoordinatesToRef(p,this.getWorldMatrix(),p),this}markAsDirty(p){if(this._isDirty)return this;if(this._children)for(const _ of this._children)_.markAsDirty(p);return super.markAsDirty(p)}setParent(p,_=!1,E=!1){if(!p&&!this.parent)return this;const A=pi.Quaternion[0],$=pi.Vector3[0],ne=pi.Vector3[1],xe=pi.Matrix[1];Yt.IdentityToRef(xe);const ce=pi.Matrix[0];this.computeWorldMatrix(!0);let Te=this.rotationQuaternion;return Te||(Te=zr._TmpRotation,_s.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,Te)),Yt.ComposeToRef(this.scaling,Te,this.position,ce),this.parent&&ce.multiplyToRef(this.parent.computeWorldMatrix(!0),ce),p&&(p.computeWorldMatrix(!0).invertToRef(xe),ce.multiplyToRef(xe,ce)),ce.decompose(ne,A,$,_?this:void 0),this.rotationQuaternion?this.rotationQuaternion.copyFrom(A):A.toEulerAnglesToRef(this.rotation),this.scaling.copyFrom(ne),this.position.copyFrom($),this.parent=p,E&&this.setPivotMatrix(Yt.Identity()),this}get nonUniformScaling(){return this._nonUniformScaling}_updateNonUniformScalingState(p){return this._nonUniformScaling===p?!1:(this._nonUniformScaling=p,!0)}attachToBone(p,_){return this._currentParentWhenAttachingToBone=this.parent,this._transformToBoneReferal=_,this.parent=p,p.getSkeleton().prepare(!0),p.getFinalMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this}detachFromBone(p=!1){return this.parent?(this.parent.getWorldMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this._transformToBoneReferal=null,p?this.parent=this._currentParentWhenAttachingToBone:this.parent=null,this):(p&&(this.parent=this._currentParentWhenAttachingToBone),this)}rotate(p,_,E){p.normalize(),this.rotationQuaternion||(this.rotationQuaternion=this.rotation.toQuaternion(),this.rotation.setAll(0));let A;if(!E||E===Xn.LOCAL)A=_s.RotationAxisToRef(p,_,zr._RotationAxisCache),this.rotationQuaternion.multiplyToRef(A,this.rotationQuaternion);else{if(this.parent){const $=this.parent.getWorldMatrix(),ne=pi.Matrix[0];$.invertToRef(ne),p=nt.TransformNormal(p,ne),$.determinant()<0&&(_*=-1)}A=_s.RotationAxisToRef(p,_,zr._RotationAxisCache),A.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion)}return this}rotateAround(p,_,E){_.normalize(),this.rotationQuaternion||(this.rotationQuaternion=_s.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z),this.rotation.setAll(0));const A=pi.Vector3[0],$=pi.Vector3[1],ne=pi.Vector3[2],xe=pi.Quaternion[0],ce=pi.Matrix[0],Te=pi.Matrix[1],Re=pi.Matrix[2],ke=pi.Matrix[3];return p.subtractToRef(this.position,A),Yt.TranslationToRef(A.x,A.y,A.z,ce),Yt.TranslationToRef(-A.x,-A.y,-A.z,Te),Yt.RotationAxisToRef(_,E,Re),Te.multiplyToRef(Re,ke),ke.multiplyToRef(ce,ke),ke.decompose($,xe,ne),this.position.addInPlace(ne),xe.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion),this}translate(p,_,E){const A=p.scale(_);if(!E||E===Xn.LOCAL){const $=this.getPositionExpressedInLocalSpace().add(A);this.setPositionWithLocalVector($)}else this.setAbsolutePosition(this.getAbsolutePosition().add(A));return this}addRotation(p,_,E){let A;this.rotationQuaternion?A=this.rotationQuaternion:(A=pi.Quaternion[1],_s.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,A));const $=pi.Quaternion[0];return _s.RotationYawPitchRollToRef(_,p,E,$),A.multiplyInPlace($),this.rotationQuaternion||A.toEulerAnglesToRef(this.rotation),this}_getEffectiveParent(){return this.parent}isWorldMatrixCameraDependent(){return this._infiniteDistance&&!this.parent||this._billboardMode!==zr.BILLBOARDMODE_NONE&&!this.preserveParentRotationForBillboard}computeWorldMatrix(p=!1,_=null){if(this._isWorldMatrixFrozen&&!this._isDirty)return this._worldMatrix;const E=this.getScene().getRenderId();if(!this._isDirty&&!p&&(this._currentRenderId===E||this.isSynchronized()))return this._currentRenderId=E,this._worldMatrix;_=_||this.getScene().activeCamera,this._updateCache();const A=this._cache;A.pivotMatrixUpdated=!1,A.billboardMode=this.billboardMode,A.infiniteDistance=this.infiniteDistance,A.parent=this._parentNode,this._currentRenderId=E,this._childUpdateId+=1,this._isDirty=!1,this._position._isDirty=!1,this._rotation._isDirty=!1,this._scaling._isDirty=!1;const $=this._getEffectiveParent(),ne=zr._TmpScaling;let xe=this._position;if(this._infiniteDistance&&!this.parent&&_){const Te=_.getWorldMatrix(),Re=new nt(Te.m[12],Te.m[13],Te.m[14]);xe=zr._TmpTranslation,xe.copyFromFloats(this._position.x+Re.x,this._position.y+Re.y,this._position.z+Re.z)}ne.copyFromFloats(this._scaling.x*this.scalingDeterminant,this._scaling.y*this.scalingDeterminant,this._scaling.z*this.scalingDeterminant);let ce;if(this._rotationQuaternion?(this._rotationQuaternion._isDirty=!1,ce=this._rotationQuaternion,this.reIntegrateRotationIntoRotationQuaternion&&this.rotation.lengthSquared()&&(this._rotationQuaternion.multiplyInPlace(_s.RotationYawPitchRoll(this._rotation.y,this._rotation.x,this._rotation.z)),this._rotation.copyFromFloats(0,0,0))):(ce=zr._TmpRotation,_s.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,ce)),this._usePivotMatrix){const Te=pi.Matrix[1];Yt.ScalingToRef(ne.x,ne.y,ne.z,Te);const Re=pi.Matrix[0];ce.toRotationMatrix(Re),this._pivotMatrix.multiplyToRef(Te,pi.Matrix[4]),pi.Matrix[4].multiplyToRef(Re,this._localMatrix),this._postMultiplyPivotMatrix&&this._localMatrix.multiplyToRef(this._pivotMatrixInverse,this._localMatrix),this._localMatrix.addTranslationFromFloats(xe.x,xe.y,xe.z)}else Yt.ComposeToRef(ne,ce,xe,this._localMatrix);if($&&$.getWorldMatrix){if(p&&$.computeWorldMatrix(p),A.useBillboardPath){if(this._transformToBoneReferal){const We=this.parent;We.getSkeleton().prepare(),We.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),pi.Matrix[7])}else pi.Matrix[7].copyFrom($.getWorldMatrix());const Te=pi.Vector3[5],Re=pi.Vector3[6],ke=pi.Quaternion[0];pi.Matrix[7].decompose(Re,ke,Te),Yt.ScalingToRef(Re.x,Re.y,Re.z,pi.Matrix[7]),pi.Matrix[7].setTranslation(Te),zr.BillboardUseParentOrientation&&(this._position.applyRotationQuaternionToRef(ke,Te),this._localMatrix.setTranslation(Te)),this._localMatrix.multiplyToRef(pi.Matrix[7],this._worldMatrix)}else if(this._transformToBoneReferal){const Te=this.parent;Te.getSkeleton().prepare(),this._localMatrix.multiplyToRef(Te.getFinalMatrix(),pi.Matrix[6]),pi.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),this._worldMatrix)}else this._localMatrix.multiplyToRef($.getWorldMatrix(),this._worldMatrix);this._markSyncedWithParent()}else this._worldMatrix.copyFrom(this._localMatrix);if(A.useBillboardPath&&_&&this.billboardMode&&!A.useBillboardPosition){const Te=pi.Vector3[0];if(this._worldMatrix.getTranslationToRef(Te),pi.Matrix[1].copyFrom(_.getViewMatrix()),this._scene.useRightHandedSystem&&pi.Matrix[1].multiplyToRef(Uw,pi.Matrix[1]),pi.Matrix[1].setTranslationFromFloats(0,0,0),pi.Matrix[1].invertToRef(pi.Matrix[0]),(this.billboardMode&zr.BILLBOARDMODE_ALL)!==zr.BILLBOARDMODE_ALL){pi.Matrix[0].decompose(void 0,pi.Quaternion[0],void 0);const Re=pi.Vector3[1];pi.Quaternion[0].toEulerAnglesToRef(Re),(this.billboardMode&zr.BILLBOARDMODE_X)!==zr.BILLBOARDMODE_X&&(Re.x=0),(this.billboardMode&zr.BILLBOARDMODE_Y)!==zr.BILLBOARDMODE_Y&&(Re.y=0),(this.billboardMode&zr.BILLBOARDMODE_Z)!==zr.BILLBOARDMODE_Z&&(Re.z=0),Yt.RotationYawPitchRollToRef(Re.y,Re.x,Re.z,pi.Matrix[0])}this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(pi.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(pi.Vector3[0])}else if(A.useBillboardPath&&_&&A.useBillboardPosition){const Te=pi.Vector3[0];this._worldMatrix.getTranslationToRef(Te);const Re=_.globalPosition;this._worldMatrix.invertToRef(pi.Matrix[1]);const ke=pi.Vector3[1];nt.TransformCoordinatesToRef(Re,pi.Matrix[1],ke),ke.normalize();const We=-Math.atan2(ke.z,ke.x)+Math.PI/2,Xe=Math.sqrt(ke.x*ke.x+ke.z*ke.z),xt=-Math.atan2(ke.y,Xe);if(_s.RotationYawPitchRollToRef(We,xt,0,pi.Quaternion[0]),(this.billboardMode&zr.BILLBOARDMODE_ALL)!==zr.BILLBOARDMODE_ALL){const qe=pi.Vector3[1];pi.Quaternion[0].toEulerAnglesToRef(qe),(this.billboardMode&zr.BILLBOARDMODE_X)!==zr.BILLBOARDMODE_X&&(qe.x=0),(this.billboardMode&zr.BILLBOARDMODE_Y)!==zr.BILLBOARDMODE_Y&&(qe.y=0),(this.billboardMode&zr.BILLBOARDMODE_Z)!==zr.BILLBOARDMODE_Z&&(qe.z=0),Yt.RotationYawPitchRollToRef(qe.y,qe.x,qe.z,pi.Matrix[0])}else Yt.FromQuaternionToRef(pi.Quaternion[0],pi.Matrix[0]);this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(pi.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(pi.Vector3[0])}return this.ignoreNonUniformScaling?this._updateNonUniformScalingState(!1):this._scaling.isNonUniformWithinEpsilon(1e-6)?this._updateNonUniformScalingState(!0):$&&$._nonUniformScaling?this._updateNonUniformScalingState($._nonUniformScaling):this._updateNonUniformScalingState(!1),this._afterComputeWorldMatrix(),this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._isAbsoluteSynced=!1,this.onAfterWorldMatrixUpdateObservable.notifyObservers(this),this._poseMatrix||(this._poseMatrix=Yt.Invert(this._worldMatrix)),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix}resetLocalMatrix(p=!0){if(this.computeWorldMatrix(),p){const _=this.getChildren();for(let E=0;E<_.length;++E){const A=_[E];if(A){A.computeWorldMatrix();const $=pi.Matrix[0];A._localMatrix.multiplyToRef(this._localMatrix,$);const ne=pi.Quaternion[0];$.decompose(A.scaling,ne,A.position),A.rotationQuaternion?A.rotationQuaternion.copyFrom(ne):ne.toEulerAnglesToRef(A.rotation)}}}this.scaling.copyFromFloats(1,1,1),this.position.copyFromFloats(0,0,0),this.rotation.copyFromFloats(0,0,0),this.rotationQuaternion&&(this.rotationQuaternion=_s.Identity()),this._worldMatrix=Yt.Identity()}_afterComputeWorldMatrix(){}registerAfterWorldMatrixUpdate(p){return this.onAfterWorldMatrixUpdateObservable.add(p),this}unregisterAfterWorldMatrixUpdate(p){return this.onAfterWorldMatrixUpdateObservable.removeCallback(p),this}getPositionInCameraSpace(p=null){return p||(p=this.getScene().activeCamera),nt.TransformCoordinates(this.getAbsolutePosition(),p.getViewMatrix())}getDistanceToCamera(p=null){return p||(p=this.getScene().activeCamera),this.getAbsolutePosition().subtract(p.globalPosition).length()}clone(p,_,E){const A=Xr.Clone(()=>new zr(p,this.getScene()),this);if(A.name=p,A.id=p,_&&(A.parent=_),!E){const $=this.getDescendants(!0);for(let ne=0;ne<$.length;ne++){const xe=$[ne];xe.clone&&xe.clone(p+"."+xe.name,A)}}return A}serialize(p){const _=Xr.Serialize(this,p);return _.type=this.getClassName(),_.uniqueId=this.uniqueId,this.parent&&this.parent._serializeAsParent(_),_.localMatrix=this.getPivotMatrix().asArray(),_.isEnabled=this.isEnabled(),Xr.AppendSerializedAnimations(this,_),_.ranges=this.serializeAnimationRanges(),_}static Parse(p,_,E){const A=Xr.Parse(()=>new zr(p.name,_),p,_,E);if(p.localMatrix?A.setPreTransformMatrix(Yt.FromArray(p.localMatrix)):p.pivotMatrix&&A.setPivotMatrix(Yt.FromArray(p.pivotMatrix)),A.setEnabled(p.isEnabled),A._waitingParsedUniqueId=p.uniqueId,p.parentId!==void 0&&(A._waitingParentId=p.parentId),p.parentInstanceIndex!==void 0&&(A._waitingParentInstanceIndex=p.parentInstanceIndex),p.animations){for(let $=0;$<p.animations.length;$++){const ne=p.animations[$],xe=a0("BABYLON.Animation");xe&&A.animations.push(xe.Parse(ne))}Ka.ParseAnimationRanges(A,p,_)}return p.autoAnimate&&_.beginAnimation(A,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1),A}getChildTransformNodes(p,_){const E=[];return this._getDescendants(E,p,A=>(!_||_(A))&&A instanceof zr),E}dispose(p,_=!1){if(this.getScene().stopAnimation(this),this.getScene().removeTransformNode(this),this._parentContainer){const E=this._parentContainer.transformNodes.indexOf(this);E>-1&&this._parentContainer.transformNodes.splice(E,1),this._parentContainer=null}if(this.onAfterWorldMatrixUpdateObservable.clear(),p){const E=this.getChildTransformNodes(!0);for(const A of E)A.parent=null,A.computeWorldMatrix(!0)}super.dispose(p,_)}normalizeToUnitCube(p=!0,_=!1,E){let A=null,$=null;_&&(this.rotationQuaternion?($=this.rotationQuaternion.clone(),this.rotationQuaternion.copyFromFloats(0,0,0,1)):this.rotation&&(A=this.rotation.clone(),this.rotation.copyFromFloats(0,0,0)));const ne=this.getHierarchyBoundingVectors(p,E),xe=ne.max.subtract(ne.min),ce=Math.max(xe.x,xe.y,xe.z);if(ce===0)return this;const Te=1/ce;return this.scaling.scaleInPlace(Te),_&&(this.rotationQuaternion&&$?this.rotationQuaternion.copyFrom($):this.rotation&&A&&this.rotation.copyFrom(A)),this}_syncAbsoluteScalingAndRotation(){this._isAbsoluteSynced||(this._worldMatrix.decompose(this._absoluteScaling,this._absoluteRotationQuaternion),this._isAbsoluteSynced=!0)}}zr.BILLBOARDMODE_NONE=0,zr.BILLBOARDMODE_X=1,zr.BILLBOARDMODE_Y=2,zr.BILLBOARDMODE_Z=4,zr.BILLBOARDMODE_ALL=7,zr.BILLBOARDMODE_USE_POSITION=128,zr.BillboardUseParentOrientation=!1,zr._TmpRotation=_s.Zero(),zr._TmpScaling=nt.Zero(),zr._TmpTranslation=nt.Zero(),zr._LookAtVectorCache=new nt(0,0,0),zr._RotationAxisCache=new _s,Mt([jn("position")],zr.prototype,"_position",void 0),Mt([jn("rotation")],zr.prototype,"_rotation",void 0),Mt([KO("rotationQuaternion")],zr.prototype,"_rotationQuaternion",void 0),Mt([jn("scaling")],zr.prototype,"_scaling",void 0),Mt([Gt("billboardMode")],zr.prototype,"_billboardMode",void 0),Mt([Gt()],zr.prototype,"scalingDeterminant",void 0),Mt([Gt("infiniteDistance")],zr.prototype,"_infiniteDistance",void 0),Mt([Gt()],zr.prototype,"ignoreNonUniformScaling",void 0),Mt([Gt()],zr.prototype,"reIntegrateRotationIntoRotationQuaternion",void 0);class p_{constructor(){this._defines={},this._currentRank=32,this._maxRank=-1,this._mesh=null}unBindMesh(){this._mesh=null}addFallback(p,_){this._defines[p]||(p<this._currentRank&&(this._currentRank=p),p>this._maxRank&&(this._maxRank=p),this._defines[p]=new Array),this._defines[p].push(_)}addCPUSkinningFallback(p,_){this._mesh=_,p<this._currentRank&&(this._currentRank=p),p>this._maxRank&&(this._maxRank=p)}get hasMoreFallbacks(){return this._currentRank<=this._maxRank}reduce(p,_){if(this._mesh&&this._mesh.computeBonesUsingShaders&&this._mesh.numBoneInfluencers>0){this._mesh.computeBonesUsingShaders=!1,p=p.replace("#define NUM_BONE_INFLUENCERS "+this._mesh.numBoneInfluencers,"#define NUM_BONE_INFLUENCERS 0"),_._bonesComputationForcedToCPU=!0;const E=this._mesh.getScene();for(let A=0;A<E.meshes.length;A++){const $=E.meshes[A];if(!$.material){!this._mesh.material&&$.computeBonesUsingShaders&&$.numBoneInfluencers>0&&($.computeBonesUsingShaders=!1);continue}if(!(!$.computeBonesUsingShaders||$.numBoneInfluencers===0)){if($.material.getEffect()===_)$.computeBonesUsingShaders=!1;else if($.subMeshes){for(const ne of $.subMeshes)if(ne.effect===_){$.computeBonesUsingShaders=!1;break}}}}}else{const E=this._defines[this._currentRank];if(E)for(let A=0;A<E.length;A++)p=p.replace("#define "+E[A],"");this._currentRank++}return p}}class cE extends Xi{constructor(p,_,E=!0){super(p,_),this._normalMatrix=new Yt,this._storeEffectOnSubMeshes=E}getEffect(){return this._storeEffectOnSubMeshes?this._activeEffect:super.getEffect()}isReady(p,_){return p?!this._storeEffectOnSubMeshes||!p.subMeshes||p.subMeshes.length===0?!0:this.isReadyForSubMesh(p,p.subMeshes[0],_):!1}_isReadyForSubMesh(p){const _=p.materialDefines;return!!(!this.checkReadyOnEveryCall&&p.effect&&_&&_._renderId===this.getScene().getRenderId())}bindOnlyWorldMatrix(p){this._activeEffect.setMatrix("world",p)}bindOnlyNormalMatrix(p){this._activeEffect.setMatrix("normalMatrix",p)}bind(p,_){_&&this.bindForSubMesh(p,_,_.subMeshes[0])}_afterBind(p,_=null,E){super._afterBind(p,_,E),this.getScene()._cachedEffect=_,E?E._drawWrapper._forceRebindOnNextCall=!1:this._drawWrapper._forceRebindOnNextCall=!1}_mustRebind(p,_,E,A=1){return E._drawWrapper._forceRebindOnNextCall||p.isCachedMaterialInvalid(this,_,A)}dispose(p,_,E){this._activeEffect=void 0,super.dispose(p,_,E)}}const m_={effect:null,subMesh:null};class $h extends cE{constructor(p,_,E,A={},$=!0){super(p,_,$),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new Yt,this._cachedWorldViewProjectionMatrix=new Yt,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=E,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...A}}get shaderPath(){return this._shaderPath}set shaderPath(p){this._shaderPath=p}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(p){this._options.uniforms.indexOf(p)===-1&&this._options.uniforms.push(p)}setTexture(p,_){return this._options.samplers.indexOf(p)===-1&&this._options.samplers.push(p),this._textures[p]=_,this}setTextureArray(p,_){return this._options.samplers.indexOf(p)===-1&&this._options.samplers.push(p),this._checkUniform(p),this._textureArrays[p]=_,this}setExternalTexture(p,_){return this._options.externalTextures.indexOf(p)===-1&&this._options.externalTextures.push(p),this._externalTextures[p]=_,this}setFloat(p,_){return this._checkUniform(p),this._floats[p]=_,this}setInt(p,_){return this._checkUniform(p),this._ints[p]=_,this}setUInt(p,_){return this._checkUniform(p),this._uints[p]=_,this}setFloats(p,_){return this._checkUniform(p),this._floatsArrays[p]=_,this}setColor3(p,_){return this._checkUniform(p),this._colors3[p]=_,this}setColor3Array(p,_){return this._checkUniform(p),this._colors3Arrays[p]=_.reduce((E,A)=>(A.toArray(E,E.length),E),[]),this}setColor4(p,_){return this._checkUniform(p),this._colors4[p]=_,this}setColor4Array(p,_){return this._checkUniform(p),this._colors4Arrays[p]=_.reduce((E,A)=>(A.toArray(E,E.length),E),[]),this}setVector2(p,_){return this._checkUniform(p),this._vectors2[p]=_,this}setVector3(p,_){return this._checkUniform(p),this._vectors3[p]=_,this}setVector4(p,_){return this._checkUniform(p),this._vectors4[p]=_,this}setQuaternion(p,_){return this._checkUniform(p),this._quaternions[p]=_,this}setQuaternionArray(p,_){return this._checkUniform(p),this._quaternionsArrays[p]=_.reduce((E,A)=>(A.toArray(E,E.length),E),[]),this}setMatrix(p,_){return this._checkUniform(p),this._matrices[p]=_,this}setMatrices(p,_){this._checkUniform(p);const E=new Float32Array(_.length*16);for(let A=0;A<_.length;A++)_[A].copyToArray(E,A*16);return this._matrixArrays[p]=E,this}setMatrix3x3(p,_){return this._checkUniform(p),this._matrices3x3[p]=_,this}setMatrix2x2(p,_){return this._checkUniform(p),this._matrices2x2[p]=_,this}setArray2(p,_){return this._checkUniform(p),this._vectors2Arrays[p]=_,this}setArray3(p,_){return this._checkUniform(p),this._vectors3Arrays[p]=_,this}setArray4(p,_){return this._checkUniform(p),this._vectors4Arrays[p]=_,this}setUniformBuffer(p,_){return this._options.uniformBuffers.indexOf(p)===-1&&this._options.uniformBuffers.push(p),this._uniformBuffers[p]=_,this}setTextureSampler(p,_){return this._options.samplerObjects.indexOf(p)===-1&&this._options.samplerObjects.push(p),this._textureSamplers[p]=_,this}setStorageBuffer(p,_){return this._options.storageBuffers.indexOf(p)===-1&&this._options.storageBuffers.push(p),this._storageBuffers[p]=_,this}setDefine(p,_){const E=p.trimEnd()+" ",A=this.options.defines.findIndex($=>$===p||$.startsWith(E));return A>=0&&this.options.defines.splice(A,1),(typeof _!="boolean"||_)&&this.options.defines.push(E+_),this}isReadyForSubMesh(p,_,E){return this.isReady(p,E,_)}isReady(p,_,E){const A=E&&this._storeEffectOnSubMeshes;if(this.isFrozen){const Wt=A?E._drawWrapper:this._drawWrapper;if(Wt.effect&&Wt._wasPreviouslyReady&&Wt._wasPreviouslyUsingInstances===_)return!0}const $=this.getScene(),ne=$.getEngine(),xe=[],ce=[],Te=new p_;let Re=this._shaderPath,ke=this._options.uniforms,We=this._options.uniformBuffers,Xe=this._options.samplers;ne.getCaps().multiview&&$.activeCamera&&$.activeCamera.outputRenderTarget&&$.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,xe.push("#define MULTIVIEW"),ke.indexOf("viewProjection")!==-1&&ke.indexOf("viewProjectionR")===-1&&ke.push("viewProjectionR"));for(let Wt=0;Wt<this._options.defines.length;Wt++){const zt=this._options.defines[Wt].indexOf("#define")===0?this._options.defines[Wt]:`#define ${this._options.defines[Wt]}`;xe.push(zt)}for(let Wt=0;Wt<this._options.attributes.length;Wt++)ce.push(this._options.attributes[Wt]);if(p&&p.isVerticesDataPresent(ut.ColorKind)&&(ce.indexOf(ut.ColorKind)===-1&&ce.push(ut.ColorKind),xe.push("#define VERTEXCOLOR")),_&&(xe.push("#define INSTANCES"),nr.PushAttributesForInstances(ce,this._materialHelperNeedsPreviousMatrices),p?.hasThinInstances&&(xe.push("#define THIN_INSTANCES"),p&&p.isVerticesDataPresent(ut.ColorInstanceKind)&&(ce.push(ut.ColorInstanceKind),xe.push("#define INSTANCESCOLOR")))),p&&p.useBones&&p.computeBonesUsingShaders&&p.skeleton){ce.push(ut.MatricesIndicesKind),ce.push(ut.MatricesWeightsKind),p.numBoneInfluencers>4&&(ce.push(ut.MatricesIndicesExtraKind),ce.push(ut.MatricesWeightsExtraKind));const Wt=p.skeleton;xe.push("#define NUM_BONE_INFLUENCERS "+p.numBoneInfluencers),Te.addCPUSkinningFallback(0,p),Wt.isUsingTextureForMatrices?(xe.push("#define BONETEXTURE"),ke.indexOf("boneTextureWidth")===-1&&ke.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(xe.push("#define BonesPerMesh "+(Wt.bones.length+1)),ke.indexOf("mBones")===-1&&ke.push("mBones"))}else xe.push("#define NUM_BONE_INFLUENCERS 0");let xt=0;const qe=p?p.morphTargetManager:null;if(qe){const Wt=qe.supportsUVs&&xe.indexOf("#define UV1")!==-1,zt=qe.supportsTangents&&xe.indexOf("#define TANGENT")!==-1,xi=qe.supportsNormals&&xe.indexOf("#define NORMAL")!==-1;xt=qe.numMaxInfluencers||qe.numInfluencers,Wt&&xe.push("#define MORPHTARGETS_UV"),zt&&xe.push("#define MORPHTARGETS_TANGENT"),xi&&xe.push("#define MORPHTARGETS_NORMAL"),xt>0&&xe.push("#define MORPHTARGETS"),qe.isUsingTextureForTargets&&(xe.push("#define MORPHTARGETS_TEXTURE"),ke.indexOf("morphTargetTextureIndices")===-1&&ke.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),xe.push("#define NUM_MORPH_INFLUENCERS "+xt);for(let wi=0;wi<xt;wi++)ce.push(ut.PositionKind+wi),xi&&ce.push(ut.NormalKind+wi),zt&&ce.push(ut.TangentKind+wi),Wt&&ce.push(ut.UVKind+"_"+wi);xt>0&&(ke=ke.slice(),ke.push("morphTargetInfluences"),ke.push("morphTargetCount"),ke.push("morphTargetTextureInfo"),ke.push("morphTargetTextureIndices"))}else xe.push("#define NUM_MORPH_INFLUENCERS 0");if(p){const Wt=p.bakedVertexAnimationManager;Wt&&Wt.isEnabled&&(xe.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),ke.indexOf("bakedVertexAnimationSettings")===-1&&ke.push("bakedVertexAnimationSettings"),ke.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&ke.push("bakedVertexAnimationTextureSizeInverted"),ke.indexOf("bakedVertexAnimationTime")===-1&&ke.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture")),nr.PrepareAttributesForBakedVertexAnimation(ce,p,xe)}for(const Wt in this._textures)if(!this._textures[Wt].isReady())return!1;p&&this._shouldTurnAlphaTestOn(p)&&xe.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(cg(ke),l_(this,$,xe)),$.fogEnabled&&p?.applyFog&&$.fogMode!==W0.FOGMODE_NONE&&(xe.push("#define FOG"),ke.indexOf("view")===-1&&ke.push("view"),ke.indexOf("vFogInfos")===-1&&ke.push("vFogInfos"),ke.indexOf("vFogColor")===-1&&ke.push("vFogColor")),this._useLogarithmicDepth&&(xe.push("#define LOGARITHMICDEPTH"),ke.indexOf("logarithmicDepthConstant")===-1&&ke.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(ke=ke.slice(),We=We.slice(),Xe=Xe.slice(),Re=this.customShaderNameResolve(Re,ke,We,Xe,xe,ce));const ht=A?E._getDrawWrapper(void 0,!0):this._drawWrapper,Nt=ht?.effect??null,wt=ht?.defines??null,Qt=xe.join(`
`);let Ht=Nt;return wt!==Qt&&(Ht=ne.createEffect(Re,{attributes:ce,uniformsNames:ke,uniformBuffersNames:We,samplers:Xe,defines:Qt,fallbacks:Te,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:xt},shaderLanguage:this._options.shaderLanguage},ne),A?E.setEffect(Ht,Qt,this._materialContext):ht&&ht.setEffect(Ht,Qt),this._onEffectCreatedObservable&&(m_.effect=Ht,m_.subMesh=E??p?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(m_))),ht._wasPreviouslyUsingInstances=!!_,Ht?.isReady()?(Nt!==Ht&&$.resetCachedMaterial(),ht._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(p,_){const E=this.getScene(),A=_??this.getEffect();A&&(this._options.uniforms.indexOf("world")!==-1&&A.setMatrix("world",p),this._options.uniforms.indexOf("worldView")!==-1&&(p.multiplyToRef(E.getViewMatrix(),this._cachedWorldViewMatrix),A.setMatrix("worldView",this._cachedWorldViewMatrix)),this._options.uniforms.indexOf("worldViewProjection")!==-1&&(p.multiplyToRef(E.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),A.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),this._options.uniforms.indexOf("view")!==-1&&A.setMatrix("view",E.getViewMatrix()))}bindForSubMesh(p,_,E){this.bind(p,_,E._drawWrapperOverride?.effect,E)}bind(p,_,E,A){const $=A&&this._storeEffectOnSubMeshes,ne=E??($?A.effect:this.getEffect());if(!ne)return;const xe=this.getScene();this._activeEffect=ne,this.bindOnlyWorldMatrix(p,E);const ce=this._options.uniformBuffers;let Te=!1;if(ne&&ce&&ce.length>0&&xe.getEngine().supportsUniformBuffers)for(let ke=0;ke<ce.length;++ke)switch(ce[ke]){case"Mesh":_&&(_.getMeshUniformBuffer().bindToEffect(ne,"Mesh"),_.transferToEffect(p));break;case"Scene":nr.BindSceneUniformBuffer(ne,xe.getSceneUniformBuffer()),xe.finalizeSceneUbo(),Te=!0;break}const Re=_&&$?this._mustRebind(xe,ne,A,_.visibility):xe.getCachedMaterial()!==this;if(ne&&Re){!Te&&this._options.uniforms.indexOf("view")!==-1&&ne.setMatrix("view",xe.getViewMatrix()),!Te&&this._options.uniforms.indexOf("projection")!==-1&&ne.setMatrix("projection",xe.getProjectionMatrix()),!Te&&this._options.uniforms.indexOf("viewProjection")!==-1&&(ne.setMatrix("viewProjection",xe.getTransformMatrix()),this._multiview&&ne.setMatrix("viewProjectionR",xe._transformMatrixR)),xe.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&ne.setVector3("cameraPosition",xe.activeCamera.globalPosition),nr.BindBonesParameters(_,ne),ug(ne,this,xe),this._useLogarithmicDepth&&nr.BindLogDepth($?A.materialDefines:ne.defines,ne,xe),_&&nr.BindFogParameters(xe,_,ne);let ke;for(ke in this._textures)ne.setTexture(ke,this._textures[ke]);for(ke in this._textureArrays)ne.setTextureArray(ke,this._textureArrays[ke]);for(ke in this._externalTextures)ne.setExternalTexture(ke,this._externalTextures[ke]);for(ke in this._ints)ne.setInt(ke,this._ints[ke]);for(ke in this._uints)ne.setUInt(ke,this._uints[ke]);for(ke in this._floats)ne.setFloat(ke,this._floats[ke]);for(ke in this._floatsArrays)ne.setArray(ke,this._floatsArrays[ke]);for(ke in this._colors3)ne.setColor3(ke,this._colors3[ke]);for(ke in this._colors3Arrays)ne.setArray3(ke,this._colors3Arrays[ke]);for(ke in this._colors4){const We=this._colors4[ke];ne.setFloat4(ke,We.r,We.g,We.b,We.a)}for(ke in this._colors4Arrays)ne.setArray4(ke,this._colors4Arrays[ke]);for(ke in this._vectors2)ne.setVector2(ke,this._vectors2[ke]);for(ke in this._vectors3)ne.setVector3(ke,this._vectors3[ke]);for(ke in this._vectors4)ne.setVector4(ke,this._vectors4[ke]);for(ke in this._quaternions)ne.setQuaternion(ke,this._quaternions[ke]);for(ke in this._matrices)ne.setMatrix(ke,this._matrices[ke]);for(ke in this._matrixArrays)ne.setMatrices(ke,this._matrixArrays[ke]);for(ke in this._matrices3x3)ne.setMatrix3x3(ke,this._matrices3x3[ke]);for(ke in this._matrices2x2)ne.setMatrix2x2(ke,this._matrices2x2[ke]);for(ke in this._vectors2Arrays)ne.setArray2(ke,this._vectors2Arrays[ke]);for(ke in this._vectors3Arrays)ne.setArray3(ke,this._vectors3Arrays[ke]);for(ke in this._vectors4Arrays)ne.setArray4(ke,this._vectors4Arrays[ke]);for(ke in this._quaternionsArrays)ne.setArray4(ke,this._quaternionsArrays[ke]);for(ke in this._uniformBuffers){const We=this._uniformBuffers[ke].getBuffer();We&&ne.bindUniformBuffer(We,ke)}for(ke in this._textureSamplers)ne.setTextureSampler(ke,this._textureSamplers[ke]);for(ke in this._storageBuffers)ne.setStorageBuffer(ke,this._storageBuffers[ke])}if(ne&&_&&(Re||!this.isFrozen)){const ke=_.morphTargetManager;ke&&ke.numInfluencers>0&&nr.BindMorphTargetParameters(_,ne);const We=_.bakedVertexAnimationManager;if(We&&We.isEnabled){const Xe=$?A._drawWrapper:this._drawWrapper;_.bakedVertexAnimationManager?.bind(ne,!!Xe._wasPreviouslyUsingInstances)}}this._afterBind(_,ne,A)}getActiveTextures(){const p=super.getActiveTextures();for(const _ in this._textures)p.push(this._textures[_]);for(const _ in this._textureArrays){const E=this._textureArrays[_];for(let A=0;A<E.length;A++)p.push(E[A])}return p}hasTexture(p){if(super.hasTexture(p))return!0;for(const _ in this._textures)if(this._textures[_]===p)return!0;for(const _ in this._textureArrays){const E=this._textureArrays[_];for(let A=0;A<E.length;A++)if(E[A]===p)return!0}return!1}clone(p){const _=Xr.Clone(()=>new $h(p,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);_.name=p,_.id=p,typeof _._shaderPath=="object"&&(_._shaderPath={..._._shaderPath}),this._options={...this._options},Object.keys(this._options).forEach(E=>{const A=this._options[E];Array.isArray(A)&&(this._options[E]=A.slice(0))}),this.stencil.copyTo(_.stencil);for(const E in this._textures)_.setTexture(E,this._textures[E]);for(const E in this._textureArrays)_.setTextureArray(E,this._textureArrays[E]);for(const E in this._externalTextures)_.setExternalTexture(E,this._externalTextures[E]);for(const E in this._ints)_.setInt(E,this._ints[E]);for(const E in this._uints)_.setUInt(E,this._uints[E]);for(const E in this._floats)_.setFloat(E,this._floats[E]);for(const E in this._floatsArrays)_.setFloats(E,this._floatsArrays[E]);for(const E in this._colors3)_.setColor3(E,this._colors3[E]);for(const E in this._colors3Arrays)_._colors3Arrays[E]=this._colors3Arrays[E];for(const E in this._colors4)_.setColor4(E,this._colors4[E]);for(const E in this._colors4Arrays)_._colors4Arrays[E]=this._colors4Arrays[E];for(const E in this._vectors2)_.setVector2(E,this._vectors2[E]);for(const E in this._vectors3)_.setVector3(E,this._vectors3[E]);for(const E in this._vectors4)_.setVector4(E,this._vectors4[E]);for(const E in this._quaternions)_.setQuaternion(E,this._quaternions[E]);for(const E in this._quaternionsArrays)_._quaternionsArrays[E]=this._quaternionsArrays[E];for(const E in this._matrices)_.setMatrix(E,this._matrices[E]);for(const E in this._matrixArrays)_._matrixArrays[E]=this._matrixArrays[E].slice();for(const E in this._matrices3x3)_.setMatrix3x3(E,this._matrices3x3[E]);for(const E in this._matrices2x2)_.setMatrix2x2(E,this._matrices2x2[E]);for(const E in this._vectors2Arrays)_.setArray2(E,this._vectors2Arrays[E]);for(const E in this._vectors3Arrays)_.setArray3(E,this._vectors3Arrays[E]);for(const E in this._vectors4Arrays)_.setArray4(E,this._vectors4Arrays[E]);for(const E in this._uniformBuffers)_.setUniformBuffer(E,this._uniformBuffers[E]);for(const E in this._textureSamplers)_.setTextureSampler(E,this._textureSamplers[E]);for(const E in this._storageBuffers)_.setStorageBuffer(E,this._storageBuffers[E]);return _}dispose(p,_,E){if(_){let A;for(A in this._textures)this._textures[A].dispose();for(A in this._textureArrays){const $=this._textureArrays[A];for(let ne=0;ne<$.length;ne++)$[ne].dispose()}}this._textures={},super.dispose(p,_,E)}serialize(){const p=Xr.Serialize(this);p.customType="BABYLON.ShaderMaterial",p.uniqueId=this.uniqueId,p.options=this._options,p.shaderPath=this._shaderPath,p.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let _;p.stencil=this.stencil.serialize(),p.textures={};for(_ in this._textures)p.textures[_]=this._textures[_].serialize();p.textureArrays={};for(_ in this._textureArrays){p.textureArrays[_]=[];const E=this._textureArrays[_];for(let A=0;A<E.length;A++)p.textureArrays[_].push(E[A].serialize())}p.ints={};for(_ in this._ints)p.ints[_]=this._ints[_];p.uints={};for(_ in this._uints)p.uints[_]=this._uints[_];p.floats={};for(_ in this._floats)p.floats[_]=this._floats[_];p.floatsArrays={};for(_ in this._floatsArrays)p.floatsArrays[_]=this._floatsArrays[_];p.colors3={};for(_ in this._colors3)p.colors3[_]=this._colors3[_].asArray();p.colors3Arrays={};for(_ in this._colors3Arrays)p.colors3Arrays[_]=this._colors3Arrays[_];p.colors4={};for(_ in this._colors4)p.colors4[_]=this._colors4[_].asArray();p.colors4Arrays={};for(_ in this._colors4Arrays)p.colors4Arrays[_]=this._colors4Arrays[_];p.vectors2={};for(_ in this._vectors2)p.vectors2[_]=this._vectors2[_].asArray();p.vectors3={};for(_ in this._vectors3)p.vectors3[_]=this._vectors3[_].asArray();p.vectors4={};for(_ in this._vectors4)p.vectors4[_]=this._vectors4[_].asArray();p.quaternions={};for(_ in this._quaternions)p.quaternions[_]=this._quaternions[_].asArray();p.matrices={};for(_ in this._matrices)p.matrices[_]=this._matrices[_].asArray();p.matrixArray={};for(_ in this._matrixArrays)p.matrixArray[_]=this._matrixArrays[_];p.matrices3x3={};for(_ in this._matrices3x3)p.matrices3x3[_]=this._matrices3x3[_];p.matrices2x2={};for(_ in this._matrices2x2)p.matrices2x2[_]=this._matrices2x2[_];p.vectors2Arrays={};for(_ in this._vectors2Arrays)p.vectors2Arrays[_]=this._vectors2Arrays[_];p.vectors3Arrays={};for(_ in this._vectors3Arrays)p.vectors3Arrays[_]=this._vectors3Arrays[_];p.vectors4Arrays={};for(_ in this._vectors4Arrays)p.vectors4Arrays[_]=this._vectors4Arrays[_];p.quaternionsArrays={};for(_ in this._quaternionsArrays)p.quaternionsArrays[_]=this._quaternionsArrays[_];return p}static Parse(p,_,E){const A=Xr.Parse(()=>new $h(p.name,_,p.shaderPath,p.options,p.storeEffectOnSubMeshes),p,_,E);let $;p.stencil&&A.stencil.parse(p.stencil,_,E);for($ in p.textures)A.setTexture($,Hi.Parse(p.textures[$],_,E));for($ in p.textureArrays){const ne=p.textureArrays[$],xe=[];for(let ce=0;ce<ne.length;ce++)xe.push(Hi.Parse(ne[ce],_,E));A.setTextureArray($,xe)}for($ in p.ints)A.setInt($,p.ints[$]);for($ in p.uints)A.setUInt($,p.uints[$]);for($ in p.floats)A.setFloat($,p.floats[$]);for($ in p.floatsArrays)A.setFloats($,p.floatsArrays[$]);for($ in p.colors3)A.setColor3($,ws.FromArray(p.colors3[$]));for($ in p.colors3Arrays){const ne=p.colors3Arrays[$].reduce((xe,ce,Te)=>(Te%3===0?xe.push([ce]):xe[xe.length-1].push(ce),xe),[]).map(xe=>ws.FromArray(xe));A.setColor3Array($,ne)}for($ in p.colors4)A.setColor4($,vr.FromArray(p.colors4[$]));for($ in p.colors4Arrays){const ne=p.colors4Arrays[$].reduce((xe,ce,Te)=>(Te%4===0?xe.push([ce]):xe[xe.length-1].push(ce),xe),[]).map(xe=>vr.FromArray(xe));A.setColor4Array($,ne)}for($ in p.vectors2)A.setVector2($,xr.FromArray(p.vectors2[$]));for($ in p.vectors3)A.setVector3($,nt.FromArray(p.vectors3[$]));for($ in p.vectors4)A.setVector4($,Gr.FromArray(p.vectors4[$]));for($ in p.quaternions)A.setQuaternion($,_s.FromArray(p.quaternions[$]));for($ in p.matrices)A.setMatrix($,Yt.FromArray(p.matrices[$]));for($ in p.matrixArray)A._matrixArrays[$]=new Float32Array(p.matrixArray[$]);for($ in p.matrices3x3)A.setMatrix3x3($,p.matrices3x3[$]);for($ in p.matrices2x2)A.setMatrix2x2($,p.matrices2x2[$]);for($ in p.vectors2Arrays)A.setArray2($,p.vectors2Arrays[$]);for($ in p.vectors3Arrays)A.setArray3($,p.vectors3Arrays[$]);for($ in p.vectors4Arrays)A.setArray4($,p.vectors4Arrays[$]);for($ in p.quaternionsArrays)A.setArray4($,p.quaternionsArrays[$]);return A}static ParseFromFileAsync(p,_,E,A=""){return new Promise(($,ne)=>{const xe=new za;xe.addEventListener("readystatechange",()=>{if(xe.readyState==4)if(xe.status==200){const ce=JSON.parse(xe.responseText),Te=this.Parse(ce,E||wr.LastCreatedScene,A);p&&(Te.name=p),$(Te)}else ne("Unable to load the ShaderMaterial")}),xe.open("GET",_),xe.send()})}static ParseFromSnippetAsync(p,_,E=""){return new Promise((A,$)=>{const ne=new za;ne.addEventListener("readystatechange",()=>{if(ne.readyState==4)if(ne.status==200){const xe=JSON.parse(JSON.parse(ne.responseText).jsonPayload),ce=JSON.parse(xe.shaderMaterial),Te=this.Parse(ce,_||wr.LastCreatedScene,E);Te.snippetId=p,A(Te)}else $("Unable to load the snippet "+p)}),ne.open("GET",this.SnippetUrl+"/"+p.replace(/#/g,"/")),ne.send()})}}$h.SnippetUrl="https://snippet.babylonjs.com",$h.CreateFromSnippetAsync=$h.ParseFromSnippetAsync,zs("BABYLON.ShaderMaterial",$h);const uE="bonesDeclaration",pE=`#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform highp sampler2D boneSampler;uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#endif
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}
#endif
#endif
#endif
`;Gi.IncludesShadersStore[uE]=pE;const Lk={name:uE,shader:pE},_E="bonesVertex",TE=`#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;Gi.IncludesShadersStore[_E]=TE;const kk={name:_E,shader:TE},vE="clipPlaneVertexDeclaration",RE=`#ifdef CLIPPLANE
uniform vec4 vClipPlane;varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;varying float fClipDistance6;
#endif
`;Gi.IncludesShadersStore[vE]=RE;const Uk={name:vE,shader:RE},ME="clipPlaneVertex",wE=`#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;Gi.IncludesShadersStore[ME]=wE;const Gk={name:ME,shader:wE},LE="instancesDeclaration",kE=`#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;Gi.IncludesShadersStore[LE]=kE;const zk={name:LE,shader:kE},UE="instancesVertex",GE=`#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;Gi.IncludesShadersStore[UE]=GE;const Wk={name:UE,shader:GE},zE="clipPlaneFragmentDeclaration",WE=`#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;Gi.IncludesShadersStore[zE]=WE;const Hk={name:zE,shader:WE},HE="clipPlaneFragment",XE=`#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{discard;}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{discard;}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{discard;}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{discard;}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{discard;}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{discard;}
#endif
`;Gi.IncludesShadersStore[HE]=XE;const Xk={name:HE,shader:XE};class KE extends null{constructor(p,_,E=1){super(p,_,["image"],{},jE("max",E),void 0,!0,!0)}}class YE extends null{constructor(p,_,E=1){super(p,_,["image"],{},jE("min",E),void 0,!0,!0)}}function jE(_e,p=1){return`
        precision mediump float;
        varying vec2 xy;
        uniform vec2 wh;
        uniform sampler2D image;
        void main() {
            float res = texture2D(image, xy).r;
            for (int x = -`+p+"; x <= "+p+`; x++)
                for (int y = -`+p+"; y <= "+p+`; y++)
                    res = `+_e+`(res, texture2D(image, xy + vec2(x, y) / wh).r);
            gl_FragColor = vec4(res, res, res, 1.0);
        }`}var Gw=Object.defineProperty,qE=Object.getOwnPropertySymbols,zw=Object.prototype.hasOwnProperty,Ww=Object.prototype.propertyIsEnumerable,$E=(_e,p,_)=>p in _e?Gw(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,Hw=(_e,p)=>{for(var _ in p||(p={}))zw.call(p,_)&&$E(_e,_,p[_]);if(qE)for(var _ of qE(p))Ww.call(p,_)&&$E(_e,_,p[_]);return _e};class Kk extends null{constructor(p={width:256,height:256}){super(),this.size=p,this.ordinal=o.PreProcess}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.maskTexture=new d(_,this.size,!0,!0),super.load(p)}unload(){var p;this.loaded&&((p=this.maskTexture)==null||p.dispose(),delete this.maskTexture,super.unload())}async update(p,_){const{maskTexture:E}=this;if(!this.loaded||!E)return;const A=_g(p);if(!A||!A.mask)return;this.size=Hw({},A.mask.size),E.resize(A.mask.size),E.update(A.mask.buffer);const $=E.texture();$&&(A.maskTex={texture:$,size:A.mask.size,box:A.mask.box})}}function pg(_e){return[_e[0][0],_e[0][1],_e[1][0]-_e[0][0],_e[1][1]-_e[0][1]]}function _g(_e){return"poses"in _e&&_e.poses[0]||"faces"in _e&&_e.faces[0]||"masks"in _e&&_e.masks[0]||void 0}function Yk(_e){var p;return(p=_g(_e))==null?void 0:p.mask}function au(_e){var p;return(p=_g(_e))==null?void 0:p.maskTex}var Xw=Object.defineProperty,rT=Object.getOwnPropertySymbols,Kw=Object.prototype.hasOwnProperty,Yw=Object.prototype.propertyIsEnumerable,nT=(_e,p,_)=>p in _e?Xw(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,aT=(_e,p)=>{for(var _ in p||(p={}))Kw.call(p,_)&&nT(_e,_,p[_]);if(rT)for(var _ of rT(p))Yw.call(p,_)&&nT(_e,_,p[_]);return _e};class jw{constructor(){this.upscalers=[],this.upscaleSize={width:1024,height:1024}}load(p,_,E=.55,A=2){const $=aT({},_);for(let ne=0;ne<A;ne++){$.width*=2,$.height*=2;const xe=new x(p,$,["image","mask"],{rect:"4f"},qw(E),void 0,!0,!0),ce=new x(p,$,["mask"],{},$w(E),void 0,!0,!0);this.upscalers.push({edge:xe,fill:ce})}this.upscaleSize=$}unload(){this.upscalers.forEach(p=>{p.edge.dispose(),p.fill.dispose()}),this.upscalers=[]}upscale(p,_){const{upscalers:E}=this;if(E.length<1)return!1;const A=pg(p.box);let $=p.texture;for(let ne=0;ne<E.length;ne++){const xe=E[ne];xe.edge.process([_,$],{rect:A}),xe.fill.process([xe.edge.output()]),$=xe.fill.output()}return!0}mask(){var p;return((p=this.upscalers[this.upscalers.length-1])==null?void 0:p.fill.output())||null}size(){return this.upscaleSize}resize(p){const{upscalers:_}=this,E=aT({},p);for(let A=0;A<_.length;A++)E.width*=2,E.height*=2,_[A].edge.resize(E),_[A].fill.resize(E);this.upscaleSize=E}}const qw=(_e=.55)=>`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform vec4 rect;
    uniform sampler2D image;
    uniform sampler2D mask;

    vec4 avgColor(vec2 xyMask, vec2 whPix) {
        vec2 xy = xyMask * rect.zw + rect.xy;
        vec2 dxy = whPix * rect.zw / 3.0;
        vec4 color = vec4(0.0);
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                color += texture2D(image, xy + vec2(i, j) * dxy);
        return color / 9.0;
    }

    float minDiff(vec2 xyI, vec4 color) {
        // vec4 c = avgColor(xyI / wh, 1.0 / wh);
        // vec3 diff = color.rgb - c.rgb;
        // float ra = 0.5 * (color.r + c.r);
        // diff = diff * diff;
        // return (2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b;
        vec2 xyMask = xyI / wh;
        vec2 whPix = 1.0 / (2.0 * wh);
        float dist = 100.0;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                vec4 c = avgColor(xyMask + vec2(i, j) * whPix, whPix);
                vec3 diff = color.rgb - c.rgb;
                float ra = 0.5 * (color.r + c.r);
                diff = diff * diff;
                dist = min((2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b, dist);
            }
        }
        return dist;
    }

    float minDist(vec2 xyI, vec2 dxy, vec4 color) {
        vec2 dxyI = 0.25 * dxy;
        float dist = 100.0;
        for (int i = 0; i < 8; i++) {
            vec4 c = texture2D(image, (xyI + float(i) * dxyI) / wh * rect.zw + rect.xy);
            vec3 diff = color.rgb - c.rgb;
            float ra = 0.5 * (color.r + c.r);
            diff = diff * diff;
            dist = min((2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b, dist);
        }
        return dist;
    }

    void main() {
        vec2 xyI = floor(xy * wh);
        float val[9];
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                val[j * 3 + i] = texture2D(mask,
                    (xyI + vec2(i, j) - 1.0) / wh).r;
        bool fg[9];
        int fgCount = 0;
        for (int i = 0; i < 9; i++) {
            fg[i] = val[i] > `+_e+`;
            fgCount += int(fg[i]);
        }
        if (fgCount <= 0) {
            float valMin = min(val[0], min(
                min(min(val[1], val[2]), min(val[3], val[4])),
                min(min(val[5], val[6]), min(val[7], val[8]))));
            gl_FragColor = vec4(valMin, 0, 0, 1);
            return;
        }
        if (fgCount >= 9) {
            float valMax = max(val[0], max(
                max(max(val[1], val[2]), max(val[3], val[4])),
                max(max(val[5], val[6]), max(val[7], val[8]))));
            gl_FragColor = vec4(valMax, 0, 0, 1);
            return;
        }
        vec2 dxy = normalize(vec2(
            val[2] + 2.0 * val[5] + val[8] - val[0] - 2.0 * val[3] - val[6],
            val[6] + 2.0 * val[7] + val[8] - val[0] - 2.0 * val[1] - val[2]));
        vec4 color = avgColor(xyI / wh, 1.0 / wh);
        vec2 xyFg = xyI + (fg[4] ? 2.0 : 3.0) * dxy;
        vec2 xyBg = xyI - (fg[4] ? 3.0 : 2.0) * dxy;
        vec2 diffFgBg = sqrt(vec2(
            minDist(xyFg,  dxy, color),
            minDist(xyBg, -dxy, color)));
        diffFgBg /= diffFgBg.x + diffFgBg.y;
        vec2 valBgFg = vec2(texture2D(mask, xyBg / wh).r,
                            texture2D(mask, xyFg / wh).r);
        float valInter = dot(valBgFg, diffFgBg);
        gl_FragColor = vec4(valInter, 1, 0, 1);
    }
`,$w=(_e=.55)=>`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform sampler2D mask;

    void main() {
        vec2 xyI = floor(xy * wh);
        vec4 val0 = texture2D(mask, xyI / wh);
        if (val0.r > `+_e+`) {
            gl_FragColor = val0;
            return;
        }
        float val[9];
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                val[j * 3 + i] = texture2D(mask,
                    (xyI + vec2(i, j) - 1.0) / wh).r;
        bool fg[9];
        int fgCount = 0;
        for (int i = 0; i < 9; i++) {
            fg[i] = val[i] > `+_e+`;
            fgCount += int(fg[i]);
        }
        float valMax = max(val[0], max(
            max(max(val[1], val[2]), max(val[3], val[4])),
            max(max(val[5], val[6]), max(val[7], val[8]))));
        if (fg[0] && fg[8] || fg[1] && fg[7] ||
            fg[2] && fg[6] || fg[3] && fg[5] || fgCount >= 4) {
            gl_FragColor = vec4(valMax, 1, 0, 1);
            return;
        }
        gl_FragColor = val0;
    }
`;var rD=Object.defineProperty,xT=Object.getOwnPropertySymbols,nD=Object.prototype.hasOwnProperty,aD=Object.prototype.propertyIsEnumerable,lT=(_e,p,_)=>p in _e?rD(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,hT=(_e,p)=>{for(var _ in p||(p={}))nD.call(p,_)&&lT(_e,_,p[_]);if(xT)for(var _ of xT(p))aD.call(p,_)&&lT(_e,_,p[_]);return _e};class jk extends null{constructor(p=.55,_=2,E={width:256,height:256}){super(),this.thresh=p,this.steps=_,this.size=E,this.upscaler=new jw,this.ordinal=o.Process}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.upscaler.load(_,this.size,this.thresh,this.steps),super.load(p)}unload(){this.loaded&&(this.upscaler.unload(),super.unload())}async update(p,_){var E;const{renderer:A}=this;if(!this.loaded||!(A instanceof i))return;const $=(E=A.input)==null?void 0:E.texture(),ne=_g(p);if(!ne||!ne.maskTex||!$)return;this.size=hT({},ne.maskTex.size),this.upscaler.resize(ne.maskTex.size);const xe=this.upscaler.upscale(ne.maskTex,$)&&this.upscaler.mask();xe&&(ne.maskTex.texture=xe,ne.maskTex={texture:xe,size:hT({},this.upscaler.size()),box:ne.maskTex.box})}}var xD=Object.defineProperty,cT=Object.getOwnPropertySymbols,lD=Object.prototype.hasOwnProperty,hD=Object.prototype.propertyIsEnumerable,uT=(_e,p,_)=>p in _e?xD(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,cD=(_e,p)=>{for(var _ in p||(p={}))lD.call(p,_)&&uT(_e,_,p[_]);if(cT)for(var _ of cT(p))hD.call(p,_)&&uT(_e,_,p[_]);return _e};class qk extends null{constructor(p=2,_={width:256,height:256}){super(),this.smooth=p,this.size=_,this.gaussian=[],this.ordinal=o.Process;const E=-.5/p**2,A=Math.floor(2*p);this.gaussian.push(1);let $=1;for(let ne=1;ne<=A;ne++){const xe=Math.exp(E*ne**2);this.gaussian.push(xe),this.gaussian.unshift(xe),$+=2*xe}for(let ne=0;ne<this.gaussian.length;ne++)this.gaussian[ne]/=$}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.xpass=new x(_,this.size,["image"],{kernel:"1fv"},pT("x",this.smooth),void 0,!0,!0),this.xpass.setUniform("kernel",this.gaussian),this.ypass=new x(_,this.size,["image"],{kernel:"1fv"},pT("y",this.smooth),void 0,!0,!0),this.ypass.setUniform("kernel",this.gaussian),super.load(p)}unload(){var p,_;this.loaded&&((p=this.xpass)==null||p.dispose(),delete this.xpass,(_=this.ypass)==null||_.dispose(),delete this.ypass,super.unload())}async update(p,_){const E=au(p);if(!E)return;const{xpass:A,ypass:$}=this;if(!A||!$)return;this.size=cD({},E.size),A.resize(E.size),$.resize(E.size);const ne=A.process([E.texture]),xe=ne&&$.process([ne]);xe&&(E.texture=xe)}}function pT(_e,p){const _=_e==="x"?["x","x","0"]:["y","0","y"],E=Math.floor(2*p);return`
            precision mediump float;
            varying vec2 xy;
            uniform vec2 wh;
            uniform float kernel[`+(2*E+1)+`];
            uniform sampler2D image;

            void main() {
                float result = 0.0;
                for (int `+_[0]+" = "+-E+"; "+_[0]+" <= "+E+"; "+_[0]+`++)
                    result += kernel[`+_[0]+" + "+E+`] *
                        texture2D(image, xy + vec2(`+_[1]+", "+_[2]+`) / wh).r;
                gl_FragColor = vec4(result, result, result, 1.0);
            }`}var uD=Object.defineProperty,_T=Object.getOwnPropertySymbols,pD=Object.prototype.hasOwnProperty,_D=Object.prototype.propertyIsEnumerable,TT=(_e,p,_)=>p in _e?uD(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,TD=(_e,p)=>{for(var _ in p||(p={}))pD.call(p,_)&&TT(_e,_,p[_]);if(_T)for(var _ of _T(p))_D.call(p,_)&&TT(_e,_,p[_]);return _e};class $k extends null{constructor(p=1,_={width:256,height:256}){super(),this.radius=p,this.size=_,this.ordinal=o.Process}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.shader=new KE(_,this.size,this.radius),super.load(p)}unload(){var p;this.loaded&&((p=this.shader)==null||p.dispose(),delete this.shader,super.unload())}async update(p,_){const{shader:E}=this;if(!this.loaded||!E)return;const A=au(p);if(!A)return;this.size=TD({},A.size),E.resize(A.size);const $=E.process([A.texture]);$&&(A.texture=$)}}var vD=Object.defineProperty,vT=Object.getOwnPropertySymbols,RD=Object.prototype.hasOwnProperty,MD=Object.prototype.propertyIsEnumerable,RT=(_e,p,_)=>p in _e?vD(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,wD=(_e,p)=>{for(var _ in p||(p={}))RD.call(p,_)&&RT(_e,_,p[_]);if(vT)for(var _ of vT(p))MD.call(p,_)&&RT(_e,_,p[_]);return _e};class rU extends null{constructor(p=1,_={width:256,height:256}){super(),this.radius=p,this.size=_,this.ordinal=o.Process}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.shader=new YE(_,this.size,this.radius),super.load(p)}unload(){var p;this.loaded&&((p=this.shader)==null||p.dispose(),delete this.shader,super.unload())}async update(p,_){const{shader:E}=this;if(!this.loaded||!E)return;const A=au(p);if(!A)return;this.size=wD({},A.size),E.resize(A.size);const $=E.process([A.texture]);$&&(A.texture=$)}}var LD=Object.defineProperty,MT=Object.getOwnPropertySymbols,kD=Object.prototype.hasOwnProperty,UD=Object.prototype.propertyIsEnumerable,wT=(_e,p,_)=>p in _e?LD(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,GD=(_e,p)=>{for(var _ in p||(p={}))kD.call(p,_)&&wT(_e,_,p[_]);if(MT)for(var _ of MT(p))UD.call(p,_)&&wT(_e,_,p[_]);return _e};class nU extends null{constructor(p=1,_={width:256,height:256}){super(),this.radius=p,this.size=_,this.ordinal=o.Process}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.shader=this.radius>0?new KE(_,this.size,this.radius):new YE(_,this.size,-this.radius),super.load(p)}unload(){var p;this.loaded&&((p=this.shader)==null||p.dispose(),delete this.shader,super.unload())}async update(p,_){const{shader:E}=this;if(!this.loaded||!E)return;const A=au(p);if(!A)return;this.size=GD({},A.size),E.resize(A.size);const $=E.process([A.texture]);$&&(A.texture=$)}}class aU extends null{constructor(p=11,_=.55){super(["image","smooth","mask"],{rect:"4f",kernel:"1fv"},WD(p,_)),this.smooth=p,this.gaussian=[];const E=-.5/p**2,A=Math.floor(2*p);this.gaussian.push(1);let $=1;for(let ne=1;ne<=A;ne++){const xe=Math.exp(E*ne**2);this.gaussian.push(xe),this.gaussian.unshift(xe),$+=2*xe}for(let ne=0;ne<this.gaussian.length;ne++)this.gaussian[ne]/=$}async load(p){var _;const E=p instanceof i&&p.shaderCtx;this.loaded||!E||(this.xpass=new x(E,this.size,["image"],{kernel:"1fv"},zD(this.smooth)),await super.load(p),this.xpass.setUniform("kernel",this.gaussian),(_=this.shader)==null||_.setUniform("kernel",this.gaussian))}unload(){var p;this.loaded&&((p=this.xpass)==null||p.dispose(),delete this.xpass,super.unload())}async process(p,_){const E=au(p);if(!E)return!1;const{xpass:A,shader:$}=this;if(!A||!$)return!1;const ne=pg(E.box);return A.process([_]),$.process([_,A.output(),E.texture],{rect:ne}),!0}setupVideo(p){var _;super.setupVideo(p),(_=this.xpass)==null||_.resize(p)}}function zD(_e){const p=Math.floor(2*_e);return`
            precision mediump float;
            varying vec2 xy;
            uniform vec2 wh;
            uniform float kernel[`+(2*p+1)+`];
            uniform sampler2D image;

            void main() {
                vec3 result = vec3(0.0);
                for (int x = `+-p+"; x <= "+p+`; x++)
                    result += kernel[x + `+p+`] *
                        texture2D(image, xy + vec2(x, 0) / wh).rgb;
                gl_FragColor = vec4(result, 1.0);
            }`}function WD(_e,p=.55){const _=Math.floor(2*_e);return`
            precision mediump float;
            varying vec2 xy;
            uniform vec2 wh;
            uniform vec4 rect;
            uniform float kernel[`+(2*_+1)+`];
            uniform sampler2D image;
            uniform sampler2D smooth;
            uniform sampler2D mask;

            void main() {
                vec2 xyMask = (xy - rect.xy) / rect.zw;
                bool fg = texture2D(mask, xyMask).r > `+p+` &&
                          min(xyMask.x, xyMask.y) >= 0.0 &&
                          max(xyMask.x, xyMask.y) <= 1.0;
                if (fg) {
                    gl_FragColor = texture2D(image, xy);
                    return;
                }
                vec3 result = vec3(0.0);
                for (int y = `+-_+"; y <= "+_+`; y++)
                    result += kernel[y + `+_+`] *
                        texture2D(smooth, xy + vec2(0, y) / wh).rgb;
                gl_FragColor = vec4(result, 1.0);
            }`}class xU extends null{constructor(p=7,_=.05){super(["image"],{kernel:"1fv"},LT("y",p,_)),this.smooth=p,this.sense=_,this.gaussian=[];const E=-.5/p**2,A=Math.floor(2*p);this.gaussian.push(1);let $=1;for(let ne=1;ne<=A;ne++){const xe=Math.exp(E*ne**2);this.gaussian.push(xe),this.gaussian.unshift(xe),$+=2*xe}for(let ne=0;ne<2*A+1;ne++)this.gaussian[ne]/=$}async load(p){var _;const E=p instanceof i&&p.shaderCtx;this.loaded||!E||(this.xpass=new x(E,this.size,["image"],{kernel:"1fv"},LT("x",this.smooth,this.sense)),await super.load(p),this.xpass.setUniform("kernel",this.gaussian),(_=this.shader)==null||_.setUniform("kernel",this.gaussian))}unload(){var p;this.loaded&&((p=this.xpass)==null||p.dispose(),delete this.xpass,super.unload())}async process(p,_){const{xpass:E,shader:A}=this;return!E||!A?!1:(E.process([_]),A.process([E.output()]),!0)}setupVideo(p){var _;super.setupVideo(p),(_=this.xpass)==null||_.resize(p)}}function LT(_e,p,_){const E=_e==="x"?["x","x","0"]:["y","0","y"],A=Math.floor(2*p);return`
            precision mediump float;
            varying vec2 xy;
            uniform sampler2D image;
            uniform vec2 wh;
            uniform float kernel[`+(2*A+1)+`];

            void main() {
                vec3 center = texture2D(image, xy).rgb;
                vec3 result = vec3(0.0);
                float norm = 0.0;
                for (int `+E[0]+" = "+-A+"; "+E[0]+" <= "+A+"; "+E[0]+`++) {
                    vec3 pixel = texture2D(image, xy + vec2(`+E[1]+", "+E[2]+`) / wh).rgb;
                    vec3 diff = center - pixel;
                    float kc = `+1/(_*Math.sqrt(2*Math.PI))+` *
                        exp(-0.5 * dot(diff, diff) / `+_*_+`);
                    float k = kernel[`+E[0]+" + "+A+`] * kc;
                    result += k * pixel;
                    norm += k;
                }
                gl_FragColor = vec4(result / norm, 1.0);
            }`}class lU extends null{constructor(p=.55,_=512){super(["image","mask"],{rect:"4f"},HD(p,_)),this.ordinal=o.PostRender}async process(p,_){const E=au(p),{shader:A}=this;if(!E||!A)return!1;const $=pg(E.box);return A.process([_,E.texture],{rect:$}),!0}}const HD=(_e=.55,p=512)=>{const _=Math.ceil(p/8);return`
        precision mediump float;
        varying vec2 xy;
        uniform vec2 wh;
        uniform vec4 rect;
        uniform sampler2D image;
        uniform sampler2D mask;

        float readMask(vec2 xy0, vec2 dxyI) {
            return texture2D(mask, (xy0 + dxyI / wh - rect.xy) / rect.zw).r;
        }

        vec4 readProp(vec2 xy0, vec2 dxyI, vec2 ddxyI) {
            return abs(dxyI.x) + abs(dxyI.y) < `+80 .toFixed(1)+` &&
                readMask(xy0, ddxyI) < `+_e+` ?
                texture2D(image, xy0 + ddxyI / wh) :
                texture2D(image, xy0 + dxyI / wh);
        }

        float traverse(vec2 xy0, vec2 dxyI) {
            bool bg = false;
            float d = 1.0;
            for (int di = 1; di < `+_+`; di++) {
                d = bg ? d : float(di * 8);
                bg = bg || readMask(xy0, d * dxyI) < `+_e+`;
            }
            bool bg1 = bg;
            for (int di = 1; di < 8; di++) {
                float d1 = d - 1.0;
                bg1 = bg1 && readMask(xy0, d1 * dxyI) < `+_e+`;
                d = bg1 ? d1 : d;
            }
            return bg ? d : -1.0;
        }

        void main() {
            bool bg = texture2D(mask, (xy - rect.xy) / (rect.zw)).r < `+_e+`;
            bool bg1;
            vec4 color = texture2D(image, xy);
            if (bg) {
                gl_FragColor = color;
                return;
            }

            float x0 = traverse(xy, vec2(-1.0, 0.0));
            bg = x0 > 0.0;
            vec4 cx0 = bg ? readProp(xy, vec2(-x0, 0.0),
                vec2(-2.0 * x0 + 1.0, 0.0)) : color;
            x0 = bg ? 1.0 / x0 : 0.0;

            float x1 = traverse(xy, vec2(1.0, 0.0));
            bg = x1 > 0.0;
            vec4 cx1 = bg ? readProp(xy, vec2(x1, 0.0),
                vec2(2.0 * x1 - 1.0, 0.0)) : color;
            x1 = bg ? 1.0 / x1 : 0.0;

            float y0 = traverse(xy, vec2(0.0, -1.0));
            bg = y0 > 0.0;
            vec4 cy0 = bg ? readProp(xy, vec2(0.0, -y0),
                vec2(0.0, -2.0 * y0 + 1.0)) : color;
            y0 = bg ? 1.0 / y0 : 0.0;

            float y1 = traverse(xy, vec2(0.0, 1.0));
            bg = y1 > 0.0;
            vec4 cy1 = bg ? readProp(xy, vec2(0.0, y1),
                vec2(0.0, 2.0 * y1 - 1.0)) : color;
            y1 = bg ? 1.0 / y1 : 0.0;

            float s = 1.0 / (x0 + x1 + y0 + y1);
            color = cx0 * x0 * s + cx1 * x1 * s + cy0 * y0 * s + cy1 * y1 * s;
            gl_FragColor = color;
        }`};class hU extends null{constructor(p,_=.5,E=.1,A={minCutOff:.05,minCutOffD:.1,beta:.05}){super(),this.callback=p,this.rangeMax=_,this.rangeMin=E,this.filterParams=A,this.gl=null,this.texture=null,this.frameBuffer=null,this.size={width:0,height:0},this.levels=1,this.ordinal=o.PreRender,this.rangeRatio=(1-E)/(_-E)}async load(p){if(this.loaded||!(p instanceof i)||!p.shaderCtx)return;const{shaderCtx:_}=p;if(this.frameBuffer=_.createFramebuffer(),!!this.frameBuffer)return this.gl=_,this.setupVideo(this.size),super.load(p)}unload(){if(!this.loaded)return;const{gl:p}=this;p?.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,p?.deleteTexture(this.texture),this.texture=null,this.gl=null,super.unload()}async update(p,_){const{gl:E,texture:A,size:{width:$,height:ne},levels:xe}=this;if(!this.loaded||!E||!A)return;const ce=E.getParameter(E.TEXTURE_BINDING_2D),Te=E.getParameter(E.FRAMEBUFFER_BINDING);E.bindTexture(E.TEXTURE_2D,A),E.texSubImage2D(E.TEXTURE_2D,0,0,0,$,ne,E.RGBA,E.UNSIGNED_BYTE,_),E.generateMipmap(E.TEXTURE_2D),E.bindFramebuffer(E.FRAMEBUFFER,this.frameBuffer),E.framebufferTexture2D(E.FRAMEBUFFER,E.COLOR_ATTACHMENT0,E.TEXTURE_2D,A,xe-1);const Re=new Uint8Array(4);E.readPixels(0,0,1,1,E.RGBA,E.UNSIGNED_BYTE,Re);let ke=(.299*Re[0]+.587*Re[1]+.114*Re[2])/255;ke=this.filter(ke),ke=Math.min(Math.max(ke,this.rangeMin),this.rangeMax),ke=(ke-this.rangeMin)*this.rangeRatio+this.rangeMin,this.callback&&this.callback(ke),E.bindTexture(E.TEXTURE_2D,ce),E.bindFramebuffer(E.FRAMEBUFFER,Te)}setupVideo(p){const{width:_,height:E}=p;if(_===this.size.width&&E===this.size.height&&this.texture)return!0;const{gl:A}=this;if(!A||(A.deleteTexture(this.texture),this.texture=null,(_>0||E>0)&&(this.texture=A.createTexture()),!this.texture))return!1;const $=A.getParameter(A.TEXTURE_BINDING_2D);return A.bindTexture(A.TEXTURE_2D,this.texture),this.size={width:_,height:E},this.levels=1+Math.floor(Math.log2(Math.max(_,E))),A.texStorage2D(A.TEXTURE_2D,this.levels,A.RGBA8,_,E),A.bindTexture(A.TEXTURE_2D,$),!0}setCallback(p){this.callback=p}filter(p){if(!this.smooth)return this.smooth={val:p,der:0,time:Date.now()/1e3},p;const{smooth:_,filterParams:E}=this,A=Date.now()/1e3;if(A<=_.time)return p;const $=1/(A-_.time);_.time=A;const ne=(p-_.val)*$,xe=Re=>1/(1+$/(2*Math.PI*Re)),ce=xe(E.minCutOffD);_.der=_.der+ce*(ne-_.der);const Te=xe(E.minCutOff+E.beta*Math.abs(_.der));return _.val=_.val+Te*(p-_.val),_.val}}class cU extends null{constructor(p){super(),this.callback=p,this.ordinal=o.PostProcess}async update(p,_){if(this.loaded)return this.callback(p),super.update(p,_)}}class uU extends null{}class pU extends null{}class _U extends null{constructor(p){super(),this.predicate=p,this.ordinal=o.PreProcess}async update(p,_){this.loaded&&(p.poses=p.poses.filter(this.predicate))}}class TU extends null{constructor(p){super(),this.predicate=p,this.ordinal=o.PreProcess}async update(p,_){if(this.loaded)return p.faces=p.faces.filter(this.predicate),super.update(p,_)}}class vU extends null{constructor(p){super(),this.callback=p,this.fpsStart=Date.now(),this.fpsCount=0,this.ordinal=o.PostRender}async load(p){return this.fpsStart=Date.now(),this.fpsCount=0,super.load(p)}async update(p,_){if(this.loaded){if(this.fpsCount++,this.fpsCount>=30){const E=Date.now(),A=this.fpsCount*1e3/(E-this.fpsStart);this.fpsCount=0,this.fpsStart=E,this.callback(A)}return super.update(p,_)}}}class RU extends null{constructor(p=.55){super(["image","mask"],{rect:"4f"},XD(p))}async process(p,_){var E;const A=au(p);if(!A)return!1;const $=pg(A.box);return(E=this.shader)==null||E.process([_,A.texture],{rect:$}),!0}}const XD=(_e=.55)=>`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform vec4 rect;
    uniform sampler2D image;
    uniform sampler2D mask;

    void main() {
        // vec2 xyMask = floor((xy - rect.xy) / rect.zw * 256.0 + 0.5) / 256.0;
        vec2 xyMask = (xy - rect.xy) / rect.zw;
        bool fg = texture2D(mask, xyMask).r > `+_e+` &&
                  min(xyMask.x, xyMask.y) >= 0.0 && max(xyMask.x, xyMask.y) <= 1.0;
        vec4 color = texture2D(image, xy);
        if (!fg) {
            gl_FragColor = color;
            return;
        }
        gl_FragColor = mix(color, vec4(1.0, 0.0, 0.0, 1.0), 0.5);
    }
`;class KD{get depthStencilTexture(){return this._depthStencilTexture}get depthStencilTextureWithStencil(){return this._depthStencilTextureWithStencil}get isCube(){return this._isCube}get isMulti(){return this._isMulti}get is2DArray(){return this.layers>0}get size(){return this.width}get width(){return this._size.width||this._size}get height(){return this._size.height||this._size}get layers(){return this._size.layers||0}get texture(){return this._textures?.[0]??null}get textures(){return this._textures}get faceIndices(){return this._faceIndices}get layerIndices(){return this._layerIndices}get samples(){return this._samples}setSamples(p,_=!0,E=!1){if(this.samples===p&&!E)return p;const A=this._isMulti?this._engine.updateMultipleRenderTargetTextureSampleCount(this,p,_):this._engine.updateRenderTargetTextureSampleCount(this,p);return this._samples=p,A}constructor(p,_,E,A,$){this._textures=null,this._faceIndices=null,this._layerIndices=null,this._samples=1,this._attachments=null,this._generateStencilBuffer=!1,this._generateDepthBuffer=!1,this._depthStencilTextureWithStencil=!1,this._isMulti=p,this._isCube=_,this._size=E,this._engine=A,this._depthStencilTexture=null,this.label=$}setTextures(p){Array.isArray(p)?this._textures=p:p?this._textures=[p]:this._textures=null}setTexture(p,_=0,E=!0){this._textures||(this._textures=[]),this._textures[_]!==p&&(this._textures[_]&&E&&this._textures[_].dispose(),this._textures[_]=p)}setLayerAndFaceIndices(p,_){this._layerIndices=p,this._faceIndices=_}setLayerAndFaceIndex(p=0,_,E){this._layerIndices||(this._layerIndices=[]),this._faceIndices||(this._faceIndices=[]),_!==void 0&&_>=0&&(this._layerIndices[p]=_),E!==void 0&&E>=0&&(this._faceIndices[p]=E)}createDepthStencilTexture(p=0,_=!0,E=!1,A=1,$=14,ne){return this._depthStencilTexture?.dispose(),this._depthStencilTextureWithStencil=E,this._depthStencilTextureLabel=ne,this._depthStencilTexture=this._engine.createDepthStencilTexture(this._size,{bilinearFiltering:_,comparisonFunction:p,generateStencil:E,isCube:this._isCube,samples:A,depthTextureFormat:$,label:ne},this),this._depthStencilTexture}_shareDepth(p){this._depthStencilTexture&&(p._depthStencilTexture&&p._depthStencilTexture.dispose(),p._depthStencilTexture=this._depthStencilTexture,this._depthStencilTexture.incrementReferences())}_swapAndDie(p){this.texture&&this.texture._swapAndDie(p),this._textures=null,this.dispose(!0)}_cloneRenderTargetWrapper(){let p=null;if(this._isMulti){const _=this.textures;if(_&&_.length>0){let E=!1,A=_.length,$=-1;const ne=_[_.length-1]._source;(ne===Gn.Depth||ne===Gn.DepthStencil)&&(E=!0,$=_[_.length-1].format,A--);const xe=[],ce=[],Te=[],Re=[],ke=[],We=[],Xe=[],xt={};for(let Nt=0;Nt<A;++Nt){const wt=_[Nt];xe.push(wt.samplingMode),ce.push(wt.type),Te.push(wt.format),xt[wt.uniqueId]!==void 0?(Re.push(-1),Xe.push(0)):(xt[wt.uniqueId]=Nt,wt.is2DArray?(Re.push(35866),Xe.push(wt.depth)):wt.isCube?(Re.push(34067),Xe.push(0)):wt.is3D?(Re.push(32879),Xe.push(wt.depth)):(Re.push(3553),Xe.push(0))),this._faceIndices&&ke.push(this._faceIndices[Nt]??0),this._layerIndices&&We.push(this._layerIndices[Nt]??0)}const qe={samplingModes:xe,generateMipMaps:_[0].generateMipMaps,generateDepthBuffer:this._generateDepthBuffer,generateStencilBuffer:this._generateStencilBuffer,generateDepthTexture:E,depthTextureFormat:$,types:ce,formats:Te,textureCount:A,targetTypes:Re,faceIndex:ke,layerIndex:We,layerCounts:Xe,label:this.label},ht={width:this.width,height:this.height};p=this._engine.createMultipleRenderTarget(ht,qe);for(let Nt=0;Nt<A;++Nt){if(Re[Nt]!==-1)continue;const wt=xt[_[Nt].uniqueId];p.setTexture(p.textures[wt],Nt)}}}else{const _={};if(_.generateDepthBuffer=this._generateDepthBuffer,_.generateMipMaps=this.texture?.generateMipMaps??!1,_.generateStencilBuffer=this._generateStencilBuffer,_.samplingMode=this.texture?.samplingMode,_.type=this.texture?.type,_.format=this.texture?.format,_.noColorAttachment=!this._textures,_.label=this.label,this.isCube)p=this._engine.createRenderTargetCubeTexture(this.width,_);else{const E={width:this.width,height:this.height,layers:this.is2DArray?this.texture?.depth:void 0};p=this._engine.createRenderTargetTexture(E,_)}p.texture&&(p.texture.isReady=!0)}return p}_swapRenderTargetWrapper(p){if(this._textures&&p._textures)for(let _=0;_<this._textures.length;++_)this._textures[_]._swapAndDie(p._textures[_],!1),p._textures[_].isReady=!0;this._depthStencilTexture&&p._depthStencilTexture&&(this._depthStencilTexture._swapAndDie(p._depthStencilTexture),p._depthStencilTexture.isReady=!0),this._textures=null,this._depthStencilTexture=null}_rebuild(){const p=this._cloneRenderTargetWrapper();if(p){if(this._depthStencilTexture){const _=this._depthStencilTexture.samplingMode,E=this._depthStencilTexture.format,A=_===2||_===3||_===11;p.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction,A,this._depthStencilTextureWithStencil,this._depthStencilTexture.samples,E,this._depthStencilTextureLabel)}this.samples>1&&p.setSamples(this.samples),p._swapRenderTargetWrapper(this),p.dispose()}}releaseTextures(){if(this._textures)for(let p=0;p<this._textures?.length;++p)this._textures[p].dispose();this._textures=null}dispose(p=!1){p||(this._depthStencilTexture?.dispose(),this._depthStencilTexture=null,this.releaseTextures()),this._engine._releaseRenderTargetWrapper(this)}}class YD extends KD{constructor(p,_,E,A,$){super(p,_,E,A),this._framebuffer=null,this._depthStencilBuffer=null,this._MSAAFramebuffer=null,this._colorTextureArray=null,this._depthStencilTextureArray=null,this._disposeOnlyFramebuffers=!1,this._currentLOD=0,this._context=$}_cloneRenderTargetWrapper(){let p=null;return this._colorTextureArray&&this._depthStencilTextureArray?(p=this._engine.createMultiviewRenderTargetTexture(this.width,this.height),p.texture.isReady=!0):p=super._cloneRenderTargetWrapper(),p}_swapRenderTargetWrapper(p){super._swapRenderTargetWrapper(p),p._framebuffer=this._framebuffer,p._depthStencilBuffer=this._depthStencilBuffer,p._MSAAFramebuffer=this._MSAAFramebuffer,p._colorTextureArray=this._colorTextureArray,p._depthStencilTextureArray=this._depthStencilTextureArray,this._framebuffer=this._depthStencilBuffer=this._MSAAFramebuffer=this._colorTextureArray=this._depthStencilTextureArray=null}createDepthStencilTexture(p=0,_=!0,E=!1,A=1,$=14,ne){if(this._depthStencilBuffer){const xe=this._engine._currentFramebuffer,ce=this._context;this._engine._bindUnboundFramebuffer(this._framebuffer),ce.framebufferRenderbuffer(ce.FRAMEBUFFER,ce.DEPTH_STENCIL_ATTACHMENT,ce.RENDERBUFFER,null),ce.framebufferRenderbuffer(ce.FRAMEBUFFER,ce.DEPTH_ATTACHMENT,ce.RENDERBUFFER,null),ce.framebufferRenderbuffer(ce.FRAMEBUFFER,ce.STENCIL_ATTACHMENT,ce.RENDERBUFFER,null),this._engine._bindUnboundFramebuffer(xe),ce.deleteRenderbuffer(this._depthStencilBuffer),this._depthStencilBuffer=null}return super.createDepthStencilTexture(p,_,E,A,$,ne)}_shareDepth(p){super._shareDepth(p);const _=this._context,E=this._depthStencilBuffer,A=p._MSAAFramebuffer||p._framebuffer;p._depthStencilBuffer&&p._depthStencilBuffer!==E&&_.deleteRenderbuffer(p._depthStencilBuffer),p._depthStencilBuffer=E;const $=p._generateStencilBuffer?_.DEPTH_STENCIL_ATTACHMENT:_.DEPTH_ATTACHMENT;this._engine._bindUnboundFramebuffer(A),_.framebufferRenderbuffer(_.FRAMEBUFFER,$,_.RENDERBUFFER,E),this._engine._bindUnboundFramebuffer(null)}_bindTextureRenderTarget(p,_=0,E,A=0){if(!p._hardwareTexture)return;const $=this._framebuffer,ne=this._engine._currentFramebuffer;if(this._engine._bindUnboundFramebuffer($),this._engine.webGLVersion>1){const xe=this._context,ce=xe["COLOR_ATTACHMENT"+_];p.is2DArray||p.is3D?(E=E??this.layerIndices?.[_]??0,xe.framebufferTextureLayer(xe.FRAMEBUFFER,ce,p._hardwareTexture.underlyingResource,A,E)):p.isCube?(E=E??this.faceIndices?.[_]??0,xe.framebufferTexture2D(xe.FRAMEBUFFER,ce,xe.TEXTURE_CUBE_MAP_POSITIVE_X+E,p._hardwareTexture.underlyingResource,A)):xe.framebufferTexture2D(xe.FRAMEBUFFER,ce,xe.TEXTURE_2D,p._hardwareTexture.underlyingResource,A)}else{const xe=this._context,ce=xe["COLOR_ATTACHMENT"+_+"_WEBGL"],Te=E!==void 0?xe.TEXTURE_CUBE_MAP_POSITIVE_X+E:xe.TEXTURE_2D;xe.framebufferTexture2D(xe.FRAMEBUFFER,ce,Te,p._hardwareTexture.underlyingResource,A)}this._engine._bindUnboundFramebuffer(ne)}setTexture(p,_=0,E=!0){super.setTexture(p,_,E),this._bindTextureRenderTarget(p,_)}setLayerAndFaceIndices(p,_){if(super.setLayerAndFaceIndices(p,_),!this.textures||!this.layerIndices||!this.faceIndices)return;const E=this._attachments?.length??this.textures.length;for(let A=0;A<E;A++){const $=this.textures[A];$&&($.is2DArray||$.is3D?this._bindTextureRenderTarget($,A,this.layerIndices[A]):$.isCube?this._bindTextureRenderTarget($,A,this.faceIndices[A]):this._bindTextureRenderTarget($,A))}}setLayerAndFaceIndex(p=0,_,E){if(super.setLayerAndFaceIndex(p,_,E),!this.textures||!this.layerIndices||!this.faceIndices)return;const A=this.textures[p];A.is2DArray||A.is3D?this._bindTextureRenderTarget(this.textures[p],p,this.layerIndices[p]):A.isCube&&this._bindTextureRenderTarget(this.textures[p],p,this.faceIndices[p])}dispose(p=this._disposeOnlyFramebuffers){const _=this._context;p||(this._colorTextureArray&&(this._context.deleteTexture(this._colorTextureArray),this._colorTextureArray=null),this._depthStencilTextureArray&&(this._context.deleteTexture(this._depthStencilTextureArray),this._depthStencilTextureArray=null)),this._framebuffer&&(_.deleteFramebuffer(this._framebuffer),this._framebuffer=null),this._depthStencilBuffer&&(_.deleteRenderbuffer(this._depthStencilBuffer),this._depthStencilBuffer=null),this._MSAAFramebuffer&&(_.deleteFramebuffer(this._MSAAFramebuffer),this._MSAAFramebuffer=null),super.dispose(p)}}rr.prototype._createHardwareRenderTargetWrapper=function(_e,p,_){const E=new YD(_e,p,_,this,this._gl);return this._renderTargetWrapperCache.push(E),E},rr.prototype.createRenderTargetTexture=function(_e,p){const _=this._createHardwareRenderTargetWrapper(!1,!1,_e);let E=!0,A=!1,$=!1,ne,xe=1,ce;p!==void 0&&typeof p=="object"&&(E=p.generateDepthBuffer??!0,A=!!p.generateStencilBuffer,$=!!p.noColorAttachment,ne=p.colorAttachment,xe=p.samples??1,ce=p.label);const Te=ne||($?null:this._createInternalTexture(_e,p,!0,Gn.RenderTarget)),Re=_e.width||_e,ke=_e.height||_e,We=this._currentFramebuffer,Xe=this._gl,xt=Xe.createFramebuffer();return this._bindUnboundFramebuffer(xt),_._depthStencilBuffer=this._setupFramebufferDepthAttachments(A,E,Re,ke),Te&&!Te.is2DArray&&Xe.framebufferTexture2D(Xe.FRAMEBUFFER,Xe.COLOR_ATTACHMENT0,Xe.TEXTURE_2D,Te._hardwareTexture.underlyingResource,0),this._bindUnboundFramebuffer(We),_.label=ce??"RenderTargetWrapper",_._framebuffer=xt,_._generateDepthBuffer=E,_._generateStencilBuffer=A,_.setTextures(Te),this.updateRenderTargetTextureSampleCount(_,xe),_},rr.prototype.createDepthStencilTexture=function(_e,p,_){if(p.isCube){const E=_e.width||_e;return this._createDepthStencilCubeTexture(E,p)}else return this._createDepthStencilTexture(_e,p,_)},rr.prototype._createDepthStencilTexture=function(_e,p){const _=this._gl,E=_e.layers||0,A=E!==0?_.TEXTURE_2D_ARRAY:_.TEXTURE_2D,$=new u0(this,Gn.DepthStencil);if($.label=p.label,!this._caps.depthTextureExtension)return vi.Error("Depth texture is not supported by your browser or hardware."),$;const ne={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...p};if(this._bindTextureDirectly(A,$,!0),this._setupDepthStencilTexture($,_e,ne.generateStencil,ne.comparisonFunction===0?!1:ne.bilinearFiltering,ne.comparisonFunction,ne.samples),ne.depthTextureFormat!==void 0){if(ne.depthTextureFormat!==15&&ne.depthTextureFormat!==16&&ne.depthTextureFormat!==17&&ne.depthTextureFormat!==13&&ne.depthTextureFormat!==14&&ne.depthTextureFormat!==18)return vi.Error("Depth texture format is not supported."),$;$.format=ne.depthTextureFormat}else $.format=ne.generateStencil?13:16;const xe=$.format===17||$.format===13||$.format===18;let ce=_.UNSIGNED_INT;$.format===15?ce=_.UNSIGNED_SHORT:$.format===17||$.format===13?ce=_.UNSIGNED_INT_24_8:$.format===14?ce=_.FLOAT:$.format===18&&(ce=_.FLOAT_32_UNSIGNED_INT_24_8_REV);const Te=xe?_.DEPTH_STENCIL:_.DEPTH_COMPONENT;let Re=Te;return this.webGLVersion>1&&($.format===15?Re=_.DEPTH_COMPONENT16:$.format===16?Re=_.DEPTH_COMPONENT24:$.format===17||$.format===13?Re=_.DEPTH24_STENCIL8:$.format===14?Re=_.DEPTH_COMPONENT32F:$.format===18&&(Re=_.DEPTH32F_STENCIL8)),$.is2DArray?_.texImage3D(A,0,Re,$.width,$.height,E,0,Te,ce,null):_.texImage2D(A,0,Re,$.width,$.height,0,Te,ce,null),this._bindTextureDirectly(A,null),this._internalTexturesCache.push($),$},rr.prototype.updateRenderTargetTextureSampleCount=function(_e,p){if(this.webGLVersion<2||!_e||!_e.texture)return 1;if(_e.samples===p)return p;const _=this._gl;p=Math.min(p,this.getCaps().maxMSAASamples),_e._depthStencilBuffer&&(_.deleteRenderbuffer(_e._depthStencilBuffer),_e._depthStencilBuffer=null),_e._MSAAFramebuffer&&(_.deleteFramebuffer(_e._MSAAFramebuffer),_e._MSAAFramebuffer=null);const E=_e.texture._hardwareTexture;if(E.releaseMSAARenderBuffers(),p>1&&typeof _.renderbufferStorageMultisample=="function"){const A=_.createFramebuffer();if(!A)throw new Error("Unable to create multi sampled framebuffer");_e._MSAAFramebuffer=A,this._bindUnboundFramebuffer(_e._MSAAFramebuffer);const $=this._createRenderBuffer(_e.texture.width,_e.texture.height,p,-1,this._getRGBABufferInternalSizedFormat(_e.texture.type,_e.texture.format,_e.texture._useSRGBBuffer),_.COLOR_ATTACHMENT0,!1);if(!$)throw new Error("Unable to create multi sampled framebuffer");E.addMSAARenderBuffer($)}else this._bindUnboundFramebuffer(_e._framebuffer);return _e.texture.samples=p,_e._samples=p,_e._depthStencilBuffer=this._setupFramebufferDepthAttachments(_e._generateStencilBuffer,_e._generateDepthBuffer,_e.texture.width,_e.texture.height,p),this._bindUnboundFramebuffer(null),p},rr.prototype.createRenderTargetCubeTexture=function(_e,p){const _=this._createHardwareRenderTargetWrapper(!1,!0,_e),E={generateMipMaps:!0,generateDepthBuffer:!0,generateStencilBuffer:!1,type:0,samplingMode:3,format:5,...p};E.generateStencilBuffer=E.generateDepthBuffer&&E.generateStencilBuffer,(E.type===1&&!this._caps.textureFloatLinearFiltering||E.type===2&&!this._caps.textureHalfFloatLinearFiltering)&&(E.samplingMode=1);const A=this._gl,$=new u0(this,Gn.RenderTarget);this._bindTextureDirectly(A.TEXTURE_CUBE_MAP,$,!0);const ne=this._getSamplingParameters(E.samplingMode,E.generateMipMaps);E.type===1&&!this._caps.textureFloat&&(E.type=0,vi.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type")),A.texParameteri(A.TEXTURE_CUBE_MAP,A.TEXTURE_MAG_FILTER,ne.mag),A.texParameteri(A.TEXTURE_CUBE_MAP,A.TEXTURE_MIN_FILTER,ne.min),A.texParameteri(A.TEXTURE_CUBE_MAP,A.TEXTURE_WRAP_S,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_CUBE_MAP,A.TEXTURE_WRAP_T,A.CLAMP_TO_EDGE);for(let ce=0;ce<6;ce++)A.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+ce,0,this._getRGBABufferInternalSizedFormat(E.type,E.format),_e,_e,0,this._getInternalFormat(E.format),this._getWebGLTextureType(E.type),null);const xe=A.createFramebuffer();return this._bindUnboundFramebuffer(xe),_._depthStencilBuffer=this._setupFramebufferDepthAttachments(E.generateStencilBuffer,E.generateDepthBuffer,_e,_e),E.generateMipMaps&&A.generateMipmap(A.TEXTURE_CUBE_MAP),this._bindTextureDirectly(A.TEXTURE_CUBE_MAP,null),this._bindUnboundFramebuffer(null),_._framebuffer=xe,_._generateDepthBuffer=E.generateDepthBuffer,_._generateStencilBuffer=E.generateStencilBuffer,$.width=_e,$.height=_e,$.isReady=!0,$.isCube=!0,$.samples=1,$.generateMipMaps=E.generateMipMaps,$.samplingMode=E.samplingMode,$.type=E.type,$.format=E.format,this._internalTexturesCache.push($),_.setTextures($),_};const kT="postprocessVertexShader",UT=`attribute vec2 position;uniform vec2 scale;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;Gi.ShadersStore[kT]=UT;const MU={name:kT,shader:UT},g_={positions:[1,1,-1,1,-1,-1,1,-1],indices:[0,1,2,0,2,3]};class jD{constructor(p,_=g_){this._fullscreenViewport=new am(0,0,1,1);const E=_.positions??g_.positions,A=_.indices??g_.indices;this.engine=p,this._vertexBuffers={[ut.PositionKind]:new ut(p,E,ut.PositionKind,!1,!1,2)},this._indexBuffer=p.createIndexBuffer(A),this._onContextRestoredObserver=p.onContextRestoredObservable.add(()=>{this._indexBuffer=p.createIndexBuffer(A);for(const $ in this._vertexBuffers)this._vertexBuffers[$]._rebuild()})}setViewport(p=this._fullscreenViewport){this.engine.setViewport(p)}bindBuffers(p){this.engine.bindBuffers(this._vertexBuffers,this._indexBuffer,p)}applyEffectWrapper(p){this.engine.setState(!0),this.engine.depthCullingState.depthTest=!1,this.engine.stencilState.stencilTest=!1,this.engine.enableEffect(p._drawWrapper),this.bindBuffers(p.effect),p.onApplyObservable.notifyObservers({})}saveStates(){this._savedStateDepthTest=this.engine.depthCullingState.depthTest,this._savedStateStencilTest=this.engine.stencilState.stencilTest}restoreStates(){this.engine.depthCullingState.depthTest=this._savedStateDepthTest,this.engine.stencilState.stencilTest=this._savedStateStencilTest}draw(){this.engine.drawElementsType(0,0,6)}_isRenderTargetTexture(p){return p.renderTarget!==void 0}render(p,_=null){if(!p.effect.isReady())return;this.saveStates(),this.setViewport();const E=_===null?null:this._isRenderTargetTexture(_)?_.renderTarget:_;E&&this.engine.bindFramebuffer(E),this.applyEffectWrapper(p),this.draw(),E&&this.engine.unBindFramebuffer(E),this.restoreStates()}dispose(){const p=this._vertexBuffers[ut.PositionKind];p&&(p.dispose(),delete this._vertexBuffers[ut.PositionKind]),this._indexBuffer&&this.engine._releaseBuffer(this._indexBuffer),this._onContextRestoredObserver&&(this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}}class qD{get effect(){return this._drawWrapper.effect}set effect(p){this._drawWrapper.effect=p}constructor(p){this.onApplyObservable=new Mi;let _;const E=p.uniformNames||[];p.vertexShader?_={fragmentSource:p.fragmentShader,vertexSource:p.vertexShader,spectorName:p.name||"effectWrapper"}:(E.push("scale"),_={fragmentSource:p.fragmentShader,vertex:"postprocess",spectorName:p.name||"effectWrapper"},this.onApplyObservable.add(()=>{this.effect.setFloat2("scale",1,1)}));const A=p.defines?p.defines.join(`
`):"";this._drawWrapper=new nx(p.engine),p.useShaderStore?(_.fragment=_.fragmentSource,_.vertex||(_.vertex=_.vertexSource),delete _.fragmentSource,delete _.vertexSource,this.effect=p.engine.createEffect(_,p.attributeNames||["position"],E,p.samplerNames,A,void 0,p.onCompiled,void 0,void 0,p.shaderLanguage)):(this.effect=new va(_,p.attributeNames||["position"],E,p.samplerNames,p.engine,A,void 0,p.onCompiled,void 0,void 0,void 0,p.shaderLanguage),this._onContextRestoredObserver=p.engine.onContextRestoredObservable.add(()=>{this.effect._pipelineContext=null,this.effect._prepareEffect()}))}dispose(){this._onContextRestoredObserver&&(this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null),this.effect.dispose()}}const GT="passPixelShader",zT=`varying vec2 vUV;uniform sampler2D textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=texture2D(textureSampler,vUV);}`;Gi.ShadersStore[GT]=zT;const WT={name:GT,shader:zT};class Go{static _CreateDumpRenderer(){if(!Go._DumpToolsEngine){let p,_=null;const E={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};try{p=new OffscreenCanvas(100,100),_=new rr(p,!1,E)}catch{p=document.createElement("canvas"),_=new rr(p,!1,E)}_.getCaps().parallelShaderCompile=void 0;const A=new jD(_),$=new qD({engine:_,name:WT.name,fragmentShader:WT.shader,samplerNames:["textureSampler"]});Go._DumpToolsEngine={canvas:p,engine:_,renderer:A,wrapper:$}}return Go._DumpToolsEngine}static async DumpFramebuffer(p,_,E,A,$="image/png",ne,xe){const ce=await E.readPixels(0,0,p,_),Te=new Uint8Array(ce.buffer);Go.DumpData(p,_,Te,A,$,ne,!0,void 0,xe)}static DumpDataAsync(p,_,E,A="image/png",$,ne=!1,xe=!1,ce){return new Promise(Te=>{Go.DumpData(p,_,E,Re=>Te(Re),A,$,ne,xe,ce)})}static DumpData(p,_,E,A,$="image/png",ne,xe=!1,ce=!1,Te){const Re=Go._CreateDumpRenderer();if(Re.engine.setSize(p,_,!0),E instanceof Float32Array){const We=new Uint8Array(E.length);let Xe=E.length;for(;Xe--;){const xt=E[Xe];We[Xe]=Math.round(ri.Clamp(xt)*255)}E=We}const ke=Re.engine.createRawTexture(E,p,_,5,!1,!xe,1);Re.renderer.setViewport(),Re.renderer.applyEffectWrapper(Re.wrapper),Re.wrapper.effect._bindTexture("textureSampler",ke),Re.renderer.draw(),ce?ct.ToBlob(Re.canvas,We=>{const Xe=new FileReader;Xe.onload=xt=>{const qe=xt.target.result;A&&A(qe)},Xe.readAsArrayBuffer(We)},$,Te):ct.EncodeScreenshotCanvasData(Re.canvas,A,$,ne,Te),ke.dispose()}static Dispose(){Go._DumpToolsEngine&&(Go._DumpToolsEngine.wrapper.dispose(),Go._DumpToolsEngine.renderer.dispose(),Go._DumpToolsEngine.engine.dispose()),Go._DumpToolsEngine=null}}(()=>{ct.DumpData=Go.DumpData,ct.DumpDataAsync=Go.DumpDataAsync,ct.DumpFramebuffer=Go.DumpFramebuffer})();class $o extends Hi{get renderList(){return this._renderList}set renderList(p){this._unObserveRenderList&&(this._unObserveRenderList(),this._unObserveRenderList=null),p&&(this._unObserveRenderList=Mn(p,this._renderListHasChanged)),this._renderList=p}get postProcesses(){return this._postProcesses}get _prePassEnabled(){return!!this._prePassRenderTarget&&this._prePassRenderTarget.enabled}set onAfterUnbind(p){this._onAfterUnbindObserver&&this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=this.onAfterUnbindObservable.add(p)}set onBeforeRender(p){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(p)}set onAfterRender(p){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(p)}set onClear(p){this._onClearObserver&&this.onClearObservable.remove(this._onClearObserver),this._onClearObserver=this.onClearObservable.add(p)}get renderPassIds(){return this._renderPassIds}get currentRefreshId(){return this._currentRefreshId}setMaterialForRendering(p,_){let E;Array.isArray(p)?E=p:E=[p];for(let A=0;A<E.length;++A)for(let $=0;$<this._renderPassIds.length;++$)E[A].setMaterialForRenderPass(this._renderPassIds[$],_!==void 0?Array.isArray(_)?_[$]:_:void 0)}get isMulti(){return this._renderTarget?.isMulti??!1}get renderTargetOptions(){return this._renderTargetOptions}get renderTarget(){return this._renderTarget}_onRatioRescale(){this._sizeRatio&&this.resize(this._initialSizeParameter)}set boundingBoxSize(p){if(this._boundingBoxSize&&this._boundingBoxSize.equals(p))return;this._boundingBoxSize=p;const _=this.getScene();_&&_.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}get depthStencilTexture(){return this._renderTarget?._depthStencilTexture??null}constructor(p,_,E,A=!1,$=!0,ne=0,xe=!1,ce=Hi.TRILINEAR_SAMPLINGMODE,Te=!0,Re=!1,ke=!1,We=5,Xe=!1,xt,qe,ht=!1,Nt=!1){let wt,Qt=!0;if(typeof A=="object"){const Wt=A;A=!!Wt.generateMipMaps,$=Wt.doNotChangeAspectRatio??!0,ne=Wt.type??0,xe=!!Wt.isCube,ce=Wt.samplingMode??Hi.TRILINEAR_SAMPLINGMODE,Te=Wt.generateDepthBuffer??!0,Re=!!Wt.generateStencilBuffer,ke=!!Wt.isMulti,We=Wt.format??5,Xe=!!Wt.delayAllocation,xt=Wt.samples,qe=Wt.creationFlags,ht=!!Wt.noColorAttachment,Nt=!!Wt.useSRGBBuffer,wt=Wt.colorAttachment,Qt=Wt.gammaSpace??Qt}if(super(null,E,!A,void 0,ce,void 0,void 0,void 0,void 0,We),this._unObserveRenderList=null,this._renderListHasChanged=(Wt,zt)=>{const xi=this._renderList?this._renderList.length:0;(zt===0&&xi>0||xi===0)&&this.getScene()?.meshes.forEach(wi=>{wi._markSubMeshesAsLightDirty()})},this.renderParticles=!0,this.renderSprites=!1,this.forceLayerMaskCheck=!1,this.ignoreCameraViewport=!1,this.onBeforeBindObservable=new Mi,this.onAfterUnbindObservable=new Mi,this.onBeforeRenderObservable=new Mi,this.onAfterRenderObservable=new Mi,this.onClearObservable=new Mi,this.onResizeObservable=new Mi,this._cleared=!1,this.skipInitialClear=!1,this._currentRefreshId=-1,this._refreshRate=1,this._samples=1,this._canRescale=!0,this._renderTarget=null,this.boundingBoxPosition=nt.Zero(),E=this.getScene(),!E)return;const Ht=this.getScene().getEngine();this._gammaSpace=Qt,this._coordinatesMode=Hi.PROJECTION_MODE,this.renderList=[],this.name=p,this.isRenderTarget=!0,this._initialSizeParameter=_,this._renderPassIds=[],this._isCubeData=xe,this._processSizeParameter(_),this.renderPassId=this._renderPassIds[0],this._resizeObserver=Ht.onResizeObservable.add(()=>{}),this._generateMipMaps=!!A,this._doNotChangeAspectRatio=$,this._renderingManager=new ao(E),this._renderingManager._useSceneAutoClearSetup=!0,!ke&&(this._renderTargetOptions={generateMipMaps:A,type:ne,format:this._format??void 0,samplingMode:this.samplingMode,generateDepthBuffer:Te,generateStencilBuffer:Re,samples:xt,creationFlags:qe,noColorAttachment:ht,useSRGBBuffer:Nt,colorAttachment:wt,label:this.name},this.samplingMode===Hi.NEAREST_SAMPLINGMODE&&(this.wrapU=Hi.CLAMP_ADDRESSMODE,this.wrapV=Hi.CLAMP_ADDRESSMODE),Xe||(xe?(this._renderTarget=E.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions),this.coordinatesMode=Hi.INVCUBIC_MODE,this._textureMatrix=Yt.Identity()):this._renderTarget=E.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,xt!==void 0&&(this.samples=xt)))}createDepthStencilTexture(p=0,_=!0,E=!1,A=1,$=14){this._renderTarget?.createDepthStencilTexture(p,_,E,A,$)}_releaseRenderPassId(){if(this._scene){const p=this._scene.getEngine();for(let _=0;_<this._renderPassIds.length;++_)p.releaseRenderPassId(this._renderPassIds[_])}this._renderPassIds=[]}_createRenderPassId(){this._releaseRenderPassId();const p=this._scene.getEngine(),_=this._isCubeData?6:this.getRenderLayers()||1;for(let E=0;E<_;++E)this._renderPassIds[E]=p.createRenderPassId(`RenderTargetTexture - ${this.name}#${E}`)}_processSizeParameter(p,_=!0){if(p.ratio){this._sizeRatio=p.ratio;const E=this._getEngine();this._size={width:this._bestReflectionRenderTargetDimension(E.getRenderWidth(),this._sizeRatio),height:this._bestReflectionRenderTargetDimension(E.getRenderHeight(),this._sizeRatio)}}else this._size=p;_&&this._createRenderPassId()}get samples(){return this._renderTarget?.samples??this._samples}set samples(p){this._renderTarget&&(this._samples=this._renderTarget.setSamples(p))}resetRefreshCounter(){this._currentRefreshId=-1}get refreshRate(){return this._refreshRate}set refreshRate(p){this._refreshRate=p,this.resetRefreshCounter()}addPostProcess(p){if(!this._postProcessManager){const _=this.getScene();if(!_)return;this._postProcessManager=new qm(_),this._postProcesses=new Array}this._postProcesses.push(p),this._postProcesses[0].autoClear=!1}clearPostProcesses(p=!1){if(this._postProcesses){if(p)for(const _ of this._postProcesses)_.dispose();this._postProcesses=[]}}removePostProcess(p){if(!this._postProcesses)return;const _=this._postProcesses.indexOf(p);_!==-1&&(this._postProcesses.splice(_,1),this._postProcesses.length>0&&(this._postProcesses[0].autoClear=!1))}_shouldRender(){return this._currentRefreshId===-1?(this._currentRefreshId=1,!0):this.refreshRate===this._currentRefreshId?(this._currentRefreshId=1,!0):(this._currentRefreshId++,!1)}getRenderSize(){return this.getRenderWidth()}getRenderWidth(){return this._size.width?this._size.width:this._size}getRenderHeight(){return this._size.width?this._size.height:this._size}getRenderLayers(){const p=this._size.layers;return p||0}disableRescaling(){this._canRescale=!1}get canRescale(){return this._canRescale}scale(p){const _=Math.max(1,this.getRenderSize()*p);this.resize(_)}getReflectionTextureMatrix(){return this.isCube?this._textureMatrix:super.getReflectionTextureMatrix()}resize(p){const _=this.isCube;this._renderTarget?.dispose(),this._renderTarget=null;const E=this.getScene();E&&(this._processSizeParameter(p,!1),_?this._renderTarget=E.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions):this._renderTarget=E.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,this._renderTargetOptions.samples!==void 0&&(this.samples=this._renderTargetOptions.samples),this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this))}render(p=!1,_=!1){this._render(p,_)}isReadyForRendering(){return this._render(!1,!1,!0)}_render(p=!1,_=!1,E=!1){const A=this.getScene();if(!A)return E;const $=A.getEngine();if(this.useCameraPostProcesses!==void 0&&(p=this.useCameraPostProcesses),this._waitingRenderList){if(!this.renderListPredicate){this.renderList=[];for(let Re=0;Re<this._waitingRenderList.length;Re++){const ke=this._waitingRenderList[Re],We=A.getMeshById(ke);We&&this.renderList.push(We)}}this._waitingRenderList=void 0}if(this.renderListPredicate){this.renderList?this.renderList.length=0:this.renderList=[];const Re=this.getScene();if(!Re)return E;const ke=Re.meshes;for(let We=0;We<ke.length;We++){const Xe=ke[We];this.renderListPredicate(Xe)&&this.renderList.push(Xe)}}const ne=$.currentRenderPassId;this.onBeforeBindObservable.notifyObservers(this);const xe=this.activeCamera??A.activeCamera,ce=A.activeCamera;xe&&(xe!==A.activeCamera&&(A.setTransformMatrix(xe.getViewMatrix(),xe.getProjectionMatrix(!0)),A.activeCamera=xe),$.setViewport(xe.rigParent?xe.rigParent.viewport:xe.viewport,this.getRenderWidth(),this.getRenderHeight())),this._defaultRenderListPrepared=!1;let Te=E;if(E){A.getViewMatrix()||A.updateTransformMatrix();const Re=this.is2DArray?this.getRenderLayers():this.isCube?6:1;for(let ke=0;ke<Re&&Te;ke++){let We=null;const Xe=this.renderList?this.renderList:A.getActiveMeshes().data,xt=this.renderList?this.renderList.length:A.getActiveMeshes().length;$.currentRenderPassId=this._renderPassIds[ke],this.onBeforeRenderObservable.notifyObservers(ke),this.getCustomRenderList&&(We=this.getCustomRenderList(ke,Xe,xt)),We||(We=Xe),this._doNotChangeAspectRatio||A.updateTransformMatrix(!0);for(let qe=0;qe<We.length&&Te;++qe){const ht=We[qe];if(!(!ht.isEnabled()||ht.isBlocked||!ht.isVisible||!ht.subMeshes)){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(ht,this.refreshRate,E)){Te=!1;continue}}else if(!ht.isReady(!0)){Te=!1;continue}}}this.onAfterRenderObservable.notifyObservers(ke),(this.is2DArray||this.isCube)&&(A.incrementRenderId(),A.resetCachedMaterial())}}else if(this.is2DArray&&!this.isMulti)for(let Re=0;Re<this.getRenderLayers();Re++)this._renderToTarget(0,p,_,Re,xe),A.incrementRenderId(),A.resetCachedMaterial();else if(this.isCube&&!this.isMulti)for(let Re=0;Re<6;Re++)this._renderToTarget(Re,p,_,void 0,xe),A.incrementRenderId(),A.resetCachedMaterial();else this._renderToTarget(0,p,_,void 0,xe);return this.onAfterUnbindObservable.notifyObservers(this),$.currentRenderPassId=ne,ce&&(A.activeCamera=ce,this.activeCamera&&this.activeCamera!==A.activeCamera&&A.setTransformMatrix(A.activeCamera.getViewMatrix(),A.activeCamera.getProjectionMatrix(!0)),$.setViewport(A.activeCamera.viewport)),A.resetCachedMaterial(),Te}_bestReflectionRenderTargetDimension(p,_){const A=p*_,$=ui.NearestPOT(A+128*128/(128+A));return Math.min(ui.FloorPOT(p),$)}_prepareRenderingManager(p,_,E,A){const $=this.getScene();if(!$)return;this._renderingManager.reset();const ne=$.getRenderId();for(let xe=0;xe<_;xe++){const ce=p[xe];if(ce&&!ce.isBlocked){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(ce,this.refreshRate,!1)){this.resetRefreshCounter();continue}}else if(!ce.isReady(this.refreshRate===0)){this.resetRefreshCounter();continue}if(!ce._internalAbstractMeshDataInfo._currentLODIsUpToDate&&$.activeCamera&&(ce._internalAbstractMeshDataInfo._currentLOD=$.customLODSelector?$.customLODSelector(ce,this.activeCamera||$.activeCamera):ce.getLOD(this.activeCamera||$.activeCamera),ce._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0),!ce._internalAbstractMeshDataInfo._currentLOD)continue;let Te=ce._internalAbstractMeshDataInfo._currentLOD;Te._preActivateForIntermediateRendering(ne);let Re;if(A&&E?Re=(ce.layerMask&E.layerMask)===0:Re=!1,ce.isEnabled()&&ce.isVisible&&ce.subMeshes&&!Re&&(Te!==ce&&Te._activate(ne,!0),ce._activate(ne,!0)&&ce.subMeshes.length)){ce.isAnInstance?ce._internalAbstractMeshDataInfo._actAsRegularMesh&&(Te=ce):Te._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!1,Te._internalAbstractMeshDataInfo._isActiveIntermediate=!0;for(let ke=0;ke<Te.subMeshes.length;ke++){const We=Te.subMeshes[ke];this._renderingManager.dispatch(We,Te)}}}}for(let xe=0;xe<$.particleSystems.length;xe++){const ce=$.particleSystems[xe],Te=ce.emitter;!ce.isStarted()||!Te||Te.position&&!Te.isEnabled()||this._renderingManager.dispatchParticles(ce)}}_bindFrameBuffer(p=0,_=0){const E=this.getScene();if(!E)return;const A=E.getEngine();this._renderTarget&&A.bindFramebuffer(this._renderTarget,this.isCube?p:void 0,void 0,void 0,this.ignoreCameraViewport,0,_)}_unbindFrameBuffer(p,_){this._renderTarget&&p.unBindFramebuffer(this._renderTarget,this.isCube,()=>{this.onAfterRenderObservable.notifyObservers(_)})}_prepareFrame(p,_,E,A){this._postProcessManager?this._prePassEnabled||this._postProcessManager._prepareFrame(this._texture,this._postProcesses):(!A||!p.postProcessManager._prepareFrame(this._texture))&&this._bindFrameBuffer(_,E)}_renderToTarget(p,_,E,A=0,$=null){const ne=this.getScene();if(!ne)return;const xe=ne.getEngine();if(xe._debugPushGroup?.(`render to face #${p} layer #${A}`,1),this._prepareFrame(ne,p,A,_),this.is2DArray?(xe.currentRenderPassId=this._renderPassIds[A],this.onBeforeRenderObservable.notifyObservers(A)):(xe.currentRenderPassId=this._renderPassIds[p],this.onBeforeRenderObservable.notifyObservers(p)),xe.snapshotRendering&&xe.snapshotRenderingMode===1)this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(xe):this.skipInitialClear||xe.clear(this.clearColor||ne.clearColor,!0,!0,!0);else{let Te=null;const Re=this.renderList?this.renderList:ne.getActiveMeshes().data,ke=this.renderList?this.renderList.length:ne.getActiveMeshes().length;this.getCustomRenderList&&(Te=this.getCustomRenderList(this.is2DArray?A:p,Re,ke)),Te?this._prepareRenderingManager(Te,Te.length,$,this.forceLayerMaskCheck):(this._defaultRenderListPrepared||(this._prepareRenderingManager(Re,ke,$,!this.renderList||this.forceLayerMaskCheck),this._defaultRenderListPrepared=!0),Te=Re);for(const Xe of ne._beforeRenderTargetClearStage)Xe.action(this,p,A);this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(xe):this.skipInitialClear||xe.clear(this.clearColor||ne.clearColor,!0,!0,!0),this._doNotChangeAspectRatio||ne.updateTransformMatrix(!0);for(const Xe of ne._beforeRenderTargetDrawStage)Xe.action(this,p,A);this._renderingManager.render(this.customRenderFunction,Te,this.renderParticles,this.renderSprites);for(const Xe of ne._afterRenderTargetDrawStage)Xe.action(this,p,A);const We=this._texture?.generateMipMaps??!1;this._texture&&(this._texture.generateMipMaps=!1),this._postProcessManager?this._postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,p,this._postProcesses,this.ignoreCameraViewport):_&&ne.postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,p);for(const Xe of ne._afterRenderTargetPostProcessStage)Xe.action(this,p,A);this._texture&&(this._texture.generateMipMaps=We),this._doNotChangeAspectRatio||ne.updateTransformMatrix(!0),E&&Go.DumpFramebuffer(this.getRenderWidth(),this.getRenderHeight(),xe)}this._unbindFrameBuffer(xe,p),this._texture&&this.isCube&&p===5&&xe.generateMipMapsForCubemap(this._texture),xe._debugPopGroup?.(1)}setRenderingOrder(p,_=null,E=null,A=null){this._renderingManager.setRenderingOrder(p,_,E,A)}setRenderingAutoClearDepthStencil(p,_){this._renderingManager.setRenderingAutoClearDepthStencil(p,_),this._renderingManager._useSceneAutoClearSetup=!1}clone(){const p=this.getSize(),_=new $o(this.name,p,this.getScene(),this._renderTargetOptions.generateMipMaps,this._doNotChangeAspectRatio,this._renderTargetOptions.type,this.isCube,this._renderTargetOptions.samplingMode,this._renderTargetOptions.generateDepthBuffer,this._renderTargetOptions.generateStencilBuffer,void 0,this._renderTargetOptions.format,void 0,this._renderTargetOptions.samples);return _.hasAlpha=this.hasAlpha,_.level=this.level,_.coordinatesMode=this.coordinatesMode,this.renderList&&(_.renderList=this.renderList.slice(0)),_}serialize(){if(!this.name)return null;const p=super.serialize();if(p.renderTargetSize=this.getRenderSize(),p.renderList=[],this.renderList)for(let _=0;_<this.renderList.length;_++)p.renderList.push(this.renderList[_].id);return p}disposeFramebufferObjects(){this._renderTarget?.dispose(!0)}releaseInternalTexture(){this._renderTarget?.releaseTextures(),this._texture=null}dispose(){this.onResizeObservable.clear(),this.onClearObservable.clear(),this.onAfterRenderObservable.clear(),this.onAfterUnbindObservable.clear(),this.onBeforeBindObservable.clear(),this.onBeforeRenderObservable.clear(),this._postProcessManager&&(this._postProcessManager.dispose(),this._postProcessManager=null),this._prePassRenderTarget&&this._prePassRenderTarget.dispose(),this._releaseRenderPassId(),this.clearPostProcesses(!0),this._resizeObserver&&(this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null),this.renderList=null;const p=this.getScene();if(!p)return;let _=p.customRenderTargets.indexOf(this);_>=0&&p.customRenderTargets.splice(_,1);for(const E of p.cameras)_=E.customRenderTargets.indexOf(this),_>=0&&E.customRenderTargets.splice(_,1);this._renderTarget?.dispose(),this._renderTarget=null,this._texture=null,super.dispose()}_rebuild(){this.refreshRate===$o.REFRESHRATE_RENDER_ONCE&&(this.refreshRate=$o.REFRESHRATE_RENDER_ONCE),this._postProcessManager&&this._postProcessManager._rebuild()}freeRenderingGroups(){this._renderingManager&&this._renderingManager.freeRenderingGroups()}getViewCount(){return 1}}$o.REFRESHRATE_RENDER_ONCE=0,$o.REFRESHRATE_RENDER_ONEVERYFRAME=1,$o.REFRESHRATE_RENDER_ONEVERYTWOFRAMES=2,Hi._CreateRenderTargetTexture=(_e,p,_,E,A)=>new $o(_e,p,_,E);class $D{constructor(){this._checkCollisions=!1,this._collisionMask=-1,this._collisionGroup=-1,this._surroundingMeshes=null,this._collider=null,this._oldPositionForCollisions=new nt(0,0,0),this._diffPositionForCollisions=new nt(0,0,0),this._collisionResponse=!0}}class rN{constructor(){this.facetNb=0,this.partitioningSubdivisions=10,this.partitioningBBoxRatio=1.01,this.facetDataEnabled=!1,this.facetParameters={},this.bbSize=nt.Zero(),this.subDiv={max:1,X:1,Y:1,Z:1},this.facetDepthSort=!1,this.facetDepthSortEnabled=!1}}class nN{constructor(){this._hasVertexAlpha=!1,this._useVertexColors=!0,this._numBoneInfluencers=4,this._applyFog=!0,this._receiveShadows=!1,this._facetData=new rN,this._visibility=1,this._skeleton=null,this._layerMask=268435455,this._computeBonesUsingShaders=!0,this._isActive=!1,this._onlyForInstances=!1,this._isActiveIntermediate=!1,this._onlyForInstancesIntermediate=!1,this._actAsRegularMesh=!1,this._currentLOD=null,this._currentLODIsUpToDate=!1,this._collisionRetryCount=3,this._morphTargetManager=null,this._renderingGroupId=0,this._bakedVertexAnimationManager=null,this._material=null,this._positions=null,this._pointerOverDisableMeshTesting=!1,this._meshCollisionData=new $D,this._enableDistantPicking=!1,this._rawBoundingInfo=null}}class zo extends zr{static get BILLBOARDMODE_NONE(){return zr.BILLBOARDMODE_NONE}static get BILLBOARDMODE_X(){return zr.BILLBOARDMODE_X}static get BILLBOARDMODE_Y(){return zr.BILLBOARDMODE_Y}static get BILLBOARDMODE_Z(){return zr.BILLBOARDMODE_Z}static get BILLBOARDMODE_ALL(){return zr.BILLBOARDMODE_ALL}static get BILLBOARDMODE_USE_POSITION(){return zr.BILLBOARDMODE_USE_POSITION}get facetNb(){return this._internalAbstractMeshDataInfo._facetData.facetNb}get partitioningSubdivisions(){return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions}set partitioningSubdivisions(p){this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions=p}get partitioningBBoxRatio(){return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio}set partitioningBBoxRatio(p){this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio=p}get mustDepthSortFacets(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSort}set mustDepthSortFacets(p){this._internalAbstractMeshDataInfo._facetData.facetDepthSort=p}get facetDepthSortFrom(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom}set facetDepthSortFrom(p){this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom=p}get collisionRetryCount(){return this._internalAbstractMeshDataInfo._collisionRetryCount}set collisionRetryCount(p){this._internalAbstractMeshDataInfo._collisionRetryCount=p}get isFacetDataEnabled(){return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled}get morphTargetManager(){return this._internalAbstractMeshDataInfo._morphTargetManager}set morphTargetManager(p){this._internalAbstractMeshDataInfo._morphTargetManager!==p&&(this._internalAbstractMeshDataInfo._morphTargetManager=p,this._syncGeometryWithMorphTargetManager())}get bakedVertexAnimationManager(){return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager}set bakedVertexAnimationManager(p){this._internalAbstractMeshDataInfo._bakedVertexAnimationManager!==p&&(this._internalAbstractMeshDataInfo._bakedVertexAnimationManager=p,this._markSubMeshesAsAttributesDirty())}_syncGeometryWithMorphTargetManager(){}_updateNonUniformScalingState(p){return super._updateNonUniformScalingState(p)?(this._markSubMeshesAsMiscDirty(),!0):!1}get rawBoundingInfo(){return this._internalAbstractMeshDataInfo._rawBoundingInfo}set rawBoundingInfo(p){this._internalAbstractMeshDataInfo._rawBoundingInfo=p}set onCollide(p){this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver&&this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver=this.onCollideObservable.add(p)}set onCollisionPositionChange(p){this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver&&this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver=this.onCollisionPositionChangeObservable.add(p)}get visibility(){return this._internalAbstractMeshDataInfo._visibility}set visibility(p){if(this._internalAbstractMeshDataInfo._visibility===p)return;const _=this._internalAbstractMeshDataInfo._visibility;this._internalAbstractMeshDataInfo._visibility=p,(_===1&&p!==1||_!==1&&p===1)&&this._markSubMeshesAsDirty(E=>{E.markAsMiscDirty(),E.markAsPrePassDirty()})}get pointerOverDisableMeshTesting(){return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting}set pointerOverDisableMeshTesting(p){this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting=p}get renderingGroupId(){return this._internalAbstractMeshDataInfo._renderingGroupId}set renderingGroupId(p){this._internalAbstractMeshDataInfo._renderingGroupId=p}get material(){return this._internalAbstractMeshDataInfo._material}set material(p){this._internalAbstractMeshDataInfo._material!==p&&(this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),this._internalAbstractMeshDataInfo._material=p,p&&p.meshMap&&(p.meshMap[this.uniqueId]=this),this.onMaterialChangedObservable.hasObservers()&&this.onMaterialChangedObservable.notifyObservers(this),this.subMeshes&&(this.resetDrawCache(),this._unBindEffect()))}getMaterialForRenderPass(p){return this._internalAbstractMeshDataInfo._materialForRenderPass?.[p]}setMaterialForRenderPass(p,_){this.resetDrawCache(p),this._internalAbstractMeshDataInfo._materialForRenderPass||(this._internalAbstractMeshDataInfo._materialForRenderPass=[]),this._internalAbstractMeshDataInfo._materialForRenderPass[p]=_}get receiveShadows(){return this._internalAbstractMeshDataInfo._receiveShadows}set receiveShadows(p){this._internalAbstractMeshDataInfo._receiveShadows!==p&&(this._internalAbstractMeshDataInfo._receiveShadows=p,this._markSubMeshesAsLightDirty())}get hasVertexAlpha(){return this._internalAbstractMeshDataInfo._hasVertexAlpha}set hasVertexAlpha(p){this._internalAbstractMeshDataInfo._hasVertexAlpha!==p&&(this._internalAbstractMeshDataInfo._hasVertexAlpha=p,this._markSubMeshesAsAttributesDirty(),this._markSubMeshesAsMiscDirty())}get useVertexColors(){return this._internalAbstractMeshDataInfo._useVertexColors}set useVertexColors(p){this._internalAbstractMeshDataInfo._useVertexColors!==p&&(this._internalAbstractMeshDataInfo._useVertexColors=p,this._markSubMeshesAsAttributesDirty())}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(p){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==p&&(this._internalAbstractMeshDataInfo._computeBonesUsingShaders=p,this._markSubMeshesAsAttributesDirty())}get numBoneInfluencers(){return this._internalAbstractMeshDataInfo._numBoneInfluencers}set numBoneInfluencers(p){this._internalAbstractMeshDataInfo._numBoneInfluencers!==p&&(this._internalAbstractMeshDataInfo._numBoneInfluencers=p,this._markSubMeshesAsAttributesDirty())}get applyFog(){return this._internalAbstractMeshDataInfo._applyFog}set applyFog(p){this._internalAbstractMeshDataInfo._applyFog!==p&&(this._internalAbstractMeshDataInfo._applyFog=p,this._markSubMeshesAsMiscDirty())}get enableDistantPicking(){return this._internalAbstractMeshDataInfo._enableDistantPicking}set enableDistantPicking(p){this._internalAbstractMeshDataInfo._enableDistantPicking=p}get layerMask(){return this._internalAbstractMeshDataInfo._layerMask}set layerMask(p){p!==this._internalAbstractMeshDataInfo._layerMask&&(this._internalAbstractMeshDataInfo._layerMask=p,this._resyncLightSources())}get collisionMask(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask}set collisionMask(p){this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask=isNaN(p)?-1:p}get collisionResponse(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse}set collisionResponse(p){this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse=p}get collisionGroup(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup}set collisionGroup(p){this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup=isNaN(p)?-1:p}get surroundingMeshes(){return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes}set surroundingMeshes(p){this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes=p}get lightSources(){return this._lightSources}get _positions(){return null}set skeleton(p){const _=this._internalAbstractMeshDataInfo._skeleton;_&&_.needInitialSkinMatrix&&_._unregisterMeshWithPoseMatrix(this),p&&p.needInitialSkinMatrix&&p._registerMeshWithPoseMatrix(this),this._internalAbstractMeshDataInfo._skeleton=p,this._internalAbstractMeshDataInfo._skeleton||(this._bonesTransformMatrices=null),this._markSubMeshesAsAttributesDirty()}get skeleton(){return this._internalAbstractMeshDataInfo._skeleton}constructor(p,_=null){switch(super(p,_,!1),this._internalAbstractMeshDataInfo=new nN,this._waitingMaterialId=null,this.cullingStrategy=zo.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY,this.onCollideObservable=new Mi,this.onCollisionPositionChangeObservable=new Mi,this.onMaterialChangedObservable=new Mi,this.definedFacingForward=!0,this._occlusionQuery=null,this._renderingGroup=null,this.alphaIndex=Number.MAX_VALUE,this.isVisible=!0,this.isPickable=!0,this.isNearPickable=!1,this.isNearGrabbable=!1,this.showSubMeshesBoundingBox=!1,this.isBlocker=!1,this.enablePointerMoveEvents=!1,this.outlineColor=ws.Red(),this.outlineWidth=.02,this.overlayColor=ws.Red(),this.overlayAlpha=.5,this.useOctreeForRenderingSelection=!0,this.useOctreeForPicking=!0,this.useOctreeForCollisions=!0,this.alwaysSelectAsActiveMesh=!1,this.doNotSyncBoundingInfo=!1,this.actionManager=null,this.ellipsoid=new nt(.5,1,.5),this.ellipsoidOffset=new nt(0,0,0),this.edgesWidth=1,this.edgesColor=new vr(1,0,0,1),this._edgesRenderer=null,this._masterMesh=null,this._boundingInfo=null,this._boundingInfoIsDirty=!0,this._renderId=0,this._intersectionsInProgress=new Array,this._unIndexed=!1,this._lightSources=new Array,this._waitingData={lods:null,actions:null,freezeWorldMatrix:null},this._bonesTransformMatrices=null,this._transformMatrixTexture=null,this.onRebuildObservable=new Mi,this._onCollisionPositionChange=(E,A,$=null)=>{A.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length()>ui.CollisionsEpsilon&&this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),$&&this.onCollideObservable.notifyObservers($),this.onCollisionPositionChangeObservable.notifyObservers(this.position)},_=this.getScene(),_.addMesh(this),this._resyncLightSources(),this._uniformBuffer=new $s(this.getScene().getEngine(),void 0,void 0,p,!this.getScene().getEngine().isWebGPU),this._buildUniformLayout(),_.performancePriority){case R2.Aggressive:this.doNotSyncBoundingInfo=!0;case R2.Intermediate:this.alwaysSelectAsActiveMesh=!0,this.isPickable=!1;break}}_buildUniformLayout(){this._uniformBuffer.addUniform("world",16),this._uniformBuffer.addUniform("visibility",1),this._uniformBuffer.create()}transferToEffect(p){const _=this._uniformBuffer;_.updateMatrix("world",p),_.updateFloat("visibility",this._internalAbstractMeshDataInfo._visibility),_.update()}getMeshUniformBuffer(){return this._uniformBuffer}getClassName(){return"AbstractMesh"}toString(p){let _="Name: "+this.name+", isInstance: "+(this.getClassName()!=="InstancedMesh"?"YES":"NO");_+=", # of submeshes: "+(this.subMeshes?this.subMeshes.length:0);const E=this._internalAbstractMeshDataInfo._skeleton;return E&&(_+=", skeleton: "+E.name),p&&(_+=", billboard mode: "+["NONE","X","Y",null,"Z",null,null,"ALL"][this.billboardMode],_+=", freeze wrld mat: "+(this._isWorldMatrixFrozen||this._waitingData.freezeWorldMatrix?"YES":"NO")),_}_getEffectiveParent(){return this._masterMesh&&this.billboardMode!==zr.BILLBOARDMODE_NONE?this._masterMesh:super._getEffectiveParent()}_getActionManagerForTrigger(p,_=!0){if(this.actionManager&&(_||this.actionManager.isRecursive))if(p){if(this.actionManager.hasSpecificTrigger(p))return this.actionManager}else return this.actionManager;return this.parent?this.parent._getActionManagerForTrigger(p,!1):null}_rebuild(p=!1){if(this.onRebuildObservable.notifyObservers(this),this._occlusionQuery!==null&&(this._occlusionQuery=null),!!this.subMeshes){for(const _ of this.subMeshes)_._rebuild();this.resetDrawCache()}}_resyncLightSources(){this._lightSources.length=0;for(const p of this.getScene().lights)p.isEnabled()&&p.canAffectMesh(this)&&this._lightSources.push(p);this._markSubMeshesAsLightDirty()}_resyncLightSource(p){const _=p.isEnabled()&&p.canAffectMesh(this),E=this._lightSources.indexOf(p);let A=!1;if(E===-1){if(!_)return;this._lightSources.push(p)}else{if(_)return;A=!0,this._lightSources.splice(E,1)}this._markSubMeshesAsLightDirty(A)}_unBindEffect(){for(const p of this.subMeshes)p.setEffect(null)}_removeLightSource(p,_){const E=this._lightSources.indexOf(p);E!==-1&&(this._lightSources.splice(E,1),this._markSubMeshesAsLightDirty(_))}_markSubMeshesAsDirty(p){if(this.subMeshes)for(const _ of this.subMeshes)for(let E=0;E<_._drawWrappers.length;++E){const A=_._drawWrappers[E];!A||!A.defines||!A.defines.markAllAsDirty||p(A.defines)}}_markSubMeshesAsLightDirty(p=!1){this._markSubMeshesAsDirty(_=>_.markAsLightDirty(p))}_markSubMeshesAsAttributesDirty(){this._markSubMeshesAsDirty(p=>p.markAsAttributesDirty())}_markSubMeshesAsMiscDirty(){this._markSubMeshesAsDirty(p=>p.markAsMiscDirty())}markAsDirty(p){return this._currentRenderId=Number.MAX_VALUE,this._isDirty=!0,this}resetDrawCache(p){if(this.subMeshes)for(const _ of this.subMeshes)_.resetDrawCache(p)}get isBlocked(){return!1}getLOD(p){return this}getTotalVertices(){return 0}getTotalIndices(){return 0}getIndices(){return null}getVerticesData(p){return null}setVerticesData(p,_,E,A){return this}updateVerticesData(p,_,E,A){return this}setIndices(p,_){return this}isVerticesDataPresent(p){return!1}getBoundingInfo(){return this._masterMesh?this._masterMesh.getBoundingInfo():(this._boundingInfoIsDirty&&(this._boundingInfoIsDirty=!1,this._updateBoundingInfo()),this._boundingInfo)}getRawBoundingInfo(){return this.rawBoundingInfo??this.getBoundingInfo()}setBoundingInfo(p){return this._boundingInfo=p,this}get hasBoundingInfo(){return this._boundingInfo!==null}buildBoundingInfo(p,_,E){return this._boundingInfo=new lx(p,_,E),this._boundingInfo}normalizeToUnitCube(p=!0,_=!1,E){return super.normalizeToUnitCube(p,_,E)}get useBones(){return this.skeleton&&this.getScene().skeletonsEnabled&&this.isVerticesDataPresent(ut.MatricesIndicesKind)&&this.isVerticesDataPresent(ut.MatricesWeightsKind)}_preActivate(){}_preActivateForIntermediateRendering(p){}_activate(p,_){return this._renderId=p,!0}_postActivate(){}_freeze(){}_unFreeze(){}getWorldMatrix(){return this._masterMesh&&this.billboardMode===zr.BILLBOARDMODE_NONE?this._masterMesh.getWorldMatrix():super.getWorldMatrix()}_getWorldMatrixDeterminant(){return this._masterMesh?this._masterMesh._getWorldMatrixDeterminant():super._getWorldMatrixDeterminant()}get isAnInstance(){return!1}get hasInstances(){return!1}get hasThinInstances(){return!1}movePOV(p,_,E){return this.position.addInPlace(this.calcMovePOV(p,_,E)),this}calcMovePOV(p,_,E){const A=new Yt;(this.rotationQuaternion?this.rotationQuaternion:_s.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z)).toRotationMatrix(A);const ne=nt.Zero(),xe=this.definedFacingForward?-1:1;return nt.TransformCoordinatesFromFloatsToRef(p*xe,_,E*xe,A,ne),ne}rotatePOV(p,_,E){return this.rotation.addInPlace(this.calcRotatePOV(p,_,E)),this}calcRotatePOV(p,_,E){const A=this.definedFacingForward?1:-1;return new nt(p*A,_,E*A)}refreshBoundingInfo(p=!1,_=!1){return this._boundingInfo&&this._boundingInfo.isLocked?this:(this._refreshBoundingInfo(this._getPositionData(p,_),null),this)}_refreshBoundingInfo(p,_){if(p){const E=Kb(p,0,this.getTotalVertices(),_);this._boundingInfo?this._boundingInfo.reConstruct(E.minimum,E.maximum):this._boundingInfo=new lx(E.minimum,E.maximum)}if(this.subMeshes)for(let E=0;E<this.subMeshes.length;E++)this.subMeshes[E].refreshBoundingInfo(p);this._updateBoundingInfo()}_getData(p=!1,_=!1,E,A=ut.PositionKind){if(E=E??this.getVerticesData(A).slice(),E&&_&&this.morphTargetManager){let $=0,ne=0;for(let xe=0;xe<E.length;xe++){let ce=E[xe];for(let Te=0;Te<this.morphTargetManager.numTargets;Te++){const Re=this.morphTargetManager.getTarget(Te),ke=Re.influence;if(ke!==0){let We=null;switch(A){case ut.PositionKind:We=Re.getPositions();break;case ut.NormalKind:We=Re.getNormals();break;case ut.TangentKind:We=Re.getTangents();break;case ut.UVKind:We=Re.getUVs();break}We&&(ce+=(We[xe]-E[xe])*ke)}}if(E[xe]=ce,$++,A===ut.PositionKind&&this._positions&&$===3){$=0;const Te=ne*3;this._positions[ne++].copyFromFloats(E[Te],E[Te+1],E[Te+2])}}}if(E&&p&&this.skeleton){const $=this.getVerticesData(ut.MatricesIndicesKind),ne=this.getVerticesData(ut.MatricesWeightsKind);if(ne&&$){const xe=this.numBoneInfluencers>4,ce=xe?this.getVerticesData(ut.MatricesIndicesExtraKind):null,Te=xe?this.getVerticesData(ut.MatricesWeightsExtraKind):null,Re=this.skeleton.getTransformMatrices(this),ke=pi.Vector3[0],We=pi.Matrix[0],Xe=pi.Matrix[1];let xt=0;for(let qe=0;qe<E.length;qe+=3,xt+=4){We.reset();let ht,Nt;for(ht=0;ht<4;ht++)Nt=ne[xt+ht],Nt>0&&(Yt.FromFloat32ArrayToRefScaled(Re,Math.floor($[xt+ht]*16),Nt,Xe),We.addToSelf(Xe));if(xe)for(ht=0;ht<4;ht++)Nt=Te[xt+ht],Nt>0&&(Yt.FromFloat32ArrayToRefScaled(Re,Math.floor(ce[xt+ht]*16),Nt,Xe),We.addToSelf(Xe));A===ut.NormalKind?nt.TransformNormalFromFloatsToRef(E[qe],E[qe+1],E[qe+2],We,ke):nt.TransformCoordinatesFromFloatsToRef(E[qe],E[qe+1],E[qe+2],We,ke),ke.toArray(E,qe),A===ut.PositionKind&&this._positions&&this._positions[qe/3].copyFrom(ke)}}}return E}getNormalsData(p=!1,_=!1){return this._getData(p,_,null,ut.NormalKind)}getPositionData(p=!1,_=!1,E){return this._getData(p,_,E,ut.PositionKind)}_getPositionData(p,_){let E=this.getVerticesData(ut.PositionKind);if(this._internalAbstractMeshDataInfo._positions&&(this._internalAbstractMeshDataInfo._positions=null),E&&(p&&this.skeleton||_&&this.morphTargetManager)){if(E=E.slice(),this._generatePointsArray(),this._positions){const A=this._positions;this._internalAbstractMeshDataInfo._positions=new Array(A.length);for(let $=0;$<A.length;$++)this._internalAbstractMeshDataInfo._positions[$]=A[$]?.clone()||new nt}return this.getPositionData(p,_,E)}return E}_updateBoundingInfo(){return this._boundingInfo?this._boundingInfo.update(this.worldMatrixFromCache):this._boundingInfo=new lx(nt.Zero(),nt.Zero(),this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}_updateSubMeshesBoundingInfo(p){if(!this.subMeshes)return this;const _=this.subMeshes.length;for(let E=0;E<_;E++){const A=this.subMeshes[E];(_>1||!A.IsGlobal)&&A.updateBoundingInfo(p)}return this}_afterComputeWorldMatrix(){this.doNotSyncBoundingInfo||(this._boundingInfoIsDirty=!0)}isInFrustum(p){return this.getBoundingInfo().isInFrustum(p,this.cullingStrategy)}isCompletelyInFrustum(p){return this.getBoundingInfo().isCompletelyInFrustum(p)}intersectsMesh(p,_=!1,E){const A=this.getBoundingInfo(),$=p.getBoundingInfo();if(A.intersects($,_))return!0;if(E){for(const ne of this.getChildMeshes())if(ne.intersectsMesh(p,_,!0))return!0}return!1}intersectsPoint(p){return this.getBoundingInfo().intersectsPoint(p)}get checkCollisions(){return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions}set checkCollisions(p){this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions=p}get collider(){return this._internalAbstractMeshDataInfo._meshCollisionData._collider}moveWithCollisions(p){this.getAbsolutePosition().addToRef(this.ellipsoidOffset,this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);const E=this.getScene().collisionCoordinator;return this._internalAbstractMeshDataInfo._meshCollisionData._collider||(this._internalAbstractMeshDataInfo._meshCollisionData._collider=E.createCollider()),this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius=this.ellipsoid,E.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,p,this._internalAbstractMeshDataInfo._meshCollisionData._collider,this.collisionRetryCount,this,this._onCollisionPositionChange,this.uniqueId),this}_collideForSubMesh(p,_,E){if(this._generatePointsArray(),!this._positions)return this;if(!p._lastColliderWorldVertices||!p._lastColliderTransformMatrix.equals(_)){p._lastColliderTransformMatrix=_.clone(),p._lastColliderWorldVertices=[],p._trianglePlanes=[];const A=p.verticesStart,$=p.verticesStart+p.verticesCount;for(let ne=A;ne<$;ne++)p._lastColliderWorldVertices.push(nt.TransformCoordinates(this._positions[ne],_))}return E._collide(p._trianglePlanes,p._lastColliderWorldVertices,this.getIndices(),p.indexStart,p.indexStart+p.indexCount,p.verticesStart,!!p.getMaterial(),this,this._shouldConvertRHS(),p.getMaterial()?.fillMode===7),this}_processCollisionsForSubMeshes(p,_){const E=this._scene.getCollidingSubMeshCandidates(this,p),A=E.length;for(let $=0;$<A;$++){const ne=E.data[$];A>1&&!ne._checkCollision(p)||this._collideForSubMesh(ne,_,p)}return this}_shouldConvertRHS(){return!1}_checkCollision(p){if(!this.getBoundingInfo()._checkCollision(p))return this;const _=pi.Matrix[0],E=pi.Matrix[1];return Yt.ScalingToRef(1/p._radius.x,1/p._radius.y,1/p._radius.z,_),this.worldMatrixFromCache.multiplyToRef(_,E),this._processCollisionsForSubMeshes(p,E),this}_generatePointsArray(){return!1}intersects(p,_,E,A=!1,$,ne=!1){const xe=new nm,ce=this.getClassName(),Te=ce==="InstancedLinesMesh"||ce==="LinesMesh"||ce==="GreasedLineMesh"?this.intersectionThreshold:0,Re=this.getBoundingInfo();if(!this.subMeshes||!ne&&(!p.intersectsSphere(Re.boundingSphere,Te)||!p.intersectsBox(Re.boundingBox,Te)))return xe;if(A)return xe.hit=!ne,xe.pickedMesh=ne?null:this,xe.distance=ne?0:nt.Distance(p.origin,Re.boundingSphere.center),xe.subMeshId=0,xe;if(!this._generatePointsArray())return xe;let ke=null;const We=this._scene.getIntersectingSubMeshCandidates(this,p),Xe=We.length;let xt=!1;for(let qe=0;qe<Xe;qe++){const Nt=We.data[qe].getMaterial();if(Nt&&(Nt.fillMode==7||Nt.fillMode==0||Nt.fillMode==1||Nt.fillMode==2||Nt.fillMode==4)){xt=!0;break}}if(!xt)return xe.hit=!0,xe.pickedMesh=this,xe.distance=nt.Distance(p.origin,Re.boundingSphere.center),xe.subMeshId=-1,xe;for(let qe=0;qe<Xe;qe++){const ht=We.data[qe];if(Xe>1&&!ne&&!ht.canIntersects(p))continue;const Nt=ht.intersects(p,this._positions,this.getIndices(),_,E);if(Nt&&(_||!ke||Nt.distance<ke.distance)&&(ke=Nt,ke.subMeshId=qe,_))break}if(ke){const qe=$??this.getWorldMatrix(),ht=pi.Vector3[0],Nt=pi.Vector3[1];nt.TransformCoordinatesToRef(p.origin,qe,ht),p.direction.scaleToRef(ke.distance,Nt);const Qt=nt.TransformNormal(Nt,qe).addInPlace(ht);return xe.hit=!0,xe.distance=nt.Distance(ht,Qt),xe.pickedPoint=Qt,xe.pickedMesh=this,xe.bu=ke.bu||0,xe.bv=ke.bv||0,xe.subMeshFaceId=ke.faceId,xe.faceId=ke.faceId+We.data[ke.subMeshId].indexStart/(this.getClassName().indexOf("LinesMesh")!==-1?2:3),xe.subMeshId=ke.subMeshId,xe}return xe}clone(p,_,E){return null}releaseSubMeshes(){if(this.subMeshes)for(;this.subMeshes.length;)this.subMeshes[0].dispose();else this.subMeshes=[];return this}dispose(p,_=!1){let E;const A=this.getScene();for(this._scene.useMaterialMeshMap&&this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),A.freeActiveMeshes(),A.freeRenderingGroups(),A.renderingManager.maintainStateBetweenFrames&&A.renderingManager.restoreDispachedFlags(),this.actionManager!==void 0&&this.actionManager!==null&&(this._scene.meshes.some(xe=>xe!==this&&xe.actionManager===this.actionManager)||this.actionManager.dispose(),this.actionManager=null),this._internalAbstractMeshDataInfo._skeleton=null,this._transformMatrixTexture&&(this._transformMatrixTexture.dispose(),this._transformMatrixTexture=null),E=0;E<this._intersectionsInProgress.length;E++){const xe=this._intersectionsInProgress[E],ce=xe._intersectionsInProgress.indexOf(this);xe._intersectionsInProgress.splice(ce,1)}this._intersectionsInProgress.length=0,A.lights.forEach(xe=>{let ce=xe.includedOnlyMeshes.indexOf(this);ce!==-1&&xe.includedOnlyMeshes.splice(ce,1),ce=xe.excludedMeshes.indexOf(this),ce!==-1&&xe.excludedMeshes.splice(ce,1);const Te=xe.getShadowGenerators();if(Te){const Re=Te.values();for(let ke=Re.next();ke.done!==!0;ke=Re.next()){const Xe=ke.value.getShadowMap();Xe&&Xe.renderList&&(ce=Xe.renderList.indexOf(this),ce!==-1&&Xe.renderList.splice(ce,1))}}}),(this.getClassName()!=="InstancedMesh"||this.getClassName()!=="InstancedLinesMesh")&&this.releaseSubMeshes();const ne=A.getEngine();if(this._occlusionQuery!==null&&(this.isOcclusionQueryInProgress=!1,ne.deleteQuery(this._occlusionQuery),this._occlusionQuery=null),ne.wipeCaches(),A.removeMesh(this),this._parentContainer){const xe=this._parentContainer.meshes.indexOf(this);xe>-1&&this._parentContainer.meshes.splice(xe,1),this._parentContainer=null}if(_&&this.material&&(this.material.getClassName()==="MultiMaterial"?this.material.dispose(!1,!0,!0):this.material.dispose(!1,!0)),!p)for(E=0;E<A.particleSystems.length;E++)A.particleSystems[E].emitter===this&&(A.particleSystems[E].dispose(),E--);this._internalAbstractMeshDataInfo._facetData.facetDataEnabled&&this.disableFacetData(),this._uniformBuffer.dispose(),this.onAfterWorldMatrixUpdateObservable.clear(),this.onCollideObservable.clear(),this.onCollisionPositionChangeObservable.clear(),this.onRebuildObservable.clear(),super.dispose(p,_)}addChild(p,_=!1){return p.setParent(this,_),this}removeChild(p,_=!1){return p.setParent(null,_),this}_initFacetData(){const p=this._internalAbstractMeshDataInfo._facetData;p.facetNormals||(p.facetNormals=[]),p.facetPositions||(p.facetPositions=[]),p.facetPartitioning||(p.facetPartitioning=new Array),p.facetNb=this.getIndices().length/3|0,p.partitioningSubdivisions=p.partitioningSubdivisions?p.partitioningSubdivisions:10,p.partitioningBBoxRatio=p.partitioningBBoxRatio?p.partitioningBBoxRatio:1.01;for(let _=0;_<p.facetNb;_++)p.facetNormals[_]=nt.Zero(),p.facetPositions[_]=nt.Zero();return p.facetDataEnabled=!0,this}updateFacetData(){const p=this._internalAbstractMeshDataInfo._facetData;p.facetDataEnabled||this._initFacetData();const _=this.getVerticesData(ut.PositionKind),E=this.getIndices(),A=this.getVerticesData(ut.NormalKind),$=this.getBoundingInfo();if(p.facetDepthSort&&!p.facetDepthSortEnabled){if(p.facetDepthSortEnabled=!0,E instanceof Uint16Array)p.depthSortedIndices=new Uint16Array(E);else if(E instanceof Uint32Array)p.depthSortedIndices=new Uint32Array(E);else{let xe=!1;for(let ce=0;ce<E.length;ce++)if(E[ce]>65535){xe=!0;break}xe?p.depthSortedIndices=new Uint32Array(E):p.depthSortedIndices=new Uint16Array(E)}if(p.facetDepthSortFunction=function(xe,ce){return ce.sqDistance-xe.sqDistance},!p.facetDepthSortFrom){const xe=this.getScene().activeCamera;p.facetDepthSortFrom=xe?xe.position:nt.Zero()}p.depthSortedFacets=[];for(let xe=0;xe<p.facetNb;xe++){const ce={ind:xe*3,sqDistance:0};p.depthSortedFacets.push(ce)}p.invertedMatrix=Yt.Identity(),p.facetDepthSortOrigin=nt.Zero()}p.bbSize.x=$.maximum.x-$.minimum.x>as?$.maximum.x-$.minimum.x:as,p.bbSize.y=$.maximum.y-$.minimum.y>as?$.maximum.y-$.minimum.y:as,p.bbSize.z=$.maximum.z-$.minimum.z>as?$.maximum.z-$.minimum.z:as;let ne=p.bbSize.x>p.bbSize.y?p.bbSize.x:p.bbSize.y;if(ne=ne>p.bbSize.z?ne:p.bbSize.z,p.subDiv.max=p.partitioningSubdivisions,p.subDiv.X=Math.floor(p.subDiv.max*p.bbSize.x/ne),p.subDiv.Y=Math.floor(p.subDiv.max*p.bbSize.y/ne),p.subDiv.Z=Math.floor(p.subDiv.max*p.bbSize.z/ne),p.subDiv.X=p.subDiv.X<1?1:p.subDiv.X,p.subDiv.Y=p.subDiv.Y<1?1:p.subDiv.Y,p.subDiv.Z=p.subDiv.Z<1?1:p.subDiv.Z,p.facetParameters.facetNormals=this.getFacetLocalNormals(),p.facetParameters.facetPositions=this.getFacetLocalPositions(),p.facetParameters.facetPartitioning=this.getFacetLocalPartitioning(),p.facetParameters.bInfo=$,p.facetParameters.bbSize=p.bbSize,p.facetParameters.subDiv=p.subDiv,p.facetParameters.ratio=this.partitioningBBoxRatio,p.facetParameters.depthSort=p.facetDepthSort,p.facetDepthSort&&p.facetDepthSortEnabled&&(this.computeWorldMatrix(!0),this._worldMatrix.invertToRef(p.invertedMatrix),nt.TransformCoordinatesToRef(p.facetDepthSortFrom,p.invertedMatrix,p.facetDepthSortOrigin),p.facetParameters.distanceTo=p.facetDepthSortOrigin),p.facetParameters.depthSortedFacets=p.depthSortedFacets,A&&Yr.ComputeNormals(_,E,A,p.facetParameters),p.facetDepthSort&&p.facetDepthSortEnabled){p.depthSortedFacets.sort(p.facetDepthSortFunction);const xe=p.depthSortedIndices.length/3|0;for(let ce=0;ce<xe;ce++){const Te=p.depthSortedFacets[ce].ind;p.depthSortedIndices[ce*3]=E[Te],p.depthSortedIndices[ce*3+1]=E[Te+1],p.depthSortedIndices[ce*3+2]=E[Te+2]}this.updateIndices(p.depthSortedIndices,void 0,!0)}return this}getFacetLocalNormals(){const p=this._internalAbstractMeshDataInfo._facetData;return p.facetNormals||this.updateFacetData(),p.facetNormals}getFacetLocalPositions(){const p=this._internalAbstractMeshDataInfo._facetData;return p.facetPositions||this.updateFacetData(),p.facetPositions}getFacetLocalPartitioning(){const p=this._internalAbstractMeshDataInfo._facetData;return p.facetPartitioning||this.updateFacetData(),p.facetPartitioning}getFacetPosition(p){const _=nt.Zero();return this.getFacetPositionToRef(p,_),_}getFacetPositionToRef(p,_){const E=this.getFacetLocalPositions()[p],A=this.getWorldMatrix();return nt.TransformCoordinatesToRef(E,A,_),this}getFacetNormal(p){const _=nt.Zero();return this.getFacetNormalToRef(p,_),_}getFacetNormalToRef(p,_){const E=this.getFacetLocalNormals()[p];return nt.TransformNormalToRef(E,this.getWorldMatrix(),_),this}getFacetsAtLocalCoordinates(p,_,E){const A=this.getBoundingInfo(),$=this._internalAbstractMeshDataInfo._facetData,ne=Math.floor((p-A.minimum.x*$.partitioningBBoxRatio)*$.subDiv.X*$.partitioningBBoxRatio/$.bbSize.x),xe=Math.floor((_-A.minimum.y*$.partitioningBBoxRatio)*$.subDiv.Y*$.partitioningBBoxRatio/$.bbSize.y),ce=Math.floor((E-A.minimum.z*$.partitioningBBoxRatio)*$.subDiv.Z*$.partitioningBBoxRatio/$.bbSize.z);return ne<0||ne>$.subDiv.max||xe<0||xe>$.subDiv.max||ce<0||ce>$.subDiv.max?null:$.facetPartitioning[ne+$.subDiv.max*xe+$.subDiv.max*$.subDiv.max*ce]}getClosestFacetAtCoordinates(p,_,E,A,$=!1,ne=!0){const xe=this.getWorldMatrix(),ce=pi.Matrix[5];xe.invertToRef(ce);const Te=pi.Vector3[8];nt.TransformCoordinatesFromFloatsToRef(p,_,E,ce,Te);const Re=this.getClosestFacetAtLocalCoordinates(Te.x,Te.y,Te.z,A,$,ne);return A&&nt.TransformCoordinatesFromFloatsToRef(A.x,A.y,A.z,xe,A),Re}getClosestFacetAtLocalCoordinates(p,_,E,A,$=!1,ne=!0){let xe=null,ce=0,Te=0,Re=0,ke=0,We=0,Xe=0,xt=0,qe=0;const ht=this.getFacetLocalPositions(),Nt=this.getFacetLocalNormals(),wt=this.getFacetsAtLocalCoordinates(p,_,E);if(!wt)return null;let Qt=Number.MAX_VALUE,Ht=Qt,Wt,zt,xi;for(let wi=0;wi<wt.length;wi++)Wt=wt[wi],zt=Nt[Wt],xi=ht[Wt],ke=(p-xi.x)*zt.x+(_-xi.y)*zt.y+(E-xi.z)*zt.z,(!$||$&&ne&&ke>=0||$&&!ne&&ke<=0)&&(ke=zt.x*xi.x+zt.y*xi.y+zt.z*xi.z,We=-(zt.x*p+zt.y*_+zt.z*E-ke)/(zt.x*zt.x+zt.y*zt.y+zt.z*zt.z),Xe=p+zt.x*We,xt=_+zt.y*We,qe=E+zt.z*We,ce=Xe-p,Te=xt-_,Re=qe-E,Ht=ce*ce+Te*Te+Re*Re,Ht<Qt&&(Qt=Ht,xe=Wt,A&&(A.x=Xe,A.y=xt,A.z=qe)));return xe}getFacetDataParameters(){return this._internalAbstractMeshDataInfo._facetData.facetParameters}disableFacetData(){const p=this._internalAbstractMeshDataInfo._facetData;return p.facetDataEnabled&&(p.facetDataEnabled=!1,p.facetPositions=[],p.facetNormals=[],p.facetPartitioning=new Array,p.facetParameters=null,p.depthSortedIndices=new Uint32Array(0)),this}updateIndices(p,_,E=!1){return this}createNormals(p){const _=this.getVerticesData(ut.PositionKind),E=this.getIndices();let A;return this.isVerticesDataPresent(ut.NormalKind)?A=this.getVerticesData(ut.NormalKind):A=[],Yr.ComputeNormals(_,E,A,{useRightHandedSystem:this.getScene().useRightHandedSystem}),this.setVerticesData(ut.NormalKind,A,p),this}alignWithNormal(p,_){_||(_=$c.Y);const E=pi.Vector3[0],A=pi.Vector3[1];return nt.CrossToRef(_,p,A),nt.CrossToRef(p,A,E),this.rotationQuaternion?_s.RotationQuaternionFromAxisToRef(E,p,A,this.rotationQuaternion):nt.RotationFromAxisToRef(E,p,A,this.rotation),this}_checkOcclusionQuery(){return!1}disableEdgesRendering(){throw Tr("EdgesRenderer")}enableEdgesRendering(p,_,E){throw Tr("EdgesRenderer")}getConnectedParticleSystems(){return this._scene.particleSystems.filter(p=>p.emitter===this)}}zo.OCCLUSION_TYPE_NONE=0,zo.OCCLUSION_TYPE_OPTIMISTIC=1,zo.OCCLUSION_TYPE_STRICT=2,zo.OCCLUSION_ALGORITHM_TYPE_ACCURATE=0,zo.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE=1,zo.CULLINGSTRATEGY_STANDARD=0,zo.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY=1,zo.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION=2,zo.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY=3,zs("BABYLON.AbstractMesh",zo);class LU extends null{constructor(p,_,E){super({container:p,mode:_,layerCount:2,mirror:E});const A=this.canvas.layers[1];this.renderer=new l(A,!0,{alpha:!0,preserveDrawingBuffer:!0},!0);const $=window.devicePixelRatio;this.renderer.setSize(A.clientWidth*$,A.clientHeight*$),this.canvas.on("resize",()=>{this.renderer.setSize(A.clientWidth*$,A.clientHeight*$)}),this.scene=new S(this.renderer),this.scene.useRightHandedSystem=!0,this.scene.clearColor=new L(0,0,0,0),this.camera=new s("camera",new z(0,0,0),this.scene),this.camera.rotationQuaternion=new e(1,0,0,0),this.camera.fov=this.cameraAngle,this.camera.minZ=.02,this.camera.maxZ=20}updateScene(){var p;(p=this.scene)==null||p.render()}dispose(){var p;this.renderer.dispose(),this.camera.dispose(),(p=this.scene)==null||p.dispose(),super.dispose()}setupCamera(p,_){super.setupCamera(p,_),this.camera.fov=this.cameraAngle,this.camera.getProjectionMatrix(!0)}}class aN extends Ln{}class xN extends aN{}class kU extends null{}class __ extends Wi{constructor(p,_,E){super({container:p,mode:_,layerCount:1,mirror:E});const A=this.canvas.layers[0];this.renderer=new ui(A,!0,{alpha:!0,preserveDrawingBuffer:!0},!0);const $=window.devicePixelRatio;this.renderer.setSize(A.clientWidth*$,A.clientHeight*$),this.canvas.on("resize",()=>{this.renderer.setSize(A.clientWidth*$,A.clientHeight*$)}),this.scene=new W0(this.renderer),this.scene.useRightHandedSystem=!0,this.scene.clearColor=new vr(0,0,0,0),this.camera=new a_("camera",new nt(0,0,0),this.scene),this.camera.rotationQuaternion=new _s(1,0,0,0),this.camera.fov=this.cameraAngle,this.camera.minZ=.02,this.camera.maxZ=20,this.layer=new ww("video",null,this.scene,!0)}updateVideo(p){const{shader:_,shaderCtx:E}=this;if(!(!this.current||!_||!E))return _.process([this.current],{flip:[1]}),ci.prototype.updateVideo.call(this,p)}updateScene(){var p;(p=this.scene)==null||p.render()}dispose(){var p,_,E,A,$;(E=(_=(p=this.layer.texture)==null?void 0:p.getInternalTexture())==null?void 0:_._hardwareTexture)==null||E.reset(),(A=this.layer.texture)==null||A.dispose(),this.layer.dispose(),this.camera.dispose(),($=this.scene)==null||$.dispose(),this.renderer.dispose(),super.dispose()}setupVideo(p,_){var E,A,$,ne;ci.prototype.setupVideo.call(this,p,_);const{input:xe,shader:ce,videoSize:Te}=this;($=(A=(E=this.layer.texture)==null?void 0:E.getInternalTexture())==null?void 0:A._hardwareTexture)==null||$.reset(),(ne=this.layer.texture)==null||ne.dispose(),this.layer.texture=null,xe?.resize(Te),ce?.resize(Te);const Re=ce?.output();Re&&(this.layer.texture=new la(this.scene,this.renderer.wrapWebGLTexture(Re)))}setupCamera(p,_){var E;super.setupCamera(p,_),this.camera.fov=this.cameraAngle,(E=this.scene)==null||E.updateTransformMatrix()}}class lN extends __{}class UU extends null{}class GU extends null{}class zU extends null{}class WU extends null{constructor(p,_=!1){super(),this.node=p,this.shapeScale=_}async update(p,_){var E;if(!this.loaded||!this.node)return;const A=(E=p.faces[0])==null?void 0:E.transform;if(!A)return this.node.setEnabled(!1),super.update(p,_);const $=z.FromArray(A.translation),ne=new z().setAll(A.scale),xe=z.FromArray(A.shapeScale).scale(A.scale),ce=e.FromArray(A.rotation);return this.node.setEnabled(!0),this.node.rotationQuaternion=ce,this.node.position=$,this.node.scaling=this.shapeScale?xe:ne,super.update(p,_)}setNode(p){this.node=p}}class HU extends null{constructor(p,_=0,E=!1){super(),this.node=p,this.facePoint=_,this.shapeScale=E}async update(p,_){if(!this.loaded||!this.node)return;const{transform:E=void 0,metric:A=void 0}=p.faces[0]||{};if(!E||!A)return this.node.setEnabled(!1),super.update(p,_);const $=z.FromArray(A[this.facePoint]),ne=new z().setAll(E.scale),xe=z.FromArray(E.shapeScale).scale(E.scale),ce=e.FromArray(E.rotation);return this.node.setEnabled(!0),this.node.rotationQuaternion=ce,this.node.position=$,this.node.scaling=this.shapeScale?xe:ne,super.update(p,_)}setNode(p){this.node=p}}class XU extends null{constructor(p){super(),this.mesh=p,this.pointCont=k.length}async load(p){this.loaded||(await super.load(p),await this.setMesh(this.mesh))}async update(p,_){var E;if(!this.loaded||!this.mesh)return;const A=(E=p.faces[0])==null?void 0:E.metric;return A?(this.mesh.setEnabled(!0),this.mesh.updateVerticesData(u.PositionKind,A.slice(0,this.pointCont).flat()),super.update(p,_)):(this.mesh.setEnabled(!1),super.update(p,_))}async setMesh(p){if(delete this.mesh,this.mesh=p,!(!this.loaded||!p)){var _=new i;_.positions=k.flat(),_.indices=a.flat(),_.uvs=v.flat(),_.normals=[],i.ComputeNormals(_.positions,_.indices,_.normals),_.applyToMesh(p,!0),p.renderingGroupId=1}}}var hN=Object.defineProperty,cN=Object.defineProperties,uN=Object.getOwnPropertyDescriptors,HT=Object.getOwnPropertySymbols,_N=Object.prototype.hasOwnProperty,TN=Object.prototype.propertyIsEnumerable,XT=(_e,p,_)=>p in _e?hN(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,KT=(_e,p)=>{for(var _ in p||(p={}))_N.call(p,_)&&XT(_e,_,p[_]);if(HT)for(var _ of HT(p))TN.call(p,_)&&XT(_e,_,p[_]);return _e},YT=(_e,p)=>cN(_e,uN(p));const jT=null,lm=(_e,p)=>D(_e,p),vN=_e=>lm(_e,jT),y_=null,RN=null;class KU extends null{constructor(p,_={spineCurve:1,pelvisDZ:.01}){super(),this.node=p,this.tune=_,this.nodeOrigin={position:new z(0,0,-1),rotation:new e},this.cameraRatio=1920/1080,this.cameraAngle=10/180*Math.PI,this.alignScore=.9,this.alignVisibility=.9}async load(p){this.loaded||(await super.load(p),this.setNode(this.node))}unload(){this.loaded&&(delete this.node,delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,super.unload())}setNode(p){var _,E;if(delete this.skeletonNodes,delete this.skeleton,delete this.skeletonSizes,delete this.spineCurve,this.node=p,!this.loaded||!p)return;this.skeleton=((_=p.getChildMeshes(!1).find(vs=>vs.skeleton))==null?void 0:_.skeleton)||void 0;const A=(E=this.skeleton)==null?void 0:E.bones;if(!A)return;const $={root:"joint",pelvis:"pelvis",spine:"spine",spine1:"spine1",spine2:"spine2",spine3:"spine3",neck:"neck",neck1:"neck1",head:"head",headEnd:"head_tip",shoulderL:"left_shoulder",shoulderR:"right_shoulder",armL:"left_arm",armR:"right_arm",armMidL:"left_arm_middle",armMidR:"right_arm_middle",forearmL:"left_forearm",forearmR:"right_forearm",forearmMidL:"left_forearm_middie",forearmMidR:"right_forearm_middie",handL:"left_hand",handR:"right_hand",uplegL:"left_thigh",uplegR:"right_thigh",uplegMidL:"left_thigh1",uplegMidR:"right_thigh1",legL:"left_shin",legR:"right_shin",footL:"left_ankle",footR:"right_ankle"},ne=vN(vs=>{var cs;return(cs=A.find(Mr=>Mr.name.toLowerCase().endsWith($[vs])))==null?void 0:cs.getTransformNode()});function xe(vs){return jT.every(cs=>vs[cs])}if(!xe(ne))return;this.skeletonNodes=ne;const ce=lm(vs=>ne[vs].absolutePosition,["shoulderL","shoulderR","neck","neck1","head","armL","armR","armMidL","forearmL","forearmMidL","handL","uplegL","uplegR","uplegMidL","legL","footL"]),Te=z.Lerp(ce.uplegL,ce.uplegR,.5),Re=z.Lerp(ce.shoulderL,ce.shoulderR,.5),ke=Re.subtract(Te).length(),We=ce.forearmL.subtract(ce.armL).length(),Xe=ce.handL.subtract(ce.forearmL).length(),xt=ce.legL.subtract(ce.uplegL).length(),qe=ce.footL.subtract(ce.legL).length();this.skeletonSizes={spineLen:ke,hipsWidth:ce.uplegL.subtract(ce.uplegR).length(),shoulderWidth:ce.armL.subtract(ce.armR).length(),shoulderRatio:ce.shoulderL.subtract(Re).length()/ce.armL.subtract(Re).length(),neckRatio:ce.neck1.subtract(ce.neck).length()/ce.head.subtract(ce.neck).length(),armLen:We,armRatio:ce.armMidL.subtract(ce.armL).length()/We,forearmLen:Xe,forearmRatio:ce.forearmMidL.subtract(ce.forearmL).length()/Xe,uplegLen:xt,uplegRatio:ce.uplegMidL.subtract(ce.uplegL).length()/xt,legLen:qe};const ht=z.Cross(ce.shoulderL.subtract(Te),ce.shoulderR.subtract(Te)).normalize(),Nt=ne.pelvis.absolutePosition.subtract(Te).length(),wt=YT(KT({},lm(vs=>ne[vs].absolutePosition,["root","spine","spine1","spine2","spine3","neck","pelvis"])),{pelvisEnd:ne.pelvis.absolutePosition.add(new z(0,Nt,0).applyRotationQuaternion(ne.pelvis.absoluteRotationQuaternion))});this.spineCurve=D(vs=>{const cs=wt[vs].subtract(Te),Mr=z.Dot(cs,ht);return[cs.subtract(ht.scale(Mr)).length()/ke,Mr/ke]},y_),this.nodeOrigin={position:p.absolutePosition.subtract(ne.root.absolutePosition).applyRotationQuaternion(ne.root.absoluteRotationQuaternion.conjugate()),rotation:p.absoluteRotationQuaternion.multiply(ne.root.absoluteRotationQuaternion.conjugate())};let{min:Qt,max:Ht}=p.getHierarchyBoundingVectors();const Wt=Qt.add(Ht).scale(.5),zt=Ht.subtract(Qt),xi=Math.max(zt.x,zt.y,zt.z)*1.1*.5,wi=new z(xi,xi,xi);Qt=Wt.subtract(wi),Ht=Wt.add(wi),p.getChildMeshes(!1).forEach(vs=>vs.buildBoundingInfo(Qt,Ht))}async update(p,_){var E,A;if(!this.loaded||!this.node)return;const $=(E=p.poses[0])==null?void 0:E.points,{node:ne,skeletonNodes:xe,skeletonSizes:ce,spineCurve:Te}=this;if(!xe||!ce||!Te||!$)return ne.setEnabled(!1),super.update(p,_);const Re=r.map(ht=>$[ht]),ke=Re.map(ht=>ht.norm);this.equalize(ke);for(let ht=0;ht<4;ht++)this.align(Re);const We=this.estimateBones($,Te,ce),Xe={position:We.root.position.add(this.nodeOrigin.position.applyRotationQuaternion(We.root.rotation)),rotation:We.root.rotation.multiply(this.nodeOrigin.rotation)};(A=this.skeleton)==null||A.returnToRest(),this.alignBone(Xe,ne,!1),this.updateSpine(We,xe);const xt=lm(ht=>({transform:We[ht],bone:xe[ht]}),["armL","armMidL","forearmL","forearmMidL","handL","armR","armMidR","forearmR","forearmMidR","handR"]);this.updateArm({arm:xt.armL,armMid:xt.armMidL,forearm:xt.forearmL,forearmMid:xt.forearmMidL,hand:xt.handL},{shoulder:$.shoulderL,elbow:$.elbowL}),this.updateArm({arm:xt.armR,armMid:xt.armMidR,forearm:xt.forearmR,forearmMid:xt.forearmMidR,hand:xt.handR},{shoulder:$.shoulderR,elbow:$.elbowR});const qe=lm(ht=>({transform:We[ht],bone:xe[ht]}),["uplegL","uplegMidL","legL","footL","uplegR","uplegMidR","legR","footR"]);return this.updateLeg({upleg:qe.uplegL,uplegMid:qe.uplegMidL,leg:qe.legL,foot:qe.footL},{hip:$.hipL,knee:$.kneeL}),this.updateLeg({upleg:qe.uplegR,uplegMid:qe.uplegMidR,leg:qe.legR,foot:qe.footR},{hip:$.hipR,knee:$.kneeR}),ne.setEnabled(!0),super.update(p,_)}updateSpine(p,_){this.alignBone(p.root,_.root,!1),this.alignBone(p.spine,_.spine,!1),this.alignBone(p.spine1,_.spine1),this.alignBone(p.spine2,_.spine2),this.alignBone(p.spine3,_.spine3),this.alignBone(p.neck,_.neck,!1),this.alignBone(p.neck1,_.neck1,!1),this.alignBone(p.head,_.head,!1),_.head.scaling.setAll(1.1),this.alignBone(p.pelvis,_.pelvis,!1),this.alignBone(p.shoulderL,_.shoulderL,!1),this.alignBone(p.shoulderR,_.shoulderR,!1)}updateArm(p,_){this.alignBone(p.arm.transform,p.arm.bone),this.alignBone(p.armMid.transform,p.armMid.bone),this.alignBone(p.forearm.transform,p.forearm.bone),this.alignBone(p.forearmMid.transform,p.forearmMid.bone),this.connectBone(p.hand.transform.position,p.hand.bone),p.hand.bone.scaling.setAll(.95)}updateLeg(p,_){this.alignBone(p.upleg.transform,p.upleg.bone,!1),this.alignBone(p.uplegMid.transform,p.uplegMid.bone),this.alignBone(p.leg.transform,p.leg.bone),this.connectBone(p.foot.transform.position,p.foot.bone)}estimateBones(p,_,E){var A,$;const ne=c(Xe=>new z(...p[Xe].metric)),xe=this.estimateTorso(ne);if(this.tune.hipsD){const Xe=xe.hipsZ.scale(this.tune.hipsD[2]),xt=xe.hipsY.scale(this.tune.hipsD[1]).add(xe.torsoN.scale((A=this.tune)==null?void 0:A.hipsD[0]));ne.hipL.addInPlace(xt).addInPlace(Xe),ne.hipR.addInPlace(xt).addInPlace(Xe.negate()),xe.length-=this.tune.hipsD[1]}if(this.tune.shouldersD){const Xe=xe.shoulderL0.subtract(xe.shoulderR0).normalize().scale(this.tune.shouldersD[2]),xt=xe.hipsY.scale(this.tune.shouldersD[1]).add(xe.torsoN.scale(($=this.tune)==null?void 0:$.shouldersD[0]));ne.shoulderL.addInPlace(xt).addInPlace(Xe),ne.shoulderR.addInPlace(xt).addInPlace(Xe.negate()),xe.shoulderL0.addInPlace(xt),xe.shoulderR0.addInPlace(xt),xe.neck.addInPlace(xt),xe.length+=this.tune.shouldersD[1]}const ce=this.estimateSpine(ne,xe,_,E),Te=this.estimateArm({shoulder0:xe.shoulderL0,shoulder:ne.shoulderL,elbow:ne.elbowL,wrist:ne.wristL},xe,E),Re=this.estimateArm({shoulder0:xe.shoulderR0,shoulder:ne.shoulderR,elbow:ne.elbowR,wrist:ne.wristR},xe,E),ke=this.estimateLeg({hip:ne.hipL,knee:ne.kneeL,ankle:ne.ankleL},xe,E),We=this.estimateLeg({hip:ne.hipR,knee:ne.kneeR,ankle:ne.ankleR},xe,E);return YT(KT({},ce),{shoulderL:Te.shoulder,armL:Te.arm,armMidL:Te.armMid,forearmL:Te.forearm,forearmMidL:Te.forearmMid,handL:Te.hand,shoulderR:Re.shoulder,armR:Re.arm,armMidR:Re.armMid,forearmR:Re.forearm,forearmMidR:Re.forearmMid,handR:Re.hand,uplegL:ke.upleg,uplegMidL:ke.uplegMid,legL:ke.leg,footL:ke.foot,uplegR:We.upleg,uplegMidR:We.uplegMid,legR:We.leg,footR:We.foot})}estimateTorso(p){const _=z.Lerp(p.hipL,p.hipR,.5),E=z.Lerp(p.shoulderL,p.shoulderR,.5).subtract(_).normalize(),A=p.elbowL.subtract(p.shoulderL).normalize(),$=p.elbowR.subtract(p.shoulderR).normalize(),ne=z.Dot(A,E),xe=z.Dot($,E),ce=p.shoulderL.add(p.shoulderL.subtract(p.hipL).normalize().scale(((Math.acos(ne)/Math.PI)**2*2-1)*(ne>0?.04:.02))),Te=p.shoulderR.add(p.shoulderR.subtract(p.hipR).normalize().scale(((Math.acos(xe)/Math.PI)**2*2-1)*(xe>0?.04:.02))),Re=z.Lerp(ce,Te,.5),ke=z.Cross(ce.subtract(_),Te.subtract(_)).normalize(),We=Re.subtract(_),Xe=p.hipL.subtract(p.hipR).normalize(),xt=We.length();return We.normalize(),{hipsC:_,hipsY:We,hipsZ:Xe,torsoN:ke,length:xt,neck:Re,shoulderL0:ce,shoulderR0:Te}}estimateSpine(p,_,E,A){const{shoulderL0:$,shoulderR0:ne,hipsY:xe,torsoN:ce,length:Te}=_,Re=D(zt=>{const xi=z.Lerp(p.hipL,$,E[zt][0]),wi=z.Lerp(p.hipR,ne,E[zt][0]),vs=z.Lerp(xi,wi,.5),cs=wi.subtract(xi);return{position:vs,axisZ:cs}},y_);if(this.tune.spineCurve){const zt=this.tune.spineCurve*Te;y_.forEach(xi=>Re[xi].position.addInPlace(ce.scale(E[xi][1]*zt))),this.tune.pelvisDZ&&Re.pelvisEnd.position.addInPlace(ce.scale(this.tune.pelvisDZ))}const ke=z.Lerp(p.earL,p.earR,.5),We=ke.subtract(p.nose).normalize(),Xe=p.earR.subtract(p.earL).normalize(),xt=We.cross(Xe).normalize().add(We.scale(.2)).normalize(),qe=ke.add(We.scale(.02)).add(xt.scale(-.02)),ht=this.estimateRotationYZ(xt,Xe),Nt=z.Lerp(Re.neck.axisZ,Xe,.15).normalize(),wt=z.Lerp(Re.neck.position,qe,A.neckRatio),Qt=z.Lerp(Nt,Xe,A.neckRatio).normalize(),Ht=Re.pelvisEnd.position.subtract(Re.pelvis.position),Wt=this.estimateRotationYX(Ht,Re.pelvis.axisZ.negate());return{root:this.estimateBone(Re.root.position,Re.root.position.add(ce.negate()),xe),spine:this.estimateBone(Re.spine.position,Re.spine1.position,Re.spine.axisZ),spine1:this.estimateBone(Re.spine1.position,Re.spine2.position,Re.spine1.axisZ),spine2:this.estimateBone(Re.spine2.position,Re.spine3.position,Re.spine2.axisZ),spine3:this.estimateBone(Re.spine3.position,Re.neck.position,Re.spine3.axisZ),neck:this.estimateBone(Re.neck.position,wt,Nt),neck1:this.estimateBone(wt,qe,Qt),head:{position:qe,rotation:ht},pelvis:{position:Re.pelvis.position,rotation:Wt}}}estimateArm(p,_,E){const{neck:A,torsoN:$,hipsY:ne}=_,xe=p.elbow.subtract(p.shoulder).normalize(),ce=z.Lerp(A,p.shoulder,E.shoulderRatio),Te=p.shoulder.subtract(ce),Re=Math.sqrt(.5*(1+Math.sqrt(1-Math.max(z.Dot(xe,ne),0)**2))),ke=Math.sign(z.Dot($.cross(Te),ne)),We=this.estimateRotationYX(Te,$).multiply(new e(0,-Math.sqrt(.5*(1-Re))*ke,0,Math.sqrt(.5*(1+Re)))),Xe=this.estimateRotationYX(p.shoulder0.subtract(A),$),xt=new z(0,0,1).applyRotationQuaternion(Xe).applyRotationQuaternion(this.rotationBetween(Te,xe)),qe=p.wrist.subtract(p.elbow).normalize(),ht=this.rotationBetween(xe,qe),Nt=xt.applyRotationQuaternion(ht),wt=z.Lerp(p.shoulder,p.elbow,E.armRatio),Qt=z.Lerp(p.elbow,p.wrist,E.forearmRatio);return{shoulder:{position:ce,rotation:We},arm:this.estimateBone(p.shoulder,wt,xt),armMid:this.estimateBone(wt,p.elbow,xt),forearm:this.estimateBone(p.elbow,Qt,Nt),forearmMid:this.estimateBone(Qt,p.wrist,Nt),hand:{position:p.wrist,rotation:new e}}}estimateLeg(p,_,E){const{hipsZ:A,hipsY:$}=_,ne=p.knee.subtract(p.hip).normalize(),xe=this.rotationBetween($.negate(),ne),ce=A.applyRotationQuaternion(xe),Te=z.Lerp(p.hip,p.knee,E.uplegRatio),Re=p.ankle.subtract(p.knee).normalize(),ke=this.rotationBetween(ne,Re),We=ce.applyRotationQuaternion(ke);return{upleg:this.estimateBone(p.hip,Te,ce),uplegMid:this.estimateBone(Te,p.knee,ce),leg:this.estimateBone(p.knee,p.ankle,We),foot:{position:p.ankle,rotation:new e}}}estimateBone(p,_,E){return{position:p.clone(),rotation:this.estimateRotationYZ(_.subtract(p),E)}}estimateRotationYZ(p,_){const E=p.normalizeToNew(),A=E.cross(_).normalize(),$=A.cross(E);return e.RotationQuaternionFromAxis(A,E,$)}estimateRotationYX(p,_){const E=p.normalizeToNew(),A=_.cross(E).normalize(),$=E.cross(A).normalize();return e.RotationQuaternionFromAxis($,E,A)}rotationBetween(p,_){const E=z.Cross(p,_);return new e(E.x,E.y,E.z,Math.sqrt(1+z.Dot(p,_))).normalize()}alignBone(p,_,E=!0){let A=p.position.clone(),$=p.rotation.clone();_.parent instanceof R&&(A=z.TransformCoordinates(A,_.parent.computeWorldMatrix(!0).clone().invert()),$=_.parent.absoluteRotationQuaternion.conjugate().multiply($),E&&(_.parent.scaling.setAll(A.length()/_.position.length()),A=z.TransformCoordinates(p.position,_.parent.computeWorldMatrix(!0).clone().invert()))),_.position=A,_.rotationQuaternion=$}connectBone(p,_){let E=p.clone();_.parent instanceof R&&(E=z.TransformCoordinates(E,_.parent.computeWorldMatrix(!0).clone().invert()),_.parent.scaling.setAll(E.length()/_.position.length()),E=z.TransformCoordinates(p,_.parent.computeWorldMatrix(!0).clone().invert())),_.position=E}positionBone(p,_){let E=p.clone();_.parent instanceof R&&(E=z.TransformCoordinates(E,_.parent.computeWorldMatrix(!0).clone().invert())),_.position=E}rotateBone(p,_){let E=p.clone();_.parent instanceof R&&(_.parent.computeWorldMatrix(!0),E=_.parent.absoluteRotationQuaternion.conjugate().multiply(E)),_.rotationQuaternion=E}spineLength(p){const _=m(A=>new z(...p[x[A]]),RN),{length:E}=this.estimateTorso(_);return E}equalize(p){const _=O.lerp(p[11],p[12],.5),E=O.lerp(p[23],p[24],.5),A=O.sub(_,E),$=O.length(A),ne=Math.abs(A[2])/$,xe=.7;if(ne<xe){const ce=xe*(ne/xe)**7,Te=O.normalizeToLen([A[0]/$,A[1]/$,ce*Math.sign(A[2])],$),Re=O.sub(Te,A);for(let ke=0;ke<23;ke++)p[ke][0]+=Re[0],p[ke][1]+=Re[1],p[ke][2]+=Re[2]}}resize(p){const{skeletonSizes:_}=this;if(!_)return;const E=(vs,cs)=>vs.forEach(Mr=>{p[Mr][0]+=cs[0],p[Mr][1]+=cs[1],p[Mr][2]+=cs[2]}),A=O.lerp(p[11],p[12],.5),$=O.lerp(p[23],p[24],.5),ne=this.spineLength(p),xe=O.sub(A,$),ce=O.scale(xe,.5*(_.spineLen/ne-1)),Te=O.sub(p[11],p[12]),Re=O.scale(Te,.5*(_.shoulderWidth/O.length(Te)-1));E([11,13,15,17,19,21],O.add(ce,Re)),E([12,14,16,18,20,22],O.add(ce,O.negate(Re)));const ke=O.sub(p[23],p[24]),We=O.scale(ke,.5*(_.hipsWidth/O.length(ke)-1));E([23,25,27,29,31],O.add(O.negate(ce),We)),E([24,26,28,30,32],O.add(O.negate(ce),O.negate(We)));const Xe=O.sub(p[13],p[11]),xt=O.sub(p[15],p[13]),qe=O.scale(Xe,_.armLen/O.length(Xe)-1);p[13]=O.add(p[13],qe),E([15,17,19,21],O.add(qe,O.scale(xt,_.forearmLen/O.length(xt)-1)));const ht=O.sub(p[14],p[12]),Nt=O.sub(p[16],p[14]),wt=O.scale(ht,_.armLen/O.length(ht)-1);p[14]=O.add(p[14],wt),E([16,18,20,22],O.add(wt,O.scale(Nt,_.forearmLen/O.length(Nt)-1)));const Qt=O.sub(p[25],p[23]),Ht=O.sub(p[27],p[25]),Wt=O.scale(Qt,_.uplegLen/O.length(Qt)-1);p[25]=O.add(p[25],Wt),E([27,29,31],O.add(Wt,O.scale(Ht,_.legLen/O.length(Ht)-1)));const zt=O.sub(p[26],p[24]),xi=O.sub(p[28],p[26]),wi=O.scale(zt,_.uplegLen/O.length(zt)-1);p[26]=O.add(p[26],wi),E([28,30,32],O.add(wi,O.scale(xi,_.legLen/O.length(xi)-1)))}align(p,_=!0){const E=p.map(Re=>Re.norm);this.resize(E);const{alignScore:A,alignVisibility:$}=this,ne=[];if([11,12,23,24].forEach(Re=>{(p[Re].score>A||p[Re].visibility>$)&&ne.push({world:E[Re],pixel:p[Re].pixel})}),ne.length<2)return;const xe=b(ne,{angle:this.cameraAngle,ratio:this.cameraRatio});p.forEach((Re,ke)=>{const We=Re.metric;We[0]=E[ke][0]+xe[0],We[1]=E[ke][1]+xe[1],We[2]=E[ke][2]+xe[2]});const ce=2*Math.tan(.5*this.cameraAngle),Te=this.cameraRatio*ce;[11,12,23,24].forEach(Re=>{const ke=p[Re],We=[(ke.pixel[0]-.5)*Te,(ke.pixel[1]-.5)*ce],Xe=[ke.metric[0]/ke.metric[2],ke.metric[1]/ke.metric[2]],xt=[.5*(We[0]+Xe[0]),.5*(We[1]+Xe[1])];ke.pixel=[xt[0]/Te+.5,xt[1]/ce+.5,ke.pixel[2]]}),p.forEach(Re=>{if(_&&(Re.score>A||Re.visibility>$)){const ke=[(Re.pixel[0]-.5)*Te,(Re.pixel[1]-.5)*ce],We=Re.metric,Xe=Math.sqrt(We[0]**2+We[1]**2+We[2]**2),xt=Math.sqrt(ke[0]**2+ke[1]**2+1),qe=Xe/xt;We[0]=ke[0]*qe,We[1]=ke[1]*qe,We[2]=qe}Re.metric[1]=-Re.metric[1],Re.metric[2]=-Re.metric[2]}),p.forEach(Re=>{const ke=Re.metric;Re.norm=[ke[0],-ke[1],-ke[2]]})}setupCamera(p,_){this.cameraRatio=p,this.cameraAngle=_}}const qT=null,MN=(_e,p)=>D(_e,p),wN=_e=>MN(_e,qT);class YU extends null{setNode(p){var _;delete this.skirtSkeletonNodes,super.setNode(p);const E=(_=this.skeleton)==null?void 0:_.bones;if(!E)return;const A={uplegSkirtL:"left_thigh_skirt",uplegSkirtR:"right_thigh_skirt",uplegMidSkirtL:"left_thigh1_skirt",uplegMidSkirtR:"right_thigh1_skirt",legSkirtL:"left_shin_skirt",legSkirtR:"right_shin_skirt"},$=wN(xe=>{var ce;return(ce=E.find(Te=>Te.name.toLowerCase().endsWith(A[xe])))==null?void 0:ce.getTransformNode()});function ne(xe){return qT.every(ce=>xe[ce])}ne($)&&(this.skirtSkeletonNodes=$)}async update(p,_){var E,A;if(!this.loaded||!this.node)return;await super.update(p,_);const{skeletonNodes:$,skirtSkeletonNodes:ne}=this;if(!$||!ne)return;const{uplegL:xe,uplegR:ce,legL:Te,legR:Re}=$,{uplegSkirtL:ke,uplegSkirtR:We}=ne,Xe=(E=xe.rotationQuaternion)!=null?E:e.Identity(),xt=Te.position.applyRotationQuaternion(Xe.invert()).normalize(),qe=xt.clone();qe.z=Math.min(qe.z,0),qe.normalize();const ht=z.Cross(qe,xt),Nt=new e(ht.x,ht.y,ht.z,Math.sqrt(1+z.Dot(qe,xt))).normalize();ke.position=xe.position,ke.scaling=xe.scaling,ke.rotationQuaternion=Xe.multiply(Nt);const wt=(A=ce.rotationQuaternion)!=null?A:e.Identity(),Qt=Re.position.applyRotationQuaternion(wt.invert()).normalize(),Ht=Qt.clone();Ht.z=Math.max(Ht.z,0),Ht.normalize();const Wt=z.Cross(Ht,Qt),zt=new e(Wt.x,Wt.y,Wt.z,Math.sqrt(1+z.Dot(Qt,Ht))).normalize();We.position=ce.position,We.scaling=ce.scaling,We.rotationQuaternion=wt.multiply(zt)}}var LN=Object.defineProperty,kN=Object.defineProperties,UN=Object.getOwnPropertyDescriptors,$T=Object.getOwnPropertySymbols,GN=Object.prototype.hasOwnProperty,zN=Object.prototype.propertyIsEnumerable,rv=(_e,p,_)=>p in _e?LN(_e,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):_e[p]=_,WN=(_e,p)=>{for(var _ in p||(p={}))GN.call(p,_)&&rv(_e,_,p[_]);if($T)for(var _ of $T(p))zN.call(p,_)&&rv(_e,_,p[_]);return _e},HN=(_e,p)=>kN(_e,UN(p));const nv=["hips","spine","spine1","spine2","neck","head","headEnd","shoulderL","shoulderR","armL","armR","forearmL","forearmR","handL","handR","uplegL","uplegR","legL","legR","footL","footR","toeL","toeR"],Gu=(_e,p)=>jr(_e,p),XN=_e=>Gu(_e,nv),KN=["spine","spine1","spine2","neck"],YN=["hipL","hipR","shoulderL","shoulderR","elbowL","elbowR"];class jN extends xN{constructor(p,_={spineCurve:1,neckAdjust:.01,headRatio:.4}){super(),this.node=p,this.tune=_,this.nodeOrigin={position:new nt(0,0,-1),rotation:new _s},this.cameraRatio=1920/1080,this.cameraAngle=10/180*Math.PI,this.alignScore=.9,this.alignVisibility=.9}async load(p){this.loaded||(await super.load(p),this.setNode(this.node))}unload(){this.loaded&&(delete this.node,delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,super.unload())}setNode(p){var _,E;if(delete this.skeletonNodes,delete this.skeleton,delete this.skeletonSizes,delete this.spineCurve,this.node=p,!this.loaded||!p)return;this.skeleton=((_=p.getChildMeshes(!1).find(wi=>wi.skeleton))==null?void 0:_.skeleton)||void 0;const A=(E=this.skeleton)==null?void 0:E.bones;if(!A)return;const $={hips:"hips",spine:"spine",spine1:"spine1",spine2:"spine2",neck:"neck",head:"head",headEnd:"headtop_end",shoulderL:"leftshoulder",shoulderR:"rightshoulder",armL:"leftarm",armR:"rightarm",forearmL:"leftforearm",forearmR:"rightforearm",handL:"lefthand",handR:"righthand",uplegL:"leftupleg",uplegR:"rightupleg",legL:"leftleg",legR:"rightleg",footL:"leftfoot",footR:"rightfoot",toeL:"lefttoebase",toeR:"righttoebase"},ne=wi=>{var vs;return((vs=A.find(cs=>cs.name.toLowerCase().endsWith($[wi])))==null?void 0:vs.getTransformNode())||void 0},xe=XN(wi=>ne(wi));function ce(wi){return nv.every(vs=>wi[vs]!==void 0)}if(!ce(xe))return;this.skeletonNodes=xe;const Te=Gu(wi=>xe[wi].absolutePosition,["hips","shoulderL","shoulderR","neck","head","headEnd","armL","armR","forearmL","handL","uplegL","uplegR","legL","footL"]),Re=Te.hips,ke=nt.Lerp(Te.shoulderL,Te.shoulderR,.5),We=ke.subtract(Re).length(),Xe=Te.forearmL.subtract(Te.armL).length(),xt=Te.handL.subtract(Te.forearmL).length(),qe=Te.legL.subtract(Te.uplegL).length(),ht=Te.footL.subtract(Te.legL).length();this.skeletonSizes={spineLen:We,hipsWidth:Te.uplegL.subtract(Te.uplegR).length(),shoulderWidth:Te.armL.subtract(Te.armR).length(),shoulderRatio:Te.shoulderL.subtract(ke).length()/Te.armL.subtract(ke).length(),armLen:Xe,forearmLen:xt,uplegLen:qe,legLen:ht,headLen:Te.headEnd.subtract(Te.head).length()/We};const Nt=nt.Cross(Te.shoulderR.subtract(Re),Te.shoulderL.subtract(Re)).normalize();this.spineCurve=Gu(wi=>{const vs=xe[wi].absolutePosition.subtract(Re),cs=nt.Dot(vs,Nt);return[vs.subtract(Nt.scale(cs)).length()/We,cs/We]},KN),this.nodeOrigin={position:p.absolutePosition.subtract(xe.hips.absolutePosition).applyRotationQuaternion(xe.hips.absoluteRotationQuaternion.conjugate()),rotation:p.absoluteRotationQuaternion.multiply(xe.hips.absoluteRotationQuaternion.conjugate())};let{min:wt,max:Qt}=p.getHierarchyBoundingVectors();const Ht=wt.add(Qt).scale(.5),Wt=Qt.subtract(wt),zt=Math.max(Wt.x,Wt.y,Wt.z)*1.1*.5,xi=new nt(zt,zt,zt);wt=Ht.subtract(xi),Qt=Ht.add(xi),p.getChildMeshes(!1).forEach(wi=>wi.buildBoundingInfo(wt,Qt))}async update(p,_){var E,A;if(!this.loaded||!this.node)return;const $=(E=p.poses[0])==null?void 0:E.points,{node:ne,skeletonNodes:xe,skeletonSizes:ce,spineCurve:Te}=this;if(!xe||!ce||!Te||!$)return ne.setEnabled(!1),super.update(p,_);const Re=pn.map(ht=>$[ht]),ke=Re.map(ht=>ht.norm);this.equalize(ke);for(let ht=0;ht<4;ht++)this.align(Re);const We=this.estimateBones($,Te,ce),Xe={position:We.hips.position.add(this.nodeOrigin.position.applyRotationQuaternion(We.hips.rotation)),rotation:We.hips.rotation.multiply(this.nodeOrigin.rotation)};(A=this.skeleton)==null||A.returnToRest(),this.alignBone(Xe,ne,!1),this.updateSpine(We,xe);const xt=Gu(ht=>({transform:We[ht],bone:xe[ht]}),["armL","forearmL","handL","armR","forearmR","handR"]);this.updateArm({arm:xt.armL,forearm:xt.forearmL,hand:xt.handL},{shoulder:$.shoulderL,elbow:$.elbowL}),this.updateArm({arm:xt.armR,forearm:xt.forearmR,hand:xt.handR},{shoulder:$.shoulderR,elbow:$.elbowR});const qe=Gu(ht=>({transform:We[ht],bone:xe[ht]}),["uplegL","legL","footL","toeL","uplegR","legR","footR","toeR"]);return this.updateLeg({upleg:qe.uplegL,leg:qe.legL,foot:qe.footL,toe:qe.toeL},{hip:$.hipL,knee:$.kneeL,ankle:$.ankleL}),this.updateLeg({upleg:qe.uplegR,leg:qe.legR,foot:qe.footR,toe:qe.toeR},{hip:$.hipR,knee:$.kneeR,ankle:$.ankleR}),ne.setEnabled(!0),super.update(p,_)}updateSpine(p,_){this.alignBone(p.hips,_.hips,!1),this.alignBone(p.spine,_.spine),this.alignBone(p.spine1,_.spine1),this.alignBone(p.spine2,_.spine2),this.alignBone(p.neck,_.neck,!1),_.neck.scaling.setAll(1.1),this.alignBone(p.head,_.head,!1),this.alignBone(p.shoulderL,_.shoulderL,!1),this.alignBone(p.shoulderR,_.shoulderR,!1)}updateArm(p,_){const{alignScore:E,alignVisibility:A}=this;this.alignBone(p.arm.transform,p.arm.bone),!(_.elbow.score<E&&_.elbow.visibility<A)&&(this.alignBone(p.forearm.transform,p.forearm.bone),p.hand.bone.scaling.setAll(.95))}updateLeg(p,_){const{alignScore:E,alignVisibility:A}=this;_.hip.score<E&&_.hip.visibility<A||(this.alignBone(p.upleg.transform,p.upleg.bone,!1),!(_.knee.score<E&&_.knee.visibility<A)&&(this.alignBone(p.leg.transform,p.leg.bone),!(_.ankle.score<E&&_.ankle.visibility<A)&&(this.alignBone(p.foot.transform,p.foot.bone),this.alignBone(p.toe.transform,p.toe.bone))))}estimateBones(p,_,E){const A=hn(ke=>new nt(...p[ke].metric)),$=this.estimateTorso(A),ne=this.estimateSpine(A,$,_,E),xe=this.estimateArm({neck:$.neck,shoulder:A.shoulderL,elbow:A.elbowL,wrist:A.wristL,index:A.indexL,pinky:A.pinkyL},$,E,!0),ce=this.estimateArm({neck:$.neck,shoulder:A.shoulderR,elbow:A.elbowR,wrist:A.wristR,index:A.indexR,pinky:A.pinkyR},$,E,!1),Te=this.estimateLeg({hip:A.hipL,knee:A.kneeL,ankle:A.ankleL,heel:A.heelL,footIndex:A.footIndexL},$),Re=this.estimateLeg({hip:A.hipR,knee:A.kneeR,ankle:A.ankleR,heel:A.heelR,footIndex:A.footIndexR},$);return HN(WN({},ne),{shoulderL:xe.shoulder,armL:xe.arm,forearmL:xe.forearm,handL:xe.hand,shoulderR:ce.shoulder,armR:ce.arm,forearmR:ce.forearm,handR:ce.hand,uplegL:Te.upleg,legL:Te.leg,footL:Te.foot,toeL:Te.toe,uplegR:Re.upleg,legR:Re.leg,footR:Re.foot,toeR:Re.toe})}estimateTorso(p){var _,E;const A=nt.Lerp(p.hipL,p.hipR,.5),$=p.hipL.subtract(p.hipR).normalize(),ne=nt.Lerp(p.shoulderL,p.shoulderR,.5),xe=p.shoulderL.subtract(p.shoulderR).normalize(),ce=ne.subtract(A).normalize(),Te=nt.Cross(p.shoulderR.subtract(A),p.shoulderL.subtract(A)).normalize();if(this.tune.hipsD){const Ht=$.scale(this.tune.hipsD[0]),Wt=ce.scale(this.tune.hipsD[1]).add(Te.scale((_=this.tune)==null?void 0:_.hipsD[2]));p.hipL.addInPlace(Wt).addInPlace(Ht),p.hipR.addInPlace(Wt).addInPlace(Ht.negate())}if(this.tune.shouldersD){const Ht=xe.scale(this.tune.shouldersD[0]),Wt=ce.scale(this.tune.shouldersD[1]).add(Te.scale((E=this.tune)==null?void 0:E.shouldersD[2]));p.shoulderL.addInPlace(Wt).addInPlace(Ht),p.shoulderR.addInPlace(Wt).addInPlace(Ht.negate())}const Re=p.elbowL.subtract(p.shoulderL).normalize(),ke=p.elbowR.subtract(p.shoulderR).normalize(),We=nt.Dot(Re,ce),Xe=nt.Dot(ke,ce),xt=p.shoulderL.add(p.shoulderL.subtract(p.hipL).normalize().scale(((Math.acos(We)/Math.PI)**2*2-1)*(We>0?.04:.02))),qe=p.shoulderR.add(p.shoulderR.subtract(p.hipR).normalize().scale(((Math.acos(Xe)/Math.PI)**2*2-1)*(Xe>0?.04:.02))),ht=nt.Lerp(xt,qe,.5),Nt=nt.Cross(qe.subtract(A),xt.subtract(A)).normalize(),wt=ht.subtract(A),Qt=wt.length();return wt.normalize(),{hipsC:A,hipsY:wt,hipsX:$,torsoN:Nt,length:Qt,neck:ht,shoulderL0:xt,shoulderR0:qe}}estimateSpine(p,_,E,A){const $=Gu(wt=>{const Qt=nt.Lerp(p.hipL,_.shoulderL0,E[wt][0]),Ht=nt.Lerp(p.hipR,_.shoulderR0,E[wt][0]),Wt=nt.Lerp(Qt,Ht,.5),zt=Qt.subtract(Ht);return{position:Wt,axisX:zt}},["spine","spine1","spine2"]);if(this.tune.spineCurve){const wt=this.tune.spineCurve*_.length;["spine","spine1","spine2"].forEach(Qt=>$[Qt].position.addInPlace(_.torsoN.scale(E[Qt][1]*wt)))}const ne=nt.Lerp(p.earL,p.earR,.5),xe=ne.subtract(p.nose).normalize(),ce=p.earL.subtract(p.earR).normalize(),Te=ce.cross(xe).add(xe.scale(.05)).normalize(),Re=this.tune.headRatio||.4,ke=A.headLen*_.length,We=ne.add(Te.cross(ce).scale(.01)),Xe=We.add(Te.scale(-Re*ke)),xt=We.add(Te.scale((1-Re)*ke)),qe=nt.Lerp(Xe,xt,2),ht=_.shoulderL0.subtract(_.shoulderR0).normalize(),Nt=nt.Lerp(ht,ce,.5);return{hips:this.estimateBone(_.hipsC,$.spine.position,_.hipsX),spine:this.estimateBone($.spine.position,$.spine1.position,$.spine.axisX),spine1:this.estimateBone($.spine1.position,$.spine2.position,$.spine1.axisX),spine2:this.estimateBone($.spine2.position,_.neck,$.spine2.axisX),neck:this.estimateBone(_.neck,Xe,Nt),head:this.estimateBone(Xe,xt,ce),headEnd:this.estimateBone(xt,qe,ce)}}estimateArm(p,_,E,A){const $=nt.Lerp(p.neck,p.shoulder,E.shoulderRatio),ne=A?_.torsoN.clone():_.torsoN.negate(),xe=p.elbow.subtract(p.shoulder).normalize(),ce=p.shoulder.subtract(p.neck).normalize(),Te=this.rotationBetween(ce,xe),Re=ne.applyRotationQuaternion(Te),ke=p.wrist.subtract(p.elbow).normalize(),We=this.rotationBetween(xe,ke),Xe=Re.applyRotationQuaternion(We),xt=nt.Lerp(p.index,p.pinky,.5),qe=p.pinky.subtract(p.index);return A||qe.negateInPlace(),{shoulder:this.estimateBone($,p.shoulder,ne),arm:this.estimateBone(p.shoulder,p.elbow,Re),forearm:this.estimateBone(p.elbow,p.wrist,Xe),hand:this.estimateBone(p.wrist,xt,qe)}}estimateLeg(p,_){const E=p.ankle.subtract(p.knee).normalize(),A=p.footIndex.subtract(p.heel).normalize(),$=E.cross(A).normalize(),ne=nt.Lerp(p.heel,p.footIndex,.8),xe=p.knee.subtract(p.hip).normalize(),ce=this.rotationBetween(_.hipsY.negate(),xe),Te=_.hipsX.negate().applyRotationQuaternion(ce),Re=this.rotationBetween(xe,E),ke=Te.applyRotationQuaternion(Re);return{upleg:this.estimateBone(p.hip,p.knee,Te),leg:this.estimateBone(p.knee,p.ankle,ke),foot:this.estimateBone(p.ankle,ne,$),toe:this.estimateBone(ne,p.footIndex,$)}}estimateBone(p,_,E){const A=_.subtract(p).normalize(),$=E.clone().normalize().cross(A).normalize(),ne=A.cross($);return{position:p.clone(),rotation:_s.RotationQuaternionFromAxis(ne,A,$)}}rotationBetween(p,_){const E=nt.Cross(p,_);return new _s(E.x,E.y,E.z,Math.sqrt(1+nt.Dot(p,_))).normalize()}alignBone(p,_,E=!0){let A=p.rotation.clone(),$=p.position.clone();_.parent instanceof zr&&($=nt.TransformCoordinates($,_.parent.computeWorldMatrix(!0).clone().invert()),A=_.parent.absoluteRotationQuaternion.conjugate().multiply(A),E&&(_.parent.scaling.setAll($.length()/_.position.length()),$=nt.TransformCoordinates(p.position,_.parent.computeWorldMatrix(!0).clone().invert()))),_.position=$,_.rotationQuaternion=A}spineLength(p){const _=uo(A=>new nt(...p[Wo[A]]),YN),{length:E}=this.estimateTorso(_);return E}equalize(p){const _=Z.dW.lerp(p[11],p[12],.5),E=Z.dW.lerp(p[23],p[24],.5),A=Z.dW.sub(_,E),$=Z.dW.length(A),ne=Math.abs(A[2])/$,xe=.7;if(ne<xe){const ce=xe*(ne/xe)**7,Te=Z.dW.normalizeToLen([A[0]/$,A[1]/$,ce*Math.sign(A[2])],$),Re=Z.dW.sub(Te,A);for(let ke=0;ke<23;ke++)p[ke][0]+=Re[0],p[ke][1]+=Re[1],p[ke][2]+=Re[2]}}resize(p){const{skeletonSizes:_}=this;if(!_)return;const E=(vs,cs)=>vs.forEach(Mr=>{p[Mr][0]+=cs[0],p[Mr][1]+=cs[1],p[Mr][2]+=cs[2]}),A=Z.dW.lerp(p[11],p[12],.5),$=Z.dW.lerp(p[23],p[24],.5),ne=this.spineLength(p),xe=Z.dW.sub(A,$),ce=Z.dW.scale(xe,.5*(_.spineLen/ne-1)),Te=Z.dW.sub(p[11],p[12]),Re=Z.dW.scale(Te,.5*(_.shoulderWidth/Z.dW.length(Te)-1));E([11,13,15,17,19,21],Z.dW.add(ce,Re)),E([12,14,16,18,20,22],Z.dW.add(ce,Z.dW.negate(Re)));const ke=Z.dW.sub(p[23],p[24]),We=Z.dW.scale(ke,.5*(_.hipsWidth/Z.dW.length(ke)-1));E([23,25,27,29,31],Z.dW.add(Z.dW.negate(ce),We)),E([24,26,28,30,32],Z.dW.add(Z.dW.negate(ce),Z.dW.negate(We)));const Xe=Z.dW.sub(p[13],p[11]),xt=Z.dW.sub(p[15],p[13]),qe=Z.dW.scale(Xe,_.armLen/Z.dW.length(Xe)-1);p[13]=Z.dW.add(p[13],qe),E([15,17,19,21],Z.dW.add(qe,Z.dW.scale(xt,_.forearmLen/Z.dW.length(xt)-1)));const ht=Z.dW.sub(p[14],p[12]),Nt=Z.dW.sub(p[16],p[14]),wt=Z.dW.scale(ht,_.armLen/Z.dW.length(ht)-1);p[14]=Z.dW.add(p[14],wt),E([16,18,20,22],Z.dW.add(wt,Z.dW.scale(Nt,_.forearmLen/Z.dW.length(Nt)-1)));const Qt=Z.dW.sub(p[25],p[23]),Ht=Z.dW.sub(p[27],p[25]),Wt=Z.dW.scale(Qt,_.uplegLen/Z.dW.length(Qt)-1);p[25]=Z.dW.add(p[25],Wt),E([27,29,31],Z.dW.add(Wt,Z.dW.scale(Ht,_.legLen/Z.dW.length(Ht)-1)));const zt=Z.dW.sub(p[26],p[24]),xi=Z.dW.sub(p[28],p[26]),wi=Z.dW.scale(zt,_.uplegLen/Z.dW.length(zt)-1);p[26]=Z.dW.add(p[26],wi),E([28,30,32],Z.dW.add(wi,Z.dW.scale(xi,_.legLen/Z.dW.length(xi)-1)))}align(p,_=!0){const E=p.map(Re=>Re.norm);this.resize(E);const{alignScore:A,alignVisibility:$}=this,ne=[];if([11,12,23,24].forEach(Re=>{(p[Re].score>A||p[Re].visibility>$)&&ne.push({world:E[Re],pixel:p[Re].pixel})}),ne.length<2)return;const xe=(0,Z.Nn)(ne,{angle:this.cameraAngle,ratio:this.cameraRatio});p.forEach((Re,ke)=>{const We=Re.metric;We[0]=E[ke][0]+xe[0],We[1]=E[ke][1]+xe[1],We[2]=E[ke][2]+xe[2]});const ce=2*Math.tan(.5*this.cameraAngle),Te=this.cameraRatio*ce;[11,12,23,24].forEach(Re=>{const ke=p[Re],We=[(ke.pixel[0]-.5)*Te,(ke.pixel[1]-.5)*ce],Xe=[ke.metric[0]/ke.metric[2],ke.metric[1]/ke.metric[2]],xt=[.5*(We[0]+Xe[0]),.5*(We[1]+Xe[1])];ke.pixel=[xt[0]/Te+.5,xt[1]/ce+.5,ke.pixel[2]]}),p.forEach(Re=>{if(_&&(Re.score>A||Re.visibility>$)){const ke=[(Re.pixel[0]-.5)*Te,(Re.pixel[1]-.5)*ce],We=Re.metric,Xe=Math.sqrt(We[0]**2+We[1]**2+We[2]**2),xt=Math.sqrt(ke[0]**2+ke[1]**2+1),qe=Xe/xt;We[0]=ke[0]*qe,We[1]=ke[1]*qe,We[2]=qe}Re.metric[1]=-Re.metric[1],Re.metric[2]=-Re.metric[2]}),p.forEach(Re=>{const ke=Re.metric;Re.norm=[ke[0],-ke[1],-ke[2]]})}setupCamera(p,_){this.cameraRatio=p,this.cameraAngle=_}}class jU extends null{constructor(p,_,E,A,$={spineCurve:1,neckAdjust:.01,headRatio:.4}){super(p,$),this.translation=_,this.rotation=E,this.scale=A}async update(p,_){var E;if(!this.loaded||!this.node)return;await super.update(p,_);const A=(E=p.poses[0])==null?void 0:E.points,{node:$,translation:ne,rotation:xe,scale:ce}=this;if(!A)return;const Te=new z(...A.hipL.metric),Re=new z(...A.hipR.metric),ke=z.Lerp(Te,Re,.5);$.position=ne?ke.add(ne):ke,xe&&($.rotationQuaternion=xe),ce&&($.scaling=new z().setAll(ce))}updateSpine(p){const{skeletonNodes:_}=this;_&&(this.alignBone(p.hips,_.hips),this.alignBone(p.spine,_.spine),this.alignBone(p.spine1,_.spine1),this.alignBone(p.spine2,_.spine2),this.alignBone(p.neck,_.neck),this.alignBone(p.head,_.head),this.alignBone(p.shoulderL,_.shoulderL),this.alignBone(p.shoulderR,_.shoulderR))}alignBone(p,_){let E=p.rotation.clone();_.parent instanceof R&&(_.parent.computeWorldMatrix(!0),E=_.parent.absoluteRotationQuaternion.conjugate().multiply(E)),_.rotationQuaternion=E}}const av=null,qN=(_e,p)=>D(_e,p),$N=_e=>qN(_e,av);class qU extends null{setNode(p){var _;delete this.skirtSkeletonNodes,super.setNode(p);const E=(_=this.skeleton)==null?void 0:_.bones;if(!E)return;const A={uplegSkirtL:"leftuplegskirt",uplegSkirtR:"rightuplegskirt"},$=$N(xe=>{var ce;return(ce=E.find(Te=>Te.name.toLowerCase().endsWith(A[xe])))==null?void 0:ce.getTransformNode()});function ne(xe){return av.every(ce=>xe[ce])}ne($)&&(this.skirtSkeletonNodes=$)}async update(p,_){var E,A;if(!this.loaded||!this.node)return;await super.update(p,_);const{skeletonNodes:$,skirtSkeletonNodes:ne}=this;if(!$||!ne)return;const{uplegL:xe,uplegR:ce,legL:Te,legR:Re}=$,{uplegSkirtL:ke,uplegSkirtR:We}=ne,Xe=(E=xe.rotationQuaternion)!=null?E:e.Identity(),xt=Te.position.applyRotationQuaternion(Xe.invert()).normalize(),qe=xt.clone();qe.x=Math.min(qe.x,0),qe.normalize();const ht=z.Cross(qe,xt),Nt=new e(ht.x,ht.y,ht.z,Math.sqrt(1+z.Dot(qe,xt))).normalize();ke.position=xe.position,ke.scaling=xe.scaling,ke.rotationQuaternion=Xe.multiply(Nt);const wt=(A=ce.rotationQuaternion)!=null?A:e.Identity(),Qt=Re.position.applyRotationQuaternion(wt.invert()).normalize(),Ht=Qt.clone();Ht.x=Math.max(Ht.x,0),Ht.normalize();const Wt=z.Cross(Ht,Qt),zt=new e(Wt.x,Wt.y,Wt.z,Math.sqrt(1+z.Dot(Qt,Ht))).normalize();We.position=ce.position,We.scaling=ce.scaling,We.rotationQuaternion=wt.multiply(zt)}}const rF=`
attribute vec3 position;
#include<bonesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
void main(void) {
    #include<instancesVertex>
    #include<bonesVertex>
    vec4 worldPos = finalWorld * vec4(position, 1.0);
    gl_Position = viewProjection * worldPos;
    #include<clipPlaneVertex>
}`,nF=`
#include<clipPlaneFragmentDeclaration>
void main(void) {
    #include<clipPlaneFragment>
	gl_FragColor = vec4(0, 0, 0, 1);
}`;class aF extends $h{constructor(p,_){super(p,_,"simpleOccluder",{attributes:["position"],uniforms:["world","viewProjection"]}),this.disableColorWrite=!0,this.needDepthPrePass=!0,this.transparencyMode=Xi.MATERIAL_OPAQUE}}va.ShadersStore.simpleOccluderVertexShader=rF,va.ShadersStore.simpleOccluderFragmentShader=nF;class xF extends jN{constructor(p,_,E={spineCurve:1,neckAdjust:.01,headRatio:.4}){super(p,E),this.outfit=_}setNode(p){super.setNode(p);const{outfit:_,node:E}=this;!_||!E||E.getChildMeshes().forEach(A=>{const $=ne=>ne?.some(xe=>typeof xe=="string"?A.name===xe:xe.test(A.name));if($(_.occluders)){const ne=A.material;A.material=new aF("Occluder",A.getScene()),ne?.getBindedMeshes().length===0&&ne.dispose();return}if($(_.hidden)){A.setEnabled(!1);return}})}setOutfit(p,_){this.outfit=_,this.setNode(p)}}class $U extends null{constructor(p=.55,_=256){super(["image","mask","part"],{rect:"4f"},lF(p,_)),this.patchParts=[],this.keepParts=[],this.partsSkeletons=[],this.ordinal=y.PostRender}setParts(p=[],_=[]){this.partsSkeletons=[],this.patchParts=p,this.keepParts=_,this.partsTarget&&(this.partsTarget.renderList=[...p,..._],this.partsTarget.setMaterialForRendering(p,this.patchMaterial),this.partsTarget.setMaterialForRendering(_,this.keepMaterial),this.partsTarget.renderList.forEach(E=>E.skeleton&&this.partsSkeletons.indexOf(E.skeleton)<0&&this.partsSkeletons.push(E.skeleton)))}async load(p){if(!(p instanceof __))return;const{scene:_,shaderCtx:E}=p;if(!(this.loaded||!E||!_))return this.partsTarget=new H4("MasksTarget",this.size,_),this.partsTarget.clearColor=new L(0,0,0,1),this.patchMaterial=new n("PatchMaskMaterial",_,"bodypatch",{attributes:["position"],uniforms:["world","viewProjection","color"]}),this.patchMaterial.setColor4("color",new L(1,0,0,1)),this.patchMaterial.backFaceCulling=!1,this.patchMaterial.needDepthPrePass=!0,this.patchMaterial.transparencyMode=t.MATERIAL_OPAQUE,this.keepMaterial=new n("KeepMaskMaterial",_,"bodypatch",{attributes:["position"],uniforms:["world","viewProjection","color"]}),this.keepMaterial.setColor4("color",new L(0,1,0,1)),this.keepMaterial.backFaceCulling=!1,this.keepMaterial.needDepthPrePass=!0,this.keepMaterial.transparencyMode=t.MATERIAL_OPAQUE,this.setParts(this.patchParts,this.keepParts),super.load(p)}unload(){var p,_,E;this.loaded&&((p=this.partsTarget)==null||p.dispose(),delete this.partsTarget,(_=this.patchMaterial)==null||_.dispose(),delete this.patchMaterial,(E=this.keepMaterial)==null||E.dispose(),delete this.keepMaterial,super.unload())}async process(p,_){const E=H1(p),{shader:A}=this;if(!E||!A)return!1;const $=H2(E.box),ne=this.renderParts();return A.process([_,E.texture,ne||null],{rect:$}),!0}renderParts(){var p,_,E;const{partsTarget:A,partsSkeletons:$,shader:ne}=this;return!A||!ne?null:($.forEach(xe=>xe.prepare()),(p=A.renderList)==null||p.forEach(xe=>xe.computeWorldMatrix(!0)),A.render(),((E=(_=A.getInternalTexture())==null?void 0:_._hardwareTexture)==null?void 0:E._webGLTexture)||null)}setupVideo(p){var _;super.setupVideo(p),(_=this.partsTarget)==null||_.resize(p),this.setParts(this.patchParts,this.keepParts)}}const lF=(_e=.55,p=256)=>{const _=Math.ceil(p/8);return`
        precision mediump float;
        varying vec2 xy;
        uniform vec2 wh;
        uniform vec4 rect;
        uniform sampler2D image;
        uniform sampler2D mask;
        uniform sampler2D part;
        #define M_SQRT2 1.414213562

        float readMask(vec2 xy0, vec2 dxyI) {
            return texture2D(mask, (xy0 + dxyI / wh - rect.xy) / rect.zw).r;
        }

        vec4 readPart(vec2 xy0, vec2 dxyI) {
            vec2 offset = xy0 + dxyI / wh;
            return texture2D(part, vec2(offset.x, 1.0 - offset.y));
        }

        vec4 readProp(vec2 xy0, vec2 dxyI, vec2 ddxyI) {
            return abs(dxyI.x) + abs(dxyI.y) < `+80 .toFixed(1)+` &&
                readMask(xy0, ddxyI) < `+_e+` ?
                texture2D(image, xy0 + ddxyI / wh) :
                texture2D(image, xy0 + dxyI / wh);
        }

        float traverse(vec2 xy0, vec2 dxyI) {
            bool bg = false;
            float d = 1.0;
            for (int di = 1; di < `+_+`; di++) {
                d = bg ? d : float(di * 8);
                bg = bg || readMask(xy0, d * dxyI) < `+_e+`;
            }
            bool bg1 = bg;
            for (int di = 1; di < 8; di++) {
                float d1 = d - 1.0;
                bg1 = bg1 && readMask(xy0, d1 * dxyI) < `+_e+`;
                d = bg1 ? d1 : d;
            }
            return bg ? d : -1.0;
        }

        vec2 searchPart(vec2 xy0, vec2 dxyI) {
            vec2 part = vec2(`+(2*p+8+1)+`);
            bool fg = true;
            float df = 1.0;
            for (int di = 1; di < `+_+`; di++) {
                df = float(di * 8);
                vec2 partD = readPart(xy0, df * dxyI).rg;
                fg = fg && readMask(xy0, df * dxyI) >= `+_e+`;
                part.r = fg && partD.r > 0.5 && df < part.r ? df : part.r;
                part.g = fg && partD.g > 0.5 && df < part.g ? df : part.g;
            }
            vec2 part0 = part;
            for (int di = 1; di < 8; di++) {
                vec2 df = part0 - vec2(di);
                float partDR = readPart(xy0, df.r * dxyI).r;
                float partDG = readPart(xy0, df.g * dxyI).g;
                bool fgR = readMask(xy0, df.r * dxyI) >= `+_e+`;
                bool fgG = readMask(xy0, df.g * dxyI) >= `+_e+`;
                part.r = fgR && partDR > 0.5 && df.r < part.r ? df.r : part.r;
                part.g = fgG && partDG > 0.5 && df.g < part.g ? df.g : part.g;
            }
            return part;
        }

        void main() {
            bool bg = texture2D(mask, (xy - rect.xy) / (rect.zw)).r < `+_e+`;
            vec4 color = texture2D(image, xy);
            if (bg) {
                gl_FragColor = color;
                return;
            }
            vec2 part = texture2D(part, vec2(xy.x, 1.0 - xy.y)).rg;
            if (part.g > 0.5 || part.r > 0.5) {
                gl_FragColor = color;
                return;
            }

            vec2 pX0 = searchPart(xy,  vec2( 1.0,  0.0));
            vec2 pX1 = searchPart(xy,  vec2(-1.0,  0.0));
            vec2 pY0 = searchPart(xy,  vec2( 0.0,  1.0));
            vec2 pY1 = searchPart(xy,  vec2( 0.0, -1.0));
            vec2 pD00 = searchPart(xy, vec2( 1.0,  1.0));
            vec2 pD01 = searchPart(xy, vec2( 1.0, -1.0));
            vec2 pD10 = searchPart(xy, vec2(-1.0,  1.0));
            vec2 pD11 = searchPart(xy, vec2(-1.0, -1.0));
            part = min(min(min(pX0,  pX1 ), min(pY0,  pY1 )),
                       min(min(pD00, pD01), min(pD10, pD11)) * M_SQRT2);
            if (part.g < part.r && part.g < float(`+p+`) ||
                part.r >= float(`+p+`)) {
                gl_FragColor = color;
                return;
            }

            float x0 = traverse(xy, vec2(-1.0, 0.0));
            bg = x0 > 0.0;
            vec4 cx0 = bg ? readProp(xy, vec2(-x0, 0.0),
                vec2(-2.0 * x0 + 1.0, 0.0)) : color;
            x0 = bg ? 1.0 / x0 : 0.0;

            float x1 = traverse(xy, vec2(1.0, 0.0));
            bg = x1 > 0.0;
            vec4 cx1 = bg ? readProp(xy, vec2(x1, 0.0),
                vec2(2.0 * x1 - 1.0, 0.0)) : color;
            x1 = bg ? 1.0 / x1 : 0.0;

            float y0 = traverse(xy, vec2(0.0, -1.0));
            bg = y0 > 0.0;
            vec4 cy0 = bg ? readProp(xy, vec2(0.0, -y0),
                vec2(0.0, -2.0 * y0 + 1.0)) : color;
            y0 = bg ? 1.0 / y0 : 0.0;

            float y1 = traverse(xy, vec2(0.0, 1.0));
            bg = y1 > 0.0;
            vec4 cy1 = bg ? readProp(xy, vec2(0.0, y1),
                vec2(0.0, 2.0 * y1 - 1.0)) : color;
            y1 = bg ? 1.0 / y1 : 0.0;

            float s = 1.0 / (x0 + x1 + y0 + y1);
            vec4 subst = cx0 * x0 * s + cx1 * x1 * s + cy0 * y0 * s + cy1 * y1 * s;
            if (part.g >= float(`+p+`)) {
                gl_FragColor = subst;
                return;
            }

            bvec2 b[8];
            b[0] = bvec2(pX0.r < pX0.g, pX0.g < pX0.r);
            b[1] = bvec2(pD00.r < pD00.g, pD00.g < pD00.r);
            b[2] = bvec2(pY0.r < pY0.g, pY0.g < pY0.r);
            b[3] = bvec2(pD10.r < pD10.g, pD10.g < pD10.r);
            b[4] = bvec2(pX1.r < pX1.g, pX1.g < pX1.r);
            b[5] = bvec2(pD11.r < pD11.g, pD11.g < pD11.r);
            b[6] = bvec2(pY1.r < pY1.g, pY1.g < pY1.r);
            b[7] = bvec2(pD01.r < pD01.g, pD01.g < pD01.r);
            float rs[8];
            rs[0] = pX0.r;
            rs[1] = pD00.r * M_SQRT2;
            rs[2] = pY0.r;
            rs[3] = pD10.r * M_SQRT2;
            rs[4] = pX1.r;
            rs[5] = pD11.r * M_SQRT2;
            rs[6] = pY1.r;
            rs[7] = pD01.r * M_SQRT2;
            float rMin = float(`+(2*p+8+1)+`);
            bool bMin = false;
            for (int i = 0; i < 8; i++) {
                if (rs[i] < rMin) {
                    rMin = rs[i];
                    bMin = (b[i + 2 < 8 ? i + 2 : i + 2 - 8].g ||
                            b[i + 3 < 8 ? i + 3 : i + 3 - 8].g ||
                            b[i + 4 < 8 ? i + 4 : i + 4 - 8].g ||
                            b[i + 5 < 8 ? i + 5 : i + 5 - 8].g ||
                            b[i + 6 < 8 ? i + 6 : i + 6 - 8].g) &&
                          !(b[i + 3 < 8 ? i + 3 : i + 3 - 8].r ||
                            b[i + 4 < 8 ? i + 4 : i + 4 - 8].r ||
                            b[i + 5 < 8 ? i + 5 : i + 5 - 8].r);
                }
            }

            // vec4 rs[8];
            // rs[0] = vec4(1, 0, pX0.r, pX0.r);
            // rs[1] = vec4(1, 1, pD00.r, pD00.r * M_SQRT2);
            // rs[2] = vec4(0, 1, pY0.r, pY0.r);
            // rs[3] = vec4(-1, 1, pD10.r, pD10.r * M_SQRT2);
            // rs[4] = vec4(-1, 0, pX1.r, pX1.r);
            // rs[5] = vec4(-1, -1, pD11.r, pD11.r * M_SQRT2);
            // rs[6] = vec4(-1, 0, pY1.r, pY1.r);
            // rs[7] = vec4(-1, 1, pD01.r, pD01.r * M_SQRT2);
            // vec4 rMin = rs[0];
            // for (int i = 1; i < 8; i++) {
            //     if (rs[i].w < rMin.w)
            //         rMin = rs[i];
            // }
            // vec2 d0 = rMin.xy;
            // float norm = abs(d0.x) + abs(d0.y);
            // vec2 d1 = vec2(-d0.x - d0.y, -d0.y + d0.x) / norm;
            // vec2 d2 = vec2(-d0.x + d0.y, -d0.y - d0.x) / norm;
            // float d0Len = length(d0);
            // float d1Len = length(d1);
            // vec2 xyR = xy + d0 * (rMin.z / 2.0 - 1.0) / wh;
            // vec2 c0 = searchPart(xyR, vec2(-d0.x, -d0.y)) * d0Len;
            // vec2 c1 = searchPart(xyR, vec2(-d0.y,  d0.x)) * d0Len;
            // vec2 c2 = searchPart(xyR, vec2( d0.y, -d0.x)) * d0Len;
            // vec2 c3 = searchPart(xyR, vec2( d1.x,  d1.y)) * d1Len;
            // vec2 c4 = searchPart(xyR, vec2( d2.x,  d2.y)) * d1Len;
            // bool bMin = (c0.g < c0.r || c1.g < c1.r || c2.g < c2.r ||
            //              c3.g < c3.r || c4.g < c4.r);

            if (bMin) {
                gl_FragColor = mix(subst, color, pow(part.r / part.g, 0.5));
                return;
            }
            gl_FragColor = subst;
        }`},hF=`
attribute vec3 position;
#include<bonesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
void main(void) {
    #include<instancesVertex>
    #include<bonesVertex>
    vec4 worldPos = finalWorld * vec4(position, 1.0);
    gl_Position = viewProjection * worldPos;
    #include<clipPlaneVertex>
}`,cF=`
#include<clipPlaneFragmentDeclaration>
uniform vec4 color;
void main(void) {
    #include<clipPlaneFragment>
	gl_FragColor = color;
}`;va.ShadersStore.bodypatchVertexShader=hF,va.ShadersStore.bodypatchFragmentShader=cF;class r4 extends null{constructor(p){super(),this.node=p,this.cameraRatio=1920/1080,this.cameraAngle=10/180*Math.PI}async update(p,_){if(!this.loaded||!this.node)return;const{points:E=void 0,handedness:A=0,wrist:$=void 0}=p.hands[0]||{};if(!E||!A||!$)return this.node.setEnabled(!1),super.update(p,_);const ne=new z(...E[1].metric),xe=new z(...E[0].metric),ce=new z(...E[5].metric),Te=new z(...E[17].metric),Re=z.Lerp(ne.subtract(xe).normalize(),ce.subtract(Te).normalize(),.5).normalize();A>0&&Re.negateInPlace();const ke=2*Math.tan(.5*this.cameraAngle),We=this.cameraRatio*ke,Xe=$.lines.map(x0=>{const X0=[(x0.point[0]-.5)*We,-(x0.point[1]-.5)*ke],K0=[x0.vector[0],-x0.vector[1]];return{point:X0,vector:K0}}),xt=new z(...Xe[0].vector,0).normalize(),qe=new z(...Xe[1].vector,0).normalize(),ht=z.Cross(xt,qe).length(),Nt=(1-Math.abs(Re.z))*ht,wt=z.Lerp(xt,qe,.5).normalize(),Qt=Math.sqrt(1-Nt**2);wt.x/=Qt,wt.y/=Qt,wt.z=Nt,wt.normalize();const Ht=wt.clone(),Wt=Re.cross(Ht).normalize(),zt=Ht.cross(Wt),xi=new z(...E[0].metric).z,wi=new z(...Xe[0].point,1),vs=new z(...Xe[1].point,1),cs=new z(...Xe[2].point,1);wi.scaleInPlace(xi),vs.scaleInPlace(xi),cs.scaleInPlace(xi),cs.x*=-1,cs.y*=-1;const Mr=.06,xn=.045,qr=Wt.z**2,Tn=Wt.x**2+Wt.y**2,h0=Mr*xn/Math.sqrt(Mr**2*Tn+xn**2*qr),Ra=wi.subtract(vs).length()/h0;return this.node.rotationQuaternion=e.RotationQuaternionFromAxis(zt,Ht,Wt),this.node.position=cs,this.node.scaling.setAll(Ra),this.node.setEnabled(!0),super.update(p,_)}setNode(p){this.node=p}setupCamera(p,_){this.cameraRatio=p,this.cameraAngle=_}}class n4 extends null{constructor(p,_=0){super(),this.node=p,this.renderOrder=_}async load(p){if(!this.loaded)return this.node instanceof H5&&(this.node.material&&(this.node.material.disableColorWrite=!0,this.node.material.needDepthPrePass=!0),this.node.renderingGroupId=this.renderOrder),this.node.getChildMeshes(!1).forEach(_=>{_.material&&(_.material.disableColorWrite=!0,_.material.needDepthPrePass=!0),_.renderingGroupId=this.renderOrder}),super.load(p)}}const uF=`
attribute vec3 position;
#include<bonesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
varying vec2 xy;
void main(void) {
    #include<instancesVertex>
    #include<bonesVertex>
    vec4 worldPos = finalWorld * vec4(position, 1.0);
    gl_Position = viewProjection * worldPos;
    xy = 0.5 * (vec2(gl_Position.x, -gl_Position.y) / gl_Position.w + 1.0);
    #include<clipPlaneVertex>
}`,pF=.5,_F=`
#include<clipPlaneFragmentDeclaration>
varying vec2 xy;
uniform vec4 rect;
uniform sampler2D mask;
void main(void) {
    #include<clipPlaneFragment>
    bool bg = texture2D(mask, (xy - rect.xy) / (rect.zw)).r <= `+pF+`;
    if (bg)
        discard;
	gl_FragColor = vec4(0, 0, 0, 1);
}`;class TF extends null{constructor(p,_,E){super(p,_,"maskedOccluder",{attributes:["position"],uniforms:["world","viewProjection","rect"],samplers:["mask"]}),this.disableColorWrite=!0,this.needDepthPrePass=!0,this.transparencyMode=t.MATERIAL_OPAQUE,E&&this.setTexture("mask",E)}dispose(p,_,E){super.dispose(p,!1,E)}}va.ShadersStore.maskedOccluderVertexShader=uF,va.ShadersStore.maskedOccluderFragmentShader=_F;class a4 extends null{constructor(){super(...arguments),this.maskRect=new f}async load(p){this.loaded||!(p instanceof __)||(await super.load(p),this.scene&&(this.maskTexture=new P(this.scene)))}unload(){var p,_,E,A;this.loaded&&((E=(_=(p=this.maskTexture)==null?void 0:p.getInternalTexture())==null?void 0:_._hardwareTexture)==null||E.reset(),(A=this.maskTexture)==null||A.dispose(),delete this.maskTexture,super.unload())}async update(p,_){var E;if(!this.loaded)return;const A=H1(p);if(!(!A||!this.maskTexture))return this.maskTexture._texture=((E=this.scene)==null?void 0:E.getEngine().wrapWebGLTexture(A.texture))||null,this.maskRect.set(...H2(A.box)),super.update(p,_)}createMaterial(){const{scene:p}=this;if(!p)return null;const _=new TF("OcclusionMaterial",p);return _.onBindObservable.add(()=>{const{maskTexture:E,maskRect:A}=this;_.setVector4("rect",A),E&&_.setTexture("mask",E)}),_}}class x4 extends null{constructor(p,_=.85,E=.03,A={minCutOff:.05,minCutOffD:.1,beta:.05}){super(void 0,_,E,A),this.scene=p,this.rangeMax=_,this.rangeMin=E,this.filterParams=A,this.intensityMap=new Map,this.adjustIntensities=$=>{var ne;this.scene&&this.envIntensity&&(this.scene.environmentIntensity=$*this.envIntensity),(ne=this.scene)==null||ne.lights.forEach(xe=>{const ce=this.intensityMap.get(xe);ce&&(xe.intensity=$*ce)})},this.resetScene(),this.setCallback(this.adjustIntensities)}setScene(p){var _;this.scene&&this.envIntensity&&(this.scene.environmentIntensity=this.envIntensity),delete this.envIntensity,(_=this.scene)==null||_.lights.forEach(E=>{const A=this.intensityMap.get(E);A&&(E.intensity=A)}),this.intensityMap.clear(),this.envIntensity=p?.environmentIntensity,p?.lights.forEach(E=>this.intensityMap.set(E,E.intensity)),this.scene=p}resetScene(){this.setScene(this.scene)}load(p){return this.resetScene(),super.load(p)}unload(){this.setScene()}}rr.prototype._createDepthStencilCubeTexture=function(_e,p){const _=new u0(this,Gn.DepthStencil);if(_.isCube=!0,this.webGLVersion===1)return vi.Error("Depth cube texture is not supported by WebGL 1."),_;const E={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...p},A=this._gl;this._bindTextureDirectly(A.TEXTURE_CUBE_MAP,_,!0),this._setupDepthStencilTexture(_,_e,E.generateStencil,E.bilinearFiltering,E.comparisonFunction);for(let $=0;$<6;$++)E.generateStencil?A.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+$,0,A.DEPTH24_STENCIL8,_e,_e,0,A.DEPTH_STENCIL,A.UNSIGNED_INT_24_8,null):A.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+$,0,A.DEPTH_COMPONENT24,_e,_e,0,A.DEPTH_COMPONENT,A.UNSIGNED_INT,null);return this._bindTextureDirectly(A.TEXTURE_CUBE_MAP,null),this._internalTexturesCache.push(_),_},rr.prototype._partialLoadFile=function(_e,p,_,E,A=null){const $=xe=>{_[p]=xe,_._internalCount++,_._internalCount===6&&E(_)},ne=(xe,ce)=>{A&&xe&&A(xe.status+" "+xe.statusText,ce)};this._loadFile(_e,$,void 0,void 0,!0,ne)},rr.prototype._cascadeLoadFiles=function(_e,p,_,E=null){const A=[];A._internalCount=0;for(let $=0;$<6;$++)this._partialLoadFile(_[$],$,A,p,E)},rr.prototype._cascadeLoadImgs=function(_e,p,_,E,A=null,$){const ne=[];ne._internalCount=0;for(let xe=0;xe<6;xe++)this._partialLoadImg(E[xe],xe,ne,_e,p,_,A,$)},rr.prototype._partialLoadImg=function(_e,p,_,E,A,$,ne=null,xe){const ce=q0();T2(_e,ke=>{_[p]=ke,_._internalCount++,E&&E.removePendingData(ce),_._internalCount===6&&$&&$(A,_)},(ke,We)=>{E&&E.removePendingData(ce),ne&&ne(ke,We)},E?E.offlineProvider:null,xe),E&&E.addPendingData(ce)},rr.prototype._setCubeMapTextureParams=function(_e,p,_){const E=this._gl;E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_MAG_FILTER,E.LINEAR),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_MIN_FILTER,p?E.LINEAR_MIPMAP_LINEAR:E.LINEAR),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_WRAP_S,E.CLAMP_TO_EDGE),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_WRAP_T,E.CLAMP_TO_EDGE),_e.samplingMode=p?3:2,p&&this.getCaps().textureMaxLevel&&_!==void 0&&_>0&&(E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_MAX_LEVEL,_),_e._maxLodLevel=_),this._bindTextureDirectly(E.TEXTURE_CUBE_MAP,null)},rr.prototype.createCubeTextureBase=function(_e,p,_,E,A=null,$=null,ne,xe=null,ce=!1,Te=0,Re=0,ke=null,We=null,Xe=null,xt=!1){const qe=ke||new u0(this,Gn.Cube);qe.isCube=!0,qe.url=_e,qe.generateMipMaps=!E,qe._lodGenerationScale=Te,qe._lodGenerationOffset=Re,qe._useSRGBBuffer=!!xt&&this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU||!!E),qe!==ke&&(qe.label=_e.substring(0,60)),this._doNotHandleContextLost||(qe._extension=xe,qe._files=_);const ht=_e;this._transformTextureUrl&&!ke&&(_e=this._transformTextureUrl(_e));const Nt=_e.split("?")[0],wt=Nt.lastIndexOf("."),Qt=xe||(wt>-1?Nt.substring(wt).toLowerCase():"");let Ht=null;for(const zt of rr._TextureLoaders)if(zt.canLoad(Qt)){Ht=zt;break}const Wt=(zt,xi)=>{_e===ht?$&&zt&&$(zt.status+" "+zt.statusText,xi):(vi.Warn(`Failed to load ${_e}, falling back to the ${ht}`),this.createCubeTextureBase(ht,p,_,!!E,A,$,ne,xe,ce,Te,Re,qe,We,Xe,xt))};if(Ht){const zt=xi=>{We&&We(qe,xi),Ht.loadCubeData(xi,qe,ce,A,$)};_&&_.length===6?Ht.supportCascades?this._cascadeLoadFiles(p,xi=>zt(xi.map(wi=>new Uint8Array(wi))),_,$):$?$("Textures type does not support cascades."):vi.Warn("Texture loader does not support cascades."):this._loadFile(_e,xi=>zt(new Uint8Array(xi)),void 0,void 0,!0,Wt)}else{if(!_||_.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(p,qe,(zt,xi)=>{Xe&&Xe(zt,xi)},_,$)}return this._internalTexturesCache.push(qe),qe},rr.prototype.createCubeTexture=function(_e,p,_,E,A=null,$=null,ne,xe=null,ce=!1,Te=0,Re=0,ke=null,We,Xe=!1){const xt=this._gl;return this.createCubeTextureBase(_e,p,_,!!E,A,$,ne,xe,ce,Te,Re,ke,qe=>this._bindTextureDirectly(xt.TEXTURE_CUBE_MAP,qe,!0),(qe,ht)=>{const Nt=this.needPOTTextures?rr.GetExponentOfTwo(ht[0].width,this._caps.maxCubemapTextureSize):ht[0].width,wt=Nt,Qt=[xt.TEXTURE_CUBE_MAP_POSITIVE_X,xt.TEXTURE_CUBE_MAP_POSITIVE_Y,xt.TEXTURE_CUBE_MAP_POSITIVE_Z,xt.TEXTURE_CUBE_MAP_NEGATIVE_X,xt.TEXTURE_CUBE_MAP_NEGATIVE_Y,xt.TEXTURE_CUBE_MAP_NEGATIVE_Z];this._bindTextureDirectly(xt.TEXTURE_CUBE_MAP,qe,!0),this._unpackFlipY(!1);const Ht=ne?this._getInternalFormat(ne,qe._useSRGBBuffer):qe._useSRGBBuffer?this._glSRGBExtensionValues.SRGB8_ALPHA8:xt.RGBA;let Wt=ne?this._getInternalFormat(ne):xt.RGBA;qe._useSRGBBuffer&&this.webGLVersion===1&&(Wt=Ht);for(let zt=0;zt<Qt.length;zt++)if(ht[zt].width!==Nt||ht[zt].height!==wt){if(this._prepareWorkingCanvas(),!this._workingCanvas||!this._workingContext){vi.Warn("Cannot create canvas to resize texture.");return}this._workingCanvas.width=Nt,this._workingCanvas.height=wt,this._workingContext.drawImage(ht[zt],0,0,ht[zt].width,ht[zt].height,0,0,Nt,wt),xt.texImage2D(Qt[zt],0,Ht,Wt,xt.UNSIGNED_BYTE,this._workingCanvas)}else xt.texImage2D(Qt[zt],0,Ht,Wt,xt.UNSIGNED_BYTE,ht[zt]);E||xt.generateMipmap(xt.TEXTURE_CUBE_MAP),this._setCubeMapTextureParams(qe,!E),qe.width=Nt,qe.height=wt,qe.isReady=!0,ne&&(qe.format=ne),qe.onLoadedObservable.notifyObservers(qe),qe.onLoadedObservable.clear(),A&&A()},!!Xe)};class Lo extends la{set boundingBoxSize(p){if(this._boundingBoxSize&&this._boundingBoxSize.equals(p))return;this._boundingBoxSize=p;const _=this.getScene();_&&_.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}set rotationY(p){this._rotationY=p,this.setReflectionTextureMatrix(Yt.RotationY(this._rotationY))}get rotationY(){return this._rotationY}get noMipmap(){return this._noMipmap}get forcedExtension(){return this._forcedExtension}static CreateFromImages(p,_,E){let A="";return p.forEach($=>A+=$),new Lo(A,_,null,E,p)}static CreateFromPrefilteredData(p,_,E=null,A=!0){const $=_.useDelayedTextureLoading;_.useDelayedTextureLoading=!1;const ne=new Lo(p,_,null,!1,null,null,null,void 0,!0,E,A);return _.useDelayedTextureLoading=$,ne}constructor(p,_,E=null,A=!1,$=null,ne=null,xe=null,ce=5,Te=!1,Re=null,ke=!1,We=.8,Xe=0,xt,qe){super(_),this._lodScale=.8,this._lodOffset=0,this.onLoadObservable=new Mi,this.boundingBoxPosition=nt.Zero(),this._rotationY=0,this._files=null,this._forcedExtension=null,this._extensions=null,this._textureMatrixRefraction=new Yt,this.name=p,this.url=p,this._noMipmap=A,this.hasAlpha=!1,this._format=ce,this.isCube=!0,this._textureMatrix=Yt.Identity(),this._createPolynomials=ke,this.coordinatesMode=Hi.CUBIC_MODE,this._extensions=E,this._files=$,this._forcedExtension=Re,this._loaderOptions=xt,this._useSRGBBuffer=qe,this._lodScale=We,this._lodOffset=Xe,!(!p&&!$)&&this.updateURL(p,Re,ne,Te,xe,E,this.getScene()?.useDelayedTextureLoading,$)}getClassName(){return"CubeTexture"}updateURL(p,_,E=null,A=!1,$=null,ne=null,xe=!1,ce=null){(!this.name||this.name.startsWith("data:"))&&(this.name=p),this.url=p,_&&(this._forcedExtension=_);const Te=p.lastIndexOf("."),Re=_||(Te>-1?p.substring(Te).toLowerCase():""),ke=Re.indexOf(".dds")===0,We=Re.indexOf(".env")===0,Xe=Re.indexOf(".basis")===0;if(We?(this.gammaSpace=!1,this._prefiltered=!1,this.anisotropicFilteringLevel=1):(this._prefiltered=A,A&&(this.gammaSpace=!1,this.anisotropicFilteringLevel=1)),ce)this._files=ce;else if(!Xe&&!We&&!ke&&!ne&&(ne=["_px.jpg","_py.jpg","_pz.jpg","_nx.jpg","_ny.jpg","_nz.jpg"]),this._files=this._files||[],this._files.length=0,ne){for(let xt=0;xt<ne.length;xt++)this._files.push(p+ne[xt]);this._extensions=ne}xe?(this.delayLoadState=4,this._delayedOnLoad=E,this._delayedOnError=$):this._loadTexture(E,$)}delayLoad(p){this.delayLoadState===4&&(p&&(this._forcedExtension=p),this.delayLoadState=1,this._loadTexture(this._delayedOnLoad,this._delayedOnError))}getReflectionTextureMatrix(){return this._textureMatrix}setReflectionTextureMatrix(p){if(p.updateFlag===this._textureMatrix.updateFlag||(p.isIdentity()!==this._textureMatrix.isIdentity()&&this.getScene()?.markAllMaterialsAsDirty(1,$=>$.getActiveTextures().indexOf(this)!==-1),this._textureMatrix=p,!this.getScene()?.useRightHandedSystem))return;const _=pi.Vector3[0],E=pi.Quaternion[0],A=pi.Vector3[1];this._textureMatrix.decompose(_,E,A),E.z*=-1,E.w*=-1,Yt.ComposeToRef(_,E,A,this._textureMatrixRefraction)}getRefractionTextureMatrix(){return this.getScene()?.useRightHandedSystem?this._textureMatrixRefraction:this._textureMatrix}_loadTexture(p=null,_=null){const E=this.getScene(),A=this._texture;this._texture=this._getFromCache(this.url,this._noMipmap,void 0,void 0,this._useSRGBBuffer,this.isCube);const $=()=>{this.onLoadObservable.notifyObservers(this),A&&(A.dispose(),this.getScene()?.markAllMaterialsAsDirty(1)),p&&p()},ne=(xe,ce)=>{this._loadingError=!0,this._errorObject={message:xe,exception:ce},_&&_(xe,ce),Hi.OnTextureLoadErrorObservable.notifyObservers(this)};this._texture?this._texture.isReady?ct.SetImmediate(()=>$()):this._texture.onLoadedObservable.add(()=>$()):(this._prefiltered?this._texture=this._getEngine().createPrefilteredCubeTexture(this.url,E,this._lodScale,this._lodOffset,p,ne,this._format,this._forcedExtension,this._createPolynomials):this._texture=this._getEngine().createCubeTexture(this.url,E,this._files,this._noMipmap,p,ne,this._format,this._forcedExtension,!1,this._lodScale,this._lodOffset,null,this._loaderOptions,!!this._useSRGBBuffer),this._texture?.onLoadedObservable.add(()=>this.onLoadObservable.notifyObservers(this)))}static Parse(p,_,E){const A=Xr.Parse(()=>{let $=!1;return p.prefiltered&&($=p.prefiltered),new Lo(E+(p.url??p.name),_,p.extensions,!1,p.files||null,null,null,void 0,$,p.forcedExtension)},p,_);if(p.boundingBoxPosition&&(A.boundingBoxPosition=nt.FromArray(p.boundingBoxPosition)),p.boundingBoxSize&&(A.boundingBoxSize=nt.FromArray(p.boundingBoxSize)),p.animations)for(let $=0;$<p.animations.length;$++){const ne=p.animations[$],xe=a0("BABYLON.Animation");xe&&A.animations.push(xe.Parse(ne))}return A}clone(){let p=0;const _=Xr.Clone(()=>{const E=new Lo(this.url,this.getScene()||this._getEngine(),this._extensions,this._noMipmap,this._files);return p=E.uniqueId,E},this);return _.uniqueId=p,_}}Mt([Gt()],Lo.prototype,"url",void 0),Mt([jn()],Lo.prototype,"boundingBoxPosition",void 0),Mt([jn()],Lo.prototype,"boundingBoxSize",null),Mt([Gt("rotationY")],Lo.prototype,"rotationY",null),Mt([Gt("files")],Lo.prototype,"_files",void 0),Mt([Gt("forcedExtension")],Lo.prototype,"_forcedExtension",void 0),Mt([Gt("extensions")],Lo.prototype,"_extensions",void 0),Mt([lb("textureMatrix")],Lo.prototype,"_textureMatrix",void 0),Mt([lb("textureMatrixRefraction")],Lo.prototype,"_textureMatrixRefraction",void 0),Hi._CubeTextureParser=Lo.Parse,zs("BABYLON.CubeTexture",Lo);class vn extends Ka{get range(){return this._range}set range(p){this._range=p,this._inverseSquaredRange=1/(this.range*this.range)}get intensityMode(){return this._intensityMode}set intensityMode(p){this._intensityMode=p,this._computePhotometricScale()}get radius(){return this._radius}set radius(p){this._radius=p,this._computePhotometricScale()}get shadowEnabled(){return this._shadowEnabled}set shadowEnabled(p){this._shadowEnabled!==p&&(this._shadowEnabled=p,this._markMeshesAsLightDirty())}get includedOnlyMeshes(){return this._includedOnlyMeshes}set includedOnlyMeshes(p){this._includedOnlyMeshes=p,this._hookArrayForIncludedOnly(p)}get excludedMeshes(){return this._excludedMeshes}set excludedMeshes(p){this._excludedMeshes=p,this._hookArrayForExcluded(p)}get excludeWithLayerMask(){return this._excludeWithLayerMask}set excludeWithLayerMask(p){this._excludeWithLayerMask=p,this._resyncMeshes()}get includeOnlyWithLayerMask(){return this._includeOnlyWithLayerMask}set includeOnlyWithLayerMask(p){this._includeOnlyWithLayerMask=p,this._resyncMeshes()}get lightmapMode(){return this._lightmapMode}set lightmapMode(p){this._lightmapMode!==p&&(this._lightmapMode=p,this._markMeshesAsLightDirty())}getViewMatrix(p){return null}getProjectionMatrix(p,_){return null}constructor(p,_){super(p,_),this.diffuse=new ws(1,1,1),this.specular=new ws(1,1,1),this.falloffType=vn.FALLOFF_DEFAULT,this.intensity=1,this._range=Number.MAX_VALUE,this._inverseSquaredRange=0,this._photometricScale=1,this._intensityMode=vn.INTENSITYMODE_AUTOMATIC,this._radius=1e-5,this.renderPriority=0,this._shadowEnabled=!0,this._excludeWithLayerMask=0,this._includeOnlyWithLayerMask=0,this._lightmapMode=0,this._shadowGenerators=null,this._excludedMeshesIds=new Array,this._includedOnlyMeshesIds=new Array,this._isLight=!0,this.getScene().addLight(this),this._uniformBuffer=new $s(this.getScene().getEngine(),void 0,void 0,p),this._buildUniformLayout(),this.includedOnlyMeshes=[],this.excludedMeshes=[],this._resyncMeshes()}transferTexturesToEffect(p,_){return this}_bindLight(p,_,E,A,$=!0){const ne=p.toString();let xe=!1;if(this._uniformBuffer.bindToEffect(E,"Light"+ne),this._renderId!==_.getRenderId()||this._lastUseSpecular!==A||!this._uniformBuffer.useUbo){this._renderId=_.getRenderId(),this._lastUseSpecular=A;const ce=this.getScaledIntensity();this.transferToEffect(E,ne),this.diffuse.scaleToRef(ce,na.Color3[0]),this._uniformBuffer.updateColor4("vLightDiffuse",na.Color3[0],this.range,ne),A&&(this.specular.scaleToRef(ce,na.Color3[1]),this._uniformBuffer.updateColor4("vLightSpecular",na.Color3[1],this.radius,ne)),xe=!0}if(this.transferTexturesToEffect(E,ne),_.shadowsEnabled&&this.shadowEnabled&&$){const ce=this.getShadowGenerator(_.activeCamera)??this.getShadowGenerator();ce&&(ce.bindShadowLight(ne,E),xe=!0)}xe?this._uniformBuffer.update():this._uniformBuffer.bindUniformBuffer()}getClassName(){return"Light"}toString(p){let _="Name: "+this.name;if(_+=", type: "+["Point","Directional","Spot","Hemispheric"][this.getTypeID()],this.animations)for(let E=0;E<this.animations.length;E++)_+=", animation[0]: "+this.animations[E].toString(p);return _}_syncParentEnabledState(){super._syncParentEnabledState(),this.isDisposed()||this._resyncMeshes()}setEnabled(p){super.setEnabled(p),this._resyncMeshes()}getShadowGenerator(p=null){return this._shadowGenerators===null?null:this._shadowGenerators.get(p)??null}getShadowGenerators(){return this._shadowGenerators}getAbsolutePosition(){return nt.Zero()}canAffectMesh(p){return p?!(this.includedOnlyMeshes&&this.includedOnlyMeshes.length>0&&this.includedOnlyMeshes.indexOf(p)===-1||this.excludedMeshes&&this.excludedMeshes.length>0&&this.excludedMeshes.indexOf(p)!==-1||this.includeOnlyWithLayerMask!==0&&!(this.includeOnlyWithLayerMask&p.layerMask)||this.excludeWithLayerMask!==0&&this.excludeWithLayerMask&p.layerMask):!0}dispose(p,_=!1){if(this._shadowGenerators){const E=this._shadowGenerators.values();for(let A=E.next();A.done!==!0;A=E.next())A.value.dispose();this._shadowGenerators=null}if(this.getScene().stopAnimation(this),this._parentContainer){const E=this._parentContainer.lights.indexOf(this);E>-1&&this._parentContainer.lights.splice(E,1),this._parentContainer=null}for(const E of this.getScene().meshes)E._removeLightSource(this,!0);this._uniformBuffer.dispose(),this.getScene().removeLight(this),super.dispose(p,_)}getTypeID(){return 0}getScaledIntensity(){return this._photometricScale*this.intensity}clone(p,_=null){const E=vn.GetConstructorFromName(this.getTypeID(),p,this.getScene());if(!E)return null;const A=Xr.Clone(E,this);return p&&(A.name=p),_&&(A.parent=_),A.setEnabled(this.isEnabled()),this.onClonedObservable.notifyObservers(A),A}serialize(){const p=Xr.Serialize(this);return p.uniqueId=this.uniqueId,p.type=this.getTypeID(),this.parent&&this.parent._serializeAsParent(p),this.excludedMeshes.length>0&&(p.excludedMeshesIds=[],this.excludedMeshes.forEach(_=>{p.excludedMeshesIds.push(_.id)})),this.includedOnlyMeshes.length>0&&(p.includedOnlyMeshesIds=[],this.includedOnlyMeshes.forEach(_=>{p.includedOnlyMeshesIds.push(_.id)})),Xr.AppendSerializedAnimations(this,p),p.ranges=this.serializeAnimationRanges(),p.isEnabled=this.isEnabled(),p}static GetConstructorFromName(p,_,E){const A=Ka.Construct("Light_Type_"+p,_,E);return A||null}static Parse(p,_){const E=vn.GetConstructorFromName(p.type,p.name,_);if(!E)return null;const A=Xr.Parse(E,p,_);if(p.excludedMeshesIds&&(A._excludedMeshesIds=p.excludedMeshesIds),p.includedOnlyMeshesIds&&(A._includedOnlyMeshesIds=p.includedOnlyMeshesIds),p.parentId!==void 0&&(A._waitingParentId=p.parentId),p.parentInstanceIndex!==void 0&&(A._waitingParentInstanceIndex=p.parentInstanceIndex),p.falloffType!==void 0&&(A.falloffType=p.falloffType),p.lightmapMode!==void 0&&(A.lightmapMode=p.lightmapMode),p.animations){for(let $=0;$<p.animations.length;$++){const ne=p.animations[$],xe=a0("BABYLON.Animation");xe&&A.animations.push(xe.Parse(ne))}Ka.ParseAnimationRanges(A,p,_)}return p.autoAnimate&&_.beginAnimation(A,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1),p.isEnabled!==void 0&&A.setEnabled(p.isEnabled),A}_hookArrayForExcluded(p){const _=p.push;p.push=(...A)=>{const $=_.apply(p,A);for(const ne of A)ne._resyncLightSource(this);return $};const E=p.splice;p.splice=(A,$)=>{const ne=E.apply(p,[A,$]);for(const xe of ne)xe._resyncLightSource(this);return ne};for(const A of p)A._resyncLightSource(this)}_hookArrayForIncludedOnly(p){const _=p.push;p.push=(...A)=>{const $=_.apply(p,A);return this._resyncMeshes(),$};const E=p.splice;p.splice=(A,$)=>{const ne=E.apply(p,[A,$]);return this._resyncMeshes(),ne},this._resyncMeshes()}_resyncMeshes(){for(const p of this.getScene().meshes)p._resyncLightSource(this)}_markMeshesAsLightDirty(){for(const p of this.getScene().meshes)p.lightSources.indexOf(this)!==-1&&p._markSubMeshesAsLightDirty()}_computePhotometricScale(){this._photometricScale=this._getPhotometricScale(),this.getScene().resetCachedMaterial()}_getPhotometricScale(){let p=0;const _=this.getTypeID();let E=this.intensityMode;switch(E===vn.INTENSITYMODE_AUTOMATIC&&(_===vn.LIGHTTYPEID_DIRECTIONALLIGHT?E=vn.INTENSITYMODE_ILLUMINANCE:E=vn.INTENSITYMODE_LUMINOUSINTENSITY),_){case vn.LIGHTTYPEID_POINTLIGHT:case vn.LIGHTTYPEID_SPOTLIGHT:switch(E){case vn.INTENSITYMODE_LUMINOUSPOWER:p=1/(4*Math.PI);break;case vn.INTENSITYMODE_LUMINOUSINTENSITY:p=1;break;case vn.INTENSITYMODE_LUMINANCE:p=this.radius*this.radius;break}break;case vn.LIGHTTYPEID_DIRECTIONALLIGHT:switch(E){case vn.INTENSITYMODE_ILLUMINANCE:p=1;break;case vn.INTENSITYMODE_LUMINANCE:{let A=this.radius;A=Math.max(A,.001),p=2*Math.PI*(1-Math.cos(A));break}}break;case vn.LIGHTTYPEID_HEMISPHERICLIGHT:p=1;break}return p}_reorderLightsInScene(){const p=this.getScene();this._renderPriority!=0&&(p.requireLightSorting=!0),this.getScene().sortLightsByPriority()}}vn.FALLOFF_DEFAULT=qn.FALLOFF_DEFAULT,vn.FALLOFF_PHYSICAL=qn.FALLOFF_PHYSICAL,vn.FALLOFF_GLTF=qn.FALLOFF_GLTF,vn.FALLOFF_STANDARD=qn.FALLOFF_STANDARD,vn.LIGHTMAP_DEFAULT=qn.LIGHTMAP_DEFAULT,vn.LIGHTMAP_SPECULAR=qn.LIGHTMAP_SPECULAR,vn.LIGHTMAP_SHADOWSONLY=qn.LIGHTMAP_SHADOWSONLY,vn.INTENSITYMODE_AUTOMATIC=qn.INTENSITYMODE_AUTOMATIC,vn.INTENSITYMODE_LUMINOUSPOWER=qn.INTENSITYMODE_LUMINOUSPOWER,vn.INTENSITYMODE_LUMINOUSINTENSITY=qn.INTENSITYMODE_LUMINOUSINTENSITY,vn.INTENSITYMODE_ILLUMINANCE=qn.INTENSITYMODE_ILLUMINANCE,vn.INTENSITYMODE_LUMINANCE=qn.INTENSITYMODE_LUMINANCE,vn.LIGHTTYPEID_POINTLIGHT=qn.LIGHTTYPEID_POINTLIGHT,vn.LIGHTTYPEID_DIRECTIONALLIGHT=qn.LIGHTTYPEID_DIRECTIONALLIGHT,vn.LIGHTTYPEID_SPOTLIGHT=qn.LIGHTTYPEID_SPOTLIGHT,vn.LIGHTTYPEID_HEMISPHERICLIGHT=qn.LIGHTTYPEID_HEMISPHERICLIGHT,Mt([ja()],vn.prototype,"diffuse",void 0),Mt([ja()],vn.prototype,"specular",void 0),Mt([Gt()],vn.prototype,"falloffType",void 0),Mt([Gt()],vn.prototype,"intensity",void 0),Mt([Gt()],vn.prototype,"range",null),Mt([Gt()],vn.prototype,"intensityMode",null),Mt([Gt()],vn.prototype,"radius",null),Mt([Gt()],vn.prototype,"_renderPriority",void 0),Mt([ks("_reorderLightsInScene")],vn.prototype,"renderPriority",void 0),Mt([Gt("shadowEnabled")],vn.prototype,"_shadowEnabled",void 0),Mt([Gt("excludeWithLayerMask")],vn.prototype,"_excludeWithLayerMask",void 0),Mt([Gt("includeOnlyWithLayerMask")],vn.prototype,"_includeOnlyWithLayerMask",void 0),Mt([Gt("lightmapMode")],vn.prototype,"_lightmapMode",void 0);class rc extends vn{constructor(){super(...arguments),this._needProjectionMatrixCompute=!0,this._viewMatrix=Yt.Identity(),this._projectionMatrix=Yt.Identity()}_setPosition(p){this._position=p}get position(){return this._position}set position(p){this._setPosition(p)}_setDirection(p){this._direction=p}get direction(){return this._direction}set direction(p){this._setDirection(p)}get shadowMinZ(){return this._shadowMinZ}set shadowMinZ(p){this._shadowMinZ=p,this.forceProjectionMatrixCompute()}get shadowMaxZ(){return this._shadowMaxZ}set shadowMaxZ(p){this._shadowMaxZ=p,this.forceProjectionMatrixCompute()}computeTransformedInformation(){return this.parent&&this.parent.getWorldMatrix?(this.transformedPosition||(this.transformedPosition=nt.Zero()),nt.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this.transformedPosition),this.direction&&(this.transformedDirection||(this.transformedDirection=nt.Zero()),nt.TransformNormalToRef(this.direction,this.parent.getWorldMatrix(),this.transformedDirection)),!0):!1}getDepthScale(){return 50}getShadowDirection(p){return this.transformedDirection?this.transformedDirection:this.direction}getAbsolutePosition(){return this.transformedPosition?this.transformedPosition:this.position}setDirectionToTarget(p){return this.direction=nt.Normalize(p.subtract(this.position)),this.direction}getRotation(){this.direction.normalize();const p=nt.Cross(this.direction,$c.Y),_=nt.Cross(p,this.direction);return nt.RotationFromAxis(p,_,this.direction)}needCube(){return!1}needProjectionMatrixCompute(){return this._needProjectionMatrixCompute}forceProjectionMatrixCompute(){this._needProjectionMatrixCompute=!0}_initCache(){super._initCache(),this._cache.position=nt.Zero()}_isSynchronized(){return!!this._cache.position.equals(this.position)}computeWorldMatrix(p){return!p&&this.isSynchronized()?(this._currentRenderId=this.getScene().getRenderId(),this._worldMatrix):(this._updateCache(),this._cache.position.copyFrom(this.position),this._worldMatrix||(this._worldMatrix=Yt.Identity()),Yt.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this.parent&&this.parent.getWorldMatrix&&(this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(),this._worldMatrix),this._markSyncedWithParent()),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix)}getDepthMinZ(p){return this.shadowMinZ!==void 0?this.shadowMinZ:p.minZ}getDepthMaxZ(p){return this.shadowMaxZ!==void 0?this.shadowMaxZ:p.maxZ}setShadowProjectionMatrix(p,_,E){return this.customProjectionMatrixBuilder?this.customProjectionMatrixBuilder(_,E,p):this._setDefaultShadowProjectionMatrix(p,_,E),this}_syncParentEnabledState(){super._syncParentEnabledState(),(!this.parent||!this.parent.getWorldMatrix)&&(this.transformedPosition=null,this.transformedDirection=null)}getViewMatrix(p){const _=pi.Vector3[0];let E=this.position;this.computeTransformedInformation()&&(E=this.transformedPosition),nt.NormalizeToRef(this.getShadowDirection(p),_),Math.abs(nt.Dot(_,nt.Up()))===1&&(_.z=1e-13);const A=pi.Vector3[1];return E.addToRef(_,A),Yt.LookAtLHToRef(E,A,nt.Up(),this._viewMatrix),this._viewMatrix}getProjectionMatrix(p,_){return this.setShadowProjectionMatrix(this._projectionMatrix,p??this._viewMatrix,_??[]),this._projectionMatrix}}Mt([jn()],rc.prototype,"position",null),Mt([jn()],rc.prototype,"direction",null),Mt([Gt()],rc.prototype,"shadowMinZ",null),Mt([Gt()],rc.prototype,"shadowMaxZ",null),Ka.AddNodeConstructor("Light_Type_1",(_e,p)=>()=>new Kl(_e,nt.Zero(),p));class Kl extends rc{get shadowFrustumSize(){return this._shadowFrustumSize}set shadowFrustumSize(p){this._shadowFrustumSize=p,this.forceProjectionMatrixCompute()}get shadowOrthoScale(){return this._shadowOrthoScale}set shadowOrthoScale(p){this._shadowOrthoScale=p,this.forceProjectionMatrixCompute()}get orthoLeft(){return this._orthoLeft}set orthoLeft(p){this._orthoLeft=p}get orthoRight(){return this._orthoRight}set orthoRight(p){this._orthoRight=p}get orthoTop(){return this._orthoTop}set orthoTop(p){this._orthoTop=p}get orthoBottom(){return this._orthoBottom}set orthoBottom(p){this._orthoBottom=p}constructor(p,_,E){super(p,E),this._shadowFrustumSize=0,this._shadowOrthoScale=.1,this.autoUpdateExtends=!0,this.autoCalcShadowZBounds=!1,this._orthoLeft=Number.MAX_VALUE,this._orthoRight=Number.MIN_VALUE,this._orthoTop=Number.MIN_VALUE,this._orthoBottom=Number.MAX_VALUE,this.position=_.scale(-1),this.direction=_}getClassName(){return"DirectionalLight"}getTypeID(){return vn.LIGHTTYPEID_DIRECTIONALLIGHT}_setDefaultShadowProjectionMatrix(p,_,E){this.shadowFrustumSize>0?this._setDefaultFixedFrustumShadowProjectionMatrix(p):this._setDefaultAutoExtendShadowProjectionMatrix(p,_,E)}_setDefaultFixedFrustumShadowProjectionMatrix(p){const _=this.getScene().activeCamera;_&&Yt.OrthoLHToRef(this.shadowFrustumSize,this.shadowFrustumSize,this.shadowMinZ!==void 0?this.shadowMinZ:_.minZ,this.shadowMaxZ!==void 0?this.shadowMaxZ:_.maxZ,p,this.getScene().getEngine().isNDCHalfZRange)}_setDefaultAutoExtendShadowProjectionMatrix(p,_,E){const A=this.getScene().activeCamera;if(!A)return;if(this.autoUpdateExtends||this._orthoLeft===Number.MAX_VALUE){const Re=nt.Zero();this._orthoLeft=Number.MAX_VALUE,this._orthoRight=-Number.MAX_VALUE,this._orthoTop=-Number.MAX_VALUE,this._orthoBottom=Number.MAX_VALUE;let ke=Number.MAX_VALUE,We=-Number.MAX_VALUE;for(let Xe=0;Xe<E.length;Xe++){const xt=E[Xe];if(!xt)continue;const ht=xt.getBoundingInfo().boundingBox;for(let Nt=0;Nt<ht.vectorsWorld.length;Nt++)nt.TransformCoordinatesToRef(ht.vectorsWorld[Nt],_,Re),Re.x<this._orthoLeft&&(this._orthoLeft=Re.x),Re.y<this._orthoBottom&&(this._orthoBottom=Re.y),Re.x>this._orthoRight&&(this._orthoRight=Re.x),Re.y>this._orthoTop&&(this._orthoTop=Re.y),this.autoCalcShadowZBounds&&(Re.z<ke&&(ke=Re.z),Re.z>We&&(We=Re.z))}this.autoCalcShadowZBounds&&(this._shadowMinZ=ke,this._shadowMaxZ=We)}const $=this._orthoRight-this._orthoLeft,ne=this._orthoTop-this._orthoBottom,xe=this.shadowMinZ!==void 0?this.shadowMinZ:A.minZ,ce=this.shadowMaxZ!==void 0?this.shadowMaxZ:A.maxZ,Te=this.getScene().getEngine().useReverseDepthBuffer;Yt.OrthoOffCenterLHToRef(this._orthoLeft-$*this.shadowOrthoScale,this._orthoRight+$*this.shadowOrthoScale,this._orthoBottom-ne*this.shadowOrthoScale,this._orthoTop+ne*this.shadowOrthoScale,Te?ce:xe,Te?xe:ce,p,this.getScene().getEngine().isNDCHalfZRange)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(p,_){return this.computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z,1,_),this):(this._uniformBuffer.updateFloat4("vLightData",this.direction.x,this.direction.y,this.direction.z,1,_),this)}transferToNodeMaterialEffect(p,_){return this.computeTransformedInformation()?(p.setFloat3(_,this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z),this):(p.setFloat3(_,this.direction.x,this.direction.y,this.direction.z),this)}getDepthMinZ(p){const _=this._scene.getEngine();return!_.useReverseDepthBuffer&&_.isNDCHalfZRange?0:1}getDepthMaxZ(p){const _=this._scene.getEngine();return _.useReverseDepthBuffer&&_.isNDCHalfZRange?0:1}prepareLightSpecificDefines(p,_){p["DIRLIGHT"+_]=!0}}Mt([Gt()],Kl.prototype,"shadowFrustumSize",null),Mt([Gt()],Kl.prototype,"shadowOrthoScale",null),Mt([Gt()],Kl.prototype,"autoUpdateExtends",void 0),Mt([Gt()],Kl.prototype,"autoCalcShadowZBounds",void 0),Mt([Gt("orthoLeft")],Kl.prototype,"_orthoLeft",void 0),Mt([Gt("orthoRight")],Kl.prototype,"_orthoRight",void 0),Mt([Gt("orthoTop")],Kl.prototype,"_orthoTop",void 0),Mt([Gt("orthoBottom")],Kl.prototype,"_orthoBottom",void 0);class $n{static RegisterShaderCodeProcessing(p,_){if(!_){delete $n._CustomShaderCodeProcessing[p??""];return}$n._CustomShaderCodeProcessing[p??""]=_}static _GetShaderCodeProcessing(p){return $n._CustomShaderCodeProcessing[p]??$n._CustomShaderCodeProcessing[""]}get samples(){return this._samples}set samples(p){this._samples=Math.min(p,this._engine.getCaps().maxMSAASamples),this._textures.forEach(_=>{_.setSamples(this._samples)})}getEffectName(){return this._fragmentUrl}set onActivate(p){this._onActivateObserver&&this.onActivateObservable.remove(this._onActivateObserver),p&&(this._onActivateObserver=this.onActivateObservable.add(p))}set onSizeChanged(p){this._onSizeChangedObserver&&this.onSizeChangedObservable.remove(this._onSizeChangedObserver),this._onSizeChangedObserver=this.onSizeChangedObservable.add(p)}set onApply(p){this._onApplyObserver&&this.onApplyObservable.remove(this._onApplyObserver),this._onApplyObserver=this.onApplyObservable.add(p)}set onBeforeRender(p){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(p)}set onAfterRender(p){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(p)}get inputTexture(){return this._textures.data[this._currentRenderTextureInd]}set inputTexture(p){this._forcedOutputTexture=p}restoreDefaultInputTexture(){this._forcedOutputTexture&&(this._forcedOutputTexture=null,this.markTextureDirty())}getCamera(){return this._camera}get texelSize(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.texelSize:(this._forcedOutputTexture&&this._texelSize.copyFromFloats(1/this._forcedOutputTexture.width,1/this._forcedOutputTexture.height),this._texelSize)}constructor(p,_,E,A,$,ne,xe=1,ce,Te,Re=null,ke=0,We="postprocess",Xe,xt=!1,qe=5,ht=Xa.GLSL){this._parentContainer=null,this.width=-1,this.height=-1,this.nodeMaterialSource=null,this._outputTexture=null,this.autoClear=!0,this.forceAutoClearInAlphaMode=!1,this.alphaMode=0,this.animations=[],this.enablePixelPerfectMode=!1,this.forceFullscreenViewport=!0,this.scaleMode=1,this.alwaysForcePOT=!1,this._samples=1,this.adaptScaleToCurrentViewport=!1,this._reusable=!1,this._renderId=0,this.externalTextureSamplerBinding=!1,this._textures=new _t(2),this._textureCache=[],this._currentRenderTextureInd=0,this._scaleRatio=new xr(1,1),this._texelSize=xr.Zero(),this.onActivateObservable=new Mi,this.onSizeChangedObservable=new Mi,this.onApplyObservable=new Mi,this.onBeforeRenderObservable=new Mi,this.onAfterRenderObservable=new Mi,this.name=p;let Nt=1,wt=null;if(E&&!Array.isArray(E)){const Qt=E;E=Qt.uniforms??null,A=Qt.samplers??null,Nt=Qt.size??1,ne=Qt.camera??null,xe=Qt.samplingMode??1,ce=Qt.engine,Te=Qt.reusable,Re=Qt.defines??null,ke=Qt.textureType??0,We=Qt.vertexUrl??"postprocess",Xe=Qt.indexParameters,xt=Qt.blockCompilation??!1,qe=Qt.textureFormat??5,ht=Qt.shaderLanguage??Xa.GLSL,wt=Qt.uniformBuffers??null}else $&&(typeof $=="number"?Nt=$:Nt={width:$.width,height:$.height});ne!=null?(this._camera=ne,this._scene=ne.getScene(),ne.attachPostProcess(this),this._engine=this._scene.getEngine(),this._scene.postProcesses.push(this),this.uniqueId=this._scene.getUniqueId()):ce&&(this._engine=ce,this._engine.postProcesses.push(this)),this._options=Nt,this.renderTargetSamplingMode=xe||1,this._reusable=Te||!1,this._textureType=ke,this._textureFormat=qe,this._shaderLanguage=ht,this._samplers=A||[],this._samplers.push("textureSampler"),this._fragmentUrl=_,this._vertexUrl=We,this._parameters=E||[],this._parameters.push("scale"),this._uniformBuffers=wt||[],this._indexParameters=Xe,this._drawWrapper=new nx(this._engine),xt||this.updateEffect(Re)}getClassName(){return"PostProcess"}getEngine(){return this._engine}getEffect(){return this._drawWrapper.effect}shareOutputWith(p){return this._disposeTextures(),this._shareOutputWithPostProcess=p,this}useOwnOutput(){this._textures.length==0&&(this._textures=new _t(2)),this._shareOutputWithPostProcess=null}updateEffect(p=null,_=null,E=null,A,$,ne,xe,ce){const Te=$n._GetShaderCodeProcessing(this.name);if(Te?.defineCustomBindings){const Re=_?.slice()??[];Re.push(...this._parameters);const ke=E?.slice()??[];ke.push(...this._samplers),p=Te.defineCustomBindings(this.name,p,Re,ke),_=Re,E=ke}this._postProcessDefines=p,this._drawWrapper.effect=this._engine.createEffect({vertex:xe??this._vertexUrl,fragment:ce??this._fragmentUrl},{attributes:["position"],uniformsNames:_||this._parameters,uniformBuffersNames:this._uniformBuffers,samplers:E||this._samplers,defines:p!==null?p:"",fallbacks:null,onCompiled:$??null,onError:ne??null,indexParameters:A||this._indexParameters,processCodeAfterIncludes:Te?.processCodeAfterIncludes?(Re,ke)=>Te.processCodeAfterIncludes(this.name,Re,ke):null,processFinalCode:Te?.processFinalCode?(Re,ke)=>Te.processFinalCode(this.name,Re,ke):null,shaderLanguage:this._shaderLanguage},this._engine)}isReusable(){return this._reusable}markTextureDirty(){this.width=-1}_createRenderTargetTexture(p,_,E=0){for(let $=0;$<this._textureCache.length;$++)if(this._textureCache[$].texture.width===p.width&&this._textureCache[$].texture.height===p.height&&this._textureCache[$].postProcessChannel===E&&this._textureCache[$].texture._generateDepthBuffer===_.generateDepthBuffer&&this._textureCache[$].texture.samples===_.samples)return this._textureCache[$].texture;const A=this._engine.createRenderTargetTexture(p,_);return this._textureCache.push({texture:A,postProcessChannel:E,lastUsedRenderId:-1}),A}_flushTextureCache(){const p=this._renderId;for(let _=this._textureCache.length-1;_>=0;_--)if(p-this._textureCache[_].lastUsedRenderId>100){let E=!1;for(let A=0;A<this._textures.length;A++)if(this._textures.data[A]===this._textureCache[_].texture){E=!0;break}E||(this._textureCache[_].texture.dispose(),this._textureCache.splice(_,1))}}resize(p,_,E=null,A=!1,$=!1){this._textures.length>0&&this._textures.reset(),this.width=p,this.height=_;let ne=null;if(E){for(let Te=0;Te<E._postProcesses.length;Te++)if(E._postProcesses[Te]!==null){ne=E._postProcesses[Te];break}}const xe={width:this.width,height:this.height},ce={generateMipMaps:A,generateDepthBuffer:$||ne===this,generateStencilBuffer:($||ne===this)&&this._engine.isStencilEnable,samplingMode:this.renderTargetSamplingMode,type:this._textureType,format:this._textureFormat,samples:this._samples,label:"PostProcessRTT-"+this.name};this._textures.push(this._createRenderTargetTexture(xe,ce,0)),this._reusable&&this._textures.push(this._createRenderTargetTexture(xe,ce,1)),this._texelSize.copyFromFloats(1/this.width,1/this.height),this.onSizeChangedObservable.notifyObservers(this)}_getTarget(){let p;if(this._shareOutputWithPostProcess)p=this._shareOutputWithPostProcess.inputTexture;else if(this._forcedOutputTexture)p=this._forcedOutputTexture,this.width=this._forcedOutputTexture.width,this.height=this._forcedOutputTexture.height;else{p=this.inputTexture;let _;for(let E=0;E<this._textureCache.length;E++)if(this._textureCache[E].texture===p){_=this._textureCache[E];break}_&&(_.lastUsedRenderId=this._renderId)}return p}activate(p,_=null,E){p=p||this._camera;const A=p.getScene(),$=A.getEngine(),ne=$.getCaps().maxTextureSize,xe=(_?_.width:this._engine.getRenderWidth(!0))*this._options|0,ce=(_?_.height:this._engine.getRenderHeight(!0))*this._options|0;let Te=this._options.width||xe,Re=this._options.height||ce;const ke=this.renderTargetSamplingMode!==7&&this.renderTargetSamplingMode!==1&&this.renderTargetSamplingMode!==2;let We=null;if(!this._shareOutputWithPostProcess&&!this._forcedOutputTexture){if(this.adaptScaleToCurrentViewport){const Xe=$.currentViewport;Xe&&(Te*=Xe.width,Re*=Xe.height)}(ke||this.alwaysForcePOT)&&(this._options.width||(Te=$.needPOTTextures?ui.GetExponentOfTwo(Te,ne,this.scaleMode):Te),this._options.height||(Re=$.needPOTTextures?ui.GetExponentOfTwo(Re,ne,this.scaleMode):Re)),(this.width!==Te||this.height!==Re||!(We=this._getTarget()))&&this.resize(Te,Re,p,ke,E),this._textures.forEach(Xe=>{Xe.samples!==this.samples&&this._engine.updateRenderTargetTextureSampleCount(Xe,this.samples)}),this._flushTextureCache(),this._renderId++}return We||(We=this._getTarget()),this.enablePixelPerfectMode?(this._scaleRatio.copyFromFloats(xe/Te,ce/Re),this._engine.bindFramebuffer(We,0,xe,ce,this.forceFullscreenViewport)):(this._scaleRatio.copyFromFloats(1,1),this._engine.bindFramebuffer(We,0,void 0,void 0,this.forceFullscreenViewport)),this._engine._debugInsertMarker?.(`post process ${this.name} input`),this.onActivateObservable.notifyObservers(p),this.autoClear&&(this.alphaMode===0||this.forceAutoClearInAlphaMode)&&this._engine.clear(this.clearColor?this.clearColor:A.clearColor,A._allowPostProcessClearColor,!0,!0),this._reusable&&(this._currentRenderTextureInd=(this._currentRenderTextureInd+1)%2),We}get isSupported(){return this._drawWrapper.effect.isSupported}get aspectRatio(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.aspectRatio:this._forcedOutputTexture?this._forcedOutputTexture.width/this._forcedOutputTexture.height:this.width/this.height}isReady(){return this._drawWrapper.effect?.isReady()??!1}apply(){if(!this._drawWrapper.effect?.isReady())return null;this._engine.enableEffect(this._drawWrapper),this._engine.setState(!1),this._engine.setDepthBuffer(!1),this._engine.setDepthWrite(!1),this._engine.setAlphaMode(this.alphaMode),this.alphaConstants&&this.getEngine().setAlphaConstants(this.alphaConstants.r,this.alphaConstants.g,this.alphaConstants.b,this.alphaConstants.a);let p;return this._shareOutputWithPostProcess?p=this._shareOutputWithPostProcess.inputTexture:this._forcedOutputTexture?p=this._forcedOutputTexture:p=this.inputTexture,this.externalTextureSamplerBinding||this._drawWrapper.effect._bindTexture("textureSampler",p?.texture),this._drawWrapper.effect.setVector2("scale",this._scaleRatio),this.onApplyObservable.notifyObservers(this._drawWrapper.effect),$n._GetShaderCodeProcessing(this.name)?.bindCustomBindings?.(this.name,this._drawWrapper.effect),this._drawWrapper.effect}_disposeTextures(){if(this._shareOutputWithPostProcess||this._forcedOutputTexture){this._disposeTextureCache();return}this._disposeTextureCache(),this._textures.dispose()}_disposeTextureCache(){for(let p=this._textureCache.length-1;p>=0;p--)this._textureCache[p].texture.dispose();this._textureCache.length=0}setPrePassRenderer(p){return this._prePassEffectConfiguration?(this._prePassEffectConfiguration=p.addEffectConfiguration(this._prePassEffectConfiguration),this._prePassEffectConfiguration.enabled=!0,!0):!1}dispose(p){p=p||this._camera,this._disposeTextures();let _;if(this._scene&&(_=this._scene.postProcesses.indexOf(this),_!==-1&&this._scene.postProcesses.splice(_,1)),this._parentContainer){const E=this._parentContainer.postProcesses.indexOf(this);E>-1&&this._parentContainer.postProcesses.splice(E,1),this._parentContainer=null}if(_=this._engine.postProcesses.indexOf(this),_!==-1&&this._engine.postProcesses.splice(_,1),!!p){if(p.detachPostProcess(this),_=p._postProcesses.indexOf(this),_===0&&p._postProcesses.length>0){const E=this._camera._getFirstPostProcess();E&&E.markTextureDirty()}this.onActivateObservable.clear(),this.onAfterRenderObservable.clear(),this.onApplyObservable.clear(),this.onBeforeRenderObservable.clear(),this.onSizeChangedObservable.clear()}}serialize(){const p=Xr.Serialize(this),_=this.getCamera()||this._scene&&this._scene.activeCamera;return p.customType="BABYLON."+this.getClassName(),p.cameraId=_?_.id:null,p.reusable=this._reusable,p.textureType=this._textureType,p.fragmentUrl=this._fragmentUrl,p.parameters=this._parameters,p.samplers=this._samplers,p.options=this._options,p.defines=this._postProcessDefines,p.textureFormat=this._textureFormat,p.vertexUrl=this._vertexUrl,p.indexParameters=this._indexParameters,p}clone(){const p=this.serialize();p._engine=this._engine,p.cameraId=null;const _=$n.Parse(p,this._scene,"");return _?(_.onActivateObservable=this.onActivateObservable.clone(),_.onSizeChangedObservable=this.onSizeChangedObservable.clone(),_.onApplyObservable=this.onApplyObservable.clone(),_.onBeforeRenderObservable=this.onBeforeRenderObservable.clone(),_.onAfterRenderObservable=this.onAfterRenderObservable.clone(),_._prePassEffectConfiguration=this._prePassEffectConfiguration,_):null}static Parse(p,_,E){const A=a0(p.customType);if(!A||!A._Parse)return null;const $=_?_.getCameraById(p.cameraId):null;return A._Parse(p,$,_,E)}static _Parse(p,_,E,A){return Xr.Parse(()=>new $n(p.name,p.fragmentUrl,p.parameters,p.samplers,p.options,_,p.renderTargetSamplingMode,p._engine,p.reusable,p.defines,p.textureType,p.vertexUrl,p.indexParameters,!1,p.textureFormat),p,E,A)}}$n._CustomShaderCodeProcessing={},Mt([Gt()],$n.prototype,"uniqueId",void 0),Mt([Gt()],$n.prototype,"name",void 0),Mt([Gt()],$n.prototype,"width",void 0),Mt([Gt()],$n.prototype,"height",void 0),Mt([Gt()],$n.prototype,"renderTargetSamplingMode",void 0),Mt([xb()],$n.prototype,"clearColor",void 0),Mt([Gt()],$n.prototype,"autoClear",void 0),Mt([Gt()],$n.prototype,"forceAutoClearInAlphaMode",void 0),Mt([Gt()],$n.prototype,"alphaMode",void 0),Mt([Gt()],$n.prototype,"alphaConstants",void 0),Mt([Gt()],$n.prototype,"enablePixelPerfectMode",void 0),Mt([Gt()],$n.prototype,"forceFullscreenViewport",void 0),Mt([Gt()],$n.prototype,"scaleMode",void 0),Mt([Gt()],$n.prototype,"alwaysForcePOT",void 0),Mt([Gt("samples")],$n.prototype,"_samples",void 0),Mt([Gt()],$n.prototype,"adaptScaleToCurrentViewport",void 0),zs("BABYLON.PostProcess",$n);const xv="kernelBlurVaryingDeclaration",lv="varying vec2 sampleCoord{X};";Gi.IncludesShadersStore[xv]=lv;const l4={name:xv,shader:lv},hv="packingFunctions",cv=`vec4 pack(float depth)
{const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}`;Gi.IncludesShadersStore[hv]=cv;const h4={name:hv,shader:cv},uv="kernelBlurFragment",pv=`#ifdef DOF
factor=sampleCoC(sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;
#endif
`;Gi.IncludesShadersStore[uv]=pv;const c4={name:uv,shader:pv},_v="kernelBlurFragment2",Tv=`#ifdef DOF
factor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;Gi.IncludesShadersStore[_v]=Tv;const u4={name:_v,shader:Tv},vv="kernelBlurPixelShader",Rv=`uniform sampler2D textureSampler;uniform vec2 delta;varying vec2 sampleCenter;
#ifdef DOF
uniform sampler2D circleOfConfusionSampler;float sampleCoC(in vec2 offset) {float coc=texture2D(circleOfConfusionSampler,offset).r;return coc; }
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{float computedWeight=0.0;
#ifdef PACKEDFLOAT
float blend=0.;
#else
vec4 blend=vec4(0.);
#endif
#ifdef DOF
float sumOfWeights=CENTER_WEIGHT; 
float factor=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;
#else
blend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
gl_FragColor=pack(blend);
#else
gl_FragColor=blend;
#endif
#ifdef DOF
gl_FragColor/=sumOfWeights;
#endif
}`;Gi.ShadersStore[vv]=Rv;const p4={name:vv,shader:Rv},Mv="kernelBlurVertex",wv="sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";Gi.IncludesShadersStore[Mv]=wv;const _4={name:Mv,shader:wv},Lv="kernelBlurVertexShader",kv=`attribute vec2 position;uniform vec2 delta;varying vec2 sampleCenter;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
sampleCenter=(position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;Gi.ShadersStore[Lv]=kv;const T4={name:Lv,shader:kv};class nc extends $n{set kernel(p){this._idealKernel!==p&&(p=Math.max(p,1),this._idealKernel=p,this._kernel=this._nearestBestKernel(p),this._blockCompilation||this._updateParameters())}get kernel(){return this._idealKernel}set packedFloat(p){this._packedFloat!==p&&(this._packedFloat=p,this._blockCompilation||this._updateParameters())}get packedFloat(){return this._packedFloat}getClassName(){return"BlurPostProcess"}constructor(p,_,E,A,$,ne=Hi.BILINEAR_SAMPLINGMODE,xe,ce,Te=0,Re="",ke=!1,We=5){super(p,"kernelBlur",["delta","direction"],["circleOfConfusionSampler"],A,$,ne,xe,ce,null,Te,"kernelBlur",{varyingCount:0,depCount:0},!0,We),this._blockCompilation=ke,this._packedFloat=!1,this._staticDefines="",this._staticDefines=Re,this.direction=_,this.onApplyObservable.add(Xe=>{this._outputTexture?Xe.setFloat2("delta",1/this._outputTexture.width*this.direction.x,1/this._outputTexture.height*this.direction.y):Xe.setFloat2("delta",1/this.width*this.direction.x,1/this.height*this.direction.y)}),this.kernel=E}updateEffect(p=null,_=null,E=null,A,$,ne){this._updateParameters($,ne)}_updateParameters(p,_){const E=this._kernel,A=(E-1)/2;let $=[],ne=[],xe=0;for(let ht=0;ht<E;ht++){const Nt=ht/(E-1),wt=this._gaussianWeight(Nt*2-1);$[ht]=ht-A,ne[ht]=wt,xe+=wt}for(let ht=0;ht<ne.length;ht++)ne[ht]/=xe;const ce=[],Te=[],Re=[];for(let ht=0;ht<=A;ht+=2){const Nt=Math.min(ht+1,Math.floor(A));if(ht===Nt)Re.push({o:$[ht],w:ne[ht]});else{const Qt=Nt===A,Ht=ne[ht]+ne[Nt]*(Qt?.5:1),Wt=$[ht]+1/(1+ne[ht]/ne[Nt]);Wt===0?(Re.push({o:$[ht],w:ne[ht]}),Re.push({o:$[ht+1],w:ne[ht+1]})):(Re.push({o:Wt,w:Ht}),Re.push({o:-Wt,w:Ht}))}}for(let ht=0;ht<Re.length;ht++)Te[ht]=Re[ht].o,ce[ht]=Re[ht].w;$=Te,ne=ce;const ke=this.getEngine().getCaps().maxVaryingVectors,We=Math.max(ke,0)-1;let Xe=Math.min($.length,We),xt="";xt+=this._staticDefines,this._staticDefines.indexOf("DOF")!=-1&&(xt+=`#define CENTER_WEIGHT ${this._glslFloat(ne[Xe-1])}
`,Xe--);for(let ht=0;ht<Xe;ht++)xt+=`#define KERNEL_OFFSET${ht} ${this._glslFloat($[ht])}
`,xt+=`#define KERNEL_WEIGHT${ht} ${this._glslFloat(ne[ht])}
`;let qe=0;for(let ht=We;ht<$.length;ht++)xt+=`#define KERNEL_DEP_OFFSET${qe} ${this._glslFloat($[ht])}
`,xt+=`#define KERNEL_DEP_WEIGHT${qe} ${this._glslFloat(ne[ht])}
`,qe++;this.packedFloat&&(xt+="#define PACKEDFLOAT 1"),this._blockCompilation=!1,super.updateEffect(xt,null,null,{varyingCount:Xe,depCount:qe},p,_)}_nearestBestKernel(p){const _=Math.round(p);for(const E of[_,_-1,_+1,_-2,_+2])if(E%2!==0&&Math.floor(E/2)%2===0&&E>0)return Math.max(E,3);return Math.max(_,3)}_gaussianWeight(p){const _=.3333333333333333,E=Math.sqrt(2*Math.PI)*_,A=-(p*p/(2*_*_));return 1/E*Math.exp(A)}_glslFloat(p,_=8){return p.toFixed(_).replace(/0+$/,"")}static _Parse(p,_,E,A){return Xr.Parse(()=>new nc(p.name,p.direction,p.kernel,p.options,_,p.renderTargetSamplingMode,E.getEngine(),p.reusable,p.textureType,void 0,!1),p,E,A)}}Mt([Gt("kernel")],nc.prototype,"_kernel",void 0),Mt([Gt("packedFloat")],nc.prototype,"_packedFloat",void 0),Mt([jc()],nc.prototype,"direction",void 0),zs("BABYLON.BlurPostProcess",nc);const Uv="bayerDitherFunctions",Gv=`float bayerDither2(vec2 _P) {return mod(2.0*_P.y+_P.x+1.0,4.0);}
float bayerDither4(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5*mod(_P,4.0)); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);}
float bayerDither8(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5 *mod(_P,4.0)); 
vec2 P4=floor(0.25*mod(_P,8.0)); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}
`;Gi.IncludesShadersStore[Uv]=Gv;const v4={name:Uv,shader:Gv},zv="shadowMapFragmentExtraDeclaration",Wv=`#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform float softTransparentShadowSM;
#endif
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
uniform vec3 lightDataSM;varying vec3 vPositionWSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;Gi.IncludesShadersStore[zv]=Wv;const R4={name:zv,shader:Wv},Hv="shadowMapFragment",Xv=`float depthSM=vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
depthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_FragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
gl_FragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
gl_FragColor=vec4(depthSM,1.0,1.0,1.0);
#else
gl_FragColor=pack(depthSM);
#endif
return;`;Gi.IncludesShadersStore[Hv]=Xv;const M4={name:Hv,shader:Xv},Kv="shadowMapPixelShader",Yv=`#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEXTURE
float alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;
#ifdef ALPHATESTVALUE
if (alphaFromAlphaTexture<ALPHATESTVALUE)
discard;
#endif
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEXTURE
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;
#else
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;
#endif
#endif
#include<shadowMapFragment>
}`;Gi.ShadersStore[Kv]=Yv;const w4={name:Kv,shader:Yv},jv="bakedVertexAnimationDeclaration",qv=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}
#endif
`;Gi.IncludesShadersStore[jv]=qv;const L4={name:jv,shader:qv},$v="morphTargetsVertexGlobalDeclaration",rA=`#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}
#endif
#endif
`;Gi.IncludesShadersStore[$v]=rA;const k4={name:$v,shader:rA},nA="morphTargetsVertexDeclaration",aA=`#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#elif {X}==0
uniform int morphTargetCount;
#endif
#endif
`;Gi.IncludesShadersStore[nA]=aA;const U4={name:nA,shader:aA},xA="sceneVertexDeclaration",lA=`uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform mat4 view;uniform mat4 projection;uniform vec4 vEyePosition;
`;Gi.IncludesShadersStore[xA]=lA;const G4={name:xA,shader:lA},hA="meshVertexDeclaration",cA=`uniform mat4 world;uniform float visibility;
`;Gi.IncludesShadersStore[hA]=cA;const z4={name:hA,shader:cA},uA="shadowMapVertexDeclaration",pA=`#include<sceneVertexDeclaration>
#include<meshVertexDeclaration>
`;Gi.IncludesShadersStore[uA]=pA;const W4={name:uA,shader:pA},_A="sceneUboDeclaration",TA=`layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;mat4 projection;vec4 vEyePosition;};
`;Gi.IncludesShadersStore[_A]=TA;const X4={name:_A,shader:TA},vA="meshUboDeclaration",RA=`#ifdef WEBGL2
uniform mat4 world;uniform float visibility;
#else
layout(std140,column_major) uniform;uniform Mesh
{mat4 world;float visibility;};
#endif
#define WORLD_UBO
`;Gi.IncludesShadersStore[vA]=RA;const K4={name:vA,shader:RA},MA="shadowMapUboDeclaration",wA=`layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;Gi.IncludesShadersStore[MA]=wA;const Y4={name:MA,shader:wA},LA="shadowMapVertexExtraDeclaration",kA=`#if SM_NORMALBIAS==1
uniform vec3 lightDataSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
varying vec3 vPositionWSM;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;Gi.IncludesShadersStore[LA]=kA;const j4={name:LA,shader:kA},UA="morphTargetsVertexGlobal",GA=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;Gi.IncludesShadersStore[UA]=GA;const q4={name:UA,shader:GA},zA="morphTargetsVertex",WA=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
#if {X}==0
for (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];
#endif
}
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;Gi.IncludesShadersStore[zA]=WA;const $4={name:zA,shader:WA},HA="bakedVertexAnimation",XA=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`;Gi.IncludesShadersStore[HA]=XA;const r5={name:HA,shader:XA},KA="shadowMapVertexNormalBias",YA=`#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
vec3 worldLightDirSM=normalize(-lightDataSM.xyz);
#else
vec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;vec3 worldLightDirSM=normalize(directionToLightSM);
#endif
float ndlSM=dot(vNormalW,worldLightDirSM);float sinNLSM=sqrt(1.0-ndlSM*ndlSM);float normalBiasSM=biasAndScaleSM.y*sinNLSM;worldPos.xyz-=vNormalW*normalBiasSM;
#endif
`;Gi.IncludesShadersStore[KA]=YA;const n5={name:KA,shader:YA},jA="shadowMapVertexMetric",qA=`#if SM_USEDISTANCE==1
vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#else
gl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
zSM=gl_Position.z;gl_Position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
vDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
`;Gi.IncludesShadersStore[jA]=qA;const a5={name:jA,shader:qA},$A="shadowMapVertexShader",rS=`attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#endif
#include<helperFunctions>
#include<__decl__shadowMapVertex>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normWorldSM=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vec3 vNormalW=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
gl_Position=viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
}`;Gi.ShadersStore[$A]=rS;const x5={name:$A,shader:rS},nS="depthBoxBlurPixelShader",aS=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec4 colorDepth=vec4(0.0);for (int x=-OFFSET; x<=OFFSET; x++)
for (int y=-OFFSET; y<=OFFSET; y++)
colorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);gl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));}`;Gi.ShadersStore[nS]=aS;const l5={name:nS,shader:aS},xS="shadowMapFragmentSoftTransparentShadow",lS=`#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;
#endif
`;Gi.IncludesShadersStore[xS]=lS;const h5={name:xS,shader:lS};class pr{get bias(){return this._bias}set bias(p){this._bias=p}get normalBias(){return this._normalBias}set normalBias(p){this._normalBias=p}get blurBoxOffset(){return this._blurBoxOffset}set blurBoxOffset(p){this._blurBoxOffset!==p&&(this._blurBoxOffset=p,this._disposeBlurPostProcesses())}get blurScale(){return this._blurScale}set blurScale(p){this._blurScale!==p&&(this._blurScale=p,this._disposeBlurPostProcesses())}get blurKernel(){return this._blurKernel}set blurKernel(p){this._blurKernel!==p&&(this._blurKernel=p,this._disposeBlurPostProcesses())}get useKernelBlur(){return this._useKernelBlur}set useKernelBlur(p){this._useKernelBlur!==p&&(this._useKernelBlur=p,this._disposeBlurPostProcesses())}get depthScale(){return this._depthScale!==void 0?this._depthScale:this._light.getDepthScale()}set depthScale(p){this._depthScale=p}_validateFilter(p){return p}get filter(){return this._filter}set filter(p){if(p=this._validateFilter(p),this._light.needCube()){if(p===pr.FILTER_BLUREXPONENTIALSHADOWMAP){this.useExponentialShadowMap=!0;return}else if(p===pr.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP){this.useCloseExponentialShadowMap=!0;return}else if(p===pr.FILTER_PCF||p===pr.FILTER_PCSS){this.usePoissonSampling=!0;return}}if((p===pr.FILTER_PCF||p===pr.FILTER_PCSS)&&!this._scene.getEngine()._features.supportShadowSamplers){this.usePoissonSampling=!0;return}this._filter!==p&&(this._filter=p,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get usePoissonSampling(){return this.filter===pr.FILTER_POISSONSAMPLING}set usePoissonSampling(p){const _=this._validateFilter(pr.FILTER_POISSONSAMPLING);!p&&this.filter!==pr.FILTER_POISSONSAMPLING||(this.filter=p?_:pr.FILTER_NONE)}get useExponentialShadowMap(){return this.filter===pr.FILTER_EXPONENTIALSHADOWMAP}set useExponentialShadowMap(p){const _=this._validateFilter(pr.FILTER_EXPONENTIALSHADOWMAP);!p&&this.filter!==pr.FILTER_EXPONENTIALSHADOWMAP||(this.filter=p?_:pr.FILTER_NONE)}get useBlurExponentialShadowMap(){return this.filter===pr.FILTER_BLUREXPONENTIALSHADOWMAP}set useBlurExponentialShadowMap(p){const _=this._validateFilter(pr.FILTER_BLUREXPONENTIALSHADOWMAP);!p&&this.filter!==pr.FILTER_BLUREXPONENTIALSHADOWMAP||(this.filter=p?_:pr.FILTER_NONE)}get useCloseExponentialShadowMap(){return this.filter===pr.FILTER_CLOSEEXPONENTIALSHADOWMAP}set useCloseExponentialShadowMap(p){const _=this._validateFilter(pr.FILTER_CLOSEEXPONENTIALSHADOWMAP);!p&&this.filter!==pr.FILTER_CLOSEEXPONENTIALSHADOWMAP||(this.filter=p?_:pr.FILTER_NONE)}get useBlurCloseExponentialShadowMap(){return this.filter===pr.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP}set useBlurCloseExponentialShadowMap(p){const _=this._validateFilter(pr.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);!p&&this.filter!==pr.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP||(this.filter=p?_:pr.FILTER_NONE)}get usePercentageCloserFiltering(){return this.filter===pr.FILTER_PCF}set usePercentageCloserFiltering(p){const _=this._validateFilter(pr.FILTER_PCF);!p&&this.filter!==pr.FILTER_PCF||(this.filter=p?_:pr.FILTER_NONE)}get filteringQuality(){return this._filteringQuality}set filteringQuality(p){this._filteringQuality!==p&&(this._filteringQuality=p,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get useContactHardeningShadow(){return this.filter===pr.FILTER_PCSS}set useContactHardeningShadow(p){const _=this._validateFilter(pr.FILTER_PCSS);!p&&this.filter!==pr.FILTER_PCSS||(this.filter=p?_:pr.FILTER_NONE)}get contactHardeningLightSizeUVRatio(){return this._contactHardeningLightSizeUVRatio}set contactHardeningLightSizeUVRatio(p){this._contactHardeningLightSizeUVRatio=p}get darkness(){return this._darkness}set darkness(p){this.setDarkness(p)}getDarkness(){return this._darkness}setDarkness(p){return p>=1?this._darkness=1:p<=0?this._darkness=0:this._darkness=p,this}get transparencyShadow(){return this._transparencyShadow}set transparencyShadow(p){this.setTransparencyShadow(p)}setTransparencyShadow(p){return this._transparencyShadow=p,this}getShadowMap(){return this._shadowMap}getShadowMapForRendering(){return this._shadowMap2?this._shadowMap2:this._shadowMap}getClassName(){return pr.CLASSNAME}addShadowCaster(p,_=!0){if(!this._shadowMap)return this;if(this._shadowMap.renderList||(this._shadowMap.renderList=[]),this._shadowMap.renderList.indexOf(p)===-1&&this._shadowMap.renderList.push(p),_)for(const E of p.getChildMeshes())this._shadowMap.renderList.indexOf(E)===-1&&this._shadowMap.renderList.push(E);return this}removeShadowCaster(p,_=!0){if(!this._shadowMap||!this._shadowMap.renderList)return this;const E=this._shadowMap.renderList.indexOf(p);if(E!==-1&&this._shadowMap.renderList.splice(E,1),_)for(const A of p.getChildren())this.removeShadowCaster(A);return this}getLight(){return this._light}_getCamera(){return this._camera??this._scene.activeCamera}get mapSize(){return this._mapSize}set mapSize(p){this._mapSize=p,this._light._markMeshesAsLightDirty(),this.recreateShadowMap()}constructor(p,_,E,A,$){this.onBeforeShadowMapRenderObservable=new Mi,this.onAfterShadowMapRenderObservable=new Mi,this.onBeforeShadowMapRenderMeshObservable=new Mi,this.onAfterShadowMapRenderMeshObservable=new Mi,this._bias=5e-5,this._normalBias=0,this._blurBoxOffset=1,this._blurScale=2,this._blurKernel=1,this._useKernelBlur=!1,this._filter=pr.FILTER_NONE,this._filteringQuality=pr.QUALITY_HIGH,this._contactHardeningLightSizeUVRatio=.1,this._darkness=0,this._transparencyShadow=!1,this.enableSoftTransparentShadow=!1,this.useOpacityTextureForTransparentShadow=!1,this.frustumEdgeFalloff=0,this.forceBackFacesOnly=!1,this._lightDirection=nt.Zero(),this._viewMatrix=Yt.Zero(),this._projectionMatrix=Yt.Zero(),this._transformMatrix=Yt.Zero(),this._cachedPosition=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cachedDirection=new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._currentFaceIndex=0,this._currentFaceIndexCache=0,this._defaultTextureMatrix=Yt.Identity(),this._mapSize=p,this._light=_,this._scene=_.getScene(),this._camera=A??null,this._useRedTextureType=!!$;let ne=_._shadowGenerators;ne||(ne=_._shadowGenerators=new Map),ne.set(this._camera,this),this.id=_.id,this._useUBO=this._scene.getEngine().supportsUniformBuffers,this._useUBO&&(this._sceneUBOs=[],this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`))),pr._SceneComponentInitialization(this._scene);const xe=this._scene.getEngine().getCaps();E?xe.textureFloatRender&&xe.textureFloatLinearFiltering?this._textureType=1:xe.textureHalfFloatRender&&xe.textureHalfFloatLinearFiltering?this._textureType=2:this._textureType=0:xe.textureHalfFloatRender&&xe.textureHalfFloatLinearFiltering?this._textureType=2:xe.textureFloatRender&&xe.textureFloatLinearFiltering?this._textureType=1:this._textureType=0,this._initializeGenerator(),this._applyFilterValues()}_initializeGenerator(){this._light._markMeshesAsLightDirty(),this._initializeShadowMap()}_createTargetRenderTexture(){const p=this._scene.getEngine();p._features.supportDepthStencilTexture?(this._shadowMap=new $o(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube(),void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(p.useReverseDepthBuffer?516:513,!0)):this._shadowMap=new $o(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube()),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(this._createTargetRenderTexture(),this._shadowMap===null)return;this._shadowMap.wrapU=Hi.CLAMP_ADDRESSMODE,this._shadowMap.wrapV=Hi.CLAMP_ADDRESSMODE,this._shadowMap.anisotropicFilteringLevel=1,this._shadowMap.updateSamplingMode(Hi.BILINEAR_SAMPLINGMODE),this._shadowMap.renderParticles=!1,this._shadowMap.ignoreCameraViewport=!0,this._storedUniqueId&&(this._shadowMap.uniqueId=this._storedUniqueId),this._shadowMap.customRenderFunction=(A,$,ne,xe)=>this._renderForShadowMap(A,$,ne,xe),this._shadowMap.customIsReadyFunction=()=>!0;const p=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.add(()=>{this._currentSceneUBO=this._scene.getSceneUniformBuffer(),p._debugPushGroup?.(`shadow map generation for pass id ${p.currentRenderPassId}`,1)}),this._shadowMap.onBeforeRenderObservable.add(A=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[0]),this._currentFaceIndex=A,this._filter===pr.FILTER_PCF&&p.setColorWrite(!1),this.getTransformMatrix(),this._scene.setTransformMatrix(this._viewMatrix,this._projectionMatrix),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onAfterUnbindObservable.add(()=>{if(this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._currentSceneUBO),this._scene.updateTransformMatrix(),this._filter===pr.FILTER_PCF&&p.setColorWrite(!0),!this.useBlurExponentialShadowMap&&!this.useBlurCloseExponentialShadowMap){p._debugPopGroup?.(1);return}const A=this.getShadowMapForRendering();A&&(this._scene.postProcessManager.directRender(this._blurPostProcesses,A.renderTarget,!0),p.unBindFramebuffer(A.renderTarget,!0),p._debugPopGroup?.(1))});const _=new vr(0,0,0,0),E=new vr(1,1,1,1);this._shadowMap.onClearObservable.add(A=>{this._filter===pr.FILTER_PCF?A.clear(E,!1,!0,!1):this.useExponentialShadowMap||this.useBlurExponentialShadowMap?A.clear(_,!0,!0,!1):A.clear(E,!0,!0,!1)}),this._shadowMap.onResizeObservable.add(A=>{this._storedUniqueId=this._shadowMap.uniqueId,this._mapSize=A.getRenderSize(),this._light._markMeshesAsLightDirty(),this.recreateShadowMap()});for(let A=ao.MIN_RENDERINGGROUPS;A<ao.MAX_RENDERINGGROUPS;A++)this._shadowMap.setRenderingAutoClearDepthStencil(A,!1)}_initializeBlurRTTAndPostProcesses(){const p=this._scene.getEngine(),_=this._mapSize/this.blurScale;(!this.useKernelBlur||this.blurScale!==1)&&(this._shadowMap2=new $o(this._light.name+"_shadowMap2",_,this._scene,!1,!0,this._textureType,void 0,void 0,!1),this._shadowMap2.wrapU=Hi.CLAMP_ADDRESSMODE,this._shadowMap2.wrapV=Hi.CLAMP_ADDRESSMODE,this._shadowMap2.updateSamplingMode(Hi.BILINEAR_SAMPLINGMODE)),this.useKernelBlur?(this._kernelBlurXPostprocess=new nc(this._light.name+"KernelBlurX",new xr(1,0),this.blurKernel,1,null,Hi.BILINEAR_SAMPLINGMODE,p,!1,this._textureType),this._kernelBlurXPostprocess.width=_,this._kernelBlurXPostprocess.height=_,this._kernelBlurXPostprocess.externalTextureSamplerBinding=!0,this._kernelBlurXPostprocess.onApplyObservable.add(E=>{E.setTexture("textureSampler",this._shadowMap)}),this._kernelBlurYPostprocess=new nc(this._light.name+"KernelBlurY",new xr(0,1),this.blurKernel,1,null,Hi.BILINEAR_SAMPLINGMODE,p,!1,this._textureType),this._kernelBlurXPostprocess.autoClear=!1,this._kernelBlurYPostprocess.autoClear=!1,this._textureType===0&&(this._kernelBlurXPostprocess.packedFloat=!0,this._kernelBlurYPostprocess.packedFloat=!0),this._blurPostProcesses=[this._kernelBlurXPostprocess,this._kernelBlurYPostprocess]):(this._boxBlurPostprocess=new $n(this._light.name+"DepthBoxBlur","depthBoxBlur",["screenSize","boxOffset"],[],1,null,Hi.BILINEAR_SAMPLINGMODE,p,!1,"#define OFFSET "+this._blurBoxOffset,this._textureType),this._boxBlurPostprocess.externalTextureSamplerBinding=!0,this._boxBlurPostprocess.onApplyObservable.add(E=>{E.setFloat2("screenSize",_,_),E.setTexture("textureSampler",this._shadowMap)}),this._boxBlurPostprocess.autoClear=!1,this._blurPostProcesses=[this._boxBlurPostprocess])}_renderForShadowMap(p,_,E,A){let $;if(A.length)for($=0;$<A.length;$++)this._renderSubMeshForShadowMap(A.data[$]);for($=0;$<p.length;$++)this._renderSubMeshForShadowMap(p.data[$]);for($=0;$<_.length;$++)this._renderSubMeshForShadowMap(_.data[$]);if(this._transparencyShadow)for($=0;$<E.length;$++)this._renderSubMeshForShadowMap(E.data[$],!0);else for($=0;$<E.length;$++)E.data[$].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}_bindCustomEffectForRenderSubMeshForShadowMap(p,_,E){_.setMatrix("viewProjection",this.getTransformMatrix())}_renderSubMeshForShadowMap(p,_=!1){const E=p.getRenderingMesh(),A=p.getEffectiveMesh(),$=this._scene,ne=$.getEngine(),xe=p.getMaterial();if(A._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!xe||p.verticesCount===0||p._renderId===$.getRenderId())return;const ce=A._getWorldMatrixDeterminant()<0;let Te=E.overrideMaterialSideOrientation??xe.sideOrientation;ce&&(Te=Te===0?1:0);const Re=Te===0;ne.setState(xe.backFaceCulling,void 0,void 0,Re,xe.cullBackFaces);const ke=E._getInstancesRenderList(p._id,!!p.getReplacementMesh());if(ke.mustReturn)return;const We=ne.getCaps().instancedArrays&&(ke.visibleInstances[p._id]!==null&&ke.visibleInstances[p._id]!==void 0||E.hasThinInstances);if(!(this.customAllowRendering&&!this.customAllowRendering(p)))if(this.isReady(p,We,_)){p._renderId=$.getRenderId();const Xe=xe.shadowDepthWrapper,xt=Xe?.getEffect(p,this,ne.currentRenderPassId)??p._getDrawWrapper(),qe=nx.GetEffect(xt);ne.enableEffect(xt),We||E._bind(p,qe,xe.fillMode),this.getTransformMatrix(),qe.setFloat3("biasAndScaleSM",this.bias,this.normalBias,this.depthScale),this.getLight().getTypeID()===vn.LIGHTTYPEID_DIRECTIONALLIGHT?qe.setVector3("lightDataSM",this._cachedDirection):qe.setVector3("lightDataSM",this._cachedPosition);const ht=this._getCamera();if(ht&&qe.setFloat2("depthValuesSM",this.getLight().getDepthMinZ(ht),this.getLight().getDepthMinZ(ht)+this.getLight().getDepthMaxZ(ht)),_&&this.enableSoftTransparentShadow&&qe.setFloat("softTransparentShadowSM",A.visibility*xe.alpha),Xe)p._setMainDrawWrapperOverride(xt),Xe.standalone?Xe.baseMaterial.bindForSubMesh(A.getWorldMatrix(),E,p):xe.bindForSubMesh(A.getWorldMatrix(),E,p),p._setMainDrawWrapperOverride(null);else{if(this._opacityTexture&&(qe.setTexture("diffuseSampler",this._opacityTexture),qe.setMatrix("diffuseMatrix",this._opacityTexture.getTextureMatrix()||this._defaultTextureMatrix)),E.useBones&&E.computeBonesUsingShaders&&E.skeleton){const wt=E.skeleton;if(wt.isUsingTextureForMatrices){const Qt=wt.getTransformMatrixTexture(E);if(!Qt)return;qe.setTexture("boneSampler",Qt),qe.setFloat("boneTextureWidth",4*(wt.bones.length+1))}else qe.setMatrices("mBones",wt.getTransformMatrices(E))}nr.BindMorphTargetParameters(E,qe),E.morphTargetManager&&E.morphTargetManager.isUsingTextureForTargets&&E.morphTargetManager._bind(qe),ug(qe,xe,$)}!this._useUBO&&!Xe&&this._bindCustomEffectForRenderSubMeshForShadowMap(p,qe,A),nr.BindSceneUniformBuffer(qe,this._scene.getSceneUniformBuffer()),this._scene.getSceneUniformBuffer().bindUniformBuffer();const Nt=A.getWorldMatrix();We&&(A.getMeshUniformBuffer().bindToEffect(qe,"Mesh"),A.transferToEffect(Nt)),this.forceBackFacesOnly&&ne.setState(!0,0,!1,!0,xe.cullBackFaces),this.onBeforeShadowMapRenderMeshObservable.notifyObservers(E),this.onBeforeShadowMapRenderObservable.notifyObservers(qe),E._processRendering(A,p,qe,xe.fillMode,ke,We,(wt,Qt)=>{A!==E&&!wt?(E.getMeshUniformBuffer().bindToEffect(qe,"Mesh"),E.transferToEffect(Qt)):(A.getMeshUniformBuffer().bindToEffect(qe,"Mesh"),A.transferToEffect(wt?Qt:Nt))}),this.forceBackFacesOnly&&ne.setState(!0,0,!1,!1,xe.cullBackFaces),this.onAfterShadowMapRenderObservable.notifyObservers(qe),this.onAfterShadowMapRenderMeshObservable.notifyObservers(E)}else this._shadowMap&&this._shadowMap.resetRefreshCounter()}_applyFilterValues(){this._shadowMap&&(this.filter===pr.FILTER_NONE||this.filter===pr.FILTER_PCSS?this._shadowMap.updateSamplingMode(Hi.NEAREST_SAMPLINGMODE):this._shadowMap.updateSamplingMode(Hi.BILINEAR_SAMPLINGMODE))}forceCompilation(p,_){const E={useInstances:!1,..._},A=this.getShadowMap();if(!A){p&&p(this);return}const $=A.renderList;if(!$){p&&p(this);return}const ne=[];for(const Te of $)ne.push(...Te.subMeshes);if(ne.length===0){p&&p(this);return}let xe=0;const ce=()=>{if(!(!this._scene||!this._scene.getEngine())){for(;this.isReady(ne[xe],E.useInstances,ne[xe].getMaterial()?.needAlphaBlendingForMesh(ne[xe].getMesh())??!1);)if(xe++,xe>=ne.length){p&&p(this);return}setTimeout(ce,16)}};ce()}forceCompilationAsync(p){return new Promise(_=>{this.forceCompilation(()=>{_()},p)})}_isReadyCustomDefines(p,_,E){}_prepareShadowDefines(p,_,E,A){E.push("#define SM_LIGHTTYPE_"+this._light.getClassName().toUpperCase()),E.push("#define SM_FLOAT "+(this._textureType!==0?"1":"0")),E.push("#define SM_ESM "+(this.useExponentialShadowMap||this.useBlurExponentialShadowMap?"1":"0")),E.push("#define SM_DEPTHTEXTURE "+(this.usePercentageCloserFiltering||this.useContactHardeningShadow?"1":"0"));const $=p.getMesh();return E.push("#define SM_NORMALBIAS "+(this.normalBias&&$.isVerticesDataPresent(ut.NormalKind)?"1":"0")),E.push("#define SM_DIRECTIONINLIGHTDATA "+(this.getLight().getTypeID()===vn.LIGHTTYPEID_DIRECTIONALLIGHT?"1":"0")),E.push("#define SM_USEDISTANCE "+(this._light.needCube()?"1":"0")),E.push("#define SM_SOFTTRANSPARENTSHADOW "+(this.enableSoftTransparentShadow&&A?"1":"0")),this._isReadyCustomDefines(E,p,_),E}isReady(p,_,E){const A=p.getMaterial(),$=A?.shadowDepthWrapper;if(this._opacityTexture=null,!A)return!1;const ne=[];if(this._prepareShadowDefines(p,_,ne,E),$){if(!$.isReadyForSubMesh(p,ne,this,_,this._scene.getEngine().currentRenderPassId))return!1}else{const xe=p._getDrawWrapper(void 0,!0);let ce=xe.effect,Te=xe.defines;const Re=[ut.PositionKind],ke=p.getMesh();this.normalBias&&ke.isVerticesDataPresent(ut.NormalKind)&&(Re.push(ut.NormalKind),ne.push("#define NORMAL"),ke.nonUniformScaling&&ne.push("#define NONUNIFORMSCALING"));const We=A.needAlphaTesting();if((We||A.needAlphaBlending())&&(this.useOpacityTextureForTransparentShadow?this._opacityTexture=A.opacityTexture:this._opacityTexture=A.getAlphaTestTexture(),this._opacityTexture)){if(!this._opacityTexture.isReady())return!1;const Nt=A.alphaCutOff??pr.DEFAULT_ALPHA_CUTOFF;ne.push("#define ALPHATEXTURE"),We&&ne.push(`#define ALPHATESTVALUE ${Nt}${Nt%1===0?".":""}`),ke.isVerticesDataPresent(ut.UVKind)&&(Re.push(ut.UVKind),ne.push("#define UV1")),ke.isVerticesDataPresent(ut.UV2Kind)&&this._opacityTexture.coordinatesIndex===1&&(Re.push(ut.UV2Kind),ne.push("#define UV2"))}const Xe=new p_;if(ke.useBones&&ke.computeBonesUsingShaders&&ke.skeleton){Re.push(ut.MatricesIndicesKind),Re.push(ut.MatricesWeightsKind),ke.numBoneInfluencers>4&&(Re.push(ut.MatricesIndicesExtraKind),Re.push(ut.MatricesWeightsExtraKind));const Nt=ke.skeleton;ne.push("#define NUM_BONE_INFLUENCERS "+ke.numBoneInfluencers),ke.numBoneInfluencers>0&&Xe.addCPUSkinningFallback(0,ke),Nt.isUsingTextureForMatrices?ne.push("#define BONETEXTURE"):ne.push("#define BonesPerMesh "+(Nt.bones.length+1))}else ne.push("#define NUM_BONE_INFLUENCERS 0");const xt=ke.morphTargetManager;let qe=0;if(xt&&(qe=xt.numMaxInfluencers||xt.numInfluencers,qe>0&&(ne.push("#define MORPHTARGETS"),ne.push("#define NUM_MORPH_INFLUENCERS "+qe),xt.isUsingTextureForTargets&&ne.push("#define MORPHTARGETS_TEXTURE"),nr.PrepareAttributesForMorphTargetsInfluencers(Re,ke,qe))),l_(A,this._scene,ne),_&&(ne.push("#define INSTANCES"),nr.PushAttributesForInstances(Re),p.getRenderingMesh().hasThinInstances&&ne.push("#define THIN_INSTANCES")),this.customShaderOptions&&this.customShaderOptions.defines)for(const Nt of this.customShaderOptions.defines)ne.indexOf(Nt)===-1&&ne.push(Nt);const ht=ne.join(`
`);if(Te!==ht){Te=ht;let Nt="shadowMap";const wt=["world","mBones","viewProjection","diffuseMatrix","lightDataSM","depthValuesSM","biasAndScaleSM","morphTargetInfluences","morphTargetCount","boneTextureWidth","softTransparentShadowSM","morphTargetTextureInfo","morphTargetTextureIndices"],Qt=["diffuseSampler","boneSampler","morphTargets"],Ht=["Scene","Mesh"];if(cg(wt),this.customShaderOptions){if(Nt=this.customShaderOptions.shaderName,this.customShaderOptions.attributes)for(const zt of this.customShaderOptions.attributes)Re.indexOf(zt)===-1&&Re.push(zt);if(this.customShaderOptions.uniforms)for(const zt of this.customShaderOptions.uniforms)wt.indexOf(zt)===-1&&wt.push(zt);if(this.customShaderOptions.samplers)for(const zt of this.customShaderOptions.samplers)Qt.indexOf(zt)===-1&&Qt.push(zt)}const Wt=this._scene.getEngine();ce=Wt.createEffect(Nt,{attributes:Re,uniformsNames:wt,uniformBuffersNames:Ht,samplers:Qt,defines:ht,fallbacks:Xe,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:qe}},Wt),xe.setEffect(ce,Te)}if(!ce.isReady())return!1}return(this.useBlurExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(!this._blurPostProcesses||!this._blurPostProcesses.length)&&this._initializeBlurRTTAndPostProcesses(),!(this._kernelBlurXPostprocess&&!this._kernelBlurXPostprocess.isReady()||this._kernelBlurYPostprocess&&!this._kernelBlurYPostprocess.isReady()||this._boxBlurPostprocess&&!this._boxBlurPostprocess.isReady())}prepareDefines(p,_){const E=this._scene,A=this._light;!E.shadowsEnabled||!A.shadowEnabled||(p["SHADOW"+_]=!0,this.useContactHardeningShadow?(p["SHADOWPCSS"+_]=!0,this._filteringQuality===pr.QUALITY_LOW?p["SHADOWLOWQUALITY"+_]=!0:this._filteringQuality===pr.QUALITY_MEDIUM&&(p["SHADOWMEDIUMQUALITY"+_]=!0)):this.usePercentageCloserFiltering?(p["SHADOWPCF"+_]=!0,this._filteringQuality===pr.QUALITY_LOW?p["SHADOWLOWQUALITY"+_]=!0:this._filteringQuality===pr.QUALITY_MEDIUM&&(p["SHADOWMEDIUMQUALITY"+_]=!0)):this.usePoissonSampling?p["SHADOWPOISSON"+_]=!0:this.useExponentialShadowMap||this.useBlurExponentialShadowMap?p["SHADOWESM"+_]=!0:(this.useCloseExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(p["SHADOWCLOSEESM"+_]=!0),A.needCube()&&(p["SHADOWCUBE"+_]=!0))}bindShadowLight(p,_){const E=this._light;if(!this._scene.shadowsEnabled||!E.shadowEnabled)return;const $=this._getCamera();if(!$)return;const ne=this.getShadowMap();ne&&(E.needCube()||_.setMatrix("lightMatrix"+p,this.getTransformMatrix()),this._filter===pr.FILTER_PCF?(_.setDepthStencilTexture("shadowSampler"+p,this.getShadowMapForRendering()),E._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),ne.getSize().width,1/ne.getSize().width,this.frustumEdgeFalloff,p)):this._filter===pr.FILTER_PCSS?(_.setDepthStencilTexture("shadowSampler"+p,this.getShadowMapForRendering()),_.setTexture("depthSampler"+p,this.getShadowMapForRendering()),E._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/ne.getSize().width,this._contactHardeningLightSizeUVRatio*ne.getSize().width,this.frustumEdgeFalloff,p)):(_.setTexture("shadowSampler"+p,this.getShadowMapForRendering()),E._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),this.blurScale/ne.getSize().width,this.depthScale,this.frustumEdgeFalloff,p)),E._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ($),this.getLight().getDepthMinZ($)+this.getLight().getDepthMaxZ($),p))}get viewMatrix(){return this._viewMatrix}get projectionMatrix(){return this._projectionMatrix}getTransformMatrix(){const p=this._scene;if(this._currentRenderId===p.getRenderId()&&this._currentFaceIndexCache===this._currentFaceIndex)return this._transformMatrix;this._currentRenderId=p.getRenderId(),this._currentFaceIndexCache=this._currentFaceIndex;let _=this._light.position;if(this._light.computeTransformedInformation()&&(_=this._light.transformedPosition),nt.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex),this._lightDirection),Math.abs(nt.Dot(this._lightDirection,nt.Up()))===1&&(this._lightDirection.z=1e-13),this._light.needProjectionMatrixCompute()||!this._cachedPosition||!this._cachedDirection||!_.equals(this._cachedPosition)||!this._lightDirection.equals(this._cachedDirection)){this._cachedPosition.copyFrom(_),this._cachedDirection.copyFrom(this._lightDirection),Yt.LookAtLHToRef(_,_.add(this._lightDirection),nt.Up(),this._viewMatrix);const E=this.getShadowMap();if(E){const A=E.renderList;A&&this._light.setShadowProjectionMatrix(this._projectionMatrix,this._viewMatrix,A)}this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)}return this._transformMatrix}recreateShadowMap(){const p=this._shadowMap;if(!p)return;const _=p.renderList;if(this._disposeRTTandPostProcesses(),this._initializeGenerator(),this.filter=this._filter,this._applyFilterValues(),_){this._shadowMap.renderList||(this._shadowMap.renderList=[]);for(const E of _)this._shadowMap.renderList.push(E)}else this._shadowMap.renderList=null}_disposeBlurPostProcesses(){this._shadowMap2&&(this._shadowMap2.dispose(),this._shadowMap2=null),this._boxBlurPostprocess&&(this._boxBlurPostprocess.dispose(),this._boxBlurPostprocess=null),this._kernelBlurXPostprocess&&(this._kernelBlurXPostprocess.dispose(),this._kernelBlurXPostprocess=null),this._kernelBlurYPostprocess&&(this._kernelBlurYPostprocess.dispose(),this._kernelBlurYPostprocess=null),this._blurPostProcesses=[]}_disposeRTTandPostProcesses(){this._shadowMap&&(this._shadowMap.dispose(),this._shadowMap=null),this._disposeBlurPostProcesses()}_disposeSceneUBOs(){if(this._sceneUBOs){for(const p of this._sceneUBOs)p.dispose();this._sceneUBOs=[]}}dispose(){if(this._disposeRTTandPostProcesses(),this._disposeSceneUBOs(),this._light){if(this._light._shadowGenerators){const p=this._light._shadowGenerators.entries();for(let _=p.next();_.done!==!0;_=p.next()){const[E,A]=_.value;A===this&&this._light._shadowGenerators.delete(E)}this._light._shadowGenerators.size===0&&(this._light._shadowGenerators=null)}this._light._markMeshesAsLightDirty()}this.onBeforeShadowMapRenderMeshObservable.clear(),this.onBeforeShadowMapRenderObservable.clear(),this.onAfterShadowMapRenderMeshObservable.clear(),this.onAfterShadowMapRenderObservable.clear()}serialize(){const p={},_=this.getShadowMap();if(!_)return p;if(p.className=this.getClassName(),p.lightId=this._light.id,p.cameraId=this._camera?.id,p.id=this.id,p.mapSize=_.getRenderSize(),p.forceBackFacesOnly=this.forceBackFacesOnly,p.darkness=this.getDarkness(),p.transparencyShadow=this._transparencyShadow,p.frustumEdgeFalloff=this.frustumEdgeFalloff,p.bias=this.bias,p.normalBias=this.normalBias,p.usePercentageCloserFiltering=this.usePercentageCloserFiltering,p.useContactHardeningShadow=this.useContactHardeningShadow,p.contactHardeningLightSizeUVRatio=this.contactHardeningLightSizeUVRatio,p.filteringQuality=this.filteringQuality,p.useExponentialShadowMap=this.useExponentialShadowMap,p.useBlurExponentialShadowMap=this.useBlurExponentialShadowMap,p.useCloseExponentialShadowMap=this.useBlurExponentialShadowMap,p.useBlurCloseExponentialShadowMap=this.useBlurExponentialShadowMap,p.usePoissonSampling=this.usePoissonSampling,p.depthScale=this.depthScale,p.blurBoxOffset=this.blurBoxOffset,p.blurKernel=this.blurKernel,p.blurScale=this.blurScale,p.useKernelBlur=this.useKernelBlur,p.renderList=[],_.renderList)for(let E=0;E<_.renderList.length;E++){const A=_.renderList[E];p.renderList.push(A.id)}return p}static Parse(p,_,E){const A=_.getLightById(p.lightId),$=p.cameraId!==void 0?_.getCameraById(p.cameraId):null,ne=E?E(p.mapSize,A,$):new pr(p.mapSize,A,void 0,$),xe=ne.getShadowMap();for(let ce=0;ce<p.renderList.length;ce++)_.getMeshesById(p.renderList[ce]).forEach(function(Re){xe&&(xe.renderList||(xe.renderList=[]),xe.renderList.push(Re))});return p.id!==void 0&&(ne.id=p.id),ne.forceBackFacesOnly=!!p.forceBackFacesOnly,p.darkness!==void 0&&ne.setDarkness(p.darkness),p.transparencyShadow&&ne.setTransparencyShadow(!0),p.frustumEdgeFalloff!==void 0&&(ne.frustumEdgeFalloff=p.frustumEdgeFalloff),p.bias!==void 0&&(ne.bias=p.bias),p.normalBias!==void 0&&(ne.normalBias=p.normalBias),p.usePercentageCloserFiltering?ne.usePercentageCloserFiltering=!0:p.useContactHardeningShadow?ne.useContactHardeningShadow=!0:p.usePoissonSampling?ne.usePoissonSampling=!0:p.useExponentialShadowMap?ne.useExponentialShadowMap=!0:p.useBlurExponentialShadowMap?ne.useBlurExponentialShadowMap=!0:p.useCloseExponentialShadowMap?ne.useCloseExponentialShadowMap=!0:p.useBlurCloseExponentialShadowMap?ne.useBlurCloseExponentialShadowMap=!0:p.useVarianceShadowMap?ne.useExponentialShadowMap=!0:p.useBlurVarianceShadowMap&&(ne.useBlurExponentialShadowMap=!0),p.contactHardeningLightSizeUVRatio!==void 0&&(ne.contactHardeningLightSizeUVRatio=p.contactHardeningLightSizeUVRatio),p.filteringQuality!==void 0&&(ne.filteringQuality=p.filteringQuality),p.depthScale&&(ne.depthScale=p.depthScale),p.blurScale&&(ne.blurScale=p.blurScale),p.blurBoxOffset&&(ne.blurBoxOffset=p.blurBoxOffset),p.useKernelBlur&&(ne.useKernelBlur=p.useKernelBlur),p.blurKernel&&(ne.blurKernel=p.blurKernel),ne}}pr.CLASSNAME="ShadowGenerator",pr.FILTER_NONE=0,pr.FILTER_EXPONENTIALSHADOWMAP=1,pr.FILTER_POISSONSAMPLING=2,pr.FILTER_BLUREXPONENTIALSHADOWMAP=3,pr.FILTER_CLOSEEXPONENTIALSHADOWMAP=4,pr.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP=5,pr.FILTER_PCF=6,pr.FILTER_PCSS=7,pr.QUALITY_HIGH=0,pr.QUALITY_MEDIUM=1,pr.QUALITY_LOW=2,pr.DEFAULT_ALPHA_CUTOFF=.5,pr._SceneComponentInitialization=_e=>{throw Tr("ShadowGeneratorSceneComponent")};class M0{static get ForceFullSceneLoadingForIncremental(){return M0._ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(p){M0._ForceFullSceneLoadingForIncremental=p}static get ShowLoadingScreen(){return M0._ShowLoadingScreen}static set ShowLoadingScreen(p){M0._ShowLoadingScreen=p}static get loggingLevel(){return M0._LoggingLevel}static set loggingLevel(p){M0._LoggingLevel=p}static get CleanBoneMatrixWeights(){return M0._CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(p){M0._CleanBoneMatrixWeights=p}}M0._ForceFullSceneLoadingForIncremental=!1,M0._ShowLoadingScreen=!0,M0._CleanBoneMatrixWeights=!1,M0._LoggingLevel=0;var ac;(function(_e){_e[_e.Clean=0]="Clean",_e[_e.Stop=1]="Stop",_e[_e.Sync=2]="Sync",_e[_e.NoSync=3]="NoSync"})(ac||(ac={}));class kn{static get ForceFullSceneLoadingForIncremental(){return M0.ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(p){M0.ForceFullSceneLoadingForIncremental=p}static get ShowLoadingScreen(){return M0.ShowLoadingScreen}static set ShowLoadingScreen(p){M0.ShowLoadingScreen=p}static get loggingLevel(){return M0.loggingLevel}static set loggingLevel(p){M0.loggingLevel=p}static get CleanBoneMatrixWeights(){return M0.CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(p){M0.CleanBoneMatrixWeights=p}static GetDefaultPlugin(){return kn._RegisteredPlugins[".babylon"]}static _GetPluginForExtension(p){const _=kn._RegisteredPlugins[p];return _||(vi.Warn("Unable to find a plugin to load "+p+" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes"),kn.GetDefaultPlugin())}static _GetPluginForDirectLoad(p){for(const _ in kn._RegisteredPlugins){const E=kn._RegisteredPlugins[_].plugin;if(E.canDirectLoad&&E.canDirectLoad(p))return kn._RegisteredPlugins[_]}return kn.GetDefaultPlugin()}static _GetPluginForFilename(p){const _=p.indexOf("?");_!==-1&&(p=p.substring(0,_));const E=p.lastIndexOf("."),A=p.substring(E,p.length).toLowerCase();return kn._GetPluginForExtension(A)}static _GetDirectLoad(p){return p.substr(0,5)==="data:"?p.substr(5):null}static _FormatErrorMessage(p,_,E){let $="Unable to load from "+(p.rawData?"binary data":p.url);return _?$+=`: ${_}`:E&&($+=`: ${E}`),$}static _LoadData(p,_,E,A,$,ne,xe,ce){const Te=kn._GetDirectLoad(p.url);if(p.rawData&&!xe)throw"When using ArrayBufferView to load data the file extension must be provided.";const Re=xe?kn._GetPluginForExtension(xe):Te?kn._GetPluginForDirectLoad(p.url):kn._GetPluginForFilename(p.url);if(p.rawData&&!Re.isBinary)throw"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.";let ke;if(Re.plugin.createPlugin!==void 0?ke=Re.plugin.createPlugin():ke=Re.plugin,!ke)throw"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";if(kn.OnPluginActivatedObservable.notifyObservers(ke),Te&&(ke.canDirectLoad&&ke.canDirectLoad(p.url)||!kl(p.url))){if(ke.directLoad){const Ht=ke.directLoad(_,Te);Ht.then?Ht.then(Wt=>{E(ke,Wt)}).catch(Wt=>{$("Error in directLoad of _loadData: "+Wt,Wt)}):E(ke,Ht)}else E(ke,Te);return ke}const We=Re.isBinary,Xe=(Ht,Wt)=>{if(_.isDisposed){$("Scene has been disposed");return}E(ke,Ht,Wt)};let xt=null,qe=!1;const ht=ke.onDisposeObservable;ht&&ht.add(()=>{qe=!0,xt&&(xt.abort(),xt=null),ne()});const Nt=()=>{if(qe)return;const Ht=(Wt,zt)=>{$(Wt?.statusText,zt)};if(!ke.loadFile&&p.rawData)throw"Plugin does not support loading ArrayBufferView.";xt=ke.loadFile?ke.loadFile(_,p.rawData||p.file||p.url,p.rootUrl,Xe,A,We,Ht,ce):_._loadFile(p.file||p.url,Xe,A,!0,We,Ht)},wt=_.getEngine();let Qt=wt.enableOfflineSupport;if(Qt){let Ht=!1;for(const Wt of _.disableOfflineSupportExceptionRules)if(Wt.test(p.url)){Ht=!0;break}Qt=!Ht}return Qt&&ui.OfflineProviderFactory?_.offlineProvider=ui.OfflineProviderFactory(p.url,Nt,wt.disableManifestCheck):Nt(),ke}static _GetFileInfo(p,_){let E,A,$=null,ne=null;if(!_)E=p,A=ct.GetFilename(p),p=ct.GetFolderPath(p);else if(_.name){const xe=_;E=`file:${xe.name}`,A=xe.name,$=xe}else if(ArrayBuffer.isView(_))E="",A="arrayBuffer",ne=_;else if(typeof _=="string"&&_.startsWith("data:"))E=_,A="";else{const xe=_;if(xe.substr(0,1)==="/")return ct.Error("Wrong sceneFilename parameter"),null;E=p+xe,A=xe}return{url:E,rootUrl:p,name:A,file:$,rawData:ne}}static GetPluginForExtension(p){return kn._GetPluginForExtension(p).plugin}static IsPluginForExtensionAvailable(p){return!!kn._RegisteredPlugins[p]}static RegisterPlugin(p){if(typeof p.extensions=="string"){const _=p.extensions;kn._RegisteredPlugins[_.toLowerCase()]={plugin:p,isBinary:!1}}else{const _=p.extensions;Object.keys(_).forEach(E=>{kn._RegisteredPlugins[E.toLowerCase()]={plugin:p,isBinary:_[E].isBinary}})}}static ImportMesh(p,_,E="",A=wr.LastCreatedScene,$=null,ne=null,xe=null,ce=null,Te=""){if(!A)return vi.Error("No scene available to import mesh to"),null;const Re=kn._GetFileInfo(_,E);if(!Re)return null;const ke={};A.addPendingData(ke);const We=()=>{A.removePendingData(ke)},Xe=(ht,Nt)=>{const wt=kn._FormatErrorMessage(Re,ht,Nt);xe?xe(A,wt,new jo(wt,Yo.SceneLoaderError,Nt)):vi.Error(wt),We()},xt=ne?ht=>{try{ne(ht)}catch(Nt){Xe("Error in onProgress callback: "+Nt,Nt)}}:void 0,qe=(ht,Nt,wt,Qt,Ht,Wt,zt)=>{if(A.importedMeshesFiles.push(Re.url),$)try{$(ht,Nt,wt,Qt,Ht,Wt,zt)}catch(xi){Xe("Error in onSuccess callback: "+xi,xi)}A.removePendingData(ke)};return kn._LoadData(Re,A,(ht,Nt,wt)=>{if(ht.rewriteRootURL&&(Re.rootUrl=ht.rewriteRootURL(Re.rootUrl,wt)),ht.importMesh){const Qt=ht,Ht=[],Wt=[],zt=[];if(!Qt.importMesh(p,A,Nt,Re.rootUrl,Ht,Wt,zt,Xe))return;A.loadingPluginName=ht.name,qe(Ht,Wt,zt,[],[],[],[])}else ht.importMeshAsync(p,A,Nt,Re.rootUrl,xt,Re.name).then(Ht=>{A.loadingPluginName=ht.name,qe(Ht.meshes,Ht.particleSystems,Ht.skeletons,Ht.animationGroups,Ht.transformNodes,Ht.geometries,Ht.lights)}).catch(Ht=>{Xe(Ht.message,Ht)})},xt,Xe,We,ce,Te)}static ImportMeshAsync(p,_,E="",A=wr.LastCreatedScene,$=null,ne=null,xe=""){return new Promise((ce,Te)=>{kn.ImportMesh(p,_,E,A,(Re,ke,We,Xe,xt,qe,ht)=>{ce({meshes:Re,particleSystems:ke,skeletons:We,animationGroups:Xe,transformNodes:xt,geometries:qe,lights:ht})},$,(Re,ke,We)=>{Te(We||new Error(ke))},ne,xe)})}static Load(p,_="",E=wr.LastCreatedEngine,A=null,$=null,ne=null,xe=null,ce=""){return E?kn.Append(p,_,new W0(E),A,$,ne,xe,ce):(ct.Error("No engine available"),null)}static LoadAsync(p,_="",E=wr.LastCreatedEngine,A=null,$=null,ne=""){return new Promise((xe,ce)=>{kn.Load(p,_,E,Te=>{xe(Te)},A,(Te,Re,ke)=>{ce(ke||new Error(Re))},$,ne)})}static Append(p,_="",E=wr.LastCreatedScene,A=null,$=null,ne=null,xe=null,ce=""){if(!E)return vi.Error("No scene available to append to"),null;const Te=kn._GetFileInfo(p,_);if(!Te)return null;const Re={};E.addPendingData(Re);const ke=()=>{E.removePendingData(Re)};kn.ShowLoadingScreen&&!this._ShowingLoadingScreen&&(this._ShowingLoadingScreen=!0,E.getEngine().displayLoadingUI(),E.executeWhenReady(()=>{E.getEngine().hideLoadingUI(),this._ShowingLoadingScreen=!1}));const We=(qe,ht)=>{const Nt=kn._FormatErrorMessage(Te,qe,ht);ne?ne(E,Nt,new jo(Nt,Yo.SceneLoaderError,ht)):vi.Error(Nt),ke()},Xe=$?qe=>{try{$(qe)}catch(ht){We("Error in onProgress callback",ht)}}:void 0,xt=()=>{if(A)try{A(E)}catch(qe){We("Error in onSuccess callback",qe)}E.removePendingData(Re)};return kn._LoadData(Te,E,(qe,ht)=>{if(qe.load){if(!qe.load(E,ht,Te.rootUrl,We))return;E.loadingPluginName=qe.name,xt()}else qe.loadAsync(E,ht,Te.rootUrl,Xe,Te.name).then(()=>{E.loadingPluginName=qe.name,xt()}).catch(wt=>{We(wt.message,wt)})},Xe,We,ke,xe,ce)}static AppendAsync(p,_="",E=wr.LastCreatedScene,A=null,$=null,ne=""){return new Promise((xe,ce)=>{kn.Append(p,_,E,Te=>{xe(Te)},A,(Te,Re,ke)=>{ce(ke||new Error(Re))},$,ne)})}static LoadAssetContainer(p,_="",E=wr.LastCreatedScene,A=null,$=null,ne=null,xe=null,ce=""){if(!E)return vi.Error("No scene available to load asset container to"),null;const Te=kn._GetFileInfo(p,_);if(!Te)return null;const Re={};E.addPendingData(Re);const ke=()=>{E.removePendingData(Re)},We=(qe,ht)=>{const Nt=kn._FormatErrorMessage(Te,qe,ht);ne?ne(E,Nt,new jo(Nt,Yo.SceneLoaderError,ht)):vi.Error(Nt),ke()},Xe=$?qe=>{try{$(qe)}catch(ht){We("Error in onProgress callback",ht)}}:void 0,xt=qe=>{if(A)try{A(qe)}catch(ht){We("Error in onSuccess callback",ht)}E.removePendingData(Re)};return kn._LoadData(Te,E,(qe,ht)=>{if(qe.loadAssetContainer){const wt=qe.loadAssetContainer(E,ht,Te.rootUrl,We);if(!wt)return;wt.populateRootNodes(),E.loadingPluginName=qe.name,xt(wt)}else qe.loadAssetContainerAsync?qe.loadAssetContainerAsync(E,ht,Te.rootUrl,Xe,Te.name).then(wt=>{wt.populateRootNodes(),E.loadingPluginName=qe.name,xt(wt)}).catch(wt=>{We(wt.message,wt)}):We("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.")},Xe,We,ke,xe,ce)}static LoadAssetContainerAsync(p,_="",E=wr.LastCreatedScene,A=null,$=null){return new Promise((ne,xe)=>{kn.LoadAssetContainer(p,_,E,ce=>{ne(ce)},A,(ce,Te,Re)=>{xe(Re||new Error(Te))},$)})}static ImportAnimations(p,_="",E=wr.LastCreatedScene,A=!0,$=ac.Clean,ne=null,xe=null,ce=null,Te=null,Re=null){if(!E){vi.Error("No scene available to load animations to");return}if(A){for(const xt of E.animatables)xt.reset();E.stopAllAnimations(),E.animationGroups.slice().forEach(xt=>{xt.dispose()}),E.getNodes().forEach(xt=>{xt.animations&&(xt.animations=[])})}else switch($){case ac.Clean:E.animationGroups.slice().forEach(Xe=>{Xe.dispose()});break;case ac.Stop:E.animationGroups.forEach(Xe=>{Xe.stop()});break;case ac.Sync:E.animationGroups.forEach(Xe=>{Xe.reset(),Xe.restart()});break;case ac.NoSync:break;default:vi.Error("Unknown animation group loading mode value '"+$+"'");return}const ke=E.animatables.length,We=Xe=>{Xe.mergeAnimationsTo(E,E.animatables.slice(ke),ne),Xe.dispose(),E.onAnimationFileImportedObservable.notifyObservers(E),xe&&xe(E)};this.LoadAssetContainer(p,_,E,We,ce,Te,Re)}static ImportAnimationsAsync(p,_="",E=wr.LastCreatedScene,A=!0,$=ac.Clean,ne=null,xe=null,ce=null,Te=null,Re=null){return new Promise((ke,We)=>{kn.ImportAnimations(p,_,E,A,$,ne,Xe=>{ke(Xe)},ce,(Xe,xt,qe)=>{We(qe||new Error(xt))},Re)})}}kn.NO_LOGGING=0,kn.MINIMAL_LOGGING=1,kn.SUMMARY_LOGGING=2,kn.DETAILED_LOGGING=3,kn.OnPluginActivatedObservable=new Mi,kn._RegisteredPlugins={},kn._ShowingLoadingScreen=!1;const hS="depthPixelShader",cS=`#ifdef ALPHATEST
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
varying float vDepthMetric;
#ifdef PACKED
#include<packingFunctions>
#endif
#ifdef STORE_CAMERASPACE_Z
varying vec4 vViewPos;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#ifdef STORE_CAMERASPACE_Z
#ifdef PACKED
gl_FragColor=pack(vViewPos.z);
#else
gl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);
#endif
#else
#ifdef NONLINEARDEPTH
#ifdef PACKED
gl_FragColor=pack(gl_FragCoord.z);
#else
gl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
gl_FragColor=pack(vDepthMetric);
#else
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
#endif
#endif
}`;Gi.ShadersStore[hS]=cS;const c5={name:hS,shader:cS},uS="pointCloudVertexDeclaration",pS=`#ifdef POINTSIZE
uniform float pointSize;
#endif
`;Gi.IncludesShadersStore[uS]=pS;const u5={name:uS,shader:pS},_S="pointCloudVertex",TS=`#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`;Gi.IncludesShadersStore[_S]=TS;const p5={name:_S,shader:TS},vS="depthVertexShader",RS=`attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#ifdef STORE_CAMERASPACE_Z
uniform mat4 view;varying vec4 vViewPos;
#endif
#include<pointCloudVertexDeclaration>
varying float vDepthMetric;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#include<clipPlaneVertex>
gl_Position=viewProjection*worldPos;
#ifdef STORE_CAMERASPACE_Z
vViewPos=view*worldPos;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#include<pointCloudVertex>
}
`;Gi.ShadersStore[vS]=RS;const _5={name:vS,shader:RS};class Tg{setMaterialForRendering(p,_){this._depthMap.setMaterialForRendering(p,_)}constructor(p,_=1,E=null,A=!1,$=Hi.TRILINEAR_SAMPLINGMODE,ne=!1,xe){this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this.useOnlyInActiveCamera=!1,this.reverseCulling=!1,this._scene=p,this._storeNonLinearDepth=A,this._storeCameraSpaceZ=ne,this.isPacked=_===0,this.isPacked?this.clearColor=new vr(1,1,1,1):this.clearColor=new vr(ne?1e8:1,0,0,1),Tg._SceneComponentInitialization(this._scene);const ce=p.getEngine();this._camera=E,$!==Hi.NEAREST_SAMPLINGMODE&&(_===1&&!ce._caps.textureFloatLinearFiltering&&($=Hi.NEAREST_SAMPLINGMODE),_===2&&!ce._caps.textureHalfFloatLinearFiltering&&($=Hi.NEAREST_SAMPLINGMODE));const Te=this.isPacked||!ce._features.supportExtendedTextureFormats?5:6;this._depthMap=new $o(xe??"DepthRenderer",{width:ce.getRenderWidth(),height:ce.getRenderHeight()},this._scene,!1,!0,_,!1,$,void 0,void 0,void 0,Te),this._depthMap.wrapU=Hi.CLAMP_ADDRESSMODE,this._depthMap.wrapV=Hi.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.noPrePassRenderer=!0,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add(ke=>{ke.clear(this.clearColor,!0,!0,!0)}),this._depthMap.onBeforeBindObservable.add(()=>{ce._debugPushGroup?.("depth renderer",1)}),this._depthMap.onAfterUnbindObservable.add(()=>{ce._debugPopGroup?.(1)}),this._depthMap.customIsReadyFunction=(ke,We,Xe)=>{if((Xe||We===0)&&ke.subMeshes)for(let xt=0;xt<ke.subMeshes.length;++xt){const qe=ke.subMeshes[xt],ht=qe.getRenderingMesh(),Nt=ht._getInstancesRenderList(qe._id,!!qe.getReplacementMesh()),wt=ce.getCaps().instancedArrays&&(Nt.visibleInstances[qe._id]!==null&&Nt.visibleInstances[qe._id]!==void 0||ht.hasThinInstances);if(!this.isReady(qe,wt))return!1}return!0};const Re=ke=>{const We=ke.getRenderingMesh(),Xe=ke.getEffectiveMesh(),xt=this._scene,qe=xt.getEngine(),ht=ke.getMaterial();if(Xe._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!ht||Xe.infiniteDistance||ht.disableDepthWrite||ke.verticesCount===0||ke._renderId===xt.getRenderId())return;const Nt=Xe._getWorldMatrixDeterminant()<0;let wt=We.overrideMaterialSideOrientation??ht.sideOrientation;Nt&&(wt=wt===0?1:0);const Qt=wt===0;qe.setState(ht.backFaceCulling,0,!1,Qt,this.reverseCulling?!ht.cullBackFaces:ht.cullBackFaces);const Ht=We._getInstancesRenderList(ke._id,!!ke.getReplacementMesh());if(Ht.mustReturn)return;const Wt=qe.getCaps().instancedArrays&&(Ht.visibleInstances[ke._id]!==null&&Ht.visibleInstances[ke._id]!==void 0||We.hasThinInstances),zt=this._camera||xt.activeCamera;if(this.isReady(ke,Wt)&&zt){ke._renderId=xt.getRenderId();const xi=Xe._internalAbstractMeshDataInfo._materialForRenderPass?.[qe.currentRenderPassId];let wi=ke._getDrawWrapper();!wi&&xi&&(wi=xi._getDrawWrapper());const vs=zt.mode===Hr.ORTHOGRAPHIC_CAMERA;if(!wi)return;const cs=wi.effect;qe.enableEffect(wi),Wt||We._bind(ke,cs,ht.fillMode),xi?xi.bindForSubMesh(Xe.getWorldMatrix(),Xe,ke):(cs.setMatrix("viewProjection",xt.getTransformMatrix()),cs.setMatrix("world",Xe.getWorldMatrix()),this._storeCameraSpaceZ&&cs.setMatrix("view",xt.getViewMatrix()));let Mr,xn;if(vs?(Mr=!qe.useReverseDepthBuffer&&qe.isNDCHalfZRange?0:1,xn=qe.useReverseDepthBuffer&&qe.isNDCHalfZRange?0:1):(Mr=qe.useReverseDepthBuffer&&qe.isNDCHalfZRange?zt.minZ:qe.isNDCHalfZRange?0:zt.minZ,xn=qe.useReverseDepthBuffer&&qe.isNDCHalfZRange?0:zt.maxZ),cs.setFloat2("depthValues",Mr,Mr+xn),!xi){if(ht.needAlphaTesting()){const qr=ht.getAlphaTestTexture();qr&&(cs.setTexture("diffuseSampler",qr),cs.setMatrix("diffuseMatrix",qr.getTextureMatrix()))}if(We.useBones&&We.computeBonesUsingShaders&&We.skeleton){const qr=We.skeleton;if(qr.isUsingTextureForMatrices){const Tn=qr.getTransformMatrixTexture(We);if(!Tn)return;cs.setTexture("boneSampler",Tn),cs.setFloat("boneTextureWidth",4*(qr.bones.length+1))}else cs.setMatrices("mBones",qr.getTransformMatrices(We))}ug(cs,ht,xt),nr.BindMorphTargetParameters(We,cs),We.morphTargetManager&&We.morphTargetManager.isUsingTextureForTargets&&We.morphTargetManager._bind(cs),ht.pointsCloud&&cs.setFloat("pointSize",ht.pointSize)}We._processRendering(Xe,ke,cs,ht.fillMode,Ht,Wt,(qr,Tn)=>cs.setMatrix("world",Tn))}};this._depthMap.customRenderFunction=(ke,We,Xe,xt)=>{let qe;if(xt.length)for(qe=0;qe<xt.length;qe++)Re(xt.data[qe]);for(qe=0;qe<ke.length;qe++)Re(ke.data[qe]);for(qe=0;qe<We.length;qe++)Re(We.data[qe]);if(this.forceDepthWriteTransparentMeshes)for(qe=0;qe<Xe.length;qe++)Re(Xe.data[qe]);else for(qe=0;qe<Xe.length;qe++)Xe.data[qe].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}}isReady(p,_){const E=this._scene.getEngine(),A=p.getMesh(),$=A.getScene(),ne=A._internalAbstractMeshDataInfo._materialForRenderPass?.[E.currentRenderPassId];if(ne)return ne.isReadyForSubMesh(A,p,_);const xe=p.getMaterial();if(!xe||xe.disableDepthWrite)return!1;const ce=[],Te=[ut.PositionKind];xe&&xe.needAlphaTesting()&&xe.getAlphaTestTexture()&&(ce.push("#define ALPHATEST"),A.isVerticesDataPresent(ut.UVKind)&&(Te.push(ut.UVKind),ce.push("#define UV1")),A.isVerticesDataPresent(ut.UV2Kind)&&(Te.push(ut.UV2Kind),ce.push("#define UV2"))),A.useBones&&A.computeBonesUsingShaders?(Te.push(ut.MatricesIndicesKind),Te.push(ut.MatricesWeightsKind),A.numBoneInfluencers>4&&(Te.push(ut.MatricesIndicesExtraKind),Te.push(ut.MatricesWeightsExtraKind)),ce.push("#define NUM_BONE_INFLUENCERS "+A.numBoneInfluencers),ce.push("#define BonesPerMesh "+(A.skeleton?A.skeleton.bones.length+1:0)),p.getRenderingMesh().skeleton?.isUsingTextureForMatrices&&ce.push("#define BONETEXTURE")):ce.push("#define NUM_BONE_INFLUENCERS 0");const Re=A.morphTargetManager;let ke=0;Re&&(ke=Re.numMaxInfluencers||Re.numInfluencers,ke>0&&(ce.push("#define MORPHTARGETS"),ce.push("#define NUM_MORPH_INFLUENCERS "+ke),Re.isUsingTextureForTargets&&ce.push("#define MORPHTARGETS_TEXTURE"),nr.PrepareAttributesForMorphTargetsInfluencers(Te,A,ke))),xe.pointsCloud&&ce.push("#define POINTSIZE"),_&&(ce.push("#define INSTANCES"),nr.PushAttributesForInstances(Te),p.getRenderingMesh().hasThinInstances&&ce.push("#define THIN_INSTANCES")),this._storeNonLinearDepth&&ce.push("#define NONLINEARDEPTH"),this._storeCameraSpaceZ&&ce.push("#define STORE_CAMERASPACE_Z"),this.isPacked&&ce.push("#define PACKED"),l_(xe,$,ce);const We=p._getDrawWrapper(void 0,!0),Xe=We.defines,xt=ce.join(`
`);if(Xe!==xt){const qe=["world","mBones","boneTextureWidth","pointSize","viewProjection","view","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices"];cg(qe),We.setEffect(E.createEffect("depth",Te,qe,["diffuseSampler","morphTargets","boneSampler"],xt,void 0,void 0,void 0,{maxSimultaneousMorphTargets:ke}),xt)}return We.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const p=[];for(const _ in this._scene._depthRenderer)this._scene._depthRenderer[_]===this&&p.push(_);if(p.length>0){this._depthMap.dispose();for(const _ of p)delete this._scene._depthRenderer[_]}}}Tg._SceneComponentInitialization=_e=>{throw Tr("DepthRendererSceneComponent")};const MS="minmaxReduxPixelShader",wS=`varying vec2 vUV;uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform sampler2D sourceTexture;uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(sourceTexture,coord,0).r;float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;float minz=min(min(min(f1,f2),f3),f4);
#ifdef DEPTH_REDUX
float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#else
float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(MAIN)
uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(f1.x,f2.x);float maxz=max(f1.y,f2.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(LAST)
void main(void)
{glFragColor=vec4(0.);if (true) { 
discard;}}
#endif
`;Gi.ShadersStore[MS]=wS;const T5={name:MS,shader:wS};class vF{constructor(p){this.onAfterReductionPerformed=new Mi,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=p,this._postProcessManager=new qm(p.getScene()),this._onContextRestoredObserver=p.getEngine().onContextRestoredObservable.add(()=>{this._postProcessManager._rebuild()})}get sourceTexture(){return this._sourceTexture}setSourceTexture(p,_,E=2,A=!0){if(p===this._sourceTexture)return;this.dispose(!1),this._sourceTexture=p,this._reductionSteps=[],this._forceFullscreenViewport=A;const $=this._camera.getScene(),ne=new $n("Initial reduction phase","minmaxRedux",["texSize"],["sourceTexture"],1,null,1,$.getEngine(),!1,"#define INITIAL"+(_?`
#define DEPTH_REDUX`:""),E,void 0,void 0,void 0,7);ne.autoClear=!1,ne.forceFullscreenViewport=A;let xe=this._sourceTexture.getRenderWidth(),ce=this._sourceTexture.getRenderHeight();ne.onApply=((Re,ke)=>We=>{We.setTexture("sourceTexture",this._sourceTexture),We.setFloat2("texSize",Re,ke)})(xe,ce),this._reductionSteps.push(ne);let Te=1;for(;xe>1||ce>1;){xe=Math.max(Math.round(xe/2),1),ce=Math.max(Math.round(ce/2),1);const Re=new $n("Reduction phase "+Te,"minmaxRedux",["texSize"],null,{width:xe,height:ce},null,1,$.getEngine(),!1,"#define "+(xe==1&&ce==1?"LAST":xe==1||ce==1?"ONEBEFORELAST":"MAIN"),E,void 0,void 0,void 0,7);if(Re.autoClear=!1,Re.forceFullscreenViewport=A,Re.onApply=((ke,We)=>Xe=>{ke==1||We==1?Xe.setInt2("texSize",ke,We):Xe.setFloat2("texSize",ke,We)})(xe,ce),this._reductionSteps.push(Re),Te++,xe==1&&ce==1){const ke=(We,Xe,xt)=>{const qe=new Float32Array(4*We*Xe),ht={min:0,max:0};return()=>{$.getEngine()._readTexturePixels(xt.inputTexture.texture,We,Xe,-1,0,qe,!1),ht.min=qe[0],ht.max=qe[1],this.onAfterReductionPerformed.notifyObservers(ht)}};Re.onAfterRenderObservable.add(ke(xe,ce,Re))}}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(p){this._sourceTexture&&(this._sourceTexture.refreshRate=p)}get activated(){return this._activated}activate(){this._onAfterUnbindObserver||!this._sourceTexture||(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add(()=>{const p=this._camera.getScene().getEngine();p._debugPushGroup?.("min max reduction",1),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport),p.unBindFramebuffer(this._reductionSteps[0].inputTexture,!1),p._debugPopGroup?.(1)}),this._activated=!0)}deactivate(){!this._onAfterUnbindObserver||!this._sourceTexture||(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(p=!0){if(p&&(this.onAfterReductionPerformed.clear(),this._onContextRestoredObserver&&(this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)),this.deactivate(),this._reductionSteps){for(let _=0;_<this._reductionSteps.length;++_)this._reductionSteps[_].dispose();this._reductionSteps=null}this._postProcessManager&&p&&this._postProcessManager.dispose(),this._sourceTexture=null}}class RF extends vF{get depthRenderer(){return this._depthRenderer}constructor(p){super(p)}setDepthRenderer(p=null,_=2,E=!0){const A=this._camera.getScene();this._depthRenderer&&(delete A._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),p===null&&(A._depthRenderer||(A._depthRenderer={}),p=this._depthRenderer=new Tg(A,_,this._camera,!1,1),p.enabled=!1,this._depthRendererId="minmax"+this._camera.id,A._depthRenderer[this._depthRendererId]=p),super.setSourceTexture(p.getDepthMap(),!0,_,E)}setSourceTexture(p,_,E=2,A=!0){super.setSourceTexture(p,_,E,A)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(p=!0){if(super.dispose(p),this._depthRenderer&&p){const _=this._depthRenderer.getDepthMap().getScene();_&&delete _._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null}}}const LS=nt.Up(),MF=nt.Zero(),w0=new nt,zu=new nt,vg=new Yt;class $0 extends pr{_validateFilter(p){return p===pr.FILTER_NONE||p===pr.FILTER_PCF||p===pr.FILTER_PCSS?p:(vi.Error('Unsupported filter "'+p+'"!'),pr.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(p){p=Math.min(Math.max(p,$0.MIN_CASCADES_COUNT),$0.MAX_CASCADES_COUNT),p!==this._numCascades&&(this._numCascades=p,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(p){this._freezeShadowCastersBoundingInfoObservable&&p&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),!this._freezeShadowCastersBoundingInfoObservable&&!p&&(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add(()=>this._computeShadowCastersBoundingInfo())),this._freezeShadowCastersBoundingInfo=p,p&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._shadowMap&&this._shadowMap.renderList){const p=this._shadowMap.renderList;for(let E=0;E<p.length;E++){const A=p[E];if(!A)continue;const $=A.getBoundingInfo(),ne=$.boundingBox;this._scbiMin.minimizeInPlace(ne.minimumWorld),this._scbiMax.maximizeInPlace(ne.maximumWorld)}const _=this._scene.meshes;for(let E=0;E<_.length;E++){const A=_[E];if(!A||!A.isVisible||!A.isEnabled||!A.receiveShadows)continue;const $=A.getBoundingInfo(),ne=$.boundingBox;this._scbiMin.minimizeInPlace(ne.minimumWorld),this._scbiMax.maximizeInPlace(ne.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(p){this._shadowCastersBoundingInfo=p}setMinMaxDistance(p,_){this._minDistance===p&&this._maxDistance===_||(p>_&&(p=0,_=1),p<0&&(p=0),_>1&&(_=1),this._minDistance=p,this._maxDistance=_,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return $0.CLASSNAME}getCascadeMinExtents(p){return p>=0&&p<this._numCascades?this._cascadeMinExtents[p]:null}getCascadeMaxExtents(p){return p>=0&&p<this._numCascades?this._cascadeMaxExtents[p]:null}get shadowMaxZ(){return this._getCamera()?this._shadowMaxZ:0}set shadowMaxZ(p){const _=this._getCamera();if(!_){this._shadowMaxZ=p;return}this._shadowMaxZ===p||p<_.minZ||p>_.maxZ&&_.maxZ!==0||(this._shadowMaxZ=p,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0)}get debug(){return this._debug}set debug(p){this._debug=p,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(p){this._depthClamp=p}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(p){this._cascadeBlendPercentage=p,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(p){const _=Math.min(Math.max(p,0),1);this._lambda!=_&&(this._lambda=_,this._breaksAreDirty=!0)}getCascadeViewMatrix(p){return p>=0&&p<this._numCascades?this._viewMatrices[p]:null}getCascadeProjectionMatrix(p){return p>=0&&p<this._numCascades?this._projectionMatrices[p]:null}getCascadeTransformMatrix(p){return p>=0&&p<this._numCascades?this._transformMatrices[p]:null}setDepthRenderer(p){this._depthRenderer=p,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(p){const _=this._getCamera();if(_){if(this._autoCalcDepthBounds=p,!p){this._depthReducer&&this._depthReducer.deactivate(),this.setMinMaxDistance(0,1);return}this._depthReducer||(this._depthReducer=new RF(_),this._depthReducer.onAfterReductionPerformed.add(E=>{let A=E.min,$=E.max;A>=$&&(A=0,$=1),(A!=this._minDistance||$!=this._maxDistance)&&this.setMinMaxDistance(A,$)}),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate??-1}set autoCalcDepthBoundsRefreshRate(p){this._depthReducer?.depthRenderer&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=p)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const p=this._getCamera();if(!p)return;const _=p.minZ,E=p.maxZ||this._shadowMaxZ,A=E-_,$=this._minDistance,ne=this._shadowMaxZ<E&&this._shadowMaxZ>=_?Math.min((this._shadowMaxZ-_)/(E-_),this._maxDistance):this._maxDistance,xe=_+$*A,ce=_+ne*A,Te=ce-xe,Re=ce/xe;for(let ke=0;ke<this._cascades.length;++ke){const We=(ke+1)/this._numCascades,Xe=xe*Re**We,xt=xe+Te*We,qe=this._lambda*(Xe-xt)+xt;this._cascades[ke].prevBreakDistance=ke===0?$:this._cascades[ke-1].breakDistance,this._cascades[ke].breakDistance=(qe-_)/A,this._viewSpaceFrustumsZ[ke]=qe,this._frustumLengths[ke]=(this._cascades[ke].breakDistance-this._cascades[ke].prevBreakDistance)*A}this._breaksAreDirty=!1}_computeMatrices(){const p=this._scene;if(!this._getCamera())return;nt.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),Math.abs(nt.Dot(this._lightDirection,nt.Up()))===1&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const E=p.getEngine().useReverseDepthBuffer;for(let A=0;A<this._numCascades;++A){this._computeFrustumInWorldSpace(A),this._computeCascadeFrustum(A),this._cascadeMaxExtents[A].subtractToRef(this._cascadeMinExtents[A],w0),this._frustumCenter[A].addToRef(this._lightDirection.scale(this._cascadeMinExtents[A].z),this._shadowCameraPos[A]),Yt.LookAtLHToRef(this._shadowCameraPos[A],this._frustumCenter[A],LS,this._viewMatrices[A]);let $=0,ne=w0.z;const xe=this._shadowCastersBoundingInfo;xe.update(this._viewMatrices[A]),ne=Math.min(ne,xe.boundingBox.maximumWorld.z),!this._depthClamp||this.filter===pr.FILTER_PCSS?$=Math.min($,xe.boundingBox.minimumWorld.z):$=Math.max($,xe.boundingBox.minimumWorld.z),Yt.OrthoOffCenterLHToRef(this._cascadeMinExtents[A].x,this._cascadeMaxExtents[A].x,this._cascadeMinExtents[A].y,this._cascadeMaxExtents[A].y,E?ne:$,E?$:ne,this._projectionMatrices[A],p.getEngine().isNDCHalfZRange),this._cascadeMinExtents[A].z=$,this._cascadeMaxExtents[A].z=ne,this._viewMatrices[A].multiplyToRef(this._projectionMatrices[A],this._transformMatrices[A]),nt.TransformCoordinatesToRef(MF,this._transformMatrices[A],w0),w0.scaleInPlace(this._mapSize/2),zu.copyFromFloats(Math.round(w0.x),Math.round(w0.y),Math.round(w0.z)),zu.subtractInPlace(w0).scaleInPlace(2/this._mapSize),Yt.TranslationToRef(zu.x,zu.y,0,vg),this._projectionMatrices[A].multiplyToRef(vg,this._projectionMatrices[A]),this._viewMatrices[A].multiplyToRef(this._projectionMatrices[A],this._transformMatrices[A]),this._transformMatrices[A].copyToArray(this._transformMatricesAsArray,A*16)}}_computeFrustumInWorldSpace(p){const _=this._getCamera();if(!_)return;const E=this._cascades[p].prevBreakDistance,A=this._cascades[p].breakDistance,$=this._scene.getEngine().isNDCHalfZRange;_.getViewMatrix();const ne=_.maxZ===0,xe=_.maxZ;ne&&(_.maxZ=this._shadowMaxZ,_.getProjectionMatrix(!0));const ce=Yt.Invert(_.getTransformationMatrix());ne&&(_.maxZ=xe,_.getProjectionMatrix(!0));const Te=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let Re=0;Re<$0._FrustumCornersNDCSpace.length;++Re)w0.copyFrom($0._FrustumCornersNDCSpace[(Re+Te)%$0._FrustumCornersNDCSpace.length]),$&&w0.z===-1&&(w0.z=0),nt.TransformCoordinatesToRef(w0,ce,this._frustumCornersWorldSpace[p][Re]);for(let Re=0;Re<$0._FrustumCornersNDCSpace.length/2;++Re)w0.copyFrom(this._frustumCornersWorldSpace[p][Re+4]).subtractInPlace(this._frustumCornersWorldSpace[p][Re]),zu.copyFrom(w0).scaleInPlace(E),w0.scaleInPlace(A),w0.addInPlace(this._frustumCornersWorldSpace[p][Re]),this._frustumCornersWorldSpace[p][Re+4].copyFrom(w0),this._frustumCornersWorldSpace[p][Re].addInPlace(zu)}_computeCascadeFrustum(p){if(this._cascadeMinExtents[p].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[p].copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._frustumCenter[p].copyFromFloats(0,0,0),!!this._getCamera()){for(let E=0;E<this._frustumCornersWorldSpace[p].length;++E)this._frustumCenter[p].addInPlace(this._frustumCornersWorldSpace[p][E]);if(this._frustumCenter[p].scaleInPlace(1/this._frustumCornersWorldSpace[p].length),this.stabilizeCascades){let E=0;for(let A=0;A<this._frustumCornersWorldSpace[p].length;++A){const $=this._frustumCornersWorldSpace[p][A].subtractToRef(this._frustumCenter[p],w0).length();E=Math.max(E,$)}E=Math.ceil(E*16)/16,this._cascadeMaxExtents[p].copyFromFloats(E,E,E),this._cascadeMinExtents[p].copyFromFloats(-E,-E,-E)}else{const E=this._frustumCenter[p];this._frustumCenter[p].addToRef(this._lightDirection,w0),Yt.LookAtLHToRef(E,w0,LS,vg);for(let A=0;A<this._frustumCornersWorldSpace[p].length;++A)nt.TransformCoordinatesToRef(this._frustumCornersWorldSpace[p][A],vg,w0),this._cascadeMinExtents[p].minimizeInPlace(w0),this._cascadeMaxExtents[p].maximizeInPlace(w0)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let p=0;p<this._numCascades;++p)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${p})`))}static get IsSupported(){const p=wr.LastCreatedEngine;return p?p._features.supportCSM:!1}constructor(p,_,E,A,$=!0){if(!$0.IsSupported){vi.Error("CascadedShadowMap is not supported by the current engine.");return}super(p,_,E,A,$),this.usePercentageCloserFiltering=!0}_initializeGenerator(){this.penumbraDarkness=this.penumbraDarkness??1,this._numCascades=this._numCascades??$0.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=this.stabilizeCascades??!1,this._freezeShadowCastersBoundingInfoObservable=this._freezeShadowCastersBoundingInfoObservable??null,this.freezeShadowCastersBoundingInfo=this.freezeShadowCastersBoundingInfo??!1,this._scbiMin=this._scbiMin??new nt(0,0,0),this._scbiMax=this._scbiMax??new nt(0,0,0),this._shadowCastersBoundingInfo=this._shadowCastersBoundingInfo??new lx(new nt(0,0,0),new nt(0,0,0)),this._breaksAreDirty=this._breaksAreDirty??!0,this._minDistance=this._minDistance??0,this._maxDistance=this._maxDistance??1,this._currentLayer=this._currentLayer??0,this._shadowMaxZ=this._shadowMaxZ??this._getCamera()?.maxZ??1e4,this._debug=this._debug??!1,this._depthClamp=this._depthClamp??!0,this._cascadeBlendPercentage=this._cascadeBlendPercentage??.1,this._lambda=this._lambda??.5,this._autoCalcDepthBounds=this._autoCalcDepthBounds??!1,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){const p=this._scene.getEngine(),_={width:this._mapSize,height:this._mapSize,layers:this.numCascades};this._shadowMap=new $o(this._light.name+"_CSMShadowMap",_,this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(p.useReverseDepthBuffer?516:513,!0),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(super._initializeShadowMap(),this._shadowMap===null)return;this._transformMatricesAsArray=new Float32Array(this._numCascades*16),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(this._numCascades*2),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let _=0;_<this._numCascades;++_){this._cascades[_]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[_]=Yt.Zero(),this._projectionMatrices[_]=Yt.Zero(),this._transformMatrices[_]=Yt.Zero(),this._cascadeMinExtents[_]=new nt,this._cascadeMaxExtents[_]=new nt,this._frustumCenter[_]=new nt,this._shadowCameraPos[_]=new nt,this._frustumCornersWorldSpace[_]=new Array($0._FrustumCornersNDCSpace.length);for(let E=0;E<$0._FrustumCornersNDCSpace.length;++E)this._frustumCornersWorldSpace[_][E]=new nt}const p=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add(_=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[_]),this._currentLayer=_,this._filter===pr.FILTER_PCF&&p.setColorWrite(!1),this._scene.setTransformMatrix(this.getCascadeViewMatrix(_),this.getCascadeProjectionMatrix(_)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onBeforeBindObservable.add(()=>{this._currentSceneUBO=this._scene.getSceneUniformBuffer(),p._debugPushGroup?.(`cascaded shadow map generation for pass id ${p.currentRenderPassId}`,1),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()}),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(p,_){_.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(p){p.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==pr.FILTER_PCSS?"1":"0"))}prepareDefines(p,_){super.prepareDefines(p,_);const E=this._scene,A=this._light;if(!E.shadowsEnabled||!A.shadowEnabled)return;p["SHADOWCSM"+_]=!0,p["SHADOWCSMDEBUG"+_]=this.debug,p["SHADOWCSMNUM_CASCADES"+_]=this.numCascades,p["SHADOWCSM_RIGHTHANDED"+_]=E.useRightHandedSystem;const $=this._getCamera();$&&this._shadowMaxZ<=($.maxZ||this._shadowMaxZ)&&(p["SHADOWCSMUSESHADOWMAXZ"+_]=!0),this.cascadeBlendPercentage===0&&(p["SHADOWCSMNOBLEND"+_]=!0)}bindShadowLight(p,_){const E=this._light;if(!this._scene.shadowsEnabled||!E.shadowEnabled)return;const $=this._getCamera();if(!$)return;const ne=this.getShadowMap();if(!ne)return;const xe=ne.getSize().width;if(_.setMatrices("lightMatrix"+p,this._transformMatricesAsArray),_.setArray("viewFrustumZ"+p,this._viewSpaceFrustumsZ),_.setFloat("cascadeBlendFactor"+p,this.cascadeBlendPercentage===0?1e4:1/this.cascadeBlendPercentage),_.setArray("frustumLengths"+p,this._frustumLengths),this._filter===pr.FILTER_PCF)_.setDepthStencilTexture("shadowSampler"+p,ne),E._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),xe,1/xe,this.frustumEdgeFalloff,p);else if(this._filter===pr.FILTER_PCSS){for(let ce=0;ce<this._numCascades;++ce)this._lightSizeUVCorrection[ce*2+0]=ce===0?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[ce].x-this._cascadeMinExtents[ce].x),this._lightSizeUVCorrection[ce*2+1]=ce===0?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[ce].y-this._cascadeMinExtents[ce].y),this._depthCorrection[ce]=ce===0?1:(this._cascadeMaxExtents[ce].z-this._cascadeMinExtents[ce].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);_.setDepthStencilTexture("shadowSampler"+p,ne),_.setTexture("depthSampler"+p,ne),_.setArray2("lightSizeUVCorrection"+p,this._lightSizeUVCorrection),_.setArray("depthCorrection"+p,this._depthCorrection),_.setFloat("penumbraDarkness"+p,this.penumbraDarkness),E._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/xe,this._contactHardeningLightSizeUVRatio*xe,this.frustumEdgeFalloff,p)}else _.setTexture("shadowSampler"+p,ne),E._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),xe,1/xe,this.frustumEdgeFalloff,p);E._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ($),this.getLight().getDepthMinZ($)+this.getLight().getDepthMaxZ($),p)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const p=super.serialize(),_=this.getShadowMap();if(!_)return p;if(p.numCascades=this._numCascades,p.debug=this._debug,p.stabilizeCascades=this.stabilizeCascades,p.lambda=this._lambda,p.cascadeBlendPercentage=this.cascadeBlendPercentage,p.depthClamp=this._depthClamp,p.autoCalcDepthBounds=this.autoCalcDepthBounds,p.shadowMaxZ=this._shadowMaxZ,p.penumbraDarkness=this.penumbraDarkness,p.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,p.minDistance=this.minDistance,p.maxDistance=this.maxDistance,p.renderList=[],_.renderList)for(let E=0;E<_.renderList.length;E++){const A=_.renderList[E];p.renderList.push(A.id)}return p}static Parse(p,_){const E=pr.Parse(p,_,(A,$,ne)=>new $0(A,$,void 0,ne));return p.numCascades!==void 0&&(E.numCascades=p.numCascades),p.debug!==void 0&&(E.debug=p.debug),p.stabilizeCascades!==void 0&&(E.stabilizeCascades=p.stabilizeCascades),p.lambda!==void 0&&(E.lambda=p.lambda),p.cascadeBlendPercentage!==void 0&&(E.cascadeBlendPercentage=p.cascadeBlendPercentage),p.depthClamp!==void 0&&(E.depthClamp=p.depthClamp),p.autoCalcDepthBounds!==void 0&&(E.autoCalcDepthBounds=p.autoCalcDepthBounds),p.shadowMaxZ!==void 0&&(E.shadowMaxZ=p.shadowMaxZ),p.penumbraDarkness!==void 0&&(E.penumbraDarkness=p.penumbraDarkness),p.freezeShadowCastersBoundingInfo!==void 0&&(E.freezeShadowCastersBoundingInfo=p.freezeShadowCastersBoundingInfo),p.minDistance!==void 0&&p.maxDistance!==void 0&&E.setMinMaxDistance(p.minDistance,p.maxDistance),E}}$0._FrustumCornersNDCSpace=[new nt(-1,1,-1),new nt(1,1,-1),new nt(1,-1,-1),new nt(-1,-1,-1),new nt(-1,1,1),new nt(1,1,1),new nt(1,-1,1),new nt(-1,-1,1)],$0.CLASSNAME="CascadedShadowGenerator",$0.DEFAULT_CASCADES_COUNT=4,$0.MIN_CASCADES_COUNT=2,$0.MAX_CASCADES_COUNT=4,$0._SceneComponentInitialization=_e=>{throw Tr("ShadowGeneratorSceneComponent")},Mx.AddParser(_r.NAME_SHADOWGENERATOR,(_e,p)=>{if(_e.shadowGenerators!==void 0&&_e.shadowGenerators!==null)for(let _=0,E=_e.shadowGenerators.length;_<E;_++){const A=_e.shadowGenerators[_];A.className===$0.CLASSNAME?$0.Parse(A,p):pr.Parse(A,p)}});class wF{constructor(p){this.name=_r.NAME_SHADOWGENERATOR,this.scene=p}register(){this.scene._gatherRenderTargetsStage.registerStep(_r.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR,this,this._gatherRenderTargets)}rebuild(){}serialize(p){p.shadowGenerators=[];const _=this.scene.lights;for(const E of _){const A=E.getShadowGenerators();if(A){const $=A.values();for(let ne=$.next();ne.done!==!0;ne=$.next()){const xe=ne.value;p.shadowGenerators.push(xe.serialize())}}}}addFromContainer(p){}removeFromContainer(p,_){}dispose(){}_gatherRenderTargets(p){const _=this.scene;if(this.scene.shadowsEnabled)for(let E=0;E<_.lights.length;E++){const A=_.lights[E],$=A.getShadowGenerators();if(A.isEnabled()&&A.shadowEnabled&&$){const ne=$.values();for(let xe=ne.next();xe.done!==!0;xe=ne.next()){const Te=xe.value.getShadowMap();_.textures.indexOf(Te)!==-1&&p.push(Te)}}}}}pr._SceneComponentInitialization=_e=>{let p=_e._getComponent(_r.NAME_SHADOWGENERATOR);p||(p=new wF(_e),_e._addComponent(p))};var Wu;(function(_e){_e[_e.CW=0]="CW",_e[_e.CCW=1]="CCW"})(Wu||(Wu={}));class v5{static Interpolate(p,_,E,A,$){const ne=1-3*A+3*_,xe=3*A-6*_,ce=3*_;let Te=p;for(let Re=0;Re<5;Re++){const ke=Te*Te,We=ke*Te,Xe=ne*We+xe*ke+ce*Te,xt=1/(3*ne*ke+2*xe*Te+ce);Te-=(Xe-p)*xt,Te=Math.min(1,Math.max(0,Te))}return 3*Math.pow(1-Te,2)*Te*E+3*(1-Te)*Math.pow(Te,2)*$+Math.pow(Te,3)}}class M2{constructor(p){this._radians=p,this._radians<0&&(this._radians+=2*Math.PI)}degrees(){return this._radians*180/Math.PI}radians(){return this._radians}static BetweenTwoPoints(p,_){const E=_.subtract(p),A=Math.atan2(E.y,E.x);return new M2(A)}static BetweenTwoVectors(p,_){let E=p.lengthSquared()*_.lengthSquared();if(E===0)return new M2(Math.PI/2);E=Math.sqrt(E);let A=p.dot(_)/E;A=Scalar.Clamp(A,-1,1);const $=Math.acos(A);return new M2($)}static FromRadians(p){return new M2(p)}static FromDegrees(p){return new M2(p*Math.PI/180)}}class LF{constructor(p,_,E){this.startPoint=p,this.midPoint=_,this.endPoint=E;const A=Math.pow(_.x,2)+Math.pow(_.y,2),$=(Math.pow(p.x,2)+Math.pow(p.y,2)-A)/2,ne=(A-Math.pow(E.x,2)-Math.pow(E.y,2))/2,xe=(p.x-_.x)*(_.y-E.y)-(_.x-E.x)*(p.y-_.y);this.centerPoint=new Vector2(($*(_.y-E.y)-ne*(p.y-_.y))/xe,((p.x-_.x)*ne-(_.x-E.x)*$)/xe),this.radius=this.centerPoint.subtract(this.startPoint).length(),this.startAngle=M2.BetweenTwoPoints(this.centerPoint,this.startPoint);const ce=this.startAngle.degrees();let Te=M2.BetweenTwoPoints(this.centerPoint,this.midPoint).degrees(),Re=M2.BetweenTwoPoints(this.centerPoint,this.endPoint).degrees();Te-ce>180&&(Te-=360),Te-ce<-180&&(Te+=360),Re-Te>180&&(Re-=360),Re-Te<-180&&(Re+=360),this.orientation=Te-ce<0?Wu.CW:Wu.CCW,this.angle=M2.FromDegrees(this.orientation===Wu.CW?ce-Re:Re-ce)}}class kS{constructor(p,_){this._points=new Array,this._length=0,this.closed=!1,this._points.push(new Vector2(p,_))}addLineTo(p,_){if(this.closed)return this;const E=new Vector2(p,_),A=this._points[this._points.length-1];return this._points.push(E),this._length+=E.subtract(A).length(),this}addArcTo(p,_,E,A,$=36){if(this.closed)return this;const ne=this._points[this._points.length-1],xe=new Vector2(p,_),ce=new Vector2(E,A),Te=new LF(ne,xe,ce);let Re=Te.angle.radians()/$;Te.orientation===Wu.CW&&(Re*=-1);let ke=Te.startAngle.radians()+Re;for(let We=0;We<$;We++){const Xe=Math.cos(ke)*Te.radius+Te.centerPoint.x,xt=Math.sin(ke)*Te.radius+Te.centerPoint.y;this.addLineTo(Xe,xt),ke+=Re}return this}addQuadraticCurveTo(p,_,E,A,$=36){if(this.closed)return this;const ne=(ce,Te,Re,ke)=>(1-ce)*(1-ce)*Te+2*ce*(1-ce)*Re+ce*ce*ke,xe=this._points[this._points.length-1];for(let ce=0;ce<=$;ce++){const Te=ce/$,Re=ne(Te,xe.x,p,E),ke=ne(Te,xe.y,_,A);this.addLineTo(Re,ke)}return this}addBezierCurveTo(p,_,E,A,$,ne,xe=36){if(this.closed)return this;const ce=(Re,ke,We,Xe,xt)=>(1-Re)*(1-Re)*(1-Re)*ke+3*Re*(1-Re)*(1-Re)*We+3*Re*Re*(1-Re)*Xe+Re*Re*Re*xt,Te=this._points[this._points.length-1];for(let Re=0;Re<=xe;Re++){const ke=Re/xe,We=ce(ke,Te.x,p,E,$),Xe=ce(ke,Te.y,_,A,ne);this.addLineTo(We,Xe)}return this}isPointInside(p){let _=!1;const E=this._points.length;for(let A=E-1,$=0;$<E;A=$++){let ne=this._points[A],xe=this._points[$],ce=xe.x-ne.x,Te=xe.y-ne.y;if(Math.abs(Te)>Number.EPSILON){if(Te<0&&(ne=this._points[$],ce=-ce,xe=this._points[A],Te=-Te),p.y<ne.y||p.y>xe.y)continue;if(p.y===ne.y&&p.x===ne.x)return!0;{const Re=Te*(p.x-ne.x)-ce*(p.y-ne.y);if(Re===0)return!0;if(Re<0)continue;_=!_}}else{if(p.y!==ne.y)continue;if(xe.x<=p.x&&p.x<=ne.x||ne.x<=p.x&&p.x<=xe.x)return!0}}return _}close(){return this.closed=!0,this}length(){let p=this._length;if(this.closed){const _=this._points[this._points.length-1],E=this._points[0];p+=E.subtract(_).length()}return p}area(){const p=this._points.length;let _=0;for(let E=p-1,A=0;A<p;E=A++)_+=this._points[E].x*this._points[A].y-this._points[A].x*this._points[E].y;return _*.5}getPoints(){return this._points}getPointAtLengthPosition(p){if(p<0||p>1)return Vector2.Zero();const _=p*this.length();let E=0;for(let A=0;A<this._points.length;A++){const $=(A+1)%this._points.length,ne=this._points[A],ce=this._points[$].subtract(ne),Te=ce.length()+E;if(_>=E&&_<=Te){const Re=ce.normalize(),ke=_-E;return new Vector2(ne.x+Re.x*ke,ne.y+Re.y*ke)}E=Te}return Vector2.Zero()}static StartingAt(p,_){return new kS(p,_)}}class US{constructor(p,_=null,E,A=!1){this.path=p,this._curve=new Array,this._distances=new Array,this._tangents=new Array,this._normals=new Array,this._binormals=new Array,this._pointAtData={id:0,point:Vector3.Zero(),previousPointArrayIndex:0,position:0,subPosition:0,interpolateReady:!1,interpolationMatrix:Matrix.Identity()};for(let $=0;$<p.length;$++)this._curve[$]=p[$].clone();this._raw=E||!1,this._alignTangentsWithPath=A,this._compute(_,A)}getCurve(){return this._curve}getPoints(){return this._curve}length(){return this._distances[this._distances.length-1]}getTangents(){return this._tangents}getNormals(){return this._normals}getBinormals(){return this._binormals}getDistances(){return this._distances}getPointAt(p){return this._updatePointAtData(p).point}getTangentAt(p,_=!1){return this._updatePointAtData(p,_),_?Vector3.TransformCoordinates(Vector3.Forward(),this._pointAtData.interpolationMatrix):this._tangents[this._pointAtData.previousPointArrayIndex]}getNormalAt(p,_=!1){return this._updatePointAtData(p,_),_?Vector3.TransformCoordinates(Vector3.Right(),this._pointAtData.interpolationMatrix):this._normals[this._pointAtData.previousPointArrayIndex]}getBinormalAt(p,_=!1){return this._updatePointAtData(p,_),_?Vector3.TransformCoordinates(Vector3.UpReadOnly,this._pointAtData.interpolationMatrix):this._binormals[this._pointAtData.previousPointArrayIndex]}getDistanceAt(p){return this.length()*p}getPreviousPointIndexAt(p){return this._updatePointAtData(p),this._pointAtData.previousPointArrayIndex}getSubPositionAt(p){return this._updatePointAtData(p),this._pointAtData.subPosition}getClosestPositionTo(p){let _=Number.MAX_VALUE,E=0;for(let A=0;A<this._curve.length-1;A++){const $=this._curve[A+0],ne=this._curve[A+1].subtract($).normalize(),xe=this._distances[A+1]-this._distances[A+0],ce=Math.min(Math.max(Vector3.Dot(ne,p.subtract($).normalize()),0)*Vector3.Distance($,p)/xe,1),Te=Vector3.Distance($.add(ne.scale(ce*xe)),p);Te<_&&(_=Te,E=(this._distances[A+0]+xe*ce)/this.length())}return E}slice(p=0,_=1){if(p<0&&(p=1-p*-1%1),_<0&&(_=1-_*-1%1),p>_){const Te=p;p=_,_=Te}const E=this.getCurve(),A=this.getPointAt(p);let $=this.getPreviousPointIndexAt(p);const ne=this.getPointAt(_),xe=this.getPreviousPointIndexAt(_)+1,ce=[];return p!==0&&($++,ce.push(A)),ce.push(...E.slice($,xe)),(_!==1||p===1)&&ce.push(ne),new US(ce,this.getNormalAt(p),this._raw,this._alignTangentsWithPath)}update(p,_=null,E=!1){for(let A=0;A<p.length;A++)this._curve[A].x=p[A].x,this._curve[A].y=p[A].y,this._curve[A].z=p[A].z;return this._compute(_,E),this}_compute(p,_=!1){const E=this._curve.length;if(E<2)return;this._tangents[0]=this._getFirstNonNullVector(0),this._raw||this._tangents[0].normalize(),this._tangents[E-1]=this._curve[E-1].subtract(this._curve[E-2]),this._raw||this._tangents[E-1].normalize();const A=this._tangents[0],$=this._normalVector(A,p);this._normals[0]=$,this._raw||this._normals[0].normalize(),this._binormals[0]=Vector3.Cross(A,this._normals[0]),this._raw||this._binormals[0].normalize(),this._distances[0]=0;let ne,xe,ce,Te,Re;for(let ke=1;ke<E;ke++)ne=this._getLastNonNullVector(ke),ke<E-1&&(xe=this._getFirstNonNullVector(ke),this._tangents[ke]=_?xe:ne.add(xe),this._tangents[ke].normalize()),this._distances[ke]=this._distances[ke-1]+this._curve[ke].subtract(this._curve[ke-1]).length(),ce=this._tangents[ke],Re=this._binormals[ke-1],this._normals[ke]=Vector3.Cross(Re,ce),this._raw||(this._normals[ke].length()===0?(Te=this._normals[ke-1],this._normals[ke]=Te.clone()):this._normals[ke].normalize()),this._binormals[ke]=Vector3.Cross(ce,this._normals[ke]),this._raw||this._binormals[ke].normalize();this._pointAtData.id=NaN}_getFirstNonNullVector(p){let _=1,E=this._curve[p+_].subtract(this._curve[p]);for(;E.length()===0&&p+_+1<this._curve.length;)_++,E=this._curve[p+_].subtract(this._curve[p]);return E}_getLastNonNullVector(p){let _=1,E=this._curve[p].subtract(this._curve[p-_]);for(;E.length()===0&&p>_+1;)_++,E=this._curve[p].subtract(this._curve[p-_]);return E}_normalVector(p,_){let E,A=p.length();if(A===0&&(A=1),_==null){let $;Scalar.WithinEpsilon(Math.abs(p.y)/A,1,Epsilon)?Scalar.WithinEpsilon(Math.abs(p.x)/A,1,Epsilon)?Scalar.WithinEpsilon(Math.abs(p.z)/A,1,Epsilon)?$=Vector3.Zero():$=new Vector3(0,0,1):$=new Vector3(1,0,0):$=new Vector3(0,-1,0),E=Vector3.Cross(p,$)}else E=Vector3.Cross(p,_),Vector3.CrossToRef(E,p,E);return E.normalize(),E}_updatePointAtData(p,_=!1){if(this._pointAtData.id===p)return this._pointAtData.interpolateReady||this._updateInterpolationMatrix(),this._pointAtData;this._pointAtData.id=p;const E=this.getPoints();if(p<=0)return this._setPointAtData(0,0,E[0],0,_);if(p>=1)return this._setPointAtData(1,1,E[E.length-1],E.length-1,_);let A=E[0],$,ne=0;const xe=p*this.length();for(let ce=1;ce<E.length;ce++){$=E[ce];const Te=Vector3.Distance(A,$);if(ne+=Te,ne===xe)return this._setPointAtData(p,1,$,ce,_);if(ne>xe){const ke=(ne-xe)/Te,We=A.subtract($),Xe=$.add(We.scaleInPlace(ke));return this._setPointAtData(p,1-ke,Xe,ce-1,_)}A=$}return this._pointAtData}_setPointAtData(p,_,E,A,$){return this._pointAtData.point=E,this._pointAtData.position=p,this._pointAtData.subPosition=_,this._pointAtData.previousPointArrayIndex=A,this._pointAtData.interpolateReady=$,$&&this._updateInterpolationMatrix(),this._pointAtData}_updateInterpolationMatrix(){this._pointAtData.interpolationMatrix=Matrix.Identity();const p=this._pointAtData.previousPointArrayIndex;if(p!==this._tangents.length-1){const _=p+1,E=this._tangents[p].clone(),A=this._normals[p].clone(),$=this._binormals[p].clone(),ne=this._tangents[_].clone(),xe=this._normals[_].clone(),ce=this._binormals[_].clone(),Te=Quaternion.RotationQuaternionFromAxis(A,$,E),Re=Quaternion.RotationQuaternionFromAxis(xe,ce,ne);Quaternion.Slerp(Te,Re,this._pointAtData.subPosition).toRotationMatrix(this._pointAtData.interpolationMatrix)}}}class xc{static CreateQuadraticBezier(p,_,E,A){A=A>2?A:3;const $=[],ne=(xe,ce,Te,Re)=>(1-xe)*(1-xe)*ce+2*xe*(1-xe)*Te+xe*xe*Re;for(let xe=0;xe<=A;xe++)$.push(new Vector3(ne(xe/A,p.x,_.x,E.x),ne(xe/A,p.y,_.y,E.y),ne(xe/A,p.z,_.z,E.z)));return new xc($)}static CreateCubicBezier(p,_,E,A,$){$=$>3?$:4;const ne=[],xe=(ce,Te,Re,ke,We)=>(1-ce)*(1-ce)*(1-ce)*Te+3*ce*(1-ce)*(1-ce)*Re+3*ce*ce*(1-ce)*ke+ce*ce*ce*We;for(let ce=0;ce<=$;ce++)ne.push(new Vector3(xe(ce/$,p.x,_.x,E.x,A.x),xe(ce/$,p.y,_.y,E.y,A.y),xe(ce/$,p.z,_.z,E.z,A.z)));return new xc(ne)}static CreateHermiteSpline(p,_,E,A,$){const ne=[],xe=1/$;for(let ce=0;ce<=$;ce++)ne.push(Vector3.Hermite(p,_,E,A,ce*xe));return new xc(ne)}static CreateCatmullRomSpline(p,_,E){const A=[],$=1/_;let ne=0;if(E){const xe=p.length;for(let ce=0;ce<xe;ce++){ne=0;for(let Te=0;Te<_;Te++)A.push(Vector3.CatmullRom(p[ce%xe],p[(ce+1)%xe],p[(ce+2)%xe],p[(ce+3)%xe],ne)),ne+=$}A.push(A[0])}else{const xe=[];xe.push(p[0].clone()),Array.prototype.push.apply(xe,p),xe.push(p[p.length-1].clone());let ce=0;for(;ce<xe.length-3;ce++){ne=0;for(let Te=0;Te<_;Te++)A.push(Vector3.CatmullRom(xe[ce],xe[ce+1],xe[ce+2],xe[ce+3],ne)),ne+=$}ce--,A.push(Vector3.CatmullRom(xe[ce],xe[ce+1],xe[ce+2],xe[ce+3],ne))}return new xc(A)}static ArcThru3Points(p,_,E,A=32,$=!1,ne=!1){const xe=[],ce=_.subtract(p),Te=E.subtract(_),Re=p.subtract(E),ke=Vector3.Cross(ce,Te),We=ke.length();if(We<Math.pow(10,-8))return new xc(xe);const Xe=ce.lengthSquared(),xt=Te.lengthSquared(),qe=Re.lengthSquared(),ht=ke.lengthSquared(),Nt=ce.length(),wt=Te.length(),Qt=Re.length(),Ht=.5*Nt*wt*Qt/We,Wt=Vector3.Dot(ce,Re),zt=Vector3.Dot(ce,Te),xi=Vector3.Dot(Te,Re),wi=-.5*xt*Wt/ht,vs=-.5*qe*zt/ht,cs=-.5*Xe*xi/ht,Mr=p.scale(wi).add(_.scale(vs)).add(E.scale(cs)),qr=p.subtract(Mr).normalize(),Tn=Vector3.Cross(ke,qr).normalize();if(ne){const h0=2*Math.PI/A;for(let Ra=0;Ra<=2*Math.PI;Ra+=h0)xe.push(Mr.add(qr.scale(Ht*Math.cos(Ra)).add(Tn.scale(Ht*Math.sin(Ra)))));xe.push(p)}else{const h0=1/A;let Ra=0,x0=Vector3.Zero();do x0=Mr.add(qr.scale(Ht*Math.cos(Ra)).add(Tn.scale(Ht*Math.sin(Ra)))),xe.push(x0),Ra+=h0;while(!x0.equalsWithEpsilon(E,Ht*h0*1.1));xe.push(E),$&&xe.push(p)}return new xc(xe)}constructor(p){this._length=0,this._points=p,this._length=this._computeLength(p)}getPoints(){return this._points}length(){return this._length}continue(p){const _=this._points[this._points.length-1],E=this._points.slice(),A=p.getPoints();for(let ne=1;ne<A.length;ne++)E.push(A[ne].subtract(A[0]).add(_));return new xc(E)}_computeLength(p){let _=0;for(let E=1;E<p.length;E++)_+=p[E].subtract(p[E-1]).length();return _}}class GS{constructor(p=Vector3.Zero(),_=Vector3.Up()){this.position=p,this.normal=_}clone(){return new GS(this.position.clone(),this.normal.clone())}}class zS{constructor(p=Vector3.Zero(),_=Vector3.Up(),E=Vector2.Zero()){this.position=p,this.normal=_,this.uv=E}clone(){return new zS(this.position.clone(),this.normal.clone(),this.uv.clone())}}const w2=[Math.sqrt(1/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(3/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(15/(4*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(5/(16*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(15/(16*Math.PI))],kF=[()=>1,_e=>_e.y,_e=>_e.z,_e=>_e.x,_e=>_e.x*_e.y,_e=>_e.y*_e.z,_e=>3*_e.z*_e.z-1,_e=>_e.x*_e.z,_e=>_e.x*_e.x-_e.y*_e.y],hh=(_e,p)=>w2[_e]*kF[_e](p),ch=[Math.PI,2*Math.PI/3,2*Math.PI/3,2*Math.PI/3,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4];class Hu{constructor(){this.preScaled=!1,this.l00=nt.Zero(),this.l1_1=nt.Zero(),this.l10=nt.Zero(),this.l11=nt.Zero(),this.l2_2=nt.Zero(),this.l2_1=nt.Zero(),this.l20=nt.Zero(),this.l21=nt.Zero(),this.l22=nt.Zero()}addLight(p,_,E){pi.Vector3[0].set(_.r,_.g,_.b);const A=pi.Vector3[0],$=pi.Vector3[1];A.scaleToRef(E,$),$.scaleToRef(hh(0,p),pi.Vector3[2]),this.l00.addInPlace(pi.Vector3[2]),$.scaleToRef(hh(1,p),pi.Vector3[2]),this.l1_1.addInPlace(pi.Vector3[2]),$.scaleToRef(hh(2,p),pi.Vector3[2]),this.l10.addInPlace(pi.Vector3[2]),$.scaleToRef(hh(3,p),pi.Vector3[2]),this.l11.addInPlace(pi.Vector3[2]),$.scaleToRef(hh(4,p),pi.Vector3[2]),this.l2_2.addInPlace(pi.Vector3[2]),$.scaleToRef(hh(5,p),pi.Vector3[2]),this.l2_1.addInPlace(pi.Vector3[2]),$.scaleToRef(hh(6,p),pi.Vector3[2]),this.l20.addInPlace(pi.Vector3[2]),$.scaleToRef(hh(7,p),pi.Vector3[2]),this.l21.addInPlace(pi.Vector3[2]),$.scaleToRef(hh(8,p),pi.Vector3[2]),this.l22.addInPlace(pi.Vector3[2])}scaleInPlace(p){this.l00.scaleInPlace(p),this.l1_1.scaleInPlace(p),this.l10.scaleInPlace(p),this.l11.scaleInPlace(p),this.l2_2.scaleInPlace(p),this.l2_1.scaleInPlace(p),this.l20.scaleInPlace(p),this.l21.scaleInPlace(p),this.l22.scaleInPlace(p)}convertIncidentRadianceToIrradiance(){this.l00.scaleInPlace(ch[0]),this.l1_1.scaleInPlace(ch[1]),this.l10.scaleInPlace(ch[2]),this.l11.scaleInPlace(ch[3]),this.l2_2.scaleInPlace(ch[4]),this.l2_1.scaleInPlace(ch[5]),this.l20.scaleInPlace(ch[6]),this.l21.scaleInPlace(ch[7]),this.l22.scaleInPlace(ch[8])}convertIrradianceToLambertianRadiance(){this.scaleInPlace(1/Math.PI)}preScaleForRendering(){this.preScaled=!0,this.l00.scaleInPlace(w2[0]),this.l1_1.scaleInPlace(w2[1]),this.l10.scaleInPlace(w2[2]),this.l11.scaleInPlace(w2[3]),this.l2_2.scaleInPlace(w2[4]),this.l2_1.scaleInPlace(w2[5]),this.l20.scaleInPlace(w2[6]),this.l21.scaleInPlace(w2[7]),this.l22.scaleInPlace(w2[8])}updateFromArray(p){return nt.FromArrayToRef(p[0],0,this.l00),nt.FromArrayToRef(p[1],0,this.l1_1),nt.FromArrayToRef(p[2],0,this.l10),nt.FromArrayToRef(p[3],0,this.l11),nt.FromArrayToRef(p[4],0,this.l2_2),nt.FromArrayToRef(p[5],0,this.l2_1),nt.FromArrayToRef(p[6],0,this.l20),nt.FromArrayToRef(p[7],0,this.l21),nt.FromArrayToRef(p[8],0,this.l22),this}updateFromFloatsArray(p){return nt.FromFloatsToRef(p[0],p[1],p[2],this.l00),nt.FromFloatsToRef(p[3],p[4],p[5],this.l1_1),nt.FromFloatsToRef(p[6],p[7],p[8],this.l10),nt.FromFloatsToRef(p[9],p[10],p[11],this.l11),nt.FromFloatsToRef(p[12],p[13],p[14],this.l2_2),nt.FromFloatsToRef(p[15],p[16],p[17],this.l2_1),nt.FromFloatsToRef(p[18],p[19],p[20],this.l20),nt.FromFloatsToRef(p[21],p[22],p[23],this.l21),nt.FromFloatsToRef(p[24],p[25],p[26],this.l22),this}static FromArray(p){return new Hu().updateFromArray(p)}static FromPolynomial(p){const _=new Hu;return _.l00=p.xx.scale(.376127).add(p.yy.scale(.376127)).add(p.zz.scale(.376126)),_.l1_1=p.y.scale(.977204),_.l10=p.z.scale(.977204),_.l11=p.x.scale(.977204),_.l2_2=p.xy.scale(1.16538),_.l2_1=p.yz.scale(1.16538),_.l20=p.zz.scale(1.34567).subtract(p.xx.scale(.672834)).subtract(p.yy.scale(.672834)),_.l21=p.zx.scale(1.16538),_.l22=p.xx.scale(1.16538).subtract(p.yy.scale(1.16538)),_.l1_1.scaleInPlace(-1),_.l11.scaleInPlace(-1),_.l2_1.scaleInPlace(-1),_.l21.scaleInPlace(-1),_.scaleInPlace(Math.PI),_}}class Xu{constructor(){this.x=nt.Zero(),this.y=nt.Zero(),this.z=nt.Zero(),this.xx=nt.Zero(),this.yy=nt.Zero(),this.zz=nt.Zero(),this.xy=nt.Zero(),this.yz=nt.Zero(),this.zx=nt.Zero()}get preScaledHarmonics(){return this._harmonics||(this._harmonics=Hu.FromPolynomial(this)),this._harmonics.preScaled||this._harmonics.preScaleForRendering(),this._harmonics}addAmbient(p){pi.Vector3[0].copyFromFloats(p.r,p.g,p.b);const _=pi.Vector3[0];this.xx.addInPlace(_),this.yy.addInPlace(_),this.zz.addInPlace(_)}scaleInPlace(p){this.x.scaleInPlace(p),this.y.scaleInPlace(p),this.z.scaleInPlace(p),this.xx.scaleInPlace(p),this.yy.scaleInPlace(p),this.zz.scaleInPlace(p),this.yz.scaleInPlace(p),this.zx.scaleInPlace(p),this.xy.scaleInPlace(p)}updateFromHarmonics(p){return this._harmonics=p,this.x.copyFrom(p.l11),this.x.scaleInPlace(1.02333).scaleInPlace(-1),this.y.copyFrom(p.l1_1),this.y.scaleInPlace(1.02333).scaleInPlace(-1),this.z.copyFrom(p.l10),this.z.scaleInPlace(1.02333),this.xx.copyFrom(p.l00),pi.Vector3[0].copyFrom(p.l20).scaleInPlace(.247708),pi.Vector3[1].copyFrom(p.l22).scaleInPlace(.429043),this.xx.scaleInPlace(.886277).subtractInPlace(pi.Vector3[0]).addInPlace(pi.Vector3[1]),this.yy.copyFrom(p.l00),this.yy.scaleInPlace(.886277).subtractInPlace(pi.Vector3[0]).subtractInPlace(pi.Vector3[1]),this.zz.copyFrom(p.l00),pi.Vector3[0].copyFrom(p.l20).scaleInPlace(.495417),this.zz.scaleInPlace(.886277).addInPlace(pi.Vector3[0]),this.yz.copyFrom(p.l2_1),this.yz.scaleInPlace(.858086).scaleInPlace(-1),this.zx.copyFrom(p.l21),this.zx.scaleInPlace(.858086).scaleInPlace(-1),this.xy.copyFrom(p.l2_2),this.xy.scaleInPlace(.858086),this.scaleInPlace(1/Math.PI),this}static FromHarmonics(p){return new Xu().updateFromHarmonics(p)}static FromArray(p){const _=new Xu;return nt.FromArrayToRef(p[0],0,_.x),nt.FromArrayToRef(p[1],0,_.y),nt.FromArrayToRef(p[2],0,_.z),nt.FromArrayToRef(p[3],0,_.xx),nt.FromArrayToRef(p[4],0,_.yy),nt.FromArrayToRef(p[5],0,_.zz),nt.FromArrayToRef(p[6],0,_.yz),nt.FromArrayToRef(p[7],0,_.zx),nt.FromArrayToRef(p[8],0,_.xy),_}}const WS="rgbdDecodePixelShader",HS=`varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;Gi.ShadersStore[WS]=HS;const R5={name:WS,shader:HS},XS="passCubePixelShader",KS=`varying vec2 vUV;uniform samplerCube textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec2 uv=vUV*2.0-1.0;
#ifdef POSITIVEX
gl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));
#endif
#ifdef NEGATIVEX
gl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));
#endif
#ifdef POSITIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));
#endif
#ifdef NEGATIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));
#endif
#ifdef POSITIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,1.001));
#endif
#ifdef NEGATIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));
#endif
}`;Gi.ShadersStore[XS]=KS;const M5={name:XS,shader:KS};class hm extends $n{getClassName(){return"PassPostProcess"}constructor(p,_,E=null,A,$,ne,xe=0,ce=!1){super(p,"pass",null,null,_,E,A,$,ne,void 0,xe,void 0,null,ce)}static _Parse(p,_,E,A){return Xr.Parse(()=>new hm(p.name,p.options,_,p.renderTargetSamplingMode,p._engine,p.reusable),p,E,A)}}zs("BABYLON.PassPostProcess",hm);class YS extends null{get face(){return this._face}set face(p){if(!(p<0||p>5))switch(this._face=p,this._face){case 0:this.updateEffect("#define POSITIVEX");break;case 1:this.updateEffect("#define NEGATIVEX");break;case 2:this.updateEffect("#define POSITIVEY");break;case 3:this.updateEffect("#define NEGATIVEY");break;case 4:this.updateEffect("#define POSITIVEZ");break;case 5:this.updateEffect("#define NEGATIVEZ");break}}getClassName(){return"PassCubePostProcess"}constructor(p,_,E=null,A,$,ne,xe=0,ce=!1){super(p,"passCube",null,null,_,E,A,$,ne,"#define POSITIVEX",xe,void 0,null,ce),this._face=0}static _Parse(p,_,E,A){return SerializationHelper.Parse(()=>new YS(p.name,p.options,_,p.renderTargetSamplingMode,p._engine,p.reusable),p,E,A)}}ui._RescalePostProcessFactory=_e=>new hm("rescale",1,null,2,_e,!1,0);function UF(_e,p,_,E=!0){const A=_e.getScene(),$=A.getEngine(),ne=new $o("resized"+_e.name,{width:p,height:_},A,!_e.noMipmap,!0,_e._texture.type,!1,_e.samplingMode,!1);ne.wrapU=_e.wrapU,ne.wrapV=_e.wrapV,ne.uOffset=_e.uOffset,ne.vOffset=_e.vOffset,ne.uScale=_e.uScale,ne.vScale=_e.vScale,ne.uAng=_e.uAng,ne.vAng=_e.vAng,ne.wAng=_e.wAng,ne.coordinatesIndex=_e.coordinatesIndex,ne.level=_e.level,ne.anisotropicFilteringLevel=_e.anisotropicFilteringLevel,ne._texture.isReady=!1,_e.wrapU=Hi.CLAMP_ADDRESSMODE,_e.wrapV=Hi.CLAMP_ADDRESSMODE;const xe=new hm("pass",1,null,E?Hi.BILINEAR_SAMPLINGMODE:Hi.NEAREST_SAMPLINGMODE,$,!1,0);return xe.externalTextureSamplerBinding=!0,xe.getEffect().executeWhenCompiled(()=>{xe.onApply=function(Te){Te.setTexture("textureSampler",_e)};const ce=ne.renderTarget;ce&&(A.postProcessManager.directRender([xe],ce),$.unBindFramebuffer(ce),ne.disposeFramebufferObjects(),xe.dispose(),ne.getInternalTexture().isReady=!0)}),ne}function jS(_e,p,_,E,A,$,ne,xe){const ce=p.getEngine();return p.isReady=!1,A=A??p.samplingMode,E=E??p.type,$=$??p.format,ne=ne??p.width,xe=xe??p.height,E===-1&&(E=0),new Promise(Te=>{const Re=new $n("postprocess",_e,null,null,1,null,A,ce,!1,void 0,E,void 0,null,!1,$);Re.externalTextureSamplerBinding=!0;const ke=ce.createRenderTargetTexture({width:ne,height:xe},{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:A,type:E,format:$});Re.getEffect().executeWhenCompiled(()=>{Re.onApply=We=>{We._bindTexture("textureSampler",p),We.setFloat2("scale",1,1)},_.postProcessManager.directRender([Re],ke,!0),ce.restoreDefaultFramebuffer(),ce._releaseTexture(p),Re&&Re.dispose(),ke._swapAndDie(p),p.type=E,p.format=5,p.isReady=!0,Te(p)})})}let Rg,qS;function GF(_e){Rg||(Rg=new Float32Array(1),qS=new Int32Array(Rg.buffer)),Rg[0]=_e;const p=qS[0];let _=p>>16&32768,E=p>>12&2047;const A=p>>23&255;return A<103?_:A>142?(_|=31744,_|=(A==255?0:1)&&p&8388607,_):A<113?(E|=2048,_|=(E>>114-A)+(E>>113-A&1),_):(_|=A-112<<10|E>>1,_+=E&1,_)}function zF(_e){const p=(_e&32768)>>15,_=(_e&31744)>>10,E=_e&1023;return _===0?(p?-1:1)*Math.pow(2,-14)*(E/Math.pow(2,10)):_==31?E?NaN:(p?-1:1)*(1/0):(p?-1:1)*Math.pow(2,_-15)*(1+E/Math.pow(2,10))}const WF=async(_e,p,_,E,A)=>{const $=_e.getScene(),ne=$.getEngine();let xe;if(!_e.isCube)xe=new $n("lod","lod",["lod","gamma"],null,1,null,Hi.NEAREST_NEAREST_MIPNEAREST,ne);else{const Re=["#define POSITIVEX","#define NEGATIVEX","#define POSITIVEY","#define NEGATIVEY","#define POSITIVEZ","#define NEGATIVEZ"];xe=new $n("lodCube","lodCube",["lod","gamma"],null,1,null,Hi.NEAREST_NEAREST_MIPNEAREST,ne,!1,Re[E])}await new Promise(Re=>{xe.getEffect().executeWhenCompiled(()=>{Re(0)})});const ce=new $o("temp",{width:p,height:_},$,!1);xe.onApply=function(Re){Re.setTexture("textureSampler",_e),Re.setFloat("lod",A),Re.setBool("gamma",_e.gammaSpace)};const Te=_e.getInternalTexture();try{if(ce.renderTarget&&Te){const Re=Te.samplingMode;A!==0?_e.updateSamplingMode(Hi.NEAREST_NEAREST_MIPNEAREST):_e.updateSamplingMode(Hi.NEAREST_NEAREST),$.postProcessManager.directRender([xe],ce.renderTarget,!0),_e.updateSamplingMode(Re);const ke=await ne.readPixels(0,0,p,_),We=new Uint8Array(ke.buffer,0,ke.byteLength);return ne.unBindFramebuffer(ce.renderTarget),We}else throw Error("Render to texture failed.")}finally{ce.dispose(),xe.dispose()}};async function HF(_e,p,_,E=0,A=0){return!_e.isReady()&&_e._texture&&await new Promise(($,ne)=>{if(_e._texture===null){ne(0);return}_e._texture.onLoadedObservable.addOnce(()=>{$(0)})}),await WF(_e,p,_,E,A)}const w5={CreateResizedCopy:UF,ApplyPostProcess:jS,ToHalfFloat:GF,FromHalfFloat:zF,GetTextureDataAsync:HF};class b_{static ExpandRGBDTexture(p){const _=p._texture;if(!_||!p.isRGBD)return;const E=_.getEngine(),A=E.getCaps(),$=_.isReady;let ne=!1;A.textureHalfFloatRender&&A.textureHalfFloatLinearFiltering?(ne=!0,_.type=2):A.textureFloatRender&&A.textureFloatLinearFiltering&&(ne=!0,_.type=1),ne&&(_.isReady=!1,_._isRGBD=!1,_.invertY=!1);const xe=()=>{const ce=new $n("rgbdDecode","rgbdDecode",null,null,1,null,3,E,!1,void 0,_.type,void 0,null,!1);ce.externalTextureSamplerBinding=!0;const Te=E.createRenderTargetTexture(_.width,{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:_.samplingMode,type:_.type,format:5});ce.getEffect().executeWhenCompiled(()=>{ce.onApply=Re=>{Re._bindTexture("textureSampler",_),Re.setFloat2("scale",1,1)},p.getScene().postProcessManager.directRender([ce],Te,!0),E.restoreDefaultFramebuffer(),E._releaseTexture(_),ce&&ce.dispose(),Te._swapAndDie(_),_.isReady=!0})};ne&&($?xe():p.onLoadObservable.addOnce(xe))}static EncodeTextureToRGBD(p,_,E=0){return jS("rgbdEncode",p,_,E,1,5)}}class Ku{constructor(p,_,E,A){this.name=p,this.worldAxisForNormal=_,this.worldAxisForFileX=E,this.worldAxisForFileY=A}}class Mg{static ConvertCubeMapTextureToSphericalPolynomial(p){if(!p.isCube)return null;p.getScene()?.getEngine().flushFramebuffer();const _=p.getSize().width,E=p.readPixels(0,void 0,void 0,!1),A=p.readPixels(1,void 0,void 0,!1);let $,ne;p.isRenderTarget?($=p.readPixels(3,void 0,void 0,!1),ne=p.readPixels(2,void 0,void 0,!1)):($=p.readPixels(2,void 0,void 0,!1),ne=p.readPixels(3,void 0,void 0,!1));const xe=p.readPixels(4,void 0,void 0,!1),ce=p.readPixels(5,void 0,void 0,!1),Te=p.gammaSpace,Re=5;let ke=0;return(p.textureType==1||p.textureType==2)&&(ke=1),new Promise(We=>{Promise.all([A,E,$,ne,xe,ce]).then(([Xe,xt,qe,ht,Nt,wt])=>{const Qt={size:_,right:xt,left:Xe,up:qe,down:ht,front:Nt,back:wt,format:Re,type:ke,gammaSpace:Te};We(this.ConvertCubeMapToSphericalPolynomial(Qt))})})}static _AreaElement(p,_){return Math.atan2(p*_,Math.sqrt(p*p+_*_+1))}static ConvertCubeMapToSphericalPolynomial(p){const _=new Hu;let E=0;const A=2/p.size,$=A,ne=.5*A,xe=ne-1;for(let We=0;We<6;We++){const Xe=this._FileFaces[We],xt=p[Xe.name];let qe=xe;const ht=p.format===5?4:3;for(let Nt=0;Nt<p.size;Nt++){let wt=xe;for(let Qt=0;Qt<p.size;Qt++){const Ht=Xe.worldAxisForFileX.scale(wt).add(Xe.worldAxisForFileY.scale(qe)).add(Xe.worldAxisForNormal);Ht.normalize();const Wt=this._AreaElement(wt-ne,qe-ne)-this._AreaElement(wt-ne,qe+ne)-this._AreaElement(wt+ne,qe-ne)+this._AreaElement(wt+ne,qe+ne);let zt=xt[Nt*p.size*ht+Qt*ht+0],xi=xt[Nt*p.size*ht+Qt*ht+1],wi=xt[Nt*p.size*ht+Qt*ht+2];isNaN(zt)&&(zt=0),isNaN(xi)&&(xi=0),isNaN(wi)&&(wi=0),p.type===0&&(zt/=255,xi/=255,wi/=255),p.gammaSpace&&(zt=Math.pow(ri.Clamp(zt),zi),xi=Math.pow(ri.Clamp(xi),zi),wi=Math.pow(ri.Clamp(wi),zi));const vs=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const Mr=Math.max(zt,xi,wi);if(Mr>vs){const xn=vs/Mr;zt*=xn,xi*=xn,wi*=xn}}else zt=ri.Clamp(zt,0,vs),xi=ri.Clamp(xi,0,vs),wi=ri.Clamp(wi,0,vs);const cs=new ws(zt,xi,wi);_.addLight(Ht,cs,Wt),E+=Wt,wt+=A}qe+=$}}const ke=4*Math.PI*6/6/E;return _.scaleInPlace(ke),_.convertIncidentRadianceToIrradiance(),_.convertIrradianceToLambertianRadiance(),Xu.FromHarmonics(_)}}Mg._FileFaces=[new Ku("right",new nt(1,0,0),new nt(0,0,-1),new nt(0,-1,0)),new Ku("left",new nt(-1,0,0),new nt(0,0,1),new nt(0,-1,0)),new Ku("up",new nt(0,1,0),new nt(1,0,0),new nt(0,0,1)),new Ku("down",new nt(0,-1,0),new nt(1,0,0),new nt(0,0,-1)),new Ku("front",new nt(0,0,1),new nt(1,0,0),new nt(0,-1,0)),new Ku("back",new nt(0,0,-1),new nt(-1,0,0),new nt(0,-1,0))],Mg.MAX_HDRI_VALUE=4096,Mg.PRESERVE_CLAMPED_COLORS=!1,la.prototype.forceSphericalPolynomialsRecompute=function(){this._texture&&(this._texture._sphericalPolynomial=null,this._texture._sphericalPolynomialPromise=null,this._texture._sphericalPolynomialComputed=!1)},Object.defineProperty(la.prototype,"sphericalPolynomial",{get:function(){if(this._texture){if(this._texture._sphericalPolynomial||this._texture._sphericalPolynomialComputed)return this._texture._sphericalPolynomial;if(this._texture.isReady)return this._texture._sphericalPolynomialPromise||(this._texture._sphericalPolynomialPromise=Mg.ConvertCubeMapTextureToSphericalPolynomial(this),this._texture._sphericalPolynomialPromise===null?this._texture._sphericalPolynomialComputed=!0:this._texture._sphericalPolynomialPromise.then(_e=>{this._texture._sphericalPolynomial=_e,this._texture._sphericalPolynomialComputed=!0})),null}return null},set:function(_e){this._texture&&(this._texture._sphericalPolynomial=_e)},enumerable:!0,configurable:!0});const $S="rgbdEncodePixelShader",rC=`varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);}`;Gi.ShadersStore[$S]=rC;const L5={name:$S,shader:rC},E_="image/png",T_=2,cm=[134,22,135,150,246,214,150,54];function nC(_e){const p=new DataView(_e.buffer,_e.byteOffset,_e.byteLength);let _=0;for(let ne=0;ne<cm.length;ne++)if(p.getUint8(_++)!==cm[ne])return vi.Error("Not a babylon environment map"),null;let E="",A=0;for(;A=p.getUint8(_++);)E+=String.fromCharCode(A);let $=JSON.parse(E);return $=wg($),$.specular&&($.specular.specularDataPosition=_,$.specular.lodGenerationScale=$.specular.lodGenerationScale||.8),$}function wg(_e){if(_e.version>T_)throw new Error(`Unsupported babylon environment map version "${_e.version}". Latest supported version is "${T_}".`);return _e.version===2||(_e={..._e,version:2,imageType:E_}),_e}async function XF(_e,p={}){const _=_e.getInternalTexture();if(!_)return Promise.reject("The cube texture is invalid.");const E=p.imageType??E_,A=_.getEngine();if(_e.textureType!==2&&_e.textureType!==1&&_e.textureType!==0&&_e.textureType!==0&&_e.textureType!==7&&_e.textureType!==-1)return Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");let $=1;if(!A.getCaps().textureFloatRender&&($=2,!A.getCaps().textureHalfFloatRender))return Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");_e.sphericalPolynomial;const ne=_e.getInternalTexture()?._sphericalPolynomialPromise,xe=_.width,ce=new W0(A),Te={};A.flushFramebuffer();const Re=ri.ILog2(_.width);for(let Wt=0;Wt<=Re;Wt++){const zt=Math.pow(2,Re-Wt);for(let xi=0;xi<6;xi++){let wi=await _e.readPixels(xi,Wt,void 0,!1);if(wi&&wi.byteLength===wi.length){const xn=new Float32Array(wi.byteLength*4);for(let qr=0;qr<wi.byteLength;qr++)xn[qr]=wi[qr]/255,xn[qr]=Math.pow(xn[qr],2.2);wi=xn}else if(wi&&_e.gammaSpace){const xn=wi;for(let qr=0;qr<xn.length;qr++)xn[qr]=Math.pow(xn[qr],2.2)}const vs=A.createRawTexture(wi,zt,zt,5,!1,!0,1,null,$);await b_.EncodeTextureToRGBD(vs,ce,$);const cs=await A._readTexturePixels(vs,zt,zt),Mr=await Go.DumpDataAsync(zt,zt,cs,E,void 0,!1,!0,p.imageQuality);Te[Wt*6+xi]=Mr,vs.dispose()}}ce.dispose(),ne&&await ne;const ke={version:T_,width:xe,imageType:E,irradiance:KF(_e),specular:{mipmaps:[],lodGenerationScale:_e.lodGenerationScale}};let We=0;for(let Wt=0;Wt<=Re;Wt++)for(let zt=0;zt<6;zt++){const xi=Te[Wt*6+zt].byteLength;ke.specular.mipmaps.push({length:xi,position:We}),We+=xi}const Xe=JSON.stringify(ke),xt=new ArrayBuffer(Xe.length+1),qe=new Uint8Array(xt);for(let Wt=0,zt=Xe.length;Wt<zt;Wt++)qe[Wt]=Xe.charCodeAt(Wt);qe[Xe.length]=0;const ht=cm.length+We+xt.byteLength,Nt=new ArrayBuffer(ht),wt=new Uint8Array(Nt),Qt=new DataView(Nt);let Ht=0;for(let Wt=0;Wt<cm.length;Wt++)Qt.setUint8(Ht++,cm[Wt]);wt.set(new Uint8Array(xt),Ht),Ht+=xt.byteLength;for(let Wt=0;Wt<=Re;Wt++)for(let zt=0;zt<6;zt++){const xi=Te[Wt*6+zt];wt.set(new Uint8Array(xi),Ht),Ht+=xi.byteLength}return Nt}function KF(_e){const p=_e.sphericalPolynomial;return p==null?null:{x:[p.x.x,p.x.y,p.x.z],y:[p.y.x,p.y.y,p.y.z],z:[p.z.x,p.z.y,p.z.z],xx:[p.xx.x,p.xx.y,p.xx.z],yy:[p.yy.x,p.yy.y,p.yy.z],zz:[p.zz.x,p.zz.y,p.zz.z],yz:[p.yz.x,p.yz.y,p.yz.z],zx:[p.zx.x,p.zx.y,p.zx.z],xy:[p.xy.x,p.xy.y,p.xy.z]}}function aC(_e,p){p=wg(p);const _=p.specular;let E=ri.Log2(p.width);if(E=Math.round(E)+1,_.mipmaps.length!==6*E)throw new Error(`Unsupported specular mipmaps number "${_.mipmaps.length}"`);const A=new Array(E);for(let $=0;$<E;$++){A[$]=new Array(6);for(let ne=0;ne<6;ne++){const xe=_.mipmaps[$*6+ne];A[$][ne]=new Uint8Array(_e.buffer,_e.byteOffset+_.specularDataPosition+xe.position,xe.length)}}return A}function xC(_e,p,_){_=wg(_);const E=_.specular;if(!E)return Promise.resolve();_e._lodGenerationScale=E.lodGenerationScale;const A=aC(p,_);return Lg(_e,A,_.imageType)}function lC(_e,p,_,E,A,$,ne,xe,ce,Te,Re){return new Promise((ke,We)=>{if(_){const Xe=p.createTexture(null,!0,!0,null,1,null,xt=>{We(xt)},_e);E.getEffect().executeWhenCompiled(()=>{E.externalTextureSamplerBinding=!0,E.onApply=xt=>{xt._bindTexture("textureSampler",Xe),xt.setFloat2("scale",1,p._features.needsInvertingBitmap&&_e instanceof ImageBitmap?-1:1)},p.scenes.length&&(p.scenes[0].postProcessManager.directRender([E],Te,!0,$,ne),p.restoreDefaultFramebuffer(),Xe.dispose(),URL.revokeObjectURL(A),ke())})}else{if(p._uploadImageToTexture(Re,_e,$,ne),xe){const Xe=ce[ne];Xe&&p._uploadImageToTexture(Xe._texture,_e,$,0)}ke()}})}function Lg(_e,p,_=E_){if(!ct.IsExponentOfTwo(_e.width))throw new Error("Texture size must be a power of two");const E=ri.ILog2(_e.width)+1,A=_e.getEngine();let $=!1,ne=!1,xe=null,ce=null,Te=null;const Re=A.getCaps();if(_e.format=5,_e.type=0,_e.generateMipMaps=!0,_e._cachedAnisotropicFilteringLevel=null,A.updateTextureSamplingMode(3,_e),Re.textureLOD?A._features.supportRenderAndCopyToLodForFloatTextures?Re.textureHalfFloatRender&&Re.textureHalfFloatLinearFiltering?($=!0,_e.type=2):Re.textureFloatRender&&Re.textureFloatLinearFiltering&&($=!0,_e.type=1):$=!1:($=!1,ne=!0,Te={}),$)xe=new $n("rgbdDecode","rgbdDecode",null,null,1,null,3,A,!1,void 0,_e.type,void 0,null,!1),_e._isRGBD=!1,_e.invertY=!1,ce=A.createRenderTargetCubeTexture(_e.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:_e.type,format:5});else if(_e._isRGBD=!0,_e.invertY=!0,ne){const Xe=_e._lodGenerationScale,xt=_e._lodGenerationOffset;for(let qe=0;qe<3;qe++){const Nt=1-qe/2,wt=xt,Qt=(E-1)*Xe+xt,Ht=wt+(Qt-wt)*Nt,Wt=Math.round(Math.min(Math.max(Ht,0),Qt)),zt=new u0(A,Gn.Temp);zt.isCube=!0,zt.invertY=!0,zt.generateMipMaps=!1,A.updateTextureSamplingMode(2,zt);const xi=new la(null);switch(xi._isCube=!0,xi._texture=zt,Te[Wt]=xi,qe){case 0:_e._lodTextureLow=xi;break;case 1:_e._lodTextureMid=xi;break;case 2:_e._lodTextureHigh=xi;break}}}const ke=[];for(let We=0;We<p.length;We++)for(let Xe=0;Xe<6;Xe++){const xt=p[We][Xe],qe=new Blob([xt],{type:_}),ht=URL.createObjectURL(qe);let Nt;if(A._features.forceBitmapOverHTMLImageElement)Nt=A.createImageBitmap(qe,{premultiplyAlpha:"none"}).then(wt=>lC(wt,A,$,xe,ht,Xe,We,ne,Te,ce,_e));else{const wt=new Image;wt.src=ht,Nt=new Promise((Qt,Ht)=>{wt.onload=()=>{lC(wt,A,$,xe,ht,Xe,We,ne,Te,ce,_e).then(()=>Qt()).catch(Wt=>{Ht(Wt)})},wt.onerror=Wt=>{Ht(Wt)}})}ke.push(Nt)}if(p.length<E){let We;const Xe=Math.pow(2,E-1-p.length),xt=Xe*Xe*4;switch(_e.type){case 0:{We=new Uint8Array(xt);break}case 2:{We=new Uint16Array(xt);break}case 1:{We=new Float32Array(xt);break}}for(let qe=p.length;qe<E;qe++)for(let ht=0;ht<6;ht++)A._uploadArrayBufferViewToTexture(_e,We,ht,qe)}return Promise.all(ke).then(()=>{ce&&(A._releaseTexture(_e),ce._swapAndDie(_e)),xe&&xe.dispose(),ne&&(_e._lodTextureHigh&&_e._lodTextureHigh._texture&&(_e._lodTextureHigh._texture.isReady=!0),_e._lodTextureMid&&_e._lodTextureMid._texture&&(_e._lodTextureMid._texture.isReady=!0),_e._lodTextureLow&&_e._lodTextureLow._texture&&(_e._lodTextureLow._texture.isReady=!0))})}function hC(_e,p){p=wg(p);const _=p.irradiance;if(!_)return;const E=new Xu;nt.FromArrayToRef(_.x,0,E.x),nt.FromArrayToRef(_.y,0,E.y),nt.FromArrayToRef(_.z,0,E.z),nt.FromArrayToRef(_.xx,0,E.xx),nt.FromArrayToRef(_.yy,0,E.yy),nt.FromArrayToRef(_.zz,0,E.zz),nt.FromArrayToRef(_.yz,0,E.yz),nt.FromArrayToRef(_.zx,0,E.zx),nt.FromArrayToRef(_.xy,0,E.xy),_e._sphericalPolynomial=E}function YF(_e,p,_,E,A){const $=_e.getEngine().createRawCubeTexture(null,_e.width,_e.format,_e.type,_e.generateMipMaps,_e.invertY,_e.samplingMode,_e._compression),ne=Lg($,p).then(()=>_e);return _e.onRebuildCallback=xe=>({proxy:ne,isReady:!0,isAsync:!0}),_e._source=Gn.CubeRawRGBD,_e._bufferViewArrayArray=p,_e._lodGenerationScale=E,_e._lodGenerationOffset=A,_e._sphericalPolynomial=_,Lg(_e,p).then(()=>(_e.isReady=!0,_e))}const k5={GetEnvInfo:nC,CreateEnvTextureAsync:XF,CreateImageDataArrayBufferViews:aC,UploadEnvLevelsAsync:xC,UploadLevelsAsync:Lg,UploadEnvSpherical:hC};class jF{constructor(){this.supportCascades=!1}canLoad(p){return p.endsWith(".env")}loadCubeData(p,_,E,A,$){if(Array.isArray(p))return;const ne=nC(p);if(ne){_.width=ne.width,_.height=ne.width;try{hC(_,ne),xC(_,p,ne).then(()=>{_.isReady=!0,_.onLoadedObservable.notifyObservers(_),_.onLoadedObservable.clear(),A&&A()},xe=>{$?.("Can not upload environment levels",xe)})}catch(xe){$?.("Can not upload environment file",xe)}}else $&&$("Can not parse the environment file",null)}loadData(){throw".env not supported in 2d."}}ui._TextureLoaders.push(new jF);class um{get resolve(){return this._resolve}get reject(){return this._reject}constructor(){this.promise=new Promise((p,_)=>{this._resolve=p,this._reject=_})}}var kg;(function(_e){_e[_e.NONE=0]="NONE",_e[_e.STEP=1]="STEP"})(kg||(kg={}));class Yu{constructor(p,_,E){this.name=p,this.from=_,this.to=E}clone(){return new Yu(this.name,this.from,this.to)}}const qF=Object.freeze(new _s(0,0,0,0)),$F=Object.freeze(nt.Zero()),rL=Object.freeze(xr.Zero()),nL=Object.freeze(Yx.Zero()),aL=Object.freeze(ws.Black()),xL=Object.freeze(new vr(0,0,0,0)),Yl={key:0,repeatCount:0,loopMode:2};class Ui{static _PrepareAnimation(p,_,E,A,$,ne,xe,ce){let Te;if(!isNaN(parseFloat($))&&isFinite($)?Te=Ui.ANIMATIONTYPE_FLOAT:$ instanceof _s?Te=Ui.ANIMATIONTYPE_QUATERNION:$ instanceof nt?Te=Ui.ANIMATIONTYPE_VECTOR3:$ instanceof xr?Te=Ui.ANIMATIONTYPE_VECTOR2:$ instanceof ws?Te=Ui.ANIMATIONTYPE_COLOR3:$ instanceof vr?Te=Ui.ANIMATIONTYPE_COLOR4:$ instanceof Yx&&(Te=Ui.ANIMATIONTYPE_SIZE),Te==null)return null;const Re=new Ui(p,_,E,Te,xe),ke=[{frame:0,value:$},{frame:A,value:ne}];return Re.setKeys(ke),ce!==void 0&&Re.setEasingFunction(ce),Re}static CreateAnimation(p,_,E,A){const $=new Ui(p+"Animation",p,E,_,Ui.ANIMATIONLOOPMODE_CONSTANT);return $.setEasingFunction(A),$}static CreateAndStartAnimation(p,_,E,A,$,ne,xe,ce,Te,Re,ke){const We=Ui._PrepareAnimation(p,E,A,$,ne,xe,ce,Te);return!We||(_.getScene&&(ke=_.getScene()),!ke)?null:ke.beginDirectAnimation(_,[We],0,$,We.loopMode===1,1,Re)}static CreateAndStartHierarchyAnimation(p,_,E,A,$,ne,xe,ce,Te,Re,ke){const We=Ui._PrepareAnimation(p,A,$,ne,xe,ce,Te,Re);return We?_.getScene().beginDirectHierarchyAnimation(_,E,[We],0,ne,We.loopMode===1,1,ke):null}static CreateMergeAndStartAnimation(p,_,E,A,$,ne,xe,ce,Te,Re){const ke=Ui._PrepareAnimation(p,E,A,$,ne,xe,ce,Te);return ke?(_.animations.push(ke),_.getScene().beginAnimation(_,0,$,ke.loopMode===1,1,Re)):null}static MakeAnimationAdditive(p,_,E,A=!1,$){let ne;typeof _=="object"?ne=_:ne={referenceFrame:_??0,range:E,cloneOriginalAnimation:A,clonedAnimationName:$};let xe=p;if(ne.cloneOriginalAnimation&&(xe=p.clone(),xe.name=ne.clonedAnimationName||xe.name),!xe._keys.length)return xe;const ce=ne.referenceFrame&&ne.referenceFrame>=0?ne.referenceFrame:0;let Te=0;const Re=xe._keys[0];let ke=xe._keys.length-1;const We=xe._keys[ke],Xe={referenceValue:Re.value,referencePosition:pi.Vector3[0],referenceQuaternion:pi.Quaternion[0],referenceScaling:pi.Vector3[1],keyPosition:pi.Vector3[2],keyQuaternion:pi.Quaternion[1],keyScaling:pi.Vector3[3]};let xt=Re.frame,qe=We.frame;if(ne.range){const wt=xe.getRange(ne.range);wt&&(xt=wt.from,qe=wt.to)}else xt=ne.fromFrame??xt,qe=ne.toFrame??qe;if(xt!==Re.frame&&(Te=xe.createKeyForFrame(xt)),qe!==We.frame&&(ke=xe.createKeyForFrame(qe)),xe._keys.length===1){const wt=xe._getKeyValue(xe._keys[0]);Xe.referenceValue=wt.clone?wt.clone():wt}else if(ce<=Re.frame){const wt=xe._getKeyValue(Re.value);Xe.referenceValue=wt.clone?wt.clone():wt}else if(ce>=We.frame){const wt=xe._getKeyValue(We.value);Xe.referenceValue=wt.clone?wt.clone():wt}else{Yl.key=0;const wt=xe._interpolate(ce,Yl);Xe.referenceValue=wt.clone?wt.clone():wt}xe.dataType===Ui.ANIMATIONTYPE_QUATERNION?Xe.referenceValue.normalize().conjugateInPlace():xe.dataType===Ui.ANIMATIONTYPE_MATRIX&&(Xe.referenceValue.decompose(Xe.referenceScaling,Xe.referenceQuaternion,Xe.referencePosition),Xe.referenceQuaternion.normalize().conjugateInPlace());let ht=Number.MAX_VALUE;const Nt=ne.clipKeys?[]:null;for(let wt=Te;wt<=ke;wt++){let Qt=xe._keys[wt];if(Nt&&(Qt={frame:Qt.frame,value:Qt.value.clone?Qt.value.clone():Qt.value,inTangent:Qt.inTangent,outTangent:Qt.outTangent,interpolation:Qt.interpolation,lockedTangent:Qt.lockedTangent},ht===Number.MAX_VALUE&&(ht=Qt.frame),Qt.frame-=ht,Nt.push(Qt)),!(wt&&xe.dataType!==Ui.ANIMATIONTYPE_FLOAT&&Qt.value===Re.value))switch(xe.dataType){case Ui.ANIMATIONTYPE_MATRIX:Qt.value.decompose(Xe.keyScaling,Xe.keyQuaternion,Xe.keyPosition),Xe.keyPosition.subtractInPlace(Xe.referencePosition),Xe.keyScaling.divideInPlace(Xe.referenceScaling),Xe.referenceQuaternion.multiplyToRef(Xe.keyQuaternion,Xe.keyQuaternion),Yt.ComposeToRef(Xe.keyScaling,Xe.keyQuaternion,Xe.keyPosition,Qt.value);break;case Ui.ANIMATIONTYPE_QUATERNION:Xe.referenceValue.multiplyToRef(Qt.value,Qt.value);break;case Ui.ANIMATIONTYPE_VECTOR2:case Ui.ANIMATIONTYPE_VECTOR3:case Ui.ANIMATIONTYPE_COLOR3:case Ui.ANIMATIONTYPE_COLOR4:Qt.value.subtractToRef(Xe.referenceValue,Qt.value);break;case Ui.ANIMATIONTYPE_SIZE:Qt.value.width-=Xe.referenceValue.width,Qt.value.height-=Xe.referenceValue.height;break;default:Qt.value-=Xe.referenceValue}}return Nt&&xe.setKeys(Nt,!0),xe}static TransitionTo(p,_,E,A,$,ne,xe,ce=null){if(xe<=0)return E[p]=_,ce&&ce(),null;const Te=$*(xe/1e3);ne.setKeys([{frame:0,value:E[p].clone?E[p].clone():E[p]},{frame:Te,value:_}]),E.animations||(E.animations=[]),E.animations.push(ne);const Re=A.beginAnimation(E,0,Te,!1);return Re.onAnimationEnd=ce,Re}get runtimeAnimations(){return this._runtimeAnimations}get hasRunningRuntimeAnimations(){for(const p of this._runtimeAnimations)if(!p.isStopped())return!0;return!1}constructor(p,_,E,A,$,ne){this.name=p,this.targetProperty=_,this.framePerSecond=E,this.dataType=A,this.loopMode=$,this.enableBlending=ne,this._easingFunction=null,this._runtimeAnimations=new Array,this._events=new Array,this.blendingSpeed=.01,this._ranges={},this.targetPropertyPath=_.split("."),this.dataType=A,this.loopMode=$===void 0?Ui.ANIMATIONLOOPMODE_CYCLE:$,this.uniqueId=Ui._UniqueIdGenerator++}toString(p){let _="Name: "+this.name+", property: "+this.targetProperty;if(_+=", datatype: "+["Float","Vector3","Quaternion","Matrix","Color3","Vector2"][this.dataType],_+=", nKeys: "+(this._keys?this._keys.length:"none"),_+=", nRanges: "+(this._ranges?Object.keys(this._ranges).length:"none"),p){_+=", Ranges: {";let E=!0;for(const A in this._ranges)E&&(_+=", ",E=!1),_+=A;_+="}"}return _}addEvent(p){this._events.push(p),this._events.sort((_,E)=>_.frame-E.frame)}removeEvents(p){for(let _=0;_<this._events.length;_++)this._events[_].frame===p&&(this._events.splice(_,1),_--)}getEvents(){return this._events}createRange(p,_,E){this._ranges[p]||(this._ranges[p]=new Yu(p,_,E))}deleteRange(p,_=!0){const E=this._ranges[p];if(E){if(_){const A=E.from,$=E.to;for(let ne=this._keys.length-1;ne>=0;ne--)this._keys[ne].frame>=A&&this._keys[ne].frame<=$&&this._keys.splice(ne,1)}this._ranges[p]=null}}getRange(p){return this._ranges[p]}getKeys(){return this._keys}getHighestFrame(){let p=0;for(let _=0,E=this._keys.length;_<E;_++)p<this._keys[_].frame&&(p=this._keys[_].frame);return p}getEasingFunction(){return this._easingFunction}setEasingFunction(p){this._easingFunction=p}floatInterpolateFunction(p,_,E){return ri.Lerp(p,_,E)}floatInterpolateFunctionWithTangents(p,_,E,A,$){return ri.Hermite(p,_,E,A,$)}quaternionInterpolateFunction(p,_,E){return _s.Slerp(p,_,E)}quaternionInterpolateFunctionWithTangents(p,_,E,A,$){return _s.Hermite(p,_,E,A,$).normalize()}vector3InterpolateFunction(p,_,E){return nt.Lerp(p,_,E)}vector3InterpolateFunctionWithTangents(p,_,E,A,$){return nt.Hermite(p,_,E,A,$)}vector2InterpolateFunction(p,_,E){return xr.Lerp(p,_,E)}vector2InterpolateFunctionWithTangents(p,_,E,A,$){return xr.Hermite(p,_,E,A,$)}sizeInterpolateFunction(p,_,E){return Yx.Lerp(p,_,E)}color3InterpolateFunction(p,_,E){return ws.Lerp(p,_,E)}color3InterpolateFunctionWithTangents(p,_,E,A,$){return ws.Hermite(p,_,E,A,$)}color4InterpolateFunction(p,_,E){return vr.Lerp(p,_,E)}color4InterpolateFunctionWithTangents(p,_,E,A,$){return vr.Hermite(p,_,E,A,$)}_getKeyValue(p){return typeof p=="function"?p():p}evaluate(p){return Yl.key=0,this._interpolate(p,Yl)}_interpolate(p,_,E=!1){if(_.loopMode===Ui.ANIMATIONLOOPMODE_CONSTANT&&_.repeatCount>0)return _.highLimitValue.clone?_.highLimitValue.clone():_.highLimitValue;const A=this._keys,$=A.length;let ne=_.key;for(;ne>=0&&p<A[ne].frame;)--ne;for(;ne+1<=$-1&&p>=A[ne+1].frame;)++ne;if(_.key=ne,ne<0)return E?void 0:this._getKeyValue(A[0].value);if(ne+1>$-1)return E?void 0:this._getKeyValue(A[$-1].value);const xe=A[ne],ce=A[ne+1];if(E&&(p===xe.frame||p===ce.frame))return;const Te=this._getKeyValue(xe.value),Re=this._getKeyValue(ce.value);if(xe.interpolation===kg.STEP)return ce.frame>p?Te:Re;const ke=xe.outTangent!==void 0&&ce.inTangent!==void 0,We=ce.frame-xe.frame;let Xe=(p-xe.frame)/We;const xt=xe.easingFunction||this.getEasingFunction();switch(xt!==null&&(Xe=xt.ease(Xe)),this.dataType){case Ui.ANIMATIONTYPE_FLOAT:{const qe=ke?this.floatInterpolateFunctionWithTangents(Te,xe.outTangent*We,Re,ce.inTangent*We,Xe):this.floatInterpolateFunction(Te,Re,Xe);switch(_.loopMode){case Ui.ANIMATIONLOOPMODE_CYCLE:case Ui.ANIMATIONLOOPMODE_CONSTANT:case Ui.ANIMATIONLOOPMODE_YOYO:return qe;case Ui.ANIMATIONLOOPMODE_RELATIVE:case Ui.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return(_.offsetValue??0)*_.repeatCount+qe}break}case Ui.ANIMATIONTYPE_QUATERNION:{const qe=ke?this.quaternionInterpolateFunctionWithTangents(Te,xe.outTangent.scale(We),Re,ce.inTangent.scale(We),Xe):this.quaternionInterpolateFunction(Te,Re,Xe);switch(_.loopMode){case Ui.ANIMATIONLOOPMODE_CYCLE:case Ui.ANIMATIONLOOPMODE_CONSTANT:case Ui.ANIMATIONLOOPMODE_YOYO:return qe;case Ui.ANIMATIONLOOPMODE_RELATIVE:case Ui.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return qe.addInPlace((_.offsetValue||qF).scale(_.repeatCount))}return qe}case Ui.ANIMATIONTYPE_VECTOR3:{const qe=ke?this.vector3InterpolateFunctionWithTangents(Te,xe.outTangent.scale(We),Re,ce.inTangent.scale(We),Xe):this.vector3InterpolateFunction(Te,Re,Xe);switch(_.loopMode){case Ui.ANIMATIONLOOPMODE_CYCLE:case Ui.ANIMATIONLOOPMODE_CONSTANT:case Ui.ANIMATIONLOOPMODE_YOYO:return qe;case Ui.ANIMATIONLOOPMODE_RELATIVE:case Ui.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return qe.add((_.offsetValue||$F).scale(_.repeatCount))}break}case Ui.ANIMATIONTYPE_VECTOR2:{const qe=ke?this.vector2InterpolateFunctionWithTangents(Te,xe.outTangent.scale(We),Re,ce.inTangent.scale(We),Xe):this.vector2InterpolateFunction(Te,Re,Xe);switch(_.loopMode){case Ui.ANIMATIONLOOPMODE_CYCLE:case Ui.ANIMATIONLOOPMODE_CONSTANT:case Ui.ANIMATIONLOOPMODE_YOYO:return qe;case Ui.ANIMATIONLOOPMODE_RELATIVE:case Ui.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return qe.add((_.offsetValue||rL).scale(_.repeatCount))}break}case Ui.ANIMATIONTYPE_SIZE:{switch(_.loopMode){case Ui.ANIMATIONLOOPMODE_CYCLE:case Ui.ANIMATIONLOOPMODE_CONSTANT:case Ui.ANIMATIONLOOPMODE_YOYO:return this.sizeInterpolateFunction(Te,Re,Xe);case Ui.ANIMATIONLOOPMODE_RELATIVE:case Ui.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return this.sizeInterpolateFunction(Te,Re,Xe).add((_.offsetValue||nL).scale(_.repeatCount))}break}case Ui.ANIMATIONTYPE_COLOR3:{const qe=ke?this.color3InterpolateFunctionWithTangents(Te,xe.outTangent.scale(We),Re,ce.inTangent.scale(We),Xe):this.color3InterpolateFunction(Te,Re,Xe);switch(_.loopMode){case Ui.ANIMATIONLOOPMODE_CYCLE:case Ui.ANIMATIONLOOPMODE_CONSTANT:case Ui.ANIMATIONLOOPMODE_YOYO:return qe;case Ui.ANIMATIONLOOPMODE_RELATIVE:case Ui.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return qe.add((_.offsetValue||aL).scale(_.repeatCount))}break}case Ui.ANIMATIONTYPE_COLOR4:{const qe=ke?this.color4InterpolateFunctionWithTangents(Te,xe.outTangent.scale(We),Re,ce.inTangent.scale(We),Xe):this.color4InterpolateFunction(Te,Re,Xe);switch(_.loopMode){case Ui.ANIMATIONLOOPMODE_CYCLE:case Ui.ANIMATIONLOOPMODE_CONSTANT:case Ui.ANIMATIONLOOPMODE_YOYO:return qe;case Ui.ANIMATIONLOOPMODE_RELATIVE:case Ui.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return qe.add((_.offsetValue||xL).scale(_.repeatCount))}break}case Ui.ANIMATIONTYPE_MATRIX:{switch(_.loopMode){case Ui.ANIMATIONLOOPMODE_CYCLE:case Ui.ANIMATIONLOOPMODE_CONSTANT:case Ui.ANIMATIONLOOPMODE_YOYO:return Ui.AllowMatricesInterpolation?this.matrixInterpolateFunction(Te,Re,Xe,_.workValue):Te;case Ui.ANIMATIONLOOPMODE_RELATIVE:case Ui.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return Te}break}}return 0}matrixInterpolateFunction(p,_,E,A){return Ui.AllowMatrixDecomposeForInterpolation?A?(Yt.DecomposeLerpToRef(p,_,E,A),A):Yt.DecomposeLerp(p,_,E):A?(Yt.LerpToRef(p,_,E,A),A):Yt.Lerp(p,_,E)}clone(){const p=new Ui(this.name,this.targetPropertyPath.join("."),this.framePerSecond,this.dataType,this.loopMode);if(p.enableBlending=this.enableBlending,p.blendingSpeed=this.blendingSpeed,this._keys&&p.setKeys(this._keys),this._ranges){p._ranges={};for(const _ in this._ranges){const E=this._ranges[_];E&&(p._ranges[_]=E.clone())}}return p}setKeys(p,_=!1){this._keys=_?p:p.slice(0)}createKeyForFrame(p){Yl.key=0;const _=this._interpolate(p,Yl,!0);if(!_)return this._keys[Yl.key].frame===p?Yl.key:Yl.key+1;const E={frame:p,value:_.clone?_.clone():_};return this._keys.splice(Yl.key+1,0,E),Yl.key+1}serialize(){const p={};p.name=this.name,p.property=this.targetProperty,p.framePerSecond=this.framePerSecond,p.dataType=this.dataType,p.loopBehavior=this.loopMode,p.enableBlending=this.enableBlending,p.blendingSpeed=this.blendingSpeed;const _=this.dataType;p.keys=[];const E=this.getKeys();for(let A=0;A<E.length;A++){const $=E[A],ne={};switch(ne.frame=$.frame,_){case Ui.ANIMATIONTYPE_FLOAT:ne.values=[$.value],$.inTangent!==void 0&&ne.values.push($.inTangent),$.outTangent!==void 0&&($.inTangent===void 0&&ne.values.push(void 0),ne.values.push($.outTangent)),$.interpolation!==void 0&&($.inTangent===void 0&&ne.values.push(void 0),$.outTangent===void 0&&ne.values.push(void 0),ne.values.push($.interpolation));break;case Ui.ANIMATIONTYPE_QUATERNION:case Ui.ANIMATIONTYPE_MATRIX:case Ui.ANIMATIONTYPE_VECTOR3:case Ui.ANIMATIONTYPE_COLOR3:case Ui.ANIMATIONTYPE_COLOR4:ne.values=$.value.asArray(),$.inTangent!=null&&ne.values.push($.inTangent.asArray()),$.outTangent!=null&&($.inTangent===void 0&&ne.values.push(void 0),ne.values.push($.outTangent.asArray())),$.interpolation!==void 0&&($.inTangent===void 0&&ne.values.push(void 0),$.outTangent===void 0&&ne.values.push(void 0),ne.values.push($.interpolation));break}p.keys.push(ne)}p.ranges=[];for(const A in this._ranges){const $=this._ranges[A];if(!$)continue;const ne={};ne.name=A,ne.from=$.from,ne.to=$.to,p.ranges.push(ne)}return p}static _UniversalLerp(p,_,E){const A=p.constructor;return A.Lerp?A.Lerp(p,_,E):A.Slerp?A.Slerp(p,_,E):p.toFixed?p*(1-E)+E*_:_}static Parse(p){const _=new Ui(p.name,p.property,p.framePerSecond,p.dataType,p.loopBehavior),E=p.dataType,A=[];let $,ne;for(p.enableBlending&&(_.enableBlending=p.enableBlending),p.blendingSpeed&&(_.blendingSpeed=p.blendingSpeed),ne=0;ne<p.keys.length;ne++){const xe=p.keys[ne];let ce,Te,Re;switch(E){case Ui.ANIMATIONTYPE_FLOAT:$=xe.values[0],xe.values.length>=2&&(ce=xe.values[1]),xe.values.length>=3&&(Te=xe.values[2]),xe.values.length>=4&&(Re=xe.values[3]);break;case Ui.ANIMATIONTYPE_QUATERNION:if($=_s.FromArray(xe.values),xe.values.length>=8){const We=_s.FromArray(xe.values.slice(4,8));We.equals(_s.Zero())||(ce=We)}if(xe.values.length>=12){const We=_s.FromArray(xe.values.slice(8,12));We.equals(_s.Zero())||(Te=We)}xe.values.length>=13&&(Re=xe.values[12]);break;case Ui.ANIMATIONTYPE_MATRIX:$=Yt.FromArray(xe.values),xe.values.length>=17&&(Re=xe.values[16]);break;case Ui.ANIMATIONTYPE_COLOR3:$=ws.FromArray(xe.values),xe.values[3]&&(ce=ws.FromArray(xe.values[3])),xe.values[4]&&(Te=ws.FromArray(xe.values[4])),xe.values[5]&&(Re=xe.values[5]);break;case Ui.ANIMATIONTYPE_COLOR4:$=vr.FromArray(xe.values),xe.values[4]&&(ce=vr.FromArray(xe.values[4])),xe.values[5]&&(Te=vr.FromArray(xe.values[5])),xe.values[6]&&(Re=vr.FromArray(xe.values[6]));break;case Ui.ANIMATIONTYPE_VECTOR3:default:$=nt.FromArray(xe.values),xe.values[3]&&(ce=nt.FromArray(xe.values[3])),xe.values[4]&&(Te=nt.FromArray(xe.values[4])),xe.values[5]&&(Re=xe.values[5]);break}const ke={};ke.frame=xe.frame,ke.value=$,ce!=null&&(ke.inTangent=ce),Te!=null&&(ke.outTangent=Te),Re!=null&&(ke.interpolation=Re),A.push(ke)}if(_.setKeys(A),p.ranges)for(ne=0;ne<p.ranges.length;ne++)$=p.ranges[ne],_.createRange($.name,$.from,$.to);return _}static AppendSerializedAnimations(p,_){Xr.AppendSerializedAnimations(p,_)}static ParseFromFileAsync(p,_){return new Promise((E,A)=>{const $=new za;$.addEventListener("readystatechange",()=>{if($.readyState==4)if($.status==200){let ne=JSON.parse($.responseText);if(ne.animations&&(ne=ne.animations),ne.length){const xe=[];for(const ce of ne)xe.push(this.Parse(ce));E(xe)}else{const xe=this.Parse(ne);p&&(xe.name=p),E(xe)}}else A("Unable to load the animation")}),$.open("GET",_),$.send()})}static ParseFromSnippetAsync(p){return new Promise((_,E)=>{const A=new za;A.addEventListener("readystatechange",()=>{if(A.readyState==4)if(A.status==200){const $=JSON.parse(JSON.parse(A.responseText).jsonPayload);if($.animations){const ne=JSON.parse($.animations),xe=[];for(const ce of ne.animations){const Te=this.Parse(ce);Te.snippetId=p,xe.push(Te)}_(xe)}else{const ne=JSON.parse($.animation),xe=this.Parse(ne);xe.snippetId=p,_(xe)}}else E("Unable to load the snippet "+p)}),A.open("GET",this.SnippetUrl+"/"+p.replace(/#/g,"/")),A.send()})}}Ui._UniqueIdGenerator=0,Ui.AllowMatricesInterpolation=!1,Ui.AllowMatrixDecomposeForInterpolation=!0,Ui.SnippetUrl="https://snippet.babylonjs.com",Ui.ANIMATIONTYPE_FLOAT=0,Ui.ANIMATIONTYPE_VECTOR3=1,Ui.ANIMATIONTYPE_QUATERNION=2,Ui.ANIMATIONTYPE_MATRIX=3,Ui.ANIMATIONTYPE_COLOR3=4,Ui.ANIMATIONTYPE_COLOR4=7,Ui.ANIMATIONTYPE_VECTOR2=5,Ui.ANIMATIONTYPE_SIZE=6,Ui.ANIMATIONLOOPMODE_RELATIVE=0,Ui.ANIMATIONLOOPMODE_CYCLE=1,Ui.ANIMATIONLOOPMODE_CONSTANT=2,Ui.ANIMATIONLOOPMODE_YOYO=4,Ui.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT=5,Ui.CreateFromSnippetAsync=Ui.ParseFromSnippetAsync,zs("BABYLON.Animation",Ui),Ka._AnimationRangeFactory=(_e,p,_)=>new Yu(_e,p,_);class lL{getClassName(){return"TargetedAnimation"}serialize(){const p={};return p.animation=this.animation.serialize(),p.targetId=this.target.id,p}}class uh{syncWithMask(){if(!this.mask){this._numActiveAnimatables=this._targetedAnimations.length;return}this._numActiveAnimatables=0;for(let p=0;p<this._animatables.length;++p){const _=this._animatables[p];this.mask.disabled||this.mask.retainsTarget(_.target.name)?(this._numActiveAnimatables++,_.paused&&_.restart()):_.paused||_.pause()}}removeUnmaskedAnimations(){if(!(!this.mask||this.mask.disabled)){for(let p=0;p<this._animatables.length;++p){const _=this._animatables[p];this.mask.retainsTarget(_.target.name)||(_.stop(),this._animatables.splice(p,1),--p)}for(let p=0;p<this._targetedAnimations.length;p++){const _=this._targetedAnimations[p];this.mask.retainsTarget(_.target.name)||(this._targetedAnimations.splice(p,1),--p)}}}get from(){return this._from}get to(){return this._to}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(p){if(this._speedRatio!==p){this._speedRatio=p;for(let _=0;_<this._animatables.length;_++){const E=this._animatables[_];E.speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(p){if(this._loopAnimation!==p){this._loopAnimation=p;for(let _=0;_<this._animatables.length;_++){const E=this._animatables[_];E.loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(p){if(this._isAdditive!==p){this._isAdditive=p;for(let _=0;_<this._animatables.length;_++){const E=this._animatables[_];E.isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(p){this._weight!==p&&(this._weight=p,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(p){if(this._playOrder!==p&&(this._playOrder=p,this._animatables.length>0)){for(let _=0;_<this._animatables.length;_++)this._animatables[_].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(p){if(this._enableBlending!==p&&(this._enableBlending=p,p!==null))for(let _=0;_<this._targetedAnimations.length;++_)this._targetedAnimations[_].animation.enableBlending=p}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(p){if(this._blendingSpeed!==p&&(this._blendingSpeed=p,p!==null))for(let _=0;_<this._targetedAnimations.length;++_)this._targetedAnimations[_].animation.blendingSpeed=p}getLength(p,_){p=p??this._from,_=_??this._to;const E=this.targetedAnimations[0].animation.framePerSecond*this._speedRatio;return(_-p)/E}static MergeAnimationGroups(p,_=!0,E=!1,A){if(p.length===0)return null;A=A??p[0].weight;let $=Number.MAX_VALUE,ne=-Number.MAX_VALUE;if(E)for(const ce of p)ce.from<$&&($=ce.from),ce.to>ne&&(ne=ce.to);const xe=new uh(p[0].name+"_merged",p[0]._scene,A);for(const ce of p){E&&ce.normalize($,ne);for(const Te of ce.targetedAnimations)xe.addTargetedAnimation(Te.animation,Te.target);_&&ce.dispose()}return xe}constructor(p,_=null,E=-1,A=0){this.name=p,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._parentContainer=null,this.onAnimationEndObservable=new Mi,this.onAnimationLoopObservable=new Mi,this.onAnimationGroupLoopObservable=new Mi,this.onAnimationGroupEndObservable=new Mi,this.onAnimationGroupPauseObservable=new Mi,this.onAnimationGroupPlayObservable=new Mi,this.metadata=null,this._animationLoopFlags=[],this._scene=_||wr.LastCreatedScene,this._weight=E,this._playOrder=A,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(p,_){const E=new lL;E.animation=p,E.target=_;const A=p.getKeys();return this._from>A[0].frame&&(this._from=A[0].frame),this._to<A[A.length-1].frame&&(this._to=A[A.length-1].frame),this._enableBlending!==null&&(p.enableBlending=this._enableBlending),this._blendingSpeed!==null&&(p.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(E),E}removeTargetedAnimation(p){for(let _=this._targetedAnimations.length-1;_>-1;_--)this._targetedAnimations[_].animation===p&&this._targetedAnimations.splice(_,1)}normalize(p=null,_=null){p==null&&(p=this._from),_==null&&(_=this._to);for(let E=0;E<this._targetedAnimations.length;E++){const $=this._targetedAnimations[E].animation.getKeys(),ne=$[0],xe=$[$.length-1];if(ne.frame>p){const ce={frame:p,value:ne.value,inTangent:ne.inTangent,outTangent:ne.outTangent,interpolation:ne.interpolation};$.splice(0,0,ce)}if(xe.frame<_){const ce={frame:_,value:xe.value,inTangent:xe.inTangent,outTangent:xe.outTangent,interpolation:xe.interpolation};$.push(ce)}}return this._from=p,this._to=_,this}_processLoop(p,_,E){p.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(_),!this._animationLoopFlags[E]&&(this._animationLoopFlags[E]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(p=!1,_=1,E,A,$){if(this._isStarted||this._targetedAnimations.length===0)return this;this._loopAnimation=p,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let ne=0;ne<this._targetedAnimations.length;ne++){const xe=this._targetedAnimations[ne],ce=this._scene.beginDirectAnimation(xe.target,[xe.animation],E!==void 0?E:this._from,A!==void 0?A:this._to,p,_,void 0,void 0,$!==void 0?$:this._isAdditive);ce.weight=this._weight,ce.playOrder=this._playOrder,ce.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(xe),this._checkAnimationGroupEnded(ce)},this._processLoop(ce,xe,ne),this._animatables.push(ce)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=_,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let p=0;p<this._animatables.length;p++)this._animatables[p].pause();return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(p){return this.isStarted&&this._animatables.length===this._targetedAnimations.length?(p!==void 0&&(this.loopAnimation=p),this.restart()):(this.stop(),this.start(p,this._speedRatio)),this._isPaused=!1,this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(),this;for(let p=0;p<this._animatables.length;p++)this._animatables[p].reset();return this}restart(){if(!this._isStarted)return this;for(let p=0;p<this._animatables.length;p++)this._animatables[p].restart();return this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){if(!this._isStarted)return this;const p=this._animatables.slice();for(let E=0;E<p.length;E++)p[E].stop(void 0,void 0,!0);let _=0;for(let E=0;E<this._scene._activeAnimatables.length;E++){const A=this._scene._activeAnimatables[E];A._runtimeAnimations.length>0&&(this._scene._activeAnimatables[_++]=A)}return this._scene._activeAnimatables.length=_,this._isStarted=!1,this}setWeightForAllAnimatables(p){for(let _=0;_<this._animatables.length;_++){const E=this._animatables[_];E.weight=p}return this}syncAllAnimationsWith(p){for(let _=0;_<this._animatables.length;_++)this._animatables[_].syncWith(p);return this}goToFrame(p){if(!this._isStarted)return this;for(let _=0;_<this._animatables.length;_++)this._animatables[_].goToFrame(p);return this}dispose(){this._targetedAnimations.length=0,this._animatables.length=0;const p=this._scene.animationGroups.indexOf(this);if(p>-1&&this._scene.animationGroups.splice(p,1),this._parentContainer){const _=this._parentContainer.animationGroups.indexOf(this);_>-1&&this._parentContainer.animationGroups.splice(_,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(p){const _=this._animatables.indexOf(p);_>-1&&this._animatables.splice(_,1),this._animatables.length===0&&(this._isStarted=!1,this.onAnimationGroupEndObservable.notifyObservers(this))}clone(p,_,E=!1){const A=new uh(p||this.name,this._scene,this._weight,this._playOrder);A._from=this.from,A._to=this.to,A._speedRatio=this.speedRatio,A._loopAnimation=this.loopAnimation,A._isAdditive=this.isAdditive,A._enableBlending=this.enableBlending,A._blendingSpeed=this.blendingSpeed,A.metadata=this.metadata,A.mask=this.mask;for(const $ of this._targetedAnimations)A.addTargetedAnimation(E?$.animation.clone():$.animation,_?_($.target):$.target);return A}serialize(){const p={};p.name=this.name,p.from=this.from,p.to=this.to,p.speedRatio=this.speedRatio,p.loopAnimation=this.loopAnimation,p.isAdditive=this.isAdditive,p.weight=this.weight,p.playOrder=this.playOrder,p.enableBlending=this.enableBlending,p.blendingSpeed=this.blendingSpeed,p.targetedAnimations=[];for(let _=0;_<this.targetedAnimations.length;_++){const E=this.targetedAnimations[_];p.targetedAnimations[_]=E.serialize()}return ni&&ni.HasTags(this)&&(p.tags=ni.GetTags(this)),this.metadata&&(p.metadata=this.metadata),p}static Parse(p,_){const E=new uh(p.name,_,p.weight,p.playOrder);for(let A=0;A<p.targetedAnimations.length;A++){const $=p.targetedAnimations[A],ne=Ui.Parse($.animation),xe=$.targetId;if($.animation.property==="influence"){const ce=_.getMorphTargetById(xe);ce&&E.addTargetedAnimation(ne,ce)}else{const ce=_.getNodeById(xe);ce!=null&&E.addTargetedAnimation(ne,ce)}}return ni&&ni.AddTagsTo(E,p.tags),p.from!==null&&p.to!==null&&E.normalize(p.from,p.to),p.speedRatio!==void 0&&(E._speedRatio=p.speedRatio),p.loopAnimation!==void 0&&(E._loopAnimation=p.loopAnimation),p.isAdditive!==void 0&&(E._isAdditive=p.isAdditive),p.weight!==void 0&&(E._weight=p.weight),p.playOrder!==void 0&&(E._playOrder=p.playOrder),p.enableBlending!==void 0&&(E._enableBlending=p.enableBlending),p.blendingSpeed!==void 0&&(E._blendingSpeed=p.blendingSpeed),p.metadata!==void 0&&(E.metadata=p.metadata),E}static MakeAnimationAdditive(p,_,E,A=!1,$){let ne;typeof _=="object"?ne=_:ne={referenceFrame:_,range:E,cloneOriginalAnimationGroup:A,clonedAnimationName:$};let xe=p;ne.cloneOriginalAnimationGroup&&(xe=p.clone(ne.clonedAnimationGroupName||xe.name));const ce=xe.targetedAnimations;for(let Te=0;Te<ce.length;Te++){const Re=ce[Te];Re.animation=Ui.MakeAnimationAdditive(Re.animation,ne)}if(xe.isAdditive=!0,ne.clipKeys){let Te=Number.MAX_VALUE,Re=-Number.MAX_VALUE;const ke=xe.targetedAnimations;for(let We=0;We<ke.length;We++){const qe=ke[We].animation.getKeys();Te>qe[0].frame&&(Te=qe[0].frame),Re<qe[qe.length-1].frame&&(Re=qe[qe.length-1].frame)}xe._from=Te,xe._to=Re}return xe}static ClipKeys(p,_,E,A,$){const ne=p.clone(A||p.name);return uh.ClipKeysInPlace(ne,_,E,$)}static ClipKeysInPlace(p,_,E,A){return uh.ClipInPlace(p,_,E,A,!1)}static ClipFrames(p,_,E,A,$){const ne=p.clone(A||p.name);return uh.ClipFramesInPlace(ne,_,E,$)}static ClipFramesInPlace(p,_,E,A){return uh.ClipInPlace(p,_,E,A,!0)}static ClipInPlace(p,_,E,A,$=!1){let ne=Number.MAX_VALUE,xe=-Number.MAX_VALUE;const ce=p.targetedAnimations;for(let Te=0;Te<ce.length;Te++){const Re=ce[Te],ke=A?Re.animation:Re.animation.clone();$&&(ke.createKeyForFrame(_),ke.createKeyForFrame(E));const We=ke.getKeys(),Xe=[];let xt=Number.MAX_VALUE;for(let qe=0;qe<We.length;qe++){const ht=We[qe];if(!$&&qe>=_&&qe<=E||$&&ht.frame>=_&&ht.frame<=E){const Nt={frame:ht.frame,value:ht.value.clone?ht.value.clone():ht.value,inTangent:ht.inTangent,outTangent:ht.outTangent,interpolation:ht.interpolation,lockedTangent:ht.lockedTangent};xt===Number.MAX_VALUE&&(xt=Nt.frame),Nt.frame-=xt,Xe.push(Nt)}}if(Xe.length===0){ce.splice(Te,1),Te--;continue}ne>Xe[0].frame&&(ne=Xe[0].frame),xe<Xe[Xe.length-1].frame&&(xe=Xe[Xe.length-1].frame),ke.setKeys(Xe,!0),Re.animation=ke}return p._from=ne,p._to=xe,p}getClassName(){return"AnimationGroup"}toString(p){let _="Name: "+this.name;return _+=", type: "+this.getClassName(),p&&(_+=", from: "+this._from,_+=", to: "+this._to,_+=", isStarted: "+this._isStarted,_+=", speedRatio: "+this._speedRatio,_+=", targetedAnimations length: "+this._targetedAnimations.length,_+=", animatables length: "+this._animatables),_}}class pa extends Ka{get _matrix(){return this._compose(),this._localMatrix}set _matrix(p){p.updateFlag===this._localMatrix.updateFlag&&!this._needToCompose||(this._needToCompose=!1,this._localMatrix.copyFrom(p),this._markAsDirtyAndDecompose())}constructor(p,_,E=null,A=null,$=null,ne=null,xe=null){super(p,_.getScene()),this.name=p,this.children=[],this.animations=[],this._index=null,this._scalingDeterminant=1,this._needToDecompose=!0,this._needToCompose=!1,this._linkedTransformNode=null,this._waitingTransformNodeId=null,this._skeleton=_,this._localMatrix=A?.clone()??Yt.Identity(),this._restMatrix=$??this._localMatrix.clone(),this._bindMatrix=ne??this._localMatrix.clone(),this._index=xe,this._absoluteMatrix=new Yt,this._absoluteBindMatrix=new Yt,this._absoluteInverseBindMatrix=new Yt,this._finalMatrix=new Yt,_.bones.push(this),this.setParent(E,!1),this._updateAbsoluteBindMatrices()}getClassName(){return"Bone"}getSkeleton(){return this._skeleton}get parent(){return this._parentNode}getParent(){return this.parent}getChildren(){return this.children}getIndex(){return this._index===null?this.getSkeleton().bones.indexOf(this):this._index}set parent(p){this.setParent(p)}setParent(p,_=!0){if(this.parent!==p){if(this.parent){const E=this.parent.children.indexOf(this);E!==-1&&this.parent.children.splice(E,1)}this._parentNode=p,this.parent&&this.parent.children.push(this),_&&this._updateAbsoluteBindMatrices(),this.markAsDirty()}}getLocalMatrix(){return this._compose(),this._localMatrix}getBindMatrix(){return this._bindMatrix}getBaseMatrix(){return this.getBindMatrix()}getRestMatrix(){return this._restMatrix}getRestPose(){return this.getRestMatrix()}setRestMatrix(p){this._restMatrix.copyFrom(p)}setRestPose(p){this.setRestMatrix(p)}getBindPose(){return this.getBindMatrix()}setBindMatrix(p){this.updateMatrix(p)}setBindPose(p){this.setBindMatrix(p)}getFinalMatrix(){return this._finalMatrix}getWorldMatrix(){return this.getFinalMatrix()}returnToRest(){if(this._linkedTransformNode){const p=pi.Vector3[0],_=pi.Quaternion[0],E=pi.Vector3[1];this.getRestMatrix().decompose(p,_,E),this._linkedTransformNode.position.copyFrom(E),this._linkedTransformNode.rotationQuaternion=this._linkedTransformNode.rotationQuaternion??_s.Identity(),this._linkedTransformNode.rotationQuaternion.copyFrom(_),this._linkedTransformNode.scaling.copyFrom(p)}else this._matrix=this._restMatrix}getAbsoluteInverseBindMatrix(){return this._absoluteInverseBindMatrix}getInvertedAbsoluteTransform(){return this.getAbsoluteInverseBindMatrix()}getAbsoluteMatrix(){return this._absoluteMatrix}getAbsoluteTransform(){return this._absoluteMatrix}linkTransformNode(p){this._linkedTransformNode&&this._skeleton._numBonesWithLinkedTransformNode--,this._linkedTransformNode=p,this._linkedTransformNode&&this._skeleton._numBonesWithLinkedTransformNode++}getTransformNode(){return this._linkedTransformNode}get position(){return this._decompose(),this._localPosition}set position(p){this._decompose(),this._localPosition.copyFrom(p),this._markAsDirtyAndCompose()}get rotation(){return this.getRotation()}set rotation(p){this.setRotation(p)}get rotationQuaternion(){return this._decompose(),this._localRotation}set rotationQuaternion(p){this.setRotationQuaternion(p)}get scaling(){return this.getScale()}set scaling(p){this.setScale(p)}get animationPropertiesOverride(){return this._skeleton.animationPropertiesOverride}_decompose(){this._needToDecompose&&(this._needToDecompose=!1,this._localScaling||(this._localScaling=nt.Zero(),this._localRotation=_s.Zero(),this._localPosition=nt.Zero()),this._localMatrix.decompose(this._localScaling,this._localRotation,this._localPosition))}_compose(){if(this._needToCompose){if(!this._localScaling){this._needToCompose=!1;return}this._needToCompose=!1,Yt.ComposeToRef(this._localScaling,this._localRotation,this._localPosition,this._localMatrix)}}updateMatrix(p,_=!0,E=!0){this._bindMatrix.copyFrom(p),_&&this._updateAbsoluteBindMatrices(),E?this._matrix=p:this.markAsDirty()}_updateAbsoluteBindMatrices(p,_=!0){if(p||(p=this._bindMatrix),this.parent?p.multiplyToRef(this.parent._absoluteBindMatrix,this._absoluteBindMatrix):this._absoluteBindMatrix.copyFrom(p),this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix),_)for(let E=0;E<this.children.length;E++)this.children[E]._updateAbsoluteBindMatrices();this._scalingDeterminant=this._absoluteBindMatrix.determinant()<0?-1:1}markAsDirty(){return this._currentRenderId++,this._childUpdateId++,this._skeleton._markAsDirty(),this}_markAsDirtyAndCompose(){this.markAsDirty(),this._needToCompose=!0}_markAsDirtyAndDecompose(){this.markAsDirty(),this._needToDecompose=!0}_updatePosition(p,_=Xn.LOCAL,E,A=!0){const $=this.getLocalMatrix();if(_==Xn.LOCAL)A?($.addAtIndex(12,p.x),$.addAtIndex(13,p.y),$.addAtIndex(14,p.z)):$.setTranslationFromFloats(p.x,p.y,p.z);else{let ne=null;E&&(ne=E.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const xe=pa._TmpMats[0],ce=pa._TmpVecs[0];this.parent?E&&ne?(xe.copyFrom(this.parent.getAbsoluteMatrix()),xe.multiplyToRef(ne,xe)):xe.copyFrom(this.parent.getAbsoluteMatrix()):Yt.IdentityToRef(xe),A&&xe.setTranslationFromFloats(0,0,0),xe.invert(),nt.TransformCoordinatesToRef(p,xe,ce),A?($.addAtIndex(12,ce.x),$.addAtIndex(13,ce.y),$.addAtIndex(14,ce.z)):$.setTranslationFromFloats(ce.x,ce.y,ce.z)}this._markAsDirtyAndDecompose()}translate(p,_=Xn.LOCAL,E){this._updatePosition(p,_,E,!0)}setPosition(p,_=Xn.LOCAL,E){this._updatePosition(p,_,E,!1)}setAbsolutePosition(p,_){this.setPosition(p,Xn.WORLD,_)}scale(p,_,E,A=!1){const $=this.getLocalMatrix(),ne=pa._TmpMats[0];Yt.ScalingToRef(p,_,E,ne),ne.multiplyToRef($,$),ne.invert();for(const xe of this.children){const ce=xe.getLocalMatrix();ce.multiplyToRef(ne,ce),ce.multiplyAtIndex(12,p),ce.multiplyAtIndex(13,_),ce.multiplyAtIndex(14,E),xe._markAsDirtyAndDecompose()}if(this._markAsDirtyAndDecompose(),A)for(const xe of this.children)xe.scale(p,_,E,A)}setScale(p){this._decompose(),this._localScaling.copyFrom(p),this._markAsDirtyAndCompose()}getScale(){return this._decompose(),this._localScaling}getScaleToRef(p){this._decompose(),p.copyFrom(this._localScaling)}setYawPitchRoll(p,_,E,A=Xn.LOCAL,$){if(A===Xn.LOCAL){const ce=pa._TmpQuat;_s.RotationYawPitchRollToRef(p,_,E,ce),this.setRotationQuaternion(ce,A,$);return}const ne=pa._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(ne,$))return;const xe=pa._TmpMats[1];Yt.RotationYawPitchRollToRef(p,_,E,xe),ne.multiplyToRef(xe,xe),this._rotateWithMatrix(xe,A,$)}rotate(p,_,E=Xn.LOCAL,A){const $=pa._TmpMats[0];$.setTranslationFromFloats(0,0,0),Yt.RotationAxisToRef(p,_,$),this._rotateWithMatrix($,E,A)}setAxisAngle(p,_,E=Xn.LOCAL,A){if(E===Xn.LOCAL){const xe=pa._TmpQuat;_s.RotationAxisToRef(p,_,xe),this.setRotationQuaternion(xe,E,A);return}const $=pa._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef($,A))return;const ne=pa._TmpMats[1];Yt.RotationAxisToRef(p,_,ne),$.multiplyToRef(ne,ne),this._rotateWithMatrix(ne,E,A)}setRotation(p,_=Xn.LOCAL,E){this.setYawPitchRoll(p.y,p.x,p.z,_,E)}setRotationQuaternion(p,_=Xn.LOCAL,E){if(_===Xn.LOCAL){this._decompose(),this._localRotation.copyFrom(p),this._markAsDirtyAndCompose();return}const A=pa._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(A,E))return;const $=pa._TmpMats[1];Yt.FromQuaternionToRef(p,$),A.multiplyToRef($,$),this._rotateWithMatrix($,_,E)}setRotationMatrix(p,_=Xn.LOCAL,E){if(_===Xn.LOCAL){const ne=pa._TmpQuat;_s.FromRotationMatrixToRef(p,ne),this.setRotationQuaternion(ne,_,E);return}const A=pa._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(A,E))return;const $=pa._TmpMats[1];$.copyFrom(p),A.multiplyToRef(p,$),this._rotateWithMatrix($,_,E)}_rotateWithMatrix(p,_=Xn.LOCAL,E){const A=this.getLocalMatrix(),$=A.m[12],ne=A.m[13],xe=A.m[14],ce=this.getParent(),Te=pa._TmpMats[3],Re=pa._TmpMats[4];ce&&_==Xn.WORLD?(E?(Te.copyFrom(E.getWorldMatrix()),ce.getAbsoluteMatrix().multiplyToRef(Te,Te)):Te.copyFrom(ce.getAbsoluteMatrix()),Re.copyFrom(Te),Re.invert(),A.multiplyToRef(Te,A),A.multiplyToRef(p,A),A.multiplyToRef(Re,A)):_==Xn.WORLD&&E?(Te.copyFrom(E.getWorldMatrix()),Re.copyFrom(Te),Re.invert(),A.multiplyToRef(Te,A),A.multiplyToRef(p,A),A.multiplyToRef(Re,A)):A.multiplyToRef(p,A),A.setTranslationFromFloats($,ne,xe),this.computeAbsoluteMatrices(),this._markAsDirtyAndDecompose()}_getAbsoluteInverseMatrixUnscaledToRef(p,_){const E=pa._TmpMats[2];return p.copyFrom(this.getAbsoluteMatrix()),_?(p.multiplyToRef(_.getWorldMatrix(),p),Yt.ScalingToRef(_.scaling.x,_.scaling.y,_.scaling.z,E)):Yt.IdentityToRef(E),p.invert(),isNaN(p.m[0])?!1:(E.multiplyAtIndex(0,this._scalingDeterminant),p.multiplyToRef(E,p),!0)}getPosition(p=Xn.LOCAL,_=null){const E=nt.Zero();return this.getPositionToRef(p,_,E),E}getPositionToRef(p=Xn.LOCAL,_,E){if(p==Xn.LOCAL){const A=this.getLocalMatrix();E.x=A.m[12],E.y=A.m[13],E.z=A.m[14]}else{let A=null;_&&(A=_.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();let $=pa._TmpMats[0];_&&A?($.copyFrom(this.getAbsoluteMatrix()),$.multiplyToRef(A,$)):$=this.getAbsoluteMatrix(),E.x=$.m[12],E.y=$.m[13],E.z=$.m[14]}}getAbsolutePosition(p=null){const _=nt.Zero();return this.getPositionToRef(Xn.WORLD,p,_),_}getAbsolutePositionToRef(p,_){this.getPositionToRef(Xn.WORLD,p,_)}computeAbsoluteMatrices(){if(this._compose(),this.parent)this._localMatrix.multiplyToRef(this.parent._absoluteMatrix,this._absoluteMatrix);else{this._absoluteMatrix.copyFrom(this._localMatrix);const E=this._skeleton.getPoseMatrix();E&&this._absoluteMatrix.multiplyToRef(E,this._absoluteMatrix)}const p=this.children,_=p.length;for(let E=0;E<_;E++)p[E].computeAbsoluteMatrices()}computeAbsoluteTransforms(){this.computeAbsoluteMatrices()}getDirection(p,_=null){const E=nt.Zero();return this.getDirectionToRef(p,_,E),E}getDirectionToRef(p,_=null,E){let A=null;_&&(A=_.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const $=pa._TmpMats[0];$.copyFrom(this.getAbsoluteMatrix()),_&&A&&$.multiplyToRef(A,$),nt.TransformNormalToRef(p,$,E),E.normalize()}getRotation(p=Xn.LOCAL,_=null){const E=nt.Zero();return this.getRotationToRef(p,_,E),E}getRotationToRef(p=Xn.LOCAL,_=null,E){const A=pa._TmpQuat;this.getRotationQuaternionToRef(p,_,A),A.toEulerAnglesToRef(E)}getRotationQuaternion(p=Xn.LOCAL,_=null){const E=_s.Identity();return this.getRotationQuaternionToRef(p,_,E),E}getRotationQuaternionToRef(p=Xn.LOCAL,_=null,E){if(p==Xn.LOCAL)this._decompose(),E.copyFrom(this._localRotation);else{const A=pa._TmpMats[0],$=this.getAbsoluteMatrix();_?$.multiplyToRef(_.getWorldMatrix(),A):A.copyFrom($),A.multiplyAtIndex(0,this._scalingDeterminant),A.multiplyAtIndex(1,this._scalingDeterminant),A.multiplyAtIndex(2,this._scalingDeterminant),A.decompose(void 0,E,void 0)}}getRotationMatrix(p=Xn.LOCAL,_){const E=Yt.Identity();return this.getRotationMatrixToRef(p,_,E),E}getRotationMatrixToRef(p=Xn.LOCAL,_,E){if(p==Xn.LOCAL)this.getLocalMatrix().getRotationMatrixToRef(E);else{const A=pa._TmpMats[0],$=this.getAbsoluteMatrix();_?$.multiplyToRef(_.getWorldMatrix(),A):A.copyFrom($),A.multiplyAtIndex(0,this._scalingDeterminant),A.multiplyAtIndex(1,this._scalingDeterminant),A.multiplyAtIndex(2,this._scalingDeterminant),A.getRotationMatrixToRef(E)}}getAbsolutePositionFromLocal(p,_=null){const E=nt.Zero();return this.getAbsolutePositionFromLocalToRef(p,_,E),E}getAbsolutePositionFromLocalToRef(p,_=null,E){let A=null;_&&(A=_.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const $=pa._TmpMats[0];$.copyFrom(this.getAbsoluteMatrix()),_&&A&&$.multiplyToRef(A,$),nt.TransformCoordinatesToRef(p,$,E)}getLocalPositionFromAbsolute(p,_=null){const E=nt.Zero();return this.getLocalPositionFromAbsoluteToRef(p,_,E),E}getLocalPositionFromAbsoluteToRef(p,_=null,E){let A=null;_&&(A=_.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const $=pa._TmpMats[0];$.copyFrom(this.getAbsoluteMatrix()),_&&A&&$.multiplyToRef(A,$),$.invert(),nt.TransformCoordinatesToRef(p,$,E)}setCurrentPoseAsRest(){this.setRestMatrix(this.getLocalMatrix())}}pa._TmpVecs=Ms.BuildArray(2,nt.Zero),pa._TmpQuat=_s.Identity(),pa._TmpMats=Ms.BuildArray(5,Yt.Identity),rr.prototype.updateRawTexture=function(_e,p,_,E,A=null,$=0,ne=!1){if(!_e)return;const xe=this._getRGBABufferInternalSizedFormat($,_,ne),ce=this._getInternalFormat(_),Te=this._getWebGLTextureType($);this._bindTextureDirectly(this._gl.TEXTURE_2D,_e,!0),this._unpackFlipY(E===void 0?!0:!!E),this._doNotHandleContextLost||(_e._bufferView=p,_e.format=_,_e.type=$,_e.invertY=E,_e._compression=A),_e.width%4!==0&&this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,1),A&&p?this._gl.compressedTexImage2D(this._gl.TEXTURE_2D,0,this.getCaps().s3tc[A],_e.width,_e.height,0,p):this._gl.texImage2D(this._gl.TEXTURE_2D,0,xe,_e.width,_e.height,0,ce,Te,p),_e.generateMipMaps&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null),_e.isReady=!0},rr.prototype.createRawTexture=function(_e,p,_,E,A,$,ne,xe=null,ce=0,Te=0,Re=!1){const ke=new u0(this,Gn.Raw);ke.baseWidth=p,ke.baseHeight=_,ke.width=p,ke.height=_,ke.format=E,ke.generateMipMaps=A,ke.samplingMode=ne,ke.invertY=$,ke._compression=xe,ke.type=ce,ke._useSRGBBuffer=this._getUseSRGBBuffer(Re,!A),this._doNotHandleContextLost||(ke._bufferView=_e),this.updateRawTexture(ke,_e,E,$,xe,ce,ke._useSRGBBuffer),this._bindTextureDirectly(this._gl.TEXTURE_2D,ke,!0);const We=this._getSamplingParameters(ne,A);return this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,We.mag),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,We.min),A&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._internalTexturesCache.push(ke),ke},rr.prototype.createRawCubeTexture=function(_e,p,_,E,A,$,ne,xe=null){const ce=this._gl,Te=new u0(this,Gn.CubeRaw);Te.isCube=!0,Te.format=_,Te.type=E,this._doNotHandleContextLost||(Te._bufferViewArray=_e);const Re=this._getWebGLTextureType(E);let ke=this._getInternalFormat(_);ke===ce.RGB&&(ke=ce.RGBA),Re===ce.FLOAT&&!this._caps.textureFloatLinearFiltering?(A=!1,ne=1,vi.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):Re===this._gl.HALF_FLOAT_OES&&!this._caps.textureHalfFloatLinearFiltering?(A=!1,ne=1,vi.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):Re===ce.FLOAT&&!this._caps.textureFloatRender?(A=!1,vi.Warn("Render to float textures is not supported. Mipmap generation forced to false.")):Re===ce.HALF_FLOAT&&!this._caps.colorBufferFloat&&(A=!1,vi.Warn("Render to half float textures is not supported. Mipmap generation forced to false."));const We=p,Xe=We;if(Te.width=We,Te.height=Xe,Te.invertY=$,Te._compression=xe,!this.needPOTTextures||ct.IsExponentOfTwo(Te.width)&&ct.IsExponentOfTwo(Te.height)||(A=!1),_e)this.updateRawCubeTexture(Te,_e,_,E,$,xe);else{const ht=this._getRGBABufferInternalSizedFormat(E),Nt=0;this._bindTextureDirectly(ce.TEXTURE_CUBE_MAP,Te,!0);for(let wt=0;wt<6;wt++)xe?ce.compressedTexImage2D(ce.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Nt,this.getCaps().s3tc[xe],Te.width,Te.height,0,void 0):ce.texImage2D(ce.TEXTURE_CUBE_MAP_POSITIVE_X+wt,Nt,ht,Te.width,Te.height,0,ke,Re,null);this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null)}this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,Te,!0),_e&&A&&this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);const qe=this._getSamplingParameters(ne,A);return ce.texParameteri(ce.TEXTURE_CUBE_MAP,ce.TEXTURE_MAG_FILTER,qe.mag),ce.texParameteri(ce.TEXTURE_CUBE_MAP,ce.TEXTURE_MIN_FILTER,qe.min),ce.texParameteri(ce.TEXTURE_CUBE_MAP,ce.TEXTURE_WRAP_S,ce.CLAMP_TO_EDGE),ce.texParameteri(ce.TEXTURE_CUBE_MAP,ce.TEXTURE_WRAP_T,ce.CLAMP_TO_EDGE),this._bindTextureDirectly(ce.TEXTURE_CUBE_MAP,null),Te.generateMipMaps=A,Te.samplingMode=ne,Te.isReady=!0,Te},rr.prototype.updateRawCubeTexture=function(_e,p,_,E,A,$=null,ne=0){_e._bufferViewArray=p,_e.format=_,_e.type=E,_e.invertY=A,_e._compression=$;const xe=this._gl,ce=this._getWebGLTextureType(E);let Te=this._getInternalFormat(_);const Re=this._getRGBABufferInternalSizedFormat(E);let ke=!1;Te===xe.RGB&&(Te=xe.RGBA,ke=!0),this._bindTextureDirectly(xe.TEXTURE_CUBE_MAP,_e,!0),this._unpackFlipY(A===void 0?!0:!!A),_e.width%4!==0&&xe.pixelStorei(xe.UNPACK_ALIGNMENT,1);for(let Xe=0;Xe<6;Xe++){let xt=p[Xe];$?xe.compressedTexImage2D(xe.TEXTURE_CUBE_MAP_POSITIVE_X+Xe,ne,this.getCaps().s3tc[$],_e.width,_e.height,0,xt):(ke&&(xt=cC(xt,_e.width,_e.height,E)),xe.texImage2D(xe.TEXTURE_CUBE_MAP_POSITIVE_X+Xe,ne,Re,_e.width,_e.height,0,Te,ce,xt))}(!this.needPOTTextures||ct.IsExponentOfTwo(_e.width)&&ct.IsExponentOfTwo(_e.height))&&_e.generateMipMaps&&ne===0&&this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),_e.isReady=!0},rr.prototype.createRawCubeTextureFromUrl=function(_e,p,_,E,A,$,ne,xe,ce=null,Te=null,Re=3,ke=!1){const We=this._gl,Xe=this.createRawCubeTexture(null,_,E,A,!$,ke,Re,null);p?.addPendingData(Xe),Xe.url=_e,Xe.isReady=!1,this._internalTexturesCache.push(Xe);const xt=(ht,Nt)=>{p?.removePendingData(Xe),Te&&ht&&Te(ht.status+" "+ht.statusText,Nt)},qe=ht=>{const Nt=Xe.width,wt=ne(ht);if(wt){if(xe){const Qt=this._getWebGLTextureType(A);let Ht=this._getInternalFormat(E);const Wt=this._getRGBABufferInternalSizedFormat(A);let zt=!1;Ht===We.RGB&&(Ht=We.RGBA,zt=!0),this._bindTextureDirectly(We.TEXTURE_CUBE_MAP,Xe,!0),this._unpackFlipY(!1);const xi=xe(wt);for(let wi=0;wi<xi.length;wi++){const vs=Nt>>wi;for(let cs=0;cs<6;cs++){let Mr=xi[wi][cs];zt&&(Mr=cC(Mr,vs,vs,A)),We.texImage2D(cs,wi,Wt,vs,vs,0,Ht,Qt,Mr)}}this._bindTextureDirectly(We.TEXTURE_CUBE_MAP,null)}else this.updateRawCubeTexture(Xe,wt,E,A,ke);Xe.isReady=!0,p?.removePendingData(Xe),Xe.onLoadedObservable.notifyObservers(Xe),Xe.onLoadedObservable.clear(),ce&&ce()}};return this._loadFile(_e,ht=>{qe(ht)},void 0,p?.offlineProvider,!0,xt),Xe};function cC(_e,p,_,E){let A,$=1;E===1?A=new Float32Array(p*_*4):E===2?(A=new Uint16Array(p*_*4),$=15360):E===7?A=new Uint32Array(p*_*4):A=new Uint8Array(p*_*4);for(let ne=0;ne<p;ne++)for(let xe=0;xe<_;xe++){const ce=(xe*p+ne)*3,Te=(xe*p+ne)*4;A[Te+0]=_e[ce+0],A[Te+1]=_e[ce+1],A[Te+2]=_e[ce+2],A[Te+3]=$}return A}function uC(_e){return function(p,_,E,A,$,ne,xe,ce,Te=null,Re=0){const ke=_e?this._gl.TEXTURE_3D:this._gl.TEXTURE_2D_ARRAY,We=_e?Gn.Raw3D:Gn.Raw2DArray,Xe=new u0(this,We);Xe.baseWidth=_,Xe.baseHeight=E,Xe.baseDepth=A,Xe.width=_,Xe.height=E,Xe.depth=A,Xe.format=$,Xe.type=Re,Xe.generateMipMaps=ne,Xe.samplingMode=ce,_e?Xe.is3D=!0:Xe.is2DArray=!0,this._doNotHandleContextLost||(Xe._bufferView=p),_e?this.updateRawTexture3D(Xe,p,$,xe,Te,Re):this.updateRawTexture2DArray(Xe,p,$,xe,Te,Re),this._bindTextureDirectly(ke,Xe,!0);const xt=this._getSamplingParameters(ce,ne);return this._gl.texParameteri(ke,this._gl.TEXTURE_MAG_FILTER,xt.mag),this._gl.texParameteri(ke,this._gl.TEXTURE_MIN_FILTER,xt.min),ne&&this._gl.generateMipmap(ke),this._bindTextureDirectly(ke,null),this._internalTexturesCache.push(Xe),Xe}}rr.prototype.createRawTexture2DArray=uC(!1),rr.prototype.createRawTexture3D=uC(!0);function _C(_e){return function(p,_,E,A,$=null,ne=0){const xe=_e?this._gl.TEXTURE_3D:this._gl.TEXTURE_2D_ARRAY,ce=this._getWebGLTextureType(ne),Te=this._getInternalFormat(E),Re=this._getRGBABufferInternalSizedFormat(ne,E);this._bindTextureDirectly(xe,p,!0),this._unpackFlipY(A===void 0?!0:!!A),this._doNotHandleContextLost||(p._bufferView=_,p.format=E,p.invertY=A,p._compression=$),p.width%4!==0&&this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,1),$&&_?this._gl.compressedTexImage3D(xe,0,this.getCaps().s3tc[$],p.width,p.height,p.depth,0,_):this._gl.texImage3D(xe,0,Re,p.width,p.height,p.depth,0,Te,ce,_),p.generateMipMaps&&this._gl.generateMipmap(xe),this._bindTextureDirectly(xe,null),p.isReady=!0}}rr.prototype.updateRawTexture2DArray=_C(!1),rr.prototype.updateRawTexture3D=_C(!0);class jl extends Hi{constructor(p,_,E,A,$,ne=!0,xe=!1,ce=3,Te=0,Re,ke){super(null,$,!ne,xe,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,Re),this.format=A,this._engine&&(!this._engine._caps.textureFloatLinearFiltering&&Te===1&&(ce=1),!this._engine._caps.textureHalfFloatLinearFiltering&&Te===2&&(ce=1),this._texture=this._engine.createRawTexture(p,_,E,A,ne,xe,ce,null,Te,Re??0,ke??!1),this.wrapU=Hi.CLAMP_ADDRESSMODE,this.wrapV=Hi.CLAMP_ADDRESSMODE)}update(p){this._getEngine().updateRawTexture(this._texture,p,this._texture.format,this._texture.invertY,null,this._texture.type,this._texture._useSRGBBuffer)}static CreateLuminanceTexture(p,_,E,A,$=!0,ne=!1,xe=3){return new jl(p,_,E,1,A,$,ne,xe)}static CreateLuminanceAlphaTexture(p,_,E,A,$=!0,ne=!1,xe=3){return new jl(p,_,E,2,A,$,ne,xe)}static CreateAlphaTexture(p,_,E,A,$=!0,ne=!1,xe=3){return new jl(p,_,E,0,A,$,ne,xe)}static CreateRGBTexture(p,_,E,A,$=!0,ne=!1,xe=3,ce=0,Te=0,Re=!1){return new jl(p,_,E,4,A,$,ne,xe,ce,Te,Re)}static CreateRGBATexture(p,_,E,A,$=!0,ne=!1,xe=3,ce=0,Te=0,Re=!1){return new jl(p,_,E,5,A,$,ne,xe,ce,Te,Re)}static CreateRGBAStorageTexture(p,_,E,A,$=!0,ne=!1,xe=3,ce=0,Te=!1){return new jl(p,_,E,5,A,$,ne,xe,ce,1,Te)}static CreateRTexture(p,_,E,A,$=!0,ne=!1,xe=Hi.TRILINEAR_SAMPLINGMODE,ce=1){return new jl(p,_,E,6,A,$,ne,xe,ce)}static CreateRStorageTexture(p,_,E,A,$=!0,ne=!1,xe=Hi.TRILINEAR_SAMPLINGMODE,ce=1){return new jl(p,_,E,6,A,$,ne,xe,ce,1)}}class Ug{get useTextureToStoreBoneMatrices(){return this._useTextureToStoreBoneMatrices}set useTextureToStoreBoneMatrices(p){this._useTextureToStoreBoneMatrices=p,this._markAsDirty()}get animationPropertiesOverride(){return this._animationPropertiesOverride?this._animationPropertiesOverride:this._scene.animationPropertiesOverride}set animationPropertiesOverride(p){this._animationPropertiesOverride=p}get isUsingTextureForMatrices(){return this.useTextureToStoreBoneMatrices&&this._canUseTextureForBones}get uniqueId(){return this._uniqueId}constructor(p,_,E){this.name=p,this.id=_,this.bones=[],this.needInitialSkinMatrix=!1,this._isDirty=!0,this._meshesWithPoseMatrix=new Array,this._identity=Yt.Identity(),this._currentRenderId=-1,this._ranges={},this._absoluteTransformIsDirty=!0,this._canUseTextureForBones=!1,this._uniqueId=0,this._numBonesWithLinkedTransformNode=0,this._hasWaitingData=null,this._parentContainer=null,this.doNotSerialize=!1,this._useTextureToStoreBoneMatrices=!0,this._animationPropertiesOverride=null,this.onBeforeComputeObservable=new Mi,this.bones=[],this._scene=E||wr.LastCreatedScene,this._uniqueId=this._scene.getUniqueId(),this._scene.addSkeleton(this),this._isDirty=!0;const A=this._scene.getEngine().getCaps();this._canUseTextureForBones=A.textureFloat&&A.maxVertexTextureImageUnits>0}getClassName(){return"Skeleton"}getChildren(){return this.bones.filter(p=>!p.getParent())}getTransformMatrices(p){return this.needInitialSkinMatrix?(p._bonesTransformMatrices||this.prepare(!0),p._bonesTransformMatrices):((!this._transformMatrices||this._isDirty)&&this.prepare(!this._transformMatrices),this._transformMatrices)}getTransformMatrixTexture(p){return this.needInitialSkinMatrix&&p._transformMatrixTexture?p._transformMatrixTexture:this._transformMatrixTexture}getScene(){return this._scene}toString(p){let _=`Name: ${this.name}, nBones: ${this.bones.length}`;if(_+=`, nAnimationRanges: ${this._ranges?Object.keys(this._ranges).length:"none"}`,p){_+=", Ranges: {";let E=!0;for(const A in this._ranges)E&&(_+=", ",E=!1),_+=A;_+="}"}return _}getBoneIndexByName(p){for(let _=0,E=this.bones.length;_<E;_++)if(this.bones[_].name===p)return _;return-1}createAnimationRange(p,_,E){if(!this._ranges[p]){this._ranges[p]=new Yu(p,_,E);for(let A=0,$=this.bones.length;A<$;A++)this.bones[A].animations[0]&&this.bones[A].animations[0].createRange(p,_,E)}}deleteAnimationRange(p,_=!0){for(let E=0,A=this.bones.length;E<A;E++)this.bones[E].animations[0]&&this.bones[E].animations[0].deleteRange(p,_);this._ranges[p]=null}getAnimationRange(p){return this._ranges[p]||null}getAnimationRanges(){const p=[];let _;for(_ in this._ranges)p.push(this._ranges[_]);return p}copyAnimationRange(p,_,E=!1){if(this._ranges[_]||!p.getAnimationRange(_))return!1;let A=!0;const $=this._getHighestAnimationFrame()+1,ne={},xe=p.bones;let ce,Te;for(Te=0,ce=xe.length;Te<ce;Te++)ne[xe[Te].name]=xe[Te];this.bones.length!==xe.length&&(vi.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${xe.length}`),A=!1);const Re=E&&this.dimensionsAtRest&&p.dimensionsAtRest?this.dimensionsAtRest.divide(p.dimensionsAtRest):null;for(Te=0,ce=this.bones.length;Te<ce;Te++){const We=this.bones[Te].name,Xe=ne[We];Xe?A=A&&this.bones[Te].copyAnimationRange(Xe,_,$,E,Re):(vi.Warn("copyAnimationRange: not same rig, missing source bone "+We),A=!1)}const ke=p.getAnimationRange(_);return ke&&(this._ranges[_]=new Yu(_,ke.from+$,ke.to+$)),A}returnToRest(){for(const p of this.bones)p._index!==-1&&p.returnToRest()}_getHighestAnimationFrame(){let p=0;for(let _=0,E=this.bones.length;_<E;_++)if(this.bones[_].animations[0]){const A=this.bones[_].animations[0].getHighestFrame();p<A&&(p=A)}return p}beginAnimation(p,_,E,A){const $=this.getAnimationRange(p);return $?this._scene.beginAnimation(this,$.from,$.to,_,E,A):null}static MakeAnimationAdditive(p,_=0,E){const A=p.getAnimationRange(E);if(!A)return null;const $=p._scene.getAllAnimatablesByTarget(p);let ne=null;for(let ce=0;ce<$.length;ce++){const Te=$[ce];if(Te.fromFrame===A?.from&&Te.toFrame===A?.to){ne=Te;break}}const xe=p.getAnimatables();for(let ce=0;ce<xe.length;ce++){const Re=xe[ce].animations;if(Re)for(let ke=0;ke<Re.length;ke++)Ui.MakeAnimationAdditive(Re[ke],_,E)}return ne&&(ne.isAdditive=!0),p}_markAsDirty(){this._isDirty=!0,this._absoluteTransformIsDirty=!0}_registerMeshWithPoseMatrix(p){this._meshesWithPoseMatrix.push(p)}_unregisterMeshWithPoseMatrix(p){const _=this._meshesWithPoseMatrix.indexOf(p);_>-1&&this._meshesWithPoseMatrix.splice(_,1)}_computeTransformMatrices(p,_){this.onBeforeComputeObservable.notifyObservers(this);for(let E=0;E<this.bones.length;E++){const A=this.bones[E];A._childUpdateId++;const $=A.getParent();if($?A.getLocalMatrix().multiplyToRef($.getFinalMatrix(),A.getFinalMatrix()):_?A.getLocalMatrix().multiplyToRef(_,A.getFinalMatrix()):A.getFinalMatrix().copyFrom(A.getLocalMatrix()),A._index!==-1){const ne=A._index===null?E:A._index;A.getAbsoluteInverseBindMatrix().multiplyToArray(A.getFinalMatrix(),p,ne*16)}}this._identity.copyToArray(p,this.bones.length*16)}prepare(p=!1){if(!p){const _=this.getScene().getRenderId();if(this._currentRenderId===_)return;this._currentRenderId=_}if(this._numBonesWithLinkedTransformNode>0){for(const _ of this.bones)if(_._linkedTransformNode){const E=_._linkedTransformNode;_.position=E.position,E.rotationQuaternion?_.rotationQuaternion=E.rotationQuaternion:_.rotation=E.rotation,_.scaling=E.scaling}}if(this.needInitialSkinMatrix)for(const _ of this._meshesWithPoseMatrix){const E=_.getPoseMatrix();let A=this._isDirty;if((!_._bonesTransformMatrices||_._bonesTransformMatrices.length!==16*(this.bones.length+1))&&(_._bonesTransformMatrices=new Float32Array(16*(this.bones.length+1)),A=!0),!!A){if(this._synchronizedWithMesh!==_){this._synchronizedWithMesh=_;for(const $ of this.bones)$.getParent()||($.getBindMatrix().multiplyToRef(E,pi.Matrix[1]),$._updateAbsoluteBindMatrices(pi.Matrix[1]));if(this.isUsingTextureForMatrices){const $=(this.bones.length+1)*4;(!_._transformMatrixTexture||_._transformMatrixTexture.getSize().width!==$)&&(_._transformMatrixTexture&&_._transformMatrixTexture.dispose(),_._transformMatrixTexture=jl.CreateRGBATexture(_._bonesTransformMatrices,(this.bones.length+1)*4,1,this._scene,!1,!1,1,1))}}this._computeTransformMatrices(_._bonesTransformMatrices,E),this.isUsingTextureForMatrices&&_._transformMatrixTexture&&_._transformMatrixTexture.update(_._bonesTransformMatrices)}}else{if(!this._isDirty)return;(!this._transformMatrices||this._transformMatrices.length!==16*(this.bones.length+1))&&(this._transformMatrices=new Float32Array(16*(this.bones.length+1)),this.isUsingTextureForMatrices&&(this._transformMatrixTexture&&this._transformMatrixTexture.dispose(),this._transformMatrixTexture=jl.CreateRGBATexture(this._transformMatrices,(this.bones.length+1)*4,1,this._scene,!1,!1,1,1))),this._computeTransformMatrices(this._transformMatrices,null),this.isUsingTextureForMatrices&&this._transformMatrixTexture&&this._transformMatrixTexture.update(this._transformMatrices)}this._isDirty=!1}getAnimatables(){if(!this._animatables||this._animatables.length!==this.bones.length){this._animatables=[];for(let p=0;p<this.bones.length;p++)this._animatables.push(this.bones[p])}return this._animatables}clone(p,_){const E=new Ug(p,_||p,this._scene);E.needInitialSkinMatrix=this.needInitialSkinMatrix;for(let A=0;A<this.bones.length;A++){const $=this.bones[A];let ne=null;const xe=$.getParent();if(xe){const Te=this.bones.indexOf(xe);ne=E.bones[Te]}const ce=new pa($.name,E,ne,$.getBindMatrix().clone(),$.getRestMatrix().clone());ce._index=$._index,$._linkedTransformNode&&ce.linkTransformNode($._linkedTransformNode),al.DeepCopy($.animations,ce.animations)}if(this._ranges){E._ranges={};for(const A in this._ranges){const $=this._ranges[A];$&&(E._ranges[A]=$.clone())}}return this._isDirty=!0,E.prepare(!0),E}enableBlending(p=.01){this.bones.forEach(_=>{_.animations.forEach(E=>{E.enableBlending=!0,E.blendingSpeed=p})})}dispose(){if(this._meshesWithPoseMatrix.length=0,this.getScene().stopAnimation(this),this.getScene().removeSkeleton(this),this._parentContainer){const p=this._parentContainer.skeletons.indexOf(this);p>-1&&this._parentContainer.skeletons.splice(p,1),this._parentContainer=null}this._transformMatrixTexture&&(this._transformMatrixTexture.dispose(),this._transformMatrixTexture=null)}serialize(){const p={};p.name=this.name,p.id=this.id,this.dimensionsAtRest&&(p.dimensionsAtRest=this.dimensionsAtRest.asArray()),p.bones=[],p.needInitialSkinMatrix=this.needInitialSkinMatrix;for(let _=0;_<this.bones.length;_++){const E=this.bones[_],A=E.getParent(),$={parentBoneIndex:A?this.bones.indexOf(A):-1,index:E.getIndex(),name:E.name,id:E.id,matrix:E.getBindMatrix().toArray(),rest:E.getRestMatrix().toArray(),linkedTransformNodeId:E.getTransformNode()?.id};p.bones.push($),E.length&&($.length=E.length),E.metadata&&($.metadata=E.metadata),E.animations&&E.animations.length>0&&($.animation=E.animations[0].serialize()),p.ranges=[];for(const ne in this._ranges){const xe=this._ranges[ne];if(!xe)continue;const ce={};ce.name=ne,ce.from=xe.from,ce.to=xe.to,p.ranges.push(ce)}}return p}static Parse(p,_){const E=new Ug(p.name,p.id,_);p.dimensionsAtRest&&(E.dimensionsAtRest=nt.FromArray(p.dimensionsAtRest)),E.needInitialSkinMatrix=p.needInitialSkinMatrix;let A;for(A=0;A<p.bones.length;A++){const $=p.bones[A],ne=p.bones[A].index;let xe=null;$.parentBoneIndex>-1&&(xe=E.bones[$.parentBoneIndex]);const ce=$.rest?Yt.FromArray($.rest):null,Te=new pa($.name,E,xe,Yt.FromArray($.matrix),ce,null,ne);$.id!==void 0&&$.id!==null&&(Te.id=$.id),$.length&&(Te.length=$.length),$.metadata&&(Te.metadata=$.metadata),$.animation&&Te.animations.push(Ui.Parse($.animation)),$.linkedTransformNodeId!==void 0&&$.linkedTransformNodeId!==null&&(E._hasWaitingData=!0,Te._waitingTransformNodeId=$.linkedTransformNodeId)}if(p.ranges)for(A=0;A<p.ranges.length;A++){const $=p.ranges[A];E.createAnimationRange($.name,$.from,$.to)}return E}computeAbsoluteMatrices(p=!1){(this._absoluteTransformIsDirty||p)&&(this.bones[0].computeAbsoluteMatrices(),this._absoluteTransformIsDirty=!1)}computeAbsoluteTransforms(p=!1){this.computeAbsoluteMatrices(p)}getPoseMatrix(){let p=null;return this._meshesWithPoseMatrix.length>0&&(p=this._meshesWithPoseMatrix[0].getPoseMatrix()),p}sortBones(){const p=[],_=new Array(this.bones.length);for(let E=0;E<this.bones.length;E++)this._sortBones(E,p,_);this.bones=p}_sortBones(p,_,E){if(E[p])return;E[p]=!0;const A=this.bones[p];if(!A)return;A._index===void 0&&(A._index=p);const $=A.getParent();$&&this._sortBones(this.bones.indexOf($),_,E),_.push(A)}setCurrentPoseAsRest(){this.bones.forEach(p=>{p.setCurrentPoseAsRest()})}}const hL="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";let cL=0;const v_=_e=>{if(!_e.environmentBRDFTexture){const p=_e.useDelayedTextureLoading;_e.useDelayedTextureLoading=!1;const _=_e._blockEntityCollection;_e._blockEntityCollection=!1;const E=Hi.CreateFromBase64String(hL,"EnvironmentBRDFTexture"+cL++,_e,!0,!1,Hi.BILINEAR_SAMPLINGMODE);_e._blockEntityCollection=_;const A=_e.getEngine().getLoadedTexturesCache(),$=A.indexOf(E.getInternalTexture());$!==-1&&A.splice($,1),E.isRGBD=!0,E.wrapU=Hi.CLAMP_ADDRESSMODE,E.wrapV=Hi.CLAMP_ADDRESSMODE,_e.environmentBRDFTexture=E,_e.useDelayedTextureLoading=p,b_.ExpandRGBDTexture(E);const ne=_e.getEngine().onContextRestoredObservable.add(()=>{E.isRGBD=!0;const xe=_e.onBeforeRenderObservable.add(()=>{E.isReady()&&(_e.onBeforeRenderObservable.remove(xe),b_.ExpandRGBDTexture(E))})});_e.onDisposeObservable.add(()=>{_e.getEngine().onContextRestoredObservable.remove(ne)})}return _e.environmentBRDFTexture},U5={GetEnvironmentBRDFTexture:v_},uL=new RegExp("^([gimus]+)!");class lc{constructor(p){this._plugins=[],this._activePlugins=[],this._activePluginsForExtraEvents=[],this._material=p,this._scene=p.getScene(),this._engine=this._scene.getEngine()}_addPlugin(p){for(let A=0;A<this._plugins.length;++A)if(this._plugins[A].name===p.name)return!1;if(this._material._uniformBufferLayoutBuilt)throw`The plugin "${p.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;const _=p.getClassName();lc._MaterialPluginClassToMainDefine[_]||(lc._MaterialPluginClassToMainDefine[_]="MATERIALPLUGIN_"+ ++lc._MaterialPluginCounter),this._material._callbackPluginEventGeneric=(A,$)=>this._handlePluginEvent(A,$),this._plugins.push(p),this._plugins.sort((A,$)=>A.priority-$.priority),this._codeInjectionPoints={};const E={};E[lc._MaterialPluginClassToMainDefine[_]]={type:"boolean",default:!0};for(const A of this._plugins)A.collectDefines(E),this._collectPointNames("vertex",A.getCustomCode("vertex")),this._collectPointNames("fragment",A.getCustomCode("fragment"));return this._defineNamesFromPlugins=E,!0}_activatePlugin(p){this._activePlugins.indexOf(p)===-1&&(this._activePlugins.push(p),this._activePlugins.sort((_,E)=>_.priority-E.priority),this._material._callbackPluginEventIsReadyForSubMesh=this._handlePluginEventIsReadyForSubMesh.bind(this),this._material._callbackPluginEventPrepareDefinesBeforeAttributes=this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this),this._material._callbackPluginEventPrepareDefines=this._handlePluginEventPrepareDefines.bind(this),this._material._callbackPluginEventBindForSubMesh=this._handlePluginEventBindForSubMesh.bind(this),p.registerForExtraEvents&&(this._activePluginsForExtraEvents.push(p),this._activePluginsForExtraEvents.sort((_,E)=>_.priority-E.priority),this._material._callbackPluginEventHasRenderTargetTextures=this._handlePluginEventHasRenderTargetTextures.bind(this),this._material._callbackPluginEventFillRenderTargetTextures=this._handlePluginEventFillRenderTargetTextures.bind(this),this._material._callbackPluginEventHardBindForSubMesh=this._handlePluginEventHardBindForSubMesh.bind(this)))}getPlugin(p){for(let _=0;_<this._plugins.length;++_)if(this._plugins[_].name===p)return this._plugins[_];return null}_handlePluginEventIsReadyForSubMesh(p){let _=!0;for(const E of this._activePlugins)_=_&&E.isReadyForSubMesh(p.defines,this._scene,this._engine,p.subMesh);p.isReadyForSubMesh=_}_handlePluginEventPrepareDefinesBeforeAttributes(p){for(const _ of this._activePlugins)_.prepareDefinesBeforeAttributes(p.defines,this._scene,p.mesh)}_handlePluginEventPrepareDefines(p){for(const _ of this._activePlugins)_.prepareDefines(p.defines,this._scene,p.mesh)}_handlePluginEventHardBindForSubMesh(p){for(const _ of this._activePluginsForExtraEvents)_.hardBindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,p.subMesh)}_handlePluginEventBindForSubMesh(p){for(const _ of this._activePlugins)_.bindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,p.subMesh)}_handlePluginEventHasRenderTargetTextures(p){let _=!1;for(const E of this._activePluginsForExtraEvents)if(_=E.hasRenderTargetTextures(),_)break;p.hasRenderTargetTextures=_}_handlePluginEventFillRenderTargetTextures(p){for(const _ of this._activePluginsForExtraEvents)_.fillRenderTargetTextures(p.renderTargets)}_handlePluginEvent(p,_){switch(p){case wo.GetActiveTextures:{const E=_;for(const A of this._activePlugins)A.getActiveTextures(E.activeTextures);break}case wo.GetAnimatables:{const E=_;for(const A of this._activePlugins)A.getAnimatables(E.animatables);break}case wo.HasTexture:{const E=_;let A=!1;for(const $ of this._activePlugins)if(A=$.hasTexture(E.texture),A)break;E.hasTexture=A;break}case wo.Disposed:{const E=_;for(const A of this._plugins)A.dispose(E.forceDisposeTextures);break}case wo.GetDefineNames:{const E=_;E.defineNames=this._defineNamesFromPlugins;break}case wo.PrepareEffect:{const E=_;for(const A of this._activePlugins)E.fallbackRank=A.addFallbacks(E.defines,E.fallbacks,E.fallbackRank),A.getAttributes(E.attributes,this._scene,E.mesh);this._uniformList.length>0&&E.uniforms.push(...this._uniformList),this._samplerList.length>0&&E.samplers.push(...this._samplerList),this._uboList.length>0&&E.uniformBuffersNames.push(...this._uboList),E.customCode=this._injectCustomCode(E,E.customCode);break}case wo.PrepareUniformBuffer:{const E=_;this._uboDeclaration="",this._vertexDeclaration="",this._fragmentDeclaration="",this._uniformList=[],this._samplerList=[],this._uboList=[];for(const A of this._plugins){const $=A.getUniforms();if($){if($.ubo)for(const ne of $.ubo){if(ne.size&&ne.type){const xe=ne.arraySize??0;E.ubo.addUniform(ne.name,ne.size,xe),this._uboDeclaration+=`${ne.type} ${ne.name}${xe>0?`[${xe}]`:""};
`}this._uniformList.push(ne.name)}$.vertex&&(this._vertexDeclaration+=$.vertex+`
`),$.fragment&&(this._fragmentDeclaration+=$.fragment+`
`)}A.getSamplers(this._samplerList),A.getUniformBuffersNames(this._uboList)}break}}}_collectPointNames(p,_){if(_)for(const E in _)this._codeInjectionPoints[p]||(this._codeInjectionPoints[p]={}),this._codeInjectionPoints[p][E]=!0}_injectCustomCode(p,_){return(E,A)=>{_&&(A=_(E,A)),this._uboDeclaration&&(A=A.replace("#define ADDITIONAL_UBO_DECLARATION",this._uboDeclaration)),this._vertexDeclaration&&(A=A.replace("#define ADDITIONAL_VERTEX_DECLARATION",this._vertexDeclaration)),this._fragmentDeclaration&&(A=A.replace("#define ADDITIONAL_FRAGMENT_DECLARATION",this._fragmentDeclaration));const $=this._codeInjectionPoints?.[E];if(!$)return A;let ne=null;for(let xe in $){let ce="";for(const Te of this._activePlugins){let Re=Te.getCustomCode(E)?.[xe];if(Re){if(Te.resolveIncludes){if(ne===null){const ke=Xa.GLSL;ne={defines:[],indexParameters:p.indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:void 0,supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:Gi.GetShadersRepository(ke),includesShadersStore:Gi.GetIncludesShadersStore(ke),version:void 0,platformName:this._engine.shaderPlatformName,processingContext:void 0,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:void 0}}ne.isFragment=E==="fragment",po._ProcessIncludes(Re,ne,ke=>Re=ke)}ce+=Re+`
`}}if(ce.length>0)if(xe.charAt(0)==="!"){xe=xe.substring(1);let Te="g";if(xe.charAt(0)==="!")Te="",xe=xe.substring(1);else{const Xe=uL.exec(xe);Xe&&Xe.length>=2&&(Te=Xe[1],xe=xe.substring(Te.length+1))}Te.indexOf("g")<0&&(Te+="g");const Re=A,ke=new RegExp(xe,Te);let We=ke.exec(Re);for(;We!==null;){let Xe=ce;for(let xt=0;xt<We.length;++xt)Xe=Xe.replace("$"+xt,We[xt]);A=A.replace(We[0],Xe),We=ke.exec(Re)}}else{const Te="#define "+xe;A=A.replace(Te,`
`+ce+`
`+Te)}}return A}}}lc._MaterialPluginClassToMainDefine={},lc._MaterialPluginCounter=0,wr.OnEnginesDisposedObservable.add(()=>{TC()});const hc=[];let A_=!1,S_=null;function G5(_e,p){A_||(S_=Material.OnEventObservable.add(E=>{for(const[,A]of hc)A(E)},MaterialPluginEvent.Created),A_=!0);const _=hc.filter(([E,A])=>E===_e);_.length>0?_[0][1]=p:hc.push([_e,p])}function z5(_e){for(let p=0;p<hc.length;++p)if(hc[p][0]===_e)return hc.splice(p,1),hc.length===0&&TC(),!0;return!1}function TC(){hc.length=0,A_=!1,Xi.OnEventObservable.remove(S_),S_=null}class ql{_enable(p){p&&this._pluginManager._activatePlugin(this)}constructor(p,_,E,A,$=!0,ne=!1,xe=!1){this.priority=500,this.resolveIncludes=!1,this.registerForExtraEvents=!1,this._material=p,this.name=_,this.priority=E,this.resolveIncludes=xe,p.pluginManager||(p.pluginManager=new lc(p),p.onDisposeObservable.add(()=>{p.pluginManager=void 0})),this._pluginDefineNames=A,this._pluginManager=p.pluginManager,$&&this._pluginManager._addPlugin(this),ne&&this._enable(!0),this.markAllDefinesAsDirty=p._dirtyCallbacks[63]}getClassName(){return"MaterialPluginBase"}isReadyForSubMesh(p,_,E,A){return!0}hardBindForSubMesh(p,_,E,A){}bindForSubMesh(p,_,E,A){}dispose(p){}getCustomCode(p){return null}collectDefines(p){if(this._pluginDefineNames)for(const _ of Object.keys(this._pluginDefineNames)){if(_[0]==="_")continue;const E=typeof this._pluginDefineNames[_];p[_]={type:E==="number"?"number":E==="string"?"string":E==="boolean"?"boolean":"object",default:this._pluginDefineNames[_]}}}prepareDefinesBeforeAttributes(p,_,E){}prepareDefines(p,_,E){}hasTexture(p){return!1}hasRenderTargetTextures(){return!1}fillRenderTargetTextures(p){}getActiveTextures(p){}getAnimatables(p){}addFallbacks(p,_,E){return E}getSamplers(p){}getAttributes(p,_,E){}getUniformBuffersNames(p){}getUniforms(){return{}}copyTo(p){Xr.Clone(()=>p,this)}serialize(){return Xr.Serialize(this)}parse(p,_,E){Xr.Parse(()=>this,p,_,E)}}Mt([Gt()],ql.prototype,"name",void 0),Mt([Gt()],ql.prototype,"priority",void 0),Mt([Gt()],ql.prototype,"resolveIncludes",void 0),Mt([Gt()],ql.prototype,"registerForExtraEvents",void 0);class pL extends qh{constructor(){super(...arguments),this.BRDF_V_HEIGHT_CORRELATED=!1,this.MS_BRDF_ENERGY_CONSERVATION=!1,this.SPHERICAL_HARMONICS=!1,this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION=!1}}class ko extends ql{_markAllSubMeshesAsMiscDirty(){this._internalMarkAllSubMeshesAsMiscDirty()}constructor(p,_=!0){super(p,"PBRBRDF",90,new pL,_),this._useEnergyConservation=ko.DEFAULT_USE_ENERGY_CONSERVATION,this.useEnergyConservation=ko.DEFAULT_USE_ENERGY_CONSERVATION,this._useSmithVisibilityHeightCorrelated=ko.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED,this.useSmithVisibilityHeightCorrelated=ko.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED,this._useSphericalHarmonics=ko.DEFAULT_USE_SPHERICAL_HARMONICS,this.useSphericalHarmonics=ko.DEFAULT_USE_SPHERICAL_HARMONICS,this._useSpecularGlossinessInputEnergyConservation=ko.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION,this.useSpecularGlossinessInputEnergyConservation=ko.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION,this._internalMarkAllSubMeshesAsMiscDirty=p._dirtyCallbacks[16],this._enable(!0)}prepareDefines(p){p.BRDF_V_HEIGHT_CORRELATED=this._useSmithVisibilityHeightCorrelated,p.MS_BRDF_ENERGY_CONSERVATION=this._useEnergyConservation&&this._useSmithVisibilityHeightCorrelated,p.SPHERICAL_HARMONICS=this._useSphericalHarmonics,p.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION=this._useSpecularGlossinessInputEnergyConservation}getClassName(){return"PBRBRDFConfiguration"}}ko.DEFAULT_USE_ENERGY_CONSERVATION=!0,ko.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED=!0,ko.DEFAULT_USE_SPHERICAL_HARMONICS=!0,ko.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION=!0,Mt([Gt(),ks("_markAllSubMeshesAsMiscDirty")],ko.prototype,"useEnergyConservation",void 0),Mt([Gt(),ks("_markAllSubMeshesAsMiscDirty")],ko.prototype,"useSmithVisibilityHeightCorrelated",void 0),Mt([Gt(),ks("_markAllSubMeshesAsMiscDirty")],ko.prototype,"useSphericalHarmonics",void 0),Mt([Gt(),ks("_markAllSubMeshesAsMiscDirty")],ko.prototype,"useSpecularGlossinessInputEnergyConservation",void 0);class C_{constructor(){this.previousWorldMatrices={},this.previousBones={}}static AddUniforms(p){p.push("previousWorld","previousViewProjection","mPreviousBones")}static AddSamplers(p){}bindForSubMesh(p,_,E,A,$){if(_.prePassRenderer&&_.prePassRenderer.enabled&&_.prePassRenderer.currentRTisSceneRT&&_.prePassRenderer.getIndex(2)!==-1){this.previousWorldMatrices[E.uniqueId]||(this.previousWorldMatrices[E.uniqueId]=A.clone()),this.previousViewProjection||(this.previousViewProjection=_.getTransformMatrix().clone(),this.currentViewProjection=_.getTransformMatrix().clone());const ne=_.getEngine();this.currentViewProjection.updateFlag!==_.getTransformMatrix().updateFlag?(this._lastUpdateFrameId=ne.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection),this.currentViewProjection.copyFrom(_.getTransformMatrix())):this._lastUpdateFrameId!==ne.frameId&&(this._lastUpdateFrameId=ne.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection)),p.setMatrix("previousWorld",this.previousWorldMatrices[E.uniqueId]),p.setMatrix("previousViewProjection",this.previousViewProjection),this.previousWorldMatrices[E.uniqueId]=A.clone()}}}class Ls{static get DiffuseTextureEnabled(){return this._DiffuseTextureEnabled}static set DiffuseTextureEnabled(p){this._DiffuseTextureEnabled!==p&&(this._DiffuseTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get DetailTextureEnabled(){return this._DetailTextureEnabled}static set DetailTextureEnabled(p){this._DetailTextureEnabled!==p&&(this._DetailTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get DecalMapEnabled(){return this._DecalMapEnabled}static set DecalMapEnabled(p){this._DecalMapEnabled!==p&&(this._DecalMapEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get AmbientTextureEnabled(){return this._AmbientTextureEnabled}static set AmbientTextureEnabled(p){this._AmbientTextureEnabled!==p&&(this._AmbientTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get OpacityTextureEnabled(){return this._OpacityTextureEnabled}static set OpacityTextureEnabled(p){this._OpacityTextureEnabled!==p&&(this._OpacityTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get ReflectionTextureEnabled(){return this._ReflectionTextureEnabled}static set ReflectionTextureEnabled(p){this._ReflectionTextureEnabled!==p&&(this._ReflectionTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get EmissiveTextureEnabled(){return this._EmissiveTextureEnabled}static set EmissiveTextureEnabled(p){this._EmissiveTextureEnabled!==p&&(this._EmissiveTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get SpecularTextureEnabled(){return this._SpecularTextureEnabled}static set SpecularTextureEnabled(p){this._SpecularTextureEnabled!==p&&(this._SpecularTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get BumpTextureEnabled(){return this._BumpTextureEnabled}static set BumpTextureEnabled(p){this._BumpTextureEnabled!==p&&(this._BumpTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get LightmapTextureEnabled(){return this._LightmapTextureEnabled}static set LightmapTextureEnabled(p){this._LightmapTextureEnabled!==p&&(this._LightmapTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get RefractionTextureEnabled(){return this._RefractionTextureEnabled}static set RefractionTextureEnabled(p){this._RefractionTextureEnabled!==p&&(this._RefractionTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get ColorGradingTextureEnabled(){return this._ColorGradingTextureEnabled}static set ColorGradingTextureEnabled(p){this._ColorGradingTextureEnabled!==p&&(this._ColorGradingTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get FresnelEnabled(){return this._FresnelEnabled}static set FresnelEnabled(p){this._FresnelEnabled!==p&&(this._FresnelEnabled=p,ui.MarkAllMaterialsAsDirty(4))}static get ClearCoatTextureEnabled(){return this._ClearCoatTextureEnabled}static set ClearCoatTextureEnabled(p){this._ClearCoatTextureEnabled!==p&&(this._ClearCoatTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get ClearCoatBumpTextureEnabled(){return this._ClearCoatBumpTextureEnabled}static set ClearCoatBumpTextureEnabled(p){this._ClearCoatBumpTextureEnabled!==p&&(this._ClearCoatBumpTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get ClearCoatTintTextureEnabled(){return this._ClearCoatTintTextureEnabled}static set ClearCoatTintTextureEnabled(p){this._ClearCoatTintTextureEnabled!==p&&(this._ClearCoatTintTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get SheenTextureEnabled(){return this._SheenTextureEnabled}static set SheenTextureEnabled(p){this._SheenTextureEnabled!==p&&(this._SheenTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get AnisotropicTextureEnabled(){return this._AnisotropicTextureEnabled}static set AnisotropicTextureEnabled(p){this._AnisotropicTextureEnabled!==p&&(this._AnisotropicTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get ThicknessTextureEnabled(){return this._ThicknessTextureEnabled}static set ThicknessTextureEnabled(p){this._ThicknessTextureEnabled!==p&&(this._ThicknessTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get RefractionIntensityTextureEnabled(){return this._ThicknessTextureEnabled}static set RefractionIntensityTextureEnabled(p){this._RefractionIntensityTextureEnabled!==p&&(this._RefractionIntensityTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get TranslucencyIntensityTextureEnabled(){return this._ThicknessTextureEnabled}static set TranslucencyIntensityTextureEnabled(p){this._TranslucencyIntensityTextureEnabled!==p&&(this._TranslucencyIntensityTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}static get IridescenceTextureEnabled(){return this._IridescenceTextureEnabled}static set IridescenceTextureEnabled(p){this._IridescenceTextureEnabled!==p&&(this._IridescenceTextureEnabled=p,ui.MarkAllMaterialsAsDirty(1))}}Ls._DiffuseTextureEnabled=!0,Ls._DetailTextureEnabled=!0,Ls._DecalMapEnabled=!0,Ls._AmbientTextureEnabled=!0,Ls._OpacityTextureEnabled=!0,Ls._ReflectionTextureEnabled=!0,Ls._EmissiveTextureEnabled=!0,Ls._SpecularTextureEnabled=!0,Ls._BumpTextureEnabled=!0,Ls._LightmapTextureEnabled=!0,Ls._RefractionTextureEnabled=!0,Ls._ColorGradingTextureEnabled=!0,Ls._FresnelEnabled=!0,Ls._ClearCoatTextureEnabled=!0,Ls._ClearCoatBumpTextureEnabled=!0,Ls._ClearCoatTintTextureEnabled=!0,Ls._SheenTextureEnabled=!0,Ls._AnisotropicTextureEnabled=!0,Ls._ThicknessTextureEnabled=!0,Ls._RefractionIntensityTextureEnabled=!0,Ls._TranslucencyIntensityTextureEnabled=!0,Ls._IridescenceTextureEnabled=!0;const vC="prePassDeclaration",RC=`#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;Gi.IncludesShadersStore[vC]=RC;const W5={name:vC,shader:RC},MC="oitDeclaration",wC=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;
#endif
`;Gi.IncludesShadersStore[MC]=wC;const X5={name:MC,shader:wC},LC="decalFragmentDeclaration",kC=`#ifdef DECAL
uniform vec4 vDecalInfos;
#endif
`;Gi.IncludesShadersStore[LC]=kC;const K5={name:LC,shader:kC},UC="pbrFragmentDeclaration",GC=`uniform vec4 vEyePosition;uniform vec3 vReflectionColor;uniform vec4 vAlbedoColor;uniform vec4 vLightingIntensity;uniform vec4 vReflectivityColor;uniform vec4 vMetallicReflectanceFactors;uniform vec3 vEmissiveColor;uniform float visibility;uniform vec3 vAmbientColor;
#ifdef ALBEDO
uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform vec4 vAmbientInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef OPACITY
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef REFLECTIVITY
uniform vec3 vReflectivityInfos;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#ifdef REALTIME_FILTERING
uniform vec2 vReflectionFilteringInfo;
#endif
uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#ifdef CLEARCOAT
uniform vec2 vClearCoatParams;uniform vec4 vClearCoatRefractionParams;
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform vec2 vClearCoatTangentSpaceParams;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT
uniform vec4 vClearCoatTintParams;uniform float clearCoatColorAtDistance;
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#endif
#ifdef IRIDESCENCE
uniform vec4 vIridescenceParams;
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
uniform vec3 vAnisotropy;
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
uniform vec4 vSheenColor;
#ifdef SHEEN_ROUGHNESS
uniform float vSheenRoughness;
#endif
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionMicrosurfaceInfos;uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#ifdef REALTIME_FILTERING
uniform vec2 vRefractionFilteringInfo;
#endif
#ifdef SS_DISPERSION
uniform float dispersion;
#endif
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
uniform vec2 vThicknessParam;uniform vec3 vDiffusionDistance;uniform vec4 vTintColor;uniform vec3 vSubSurfaceIntensity;
#endif
#ifdef PREPASS
#ifdef SS_SCATTERING
uniform float scatteringDiffusionProfile;
#endif
#endif
#if DEBUGMODE>0
uniform vec2 vDebugMode;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;Gi.IncludesShadersStore[UC]=GC;const Y5={name:UC,shader:GC},zC="pbrUboDeclaration",WC=`layout(std140,column_major) uniform;uniform Material {vec2 vAlbedoInfos;vec4 vAmbientInfos;vec2 vOpacityInfos;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec3 vReflectivityInfos;vec2 vMicroSurfaceSamplerInfos;vec2 vReflectionInfos;vec2 vReflectionFilteringInfo;vec3 vReflectionPosition;vec3 vReflectionSize;vec3 vBumpInfos;mat4 albedoMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 reflectivityMatrix;mat4 microSurfaceSamplerMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;mat4 reflectionMatrix;vec3 vReflectionColor;vec4 vAlbedoColor;vec4 vLightingIntensity;vec3 vReflectionMicrosurfaceInfos;float pointSize;vec4 vReflectivityColor;vec3 vEmissiveColor;vec3 vAmbientColor;vec2 vDebugMode;vec4 vMetallicReflectanceFactors;vec2 vMetallicReflectanceInfos;mat4 metallicReflectanceMatrix;vec2 vReflectanceInfos;mat4 reflectanceMatrix;vec3 vSphericalL00;vec3 vSphericalL1_1;vec3 vSphericalL10;vec3 vSphericalL11;vec3 vSphericalL2_2;vec3 vSphericalL2_1;vec3 vSphericalL20;vec3 vSphericalL21;vec3 vSphericalL22;vec3 vSphericalX;vec3 vSphericalY;vec3 vSphericalZ;vec3 vSphericalXX_ZZ;vec3 vSphericalYY_ZZ;vec3 vSphericalZZ;vec3 vSphericalXY;vec3 vSphericalYZ;vec3 vSphericalZX;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;Gi.IncludesShadersStore[zC]=WC;const j5={name:zC,shader:WC},HC="mainUVVaryingDeclaration",XC=`#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;Gi.IncludesShadersStore[HC]=XC;const q5={name:HC,shader:XC},KC="pbrFragmentExtraDeclaration",YC=`varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
`;Gi.IncludesShadersStore[KC]=YC;const $5={name:KC,shader:YC},jC="lightFragmentDeclaration",qC=`#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#endif
`;Gi.IncludesShadersStore[jC]=qC;const rV={name:jC,shader:qC},$C="lightUboDeclaration",rR=`#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;Gi.IncludesShadersStore[$C]=rR;const nV={name:$C,shader:rR},nR="samplerFragmentDeclaration",aR=`#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;Gi.IncludesShadersStore[nR]=aR;const aV={name:nR,shader:aR},xR="samplerFragmentAlternateDeclaration",lR=`#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
#endif
`;Gi.IncludesShadersStore[xR]=lR;const xV={name:xR,shader:lR},hR="pbrFragmentSamplersDeclaration",cR=`#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)
#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef CLEARCOAT
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D clearCoatRoughnessSampler;
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D sheenRoughnessSampler;
#endif
#endif
#ifdef ANISOTROPIC
#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)
#endif
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
#define sampleReflection(s,c) textureCube(s,c)
uniform samplerCube reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform samplerCube irradianceSampler;
#endif
#else
#define sampleReflection(s,c) texture2D(s,c)
uniform sampler2D reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D reflectionSamplerLow;uniform sampler2D reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform sampler2D irradianceSampler;
#endif
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#endif
#ifdef ENVIRONMENTBRDF
uniform sampler2D environmentBrdfSampler;
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#ifdef SS_REFRACTIONMAP_3D
#define sampleRefraction(s,c) textureCube(s,c)
uniform samplerCube refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube refractionSamplerLow;uniform samplerCube refractionSamplerHigh;
#endif
#else
#define sampleRefraction(s,c) texture2D(s,c)
uniform sampler2D refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D refractionSamplerLow;uniform sampler2D refractionSamplerHigh;
#endif
#endif
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)
#endif
`;Gi.IncludesShadersStore[hR]=cR;const lV={name:hR,shader:cR},uR="imageProcessingDeclaration",pR=`#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;Gi.IncludesShadersStore[uR]=pR;const hV={name:uR,shader:pR},_R="logDepthDeclaration",TR=`#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;varying float vFragmentDepth;
#endif
`;Gi.IncludesShadersStore[_R]=TR;const cV={name:_R,shader:TR},vR="fogFragmentDeclaration",RR=`#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()
{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)
{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}
else if (FOGMODE_EXP==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}
else if (FOGMODE_EXP2==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}
return clamp(fogCoeff,0.0,1.0);}
#endif
`;Gi.IncludesShadersStore[vR]=RR;const uV={name:vR,shader:RR},MR="subSurfaceScatteringFunctions",wR=`bool testLightingForSSS(float diffusionProfile)
{return diffusionProfile<1.;}`;Gi.IncludesShadersStore[MR]=wR;const pV={name:MR,shader:wR},LR="importanceSampling",kR=`vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { 
float phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}`;Gi.IncludesShadersStore[LR]=kR;const _V={name:LR,shader:kR},UR="pbrHelperFunctions",GR=`#define MINIMUMVARIANCE 0.0005
float convertRoughnessToAverageSlope(float roughness)
{return square(roughness)+MINIMUMVARIANCE;}
float fresnelGrazingReflectance(float reflectance0) {float reflectance90=saturate(reflectance0*25.0);return reflectance90;}
vec2 getAARoughnessFactors(vec3 normalVector) {
#ifdef SPECULARAA
vec3 nDfdx=dFdx(normalVector.xyz);vec3 nDfdy=dFdy(normalVector.xyz);float slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));float geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);float geometricAlphaGFactor=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2(geometricRoughnessFactor,geometricAlphaGFactor);
#else
return vec2(0.);
#endif
}
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_LEGACY
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;vec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);vec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);vec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}
#else
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG,MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 bentNormal=cross(B,V);bentNormal=normalize(cross(bentNormal,B));float a=square(square(1.0-anisotropy*(1.0-roughness)));bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}
#endif
#endif
#if defined(CLEARCOAT) || defined(SS_REFRACTION)
vec3 cocaLambert(vec3 alpha,float distance) {return exp(-alpha*distance);}
vec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {return cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}
vec3 computeColorAtDistanceInMedia(vec3 color,float distance) {return -log(color)/distance;}
vec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 clearCoatAbsorption=mix(vec3(1.0),
cocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),
clearCoatIntensity);return clearCoatAbsorption;}
#endif
#ifdef MICROSURFACEAUTOMATIC
float computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)
{const float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;float reflectivityLuminance=getLuminance(reflectivityColor);float reflectivityLuma=sqrt(reflectivityLuminance);microSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return microSurface;}
#endif
`;Gi.IncludesShadersStore[UR]=GR;const TV={name:UR,shader:GR},zR="imageProcessingFunctions",WR=`#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);vec3 RRTAndODTFit(vec3 v)
{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
vec3 ACESFitted(vec3 color)
{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;}`;Gi.IncludesShadersStore[zR]=WR;const vV={name:zR,shader:WR},HR="shadowsFragmentFunctions",XR=`#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
#define inline
float computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);}
#define inline
float computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}
#define inline
float computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
/* disable_uniformity_analysis */
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.)
);const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}
else
{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
if (numBlocker<1.0) {return 1.0;}
else
{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
#endif
`;Gi.IncludesShadersStore[HR]=XR;const RV={name:HR,shader:XR},KR="harmonicsFunctions",YR=`#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
vec3 computeEnvironmentIrradiance(vec3 normal) {return vSphericalL00
+ vSphericalL1_1*(normal.y)
+ vSphericalL10*(normal.z)
+ vSphericalL11*(normal.x)
+ vSphericalL2_2*(normal.y*normal.x)
+ vSphericalL2_1*(normal.y*normal.z)
+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)
+ vSphericalL21*(normal.z*normal.x)
+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}
#else
vec3 computeEnvironmentIrradiance(vec3 normal) {float Nx=normal.x;float Ny=normal.y;float Nz=normal.z;vec3 C1=vSphericalZZ.rgb;vec3 Cx=vSphericalX.rgb;vec3 Cy=vSphericalY.rgb;vec3 Cz=vSphericalZ.rgb;vec3 Cxx_zz=vSphericalXX_ZZ.rgb;vec3 Cyy_zz=vSphericalYY_ZZ.rgb;vec3 Cxy=vSphericalXY.rgb;vec3 Cyz=vSphericalYZ.rgb;vec3 Czx=vSphericalZX.rgb;vec3 a1=Cyy_zz*Ny+Cy;vec3 a2=Cyz*Nz+a1;vec3 b1=Czx*Nz+Cx;vec3 b2=Cxy*Ny+b1;vec3 b3=Cxx_zz*Nx+b2;vec3 t1=Cz *Nz+C1;vec3 t2=a2 *Ny+t1;vec3 t3=b3 *Nx+t2;return t3;}
#endif
#endif
`;Gi.IncludesShadersStore[KR]=YR;const MV={name:KR,shader:YR},jR="pbrDirectLightingSetupFunctions",qR=`struct preLightingInfo
{vec3 lightOffset;float lightDistanceSquared;float lightDistance;float attenuation;vec3 L;vec3 H;float NdotV;float NdotLUnclamped;float NdotL;float VdotH;float roughness;
#ifdef IRIDESCENCE
float iridescenceIntensity;
#endif
};preLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightOffset=lightData.xyz-vPositionW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;
#ifdef SPECULARTERM
result.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));
#endif
return result;}`;Gi.IncludesShadersStore[jR]=qR;const wV={name:jR,shader:qR},$R="pbrDirectLightingFalloffFunctions",rI=`float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)
{return max(0.,1.0-length(lightOffset)/range);}
float computeDistanceLightFalloff_Physical(float lightDistanceSquared)
{return 1.0/maxEps(lightDistanceSquared);}
float computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)
{float lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);float factor=lightDistanceSquared*inverseSquaredRange;float attenuation=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}
float computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDistanceLightFalloff_Physical(lightDistanceSquared);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);
#else
return computeDistanceLightFalloff_Standard(lightOffset,range);
#endif
}
float computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)
{float falloff=0.0;float cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)
{falloff=max(0.,pow(cosAngle,exponent));}
return falloff;}
float computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)
{const float kMinusLog2ConeAngleIntensityRatio=6.64385618977; 
float concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);vec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);float falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}
float computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)
{float cd=dot(-lightDirection,directionToLightCenterW);float falloff=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}
float computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);
#else
return computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);
#endif
}`;Gi.IncludesShadersStore[$R]=rI;const LV={name:$R,shader:rI},nI="pbrBRDFFunctions",aI=`#define FRESNEL_MAXIMUM_ON_ROUGH 0.25
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}
#endif
#ifdef ENVIRONMENTBRDF
vec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);
#ifdef ENVIRONMENTBRDF_RGBD
brdfLookup.rgb=fromRGBD(brdfLookup.rgba);
#endif
return brdfLookup.rgb;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;
#endif
return reflectance;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;
#endif
return reflectance;}
#endif
/* NOT USED
#if defined(SHEEN) && defined(SHEEN_SOFTER)
float getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)
{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}
#endif
*/
#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)
vec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)
{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
/**
* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.
* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table
*/
vec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}
#endif
vec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
float fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
#ifdef CLEARCOAT
vec3 getR0RemappedForClearCoat(vec3 f0) {
#ifdef CLEARCOAT_DEFAULTIOR
#ifdef MOBILE
return saturate(f0*(f0*0.526868+0.529324)-0.0482256);
#else
return saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);
#endif
#else
vec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);
#endif
}
#endif
#ifdef IRIDESCENCE
const mat3 XYZ_TO_REC709=mat3(
3.2404542,-0.9692660, 0.0556434,
-1.5371385, 1.8760108,-0.2040259,
-0.4985314, 0.0415560, 1.0572252
);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}
vec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}
float getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}
vec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}
vec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}
float cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); 
vec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)
{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}
return max(I,vec3(0.0));}
#endif
float normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)
{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}
#ifdef SHEEN
float normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)
{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}
#endif
#ifdef ANISOTROPIC
float normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}
#endif
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {
#ifdef MOBILE
float GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);
#else
float a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);
#endif
}
#else
float smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)
{
#ifdef MOBILE
return 1.0/(dot+alphaG+(1.0-alphaG)*dot ));
#else
float alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));
#endif
}
float smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)
{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}
#endif
#ifdef ANISOTROPIC
float smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}
#endif
#ifdef CLEARCOAT
float visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }
#endif
#ifdef SHEEN
float visibility_Ashikhmin(float NdotL,float NdotV)
{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}
/* NOT USED
#ifdef SHEEN_SOFTER
float l(float x,float alphaG)
{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}
float lambdaSheen(float cosTheta,float alphaG)
{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}
float visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)
{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}
#endif
*/
#endif
float diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}
#ifdef SS_TRANSLUCENCY
vec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}
float computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}
#endif
`;Gi.IncludesShadersStore[nI]=aI;const kV={name:nI,shader:aI},xI="hdrFilteringFunctions",lI=`#ifdef NUM_SAMPLES
#if NUM_SAMPLES>0
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
float radicalInverse_VdC(uint bits) 
{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }
vec2 hammersley(uint i,uint N)
{return vec2(float(i)/float(N),radicalInverse_VdC(i));}
#else
float vanDerCorpus(int n,int base)
{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)
{if(n>0)
{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}
return result;}
vec2 hammersley(int i,int N)
{return vec2(float(i)/float(N),vanDerCorpus(i,2));}
#endif
float log4(float x) {return log2(x)/2.;}
const float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;
#define inline
vec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c;}}
result=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}
#define inline
vec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 c=textureCube(inputTexture,n).rgb; 
if (alphaG==0.) {
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
return c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c*NoL;}}
result=result/weight;return result;}}
#endif
#endif
`;Gi.IncludesShadersStore[xI]=lI;const UV={name:xI,shader:lI},hI="pbrDirectLightingFunctions",cI=`#define CLEARCOATREFLECTANCE90 1.0
struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef CLEARCOAT
vec4 clearCoat;
#endif
#ifdef SHEEN
vec3 sheen;
#endif
};float adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {
#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)
float lightRoughness=lightRadius/lightDistance;float totalRoughness=saturate(lightRoughness+roughness);return totalRoughness;
#else
return roughness;
#endif
}
vec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {return mix(groundColor,lightColor,info.NdotL);}
vec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {float diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return toLinearSpace(textureColor);}
#ifdef SS_TRANSLUCENCY
vec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {float NdotL=absEps(info.NdotLUnclamped);float wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);float trAdapt=step(0.,info.NdotLUnclamped);vec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);float diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}
#endif
#ifdef SPECULARTERM
vec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);
#else
float smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);
#endif
vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef ANISOTROPIC
vec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float TdotH=dot(T,info.H);float BdotH=dot(B,info.H);float TdotV=dot(T,V);float BdotV=dot(B,V);float TdotL=dot(T,info.L);float BdotL=dot(B,info.L);float alphaG=convertRoughnessToAverageSlope(info.roughness);vec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,square(geometricRoughnessFactor));vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);float smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef CLEARCOAT
vec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {float NccdotL=saturateEps(dot(Ncc,info.L));float NccdotH=saturateEps(dot(Ncc,info.H));float clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);float fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);float kelemenVisibility=visibility_Kelemen(info.VdotH);float clearCoatTerm=fresnel*distribution*kelemenVisibility;return vec4(
clearCoatTerm*info.attenuation*NccdotL*lightColor,
1.0-fresnel
);}
vec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);float NdotLRefract=saturateEps(dot(Ncc,LRefract));vec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}
#endif
#ifdef SHEEN
vec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);float fresnel=1.;float distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER
float visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);
#else */
float visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */
float sheenTerm=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}
#endif
`;Gi.IncludesShadersStore[hI]=cI;const GV={name:hI,shader:cI},uI="pbrIBLFunctions",pI=`#if defined(REFLECTION) || defined(SS_REFRACTION)
float getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {float microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;float lod=log2(microsurfaceAverageSlopeTexels);return lod;}
float getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {float lod=log2(cubeMapDimensionPixels)*roughness;return lod;}
#endif
#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)
float environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {float temp=NdotVUnclamped+ambientOcclusion;return saturate(square(temp)-1.0+ambientOcclusion);}
#endif
#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)
float environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {vec3 reflection=reflect(view,normal);float temp=saturate(1.0+1.1*dot(reflection,geometricNormal));return square(temp);}
#endif
#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)
#define UNPACK_LOD(x) (1.0-x)*255.0
float getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {float microsurfaceAverageSlope=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}
#endif
`;Gi.IncludesShadersStore[uI]=pI;const zV={name:uI,shader:pI},_I="bumpFragmentMainFunctions",TI=`#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#if defined(WEBGL2) || defined(WEBGPU)
mat4 toNormalMatrix(mat4 wMatrix)
{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}
#else
mat4 toNormalMatrix(mat4 m)
{float
a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],
a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],
a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],
a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],
b00=a00*a11-a01*a10,
b01=a00*a12-a02*a10,
b02=a00*a13-a03*a10,
b03=a01*a12-a02*a11,
b04=a01*a13-a03*a11,
b05=a02*a13-a03*a12,
b06=a20*a31-a21*a30,
b07=a20*a32-a22*a30,
b08=a20*a33-a23*a30,
b09=a21*a32-a22*a31,
b10=a21*a33-a23*a31,
b11=a22*a33-a23*a32,
det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(
a11*b11-a12*b10+a13*b09,
a02*b10-a01*b11-a03*b09,
a31*b05-a32*b04+a33*b03,
a22*b04-a21*b05-a23*b03,
a12*b08-a10*b11-a13*b07,
a00*b11-a02*b08+a03*b07,
a32*b02-a30*b05-a33*b01,
a20*b05-a22*b02+a23*b01,
a10*b10-a11*b08+a13*b06,
a01*b08-a00*b10-a03*b06,
a30*b04-a31*b02+a33*b00,
a21*b02-a20*b04-a23*b00,
a11*b07-a10*b09-a12*b06,
a00*b09-a01*b07+a02*b06,
a31*b01-a30*b03-a32*b00,
a20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}
#endif
`;Gi.IncludesShadersStore[_I]=TI;const WV={name:_I,shader:TI},vI="bumpFragmentFunctions",RI=`#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)
{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;
#ifdef PARALLAX_RHS
vCurrOffset-=stepSize*vMaxOffset;
#else
vCurrOffset+=stepSize*vMaxOffset;
#endif
lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;
#ifdef PARALLAX_RHS
return texCoordOffset;
#else
return -texCoordOffset;
#endif
}
#endif
`;Gi.IncludesShadersStore[vI]=RI;const HV={name:vI,shader:RI},MI="reflectionFunction",wI=`vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*(view*worldPos));}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*vec4(positionW,1.));}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;Gi.IncludesShadersStore[MI]=wI;const XV={name:MI,shader:wI},LI="decalFragment",kI=`#ifdef DECAL
#ifdef GAMMADECAL
decalColor.rgb=toLinearSpace(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalColor.a*=decalColor.a;
#endif
surfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);
#endif
`;Gi.IncludesShadersStore[LI]=kI;const KV={name:LI,shader:kI},UI="pbrBlockAlbedoOpacity",GI=`struct albedoOpacityOutParams
{vec3 surfaceAlbedo;float alpha;};
#define pbr_inline
void albedoOpacityBlock(
in vec4 vAlbedoColor,
#ifdef ALBEDO
in vec4 albedoTexture,
in vec2 albedoInfos,
#endif
#ifdef OPACITY
in vec4 opacityMap,
in vec2 vOpacityInfos,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
#ifdef DECAL
in vec4 decalColor,
in vec4 vDecalInfos,
#endif
out albedoOpacityOutParams outParams
)
{vec3 surfaceAlbedo=vAlbedoColor.rgb;float alpha=vAlbedoColor.a;
#ifdef ALBEDO
#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)
alpha*=albedoTexture.a;
#endif
#ifdef GAMMAALBEDO
surfaceAlbedo*=toLinearSpace(albedoTexture.rgb);
#else
surfaceAlbedo*=albedoTexture.rgb;
#endif
surfaceAlbedo*=albedoInfos.y;
#endif
#ifndef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
surfaceAlbedo*=vColor.rgb;
#endif
#ifdef DETAIL
float detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; 
#endif
#ifdef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALBEDO
#ifdef OPACITY
#ifdef OPACITYRGB
alpha=getLuminance(opacityMap.rgb);
#else
alpha*=opacityMap.a;
#endif
alpha*=vOpacityInfos.y;
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)
#ifdef ALPHATEST 
#if DEBUGMODE != 88
if (alpha<ALPHATESTVALUE)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
#endif
outParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;}
`;Gi.IncludesShadersStore[UI]=GI;const YV={name:UI,shader:GI},zI="pbrBlockReflectivity",WI=`struct reflectivityOutParams
{float microSurface;float roughness;vec3 surfaceReflectivityColor;
#ifdef METALLICWORKFLOW
vec3 surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
vec3 ambientOcclusionColor;
#endif
#if DEBUGMODE>0
#ifdef METALLICWORKFLOW
vec2 metallicRoughness;
#ifdef REFLECTIVITY
vec4 surfaceMetallicColorMap;
#endif
#ifndef FROSTBITE_REFLECTANCE
vec3 metallicF0;
#endif
#else
#ifdef REFLECTIVITY
vec4 surfaceReflectivityColorMap;
#endif
#endif
#endif
};
#define pbr_inline
void reflectivityBlock(
in vec4 vReflectivityColor,
#ifdef METALLICWORKFLOW
in vec3 surfaceAlbedo,
in vec4 metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
in vec3 reflectivityInfos,
in vec4 surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
in vec3 ambientOcclusionColorIn,
#endif
#ifdef MICROSURFACEMAP
in vec4 microSurfaceTexel,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
out reflectivityOutParams outParams
)
{float microSurface=vReflectivityColor.a;vec3 surfaceReflectivityColor=vReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec2 metallicRoughness=surfaceReflectivityColor.rg;
#ifdef REFLECTIVITY
#if DEBUGMODE>0
outParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef AOSTOREINMETALMAPRED
vec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);
#endif
#ifdef METALLNESSSTOREINMETALMAPBLUE
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;
#else
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;
#endif
#ifdef ROUGHNESSSTOREINMETALMAPALPHA
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;
#else
#ifdef ROUGHNESSSTOREINMETALMAPGREEN
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;
#endif
#endif
#endif
#ifdef DETAIL
float detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);float loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);float hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));
#endif
#ifdef MICROSURFACEMAP
metallicRoughness.g*=microSurfaceTexel.r;
#endif
#if DEBUGMODE>0
outParams.metallicRoughness=metallicRoughness;
#endif
#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS
microSurface=1.0-metallicRoughness.g;vec3 baseColor=surfaceAlbedo;
#ifdef FROSTBITE_REFLECTANCE
outParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);
#else
vec3 metallicF0=metallicReflectanceFactors.rgb;
#if DEBUGMODE>0
outParams.metallicF0=metallicF0;
#endif
outParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);
#endif
#else
#ifdef REFLECTIVITY
surfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;
#if DEBUGMODE>0
outParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef MICROSURFACEFROMREFLECTIVITYMAP
microSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;
#else
#ifdef MICROSURFACEAUTOMATIC
microSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);
#endif
#ifdef MICROSURFACEMAP
microSurface*=microSurfaceTexel.r;
#endif
#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE
#endif
#endif
#endif
microSurface=saturate(microSurface);float roughness=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;}
`;Gi.IncludesShadersStore[zI]=WI;const jV={name:zI,shader:WI},HI="pbrBlockAmbientOcclusion",XI=`struct ambientOcclusionOutParams
{vec3 ambientOcclusionColor;
#if DEBUGMODE>0 && defined(AMBIENT)
vec3 ambientOcclusionColorMap;
#endif
};
#define pbr_inline
void ambientOcclusionBlock(
#ifdef AMBIENT
in vec3 ambientOcclusionColorMap_,
in vec4 vAmbientInfos,
#endif
out ambientOcclusionOutParams outParams
)
{vec3 ambientOcclusionColor=vec3(1.,1.,1.);
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;
#ifdef AMBIENTINGRAYSCALE
ambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);
#endif
ambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);
#if DEBUGMODE>0
outParams.ambientOcclusionColorMap=ambientOcclusionColorMap;
#endif
#endif
outParams.ambientOcclusionColor=ambientOcclusionColor;}
`;Gi.IncludesShadersStore[HI]=XI;const qV={name:HI,shader:XI},KI="pbrBlockAlphaFresnel",YI=`#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
struct alphaFresnelOutParams
{float alpha;};
#define pbr_inline
void alphaFresnelBlock(
in vec3 normalW,
in vec3 viewDirectionW,
in float alpha,
in float microSurface,
out alphaFresnelOutParams outParams
)
{float opacityPerceptual=alpha;
#ifdef LINEARALPHAFRESNEL
float opacity0=opacityPerceptual;
#else
float opacity0=opacityPerceptual*opacityPerceptual;
#endif
float opacity90=fresnelGrazingReflectance(opacity0);vec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;
#ifdef ALPHATEST
if (outParams.alpha<ALPHATESTVALUE)
discard;
#ifndef ALPHABLEND
outParams.alpha=1.0;
#endif
#endif
}
#endif
#endif
`;Gi.IncludesShadersStore[KI]=YI;const $V={name:KI,shader:YI},jI="pbrBlockAnisotropic",qI=`#ifdef ANISOTROPIC
struct anisotropicOutParams
{float anisotropy;vec3 anisotropicTangent;vec3 anisotropicBitangent;vec3 anisotropicNormal;
#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)
vec3 anisotropyMapData;
#endif
};
#define pbr_inline
void anisotropicBlock(
in vec3 vAnisotropy,
in float roughness,
#ifdef ANISOTROPIC_TEXTURE
in vec3 anisotropyMapData,
#endif
in mat3 TBN,
in vec3 normalW,
in vec3 viewDirectionW,
out anisotropicOutParams outParams
)
{float anisotropy=vAnisotropy.b;vec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);
#ifdef ANISOTROPIC_TEXTURE
anisotropy*=anisotropyMapData.b;
#if DEBUGMODE>0
outParams.anisotropyMapData=anisotropyMapData;
#endif
anisotropyMapData.rg=anisotropyMapData.rg*2.0-1.0;
#ifdef ANISOTROPIC_LEGACY
anisotropyDirection.rg*=anisotropyMapData.rg;
#else
anisotropyDirection.xy=mat2(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(anisotropyMapData.rg);
#endif
#endif
mat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));vec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);vec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);}
#endif
`;Gi.IncludesShadersStore[jI]=qI;const r6={name:jI,shader:qI},$I="pbrBlockReflection",rM=`#ifdef REFLECTION
struct reflectionOutParams
{vec4 environmentRadiance;vec3 environmentIrradiance;
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords;
#else
vec2 reflectionCoords;
#endif
#ifdef SS_TRANSLUCENCY
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
vec3 irradianceVector;
#endif
#endif
#endif
};
#define pbr_inline
void createReflectionCoords(
in vec3 vPositionW,
in vec3 normalW,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REFLECTIONMAP_3D
out vec3 reflectionCoords
#else
out vec2 reflectionCoords
#endif
)
{
#ifdef ANISOTROPIC
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);
#else
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
reflectionCoords=reflectionVector;
#else
reflectionCoords=reflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
reflectionCoords/=reflectionVector.z;
#endif
reflectionCoords.y=1.0-reflectionCoords.y;
#endif
}
#define pbr_inline
#define inline
void sampleReflectionTexture(
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
const vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
const vec2 reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out vec4 environmentRadiance
)
{
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);
#elif defined(LINEARSPECULARREFLECTION)
float reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);
#else
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);
#endif
#ifdef LODBASEDMICROSFURACE
reflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;
#ifdef LODINREFLECTIONALPHA
float automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);float requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);
#else
float requestedReflectionLOD=reflectionLOD;
#endif
#ifdef REALTIME_FILTERING
environmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);
#else
environmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);
#endif
#else
float lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(
sampleReflection(reflectionSamplerHigh,reflectionCoords),
environmentMid,
lodReflectionNormalizedDoubled
);} else {environmentRadiance=mix(
environmentMid,
sampleReflection(reflectionSamplerLow,reflectionCoords),
lodReflectionNormalizedDoubled-1.0
);}
#endif
#ifdef RGBDREFLECTION
environmentRadiance.rgb=fromRGBD(environmentRadiance);
#endif
#ifdef GAMMAREFLECTION
environmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);
#endif
environmentRadiance.rgb*=vReflectionInfos.x;environmentRadiance.rgb*=vReflectionColor.rgb;}
#define pbr_inline
#define inline
void reflectionBlock(
in vec3 vPositionW,
in vec3 normalW,
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
in vec3 vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in mat4 reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out reflectionOutParams outParams
)
{vec4 environmentRadiance=vec4(0.,0.,0.,0.);
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords=vec3(0.);
#else
vec2 reflectionCoords=vec2(0.);
#endif
createReflectionCoords(
vPositionW,
normalW,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
reflectionCoords
);sampleReflectionTexture(
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
#ifdef REFLECTIONMAP_3D
reflectionSampler,
reflectionCoords,
#else
reflectionSampler,
reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentRadiance
);vec3 environmentIrradiance=vec3(0.,0.,0.);
#ifdef USESPHERICALFROMREFLECTIONMAP
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
environmentIrradiance=vEnvironmentIrradiance;
#else
#ifdef ANISOTROPIC
vec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;
#else
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#if defined(REALTIME_FILTERING)
environmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);
#else
environmentIrradiance=computeEnvironmentIrradiance(irradianceVector);
#endif
#ifdef SS_TRANSLUCENCY
outParams.irradianceVector=irradianceVector;
#endif
#endif
#elif defined(USEIRRADIANCEMAP)
vec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;
#ifdef RGBDREFLECTION
environmentIrradiance.rgb=fromRGBD(environmentIrradiance4);
#endif
#ifdef GAMMAREFLECTION
environmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);
#endif
#endif
environmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;}
#endif
`;Gi.IncludesShadersStore[$I]=rM;const n6={name:$I,shader:rM},nM="pbrBlockSheen",aM=`#ifdef SHEEN
struct sheenOutParams
{float sheenIntensity;vec3 sheenColor;float sheenRoughness;
#ifdef SHEEN_LINKWITHALBEDO
vec3 surfaceAlbedo;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
float sheenAlbedoScaling;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 finalSheenRadianceScaled;
#endif
#if DEBUGMODE>0
#ifdef SHEEN_TEXTURE
vec4 sheenMapData;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 sheenEnvironmentReflectance;
#endif
#endif
};
#define pbr_inline
#define inline
void sheenBlock(
in vec4 vSheenColor,
#ifdef SHEEN_ROUGHNESS
in float vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 sheenMapRoughnessData,
#endif
#endif
in float roughness,
#ifdef SHEEN_TEXTURE
in vec4 sheenMapData,
in float sheenMapLevel,
#endif
in float reflectance,
#ifdef SHEEN_LINKWITHALBEDO
in vec3 baseColor,
in vec3 surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
in float NdotV,
in vec3 environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
in vec2 AARoughnessFactors,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
in vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
in vec2 reflectionCoords,
#endif
in float NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
in float seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
in float eho,
#endif
#endif
out sheenOutParams outParams
)
{float sheenIntensity=vSheenColor.a;
#ifdef SHEEN_TEXTURE
#if DEBUGMODE>0
outParams.sheenMapData=sheenMapData;
#endif
#endif
#ifdef SHEEN_LINKWITHALBEDO
float sheenFactor=pow5(1.0-sheenIntensity);vec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);float sheenRoughness=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#else
vec3 sheenColor=vSheenColor.rgb;
#ifdef SHEEN_TEXTURE
#ifdef SHEEN_GAMMATEXTURE
sheenColor.rgb*=toLinearSpace(sheenMapData.rgb);
#else
sheenColor.rgb*=sheenMapData.rgb;
#endif
sheenColor.rgb*=sheenMapLevel;
#endif
#ifdef SHEEN_ROUGHNESS
float sheenRoughness=vSheenRoughness;
#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE
#if defined(SHEEN_TEXTURE)
sheenRoughness*=sheenMapData.a;
#endif
#elif defined(SHEEN_TEXTURE_ROUGHNESS)
#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL
sheenRoughness*=sheenMapData.a;
#else
sheenRoughness*=sheenMapRoughnessData.a;
#endif
#endif
#else
float sheenRoughness=roughness;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#endif
#if !defined(SHEEN_ALBEDOSCALING)
sheenIntensity*=(1.-reflectance);
#endif
sheenColor*=sheenIntensity;
#endif
#ifdef ENVIRONMENTBRDF
/*#ifdef SHEEN_SOFTER
vec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));
#else*/
#ifdef SHEEN_ROUGHNESS
vec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);
#else
vec3 environmentSheenBrdf=environmentBrdf;
#endif
/*#endif*/
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
float sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);
#ifdef SPECULARAA
sheenAlphaG+=AARoughnessFactors.y;
#endif
vec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);sampleReflectionTexture(
sheenAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
sheenRoughness,
#endif
reflectionSampler,
reflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentSheenRadiance
);vec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
sheenEnvironmentReflectance*=seo;
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
sheenEnvironmentReflectance*=eho;
#endif
#if DEBUGMODE>0
outParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;
#endif
outParams.finalSheenRadianceScaled=
environmentSheenRadiance.rgb *
sheenEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
outParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;
#endif
outParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;}
#endif
`;Gi.IncludesShadersStore[nM]=aM;const a6={name:nM,shader:aM},xM="pbrBlockClearcoat",lM=`struct clearcoatOutParams
{vec3 specularEnvironmentR0;float conservationFactor;vec3 clearCoatNormalW;vec2 clearCoatAARoughnessFactors;float clearCoatIntensity;float clearCoatRoughness;
#ifdef REFLECTION
vec3 finalClearCoatRadianceScaled;
#endif
#ifdef CLEARCOAT_TINT
vec3 absorption;float clearCoatNdotVRefract;vec3 clearCoatColor;float clearCoatThickness;
#endif
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
vec3 energyConservationFactorClearCoat;
#endif
#if DEBUGMODE>0
#ifdef CLEARCOAT_BUMP
mat3 TBNClearCoat;
#endif
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData;
#endif
#ifdef REFLECTION
vec4 environmentClearCoatRadiance;vec3 clearCoatEnvironmentReflectance;
#endif
float clearCoatNdotV;
#endif
};
#ifdef CLEARCOAT
#define pbr_inline
#define inline
void clearcoatBlock(
in vec3 vPositionW,
in vec3 geometricNormalW,
in vec3 viewDirectionW,
in vec2 vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 clearCoatMapRoughnessData,
#endif
in vec3 specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
in vec4 vClearCoatTintParams,
in float clearCoatColorAtDistance,
in vec4 vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
in vec4 clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
in vec2 vClearCoatBumpInfos,
in vec4 clearCoatBumpMapData,
in vec2 vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
in mat3 vTBN,
#else
in vec2 vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
in mat4 normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
in vec3 faceNormal,
#endif
#ifdef REFLECTION
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
in float ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
in float frontFacingMultiplier,
#endif
out clearcoatOutParams outParams
)
{float clearCoatIntensity=vClearCoatParams.x;float clearCoatRoughness=vClearCoatParams.y;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE
clearCoatRoughness*=clearCoatMapData.y;
#endif
#if DEBUGMODE>0
outParams.clearCoatMapData=clearCoatMapData;
#endif
#endif
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL
clearCoatRoughness*=clearCoatMapData.y;
#else
clearCoatRoughness*=clearCoatMapRoughnessData.y;
#endif
#endif
outParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;
#ifdef CLEARCOAT_TINT
vec3 clearCoatColor=vClearCoatTintParams.rgb;float clearCoatThickness=vClearCoatTintParams.a;
#ifdef CLEARCOAT_TINT_TEXTURE
#ifdef CLEARCOAT_TINT_GAMMATEXTURE
clearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);
#else
clearCoatColor*=clearCoatTintMapData.rgb;
#endif
clearCoatThickness*=clearCoatTintMapData.a;
#if DEBUGMODE>0
outParams.clearCoatTintMapData=clearCoatTintMapData;
#endif
#endif
outParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;
#endif
#ifdef CLEARCOAT_REMAP_F0
vec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);
#else
vec3 specularEnvironmentR0Updated=specularEnvironmentR0;
#endif
outParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);vec3 clearCoatNormalW=geometricNormalW;
#ifdef CLEARCOAT_BUMP
#ifdef NORMALXYSCALE
float clearCoatNormalScale=1.0;
#else
float clearCoatNormalScale=vClearCoatBumpInfos.y;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBNClearCoat=vTBN;
#else
vec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;mat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);
#endif
#if DEBUGMODE>0
outParams.TBNClearCoat=TBNClearCoat;
#endif
#ifdef OBJECTSPACE_NORMALMAP
clearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);
#else
clearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
clearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
clearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;
#endif
outParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);float clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);float clearCoatNdotV=absEps(clearCoatNdotVUnclamped);
#if DEBUGMODE>0
outParams.clearCoatNdotV=clearCoatNdotV;
#endif
#ifdef CLEARCOAT_TINT
vec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));
#endif
#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))
vec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);
#endif
#if defined(REFLECTION)
float clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);
#ifdef SPECULARAA
clearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;
#endif
vec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);vec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
clearCoatReflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
vec3 clearCoatReflectionCoords=clearCoatReflectionVector;
#else
vec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
clearCoatReflectionCoords/=clearCoatReflectionVector.z;
#endif
clearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;
#endif
sampleReflectionTexture(
clearCoatAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
clearCoatNdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
clearCoatRoughness,
#endif
reflectionSampler,
clearCoatReflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentClearCoatRadiance
);
#if DEBUGMODE>0
outParams.environmentClearCoatRadiance=environmentClearCoatRadiance;
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;
#endif
#endif
#endif
#else
vec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));
#endif
clearCoatEnvironmentReflectance*=clearCoatIntensity;
#if DEBUGMODE>0
outParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;
#endif
outParams.finalClearCoatRadianceScaled=
environmentClearCoatRadiance.rgb *
clearCoatEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(CLEARCOAT_TINT)
outParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);
#endif
float fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
outParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);
#endif
}
#endif
`;Gi.IncludesShadersStore[xM]=lM;const x6={name:xM,shader:lM},hM="pbrBlockIridescence",cM=`struct iridescenceOutParams
{float iridescenceIntensity;float iridescenceIOR;float iridescenceThickness;vec3 specularEnvironmentR0;};
#ifdef IRIDESCENCE
#define pbr_inline
#define inline
void iridescenceBlock(
in vec4 vIridescenceParams,
in float viewAngle,
in vec3 specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
in vec2 iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
in vec2 iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
in float NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#endif
out iridescenceOutParams outParams
)
{float iridescenceIntensity=vIridescenceParams.x;float iridescenceIOR=vIridescenceParams.y;float iridescenceThicknessMin=vIridescenceParams.z;float iridescenceThicknessMax=vIridescenceParams.w;float iridescenceThicknessWeight=1.;
#ifdef IRIDESCENCE_TEXTURE
iridescenceIntensity*=iridescenceMapData.x;
#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE
iridescenceThicknessWeight=iridescenceMapData.g;
#endif
#endif
#if defined(IRIDESCENCE_THICKNESS_TEXTURE)
iridescenceThicknessWeight=iridescenceThicknessMapData.g;
#endif
float iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);float topIor=1.; 
#ifdef CLEARCOAT
float clearCoatIntensity=vClearCoatParams.x;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#endif
topIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));
#endif
vec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;}
#endif
`;Gi.IncludesShadersStore[hM]=cM;const l6={name:hM,shader:cM},uM="pbrBlockSubSurface",pM=`struct subSurfaceOutParams
{vec3 specularEnvironmentReflectance;
#ifdef SS_REFRACTION
vec3 finalRefraction;vec3 surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
float alpha;
#endif
#ifdef REFLECTION
float refractionFactorForIrradiance;
#endif
#endif
#ifdef SS_TRANSLUCENCY
vec3 transmittance;float translucencyIntensity;
#ifdef REFLECTION
vec3 refractionIrradiance;
#endif
#endif
#if DEBUGMODE>0
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction;vec3 refractionTransmittance;
#endif
#endif
};
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#define pbr_inline
#define inline
vec4 sampleEnvironmentRefraction(
in float ior
,in float thickness
,in float refractionLOD
,in vec3 normalW
,in vec3 vPositionW
,in vec3 viewDirectionW
,in mat4 view
,in vec4 vRefractionInfos
,in mat4 refractionMatrix
,in vec4 vRefractionMicrosurfaceInfos
,in float alphaG
#ifdef SS_REFRACTIONMAP_3D
,in samplerCube refractionSampler
#ifndef LODBASEDMICROSFURACE
,in samplerCube refractionSamplerLow
,in samplerCube refractionSamplerHigh
#endif
#else
,in sampler2D refractionSampler
#ifndef LODBASEDMICROSFURACE
,in sampler2D refractionSamplerLow
,in sampler2D refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,in anisotropicOutParams anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,in vec2 vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,in vec3 refractionPosition
,in vec3 refractionSize
#endif
) {vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef ANISOTROPIC
vec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,ior);
#else
vec3 refractionVector=refract(-viewDirectionW,normalW,ior);
#endif
#ifdef SS_REFRACTIONMAP_OPPOSITEZ
refractionVector.z*=-1.0;
#endif
#ifdef SS_REFRACTIONMAP_3D
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec3 refractionCoords=refractionVector;refractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));
#else
#ifdef SS_USE_THICKNESS_AS_DEPTH
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
#endif
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;
#endif
#ifdef LODBASEDMICROSFURACE
refractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;
#ifdef SS_LODINREFRACTIONALPHA
float automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);float requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);
#else
float requestedRefractionLOD=refractionLOD;
#endif
#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)
environmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);
#else
environmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);
#endif
#else
float lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));float lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;vec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(
sampleRefraction(refractionSamplerHigh,refractionCoords),
environmentRefractionMid,
lodRefractionNormalizedDoubled
);} else {environmentRefraction=mix(
environmentRefractionMid,
sampleRefraction(refractionSamplerLow,refractionCoords),
lodRefractionNormalizedDoubled-1.0
);}
#endif
#ifdef SS_RGBDREFRACTION
environmentRefraction.rgb=fromRGBD(environmentRefraction);
#endif
#ifdef SS_GAMMAREFRACTION
environmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);
#endif
return environmentRefraction;}
#endif
#define pbr_inline
#define inline
void subSurfaceBlock(
in vec3 vSubSurfaceIntensity,
in vec2 vThicknessParam,
in vec4 vTintColor,
in vec3 normalW,
in vec3 specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
in vec4 thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
in vec4 refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
in vec4 translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
in mat4 reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in vec3 irradianceVector_,
#endif
#if defined(REALTIME_FILTERING)
in samplerCube reflectionSampler,
in vec2 vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
in vec3 surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
in vec3 vPositionW,
in vec3 viewDirectionW,
in mat4 view,
in vec4 vRefractionInfos,
in mat4 refractionMatrix,
in vec4 vRefractionMicrosurfaceInfos,
in vec4 vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
in float alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
in float NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
in float roughness,
#endif
in float alphaG,
#ifdef SS_REFRACTIONMAP_3D
in samplerCube refractionSampler,
#ifndef LODBASEDMICROSFURACE
in samplerCube refractionSamplerLow,
in samplerCube refractionSamplerHigh,
#endif
#else
in sampler2D refractionSampler,
#ifndef LODBASEDMICROSFURACE
in sampler2D refractionSamplerLow,
in sampler2D refractionSamplerHigh,
#endif
#endif
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
in vec2 vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
in vec3 refractionPosition,
in vec3 refractionSize,
#endif
#ifdef SS_DISPERSION
in float dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
in vec3 vDiffusionDistance,
#endif
out subSurfaceOutParams outParams
)
{outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;
#ifdef SS_REFRACTION
float refractionIntensity=vSubSurfaceIntensity.x;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
refractionIntensity*=(1.0-alpha);outParams.alpha=1.0;
#endif
#endif
#ifdef SS_TRANSLUCENCY
float translucencyIntensity=vSubSurfaceIntensity.y;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
#if defined(SS_USE_GLTF_TEXTURES)
float thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;
#else
float thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;
#endif
#if DEBUGMODE>0
outParams.thicknessMap=thicknessMap;
#endif
#ifdef SS_MASK_FROM_THICKNESS_TEXTURE
#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)
#if defined(SS_USE_GLTF_TEXTURES)
refractionIntensity*=thicknessMap.r;
#else
refractionIntensity*=thicknessMap.g;
#endif
#endif
#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)
translucencyIntensity*=thicknessMap.b;
#endif
#endif
#else
float thickness=vThicknessParam.y;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
#ifdef SS_USE_GLTF_TEXTURES
refractionIntensity*=refractionIntensityMap.r;
#else
refractionIntensity*=refractionIntensityMap.g;
#endif
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensity*=translucencyIntensityMap.b;
#endif
#ifdef SS_TRANSLUCENCY
thickness=maxEps(thickness);vec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef SS_HAS_THICKNESS
float ior=vRefractionInfos.y;
#else
float ior=vRefractionMicrosurfaceInfos.w;
#endif
#ifdef SS_LODINREFRACTIONALPHA
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);
#elif defined(SS_LINEARSPECULARREFRACTION)
float refractionRoughness=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);
#else
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);
#endif
float refraction_ior=vRefractionInfos.y;
#ifdef SS_DISPERSION
float realIOR=1.0/refraction_ior;float iorDispersionSpread=0.04*dispersion*(realIOR-1.0);vec3 iors=vec3(1.0/(realIOR-iorDispersionSpread),refraction_ior,1.0/(realIOR+iorDispersionSpread));for (int i=0; i<3; i++) {refraction_ior=iors[i];
#endif
vec4 envSample=sampleEnvironmentRefraction(refraction_ior,thickness,refractionLOD,normalW,vPositionW,viewDirectionW,view,vRefractionInfos,refractionMatrix,vRefractionMicrosurfaceInfos,alphaG
#ifdef SS_REFRACTIONMAP_3D
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#else
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,refractionPosition
,refractionSize
#endif
);
#ifdef SS_DISPERSION
environmentRefraction[i]=envSample[i];}
#else
environmentRefraction=envSample;
#endif
environmentRefraction.rgb*=vRefractionInfos.x;
#endif
#ifdef SS_REFRACTION
vec3 refractionTransmittance=vec3(refractionIntensity);
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,thickness);
#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)
float maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);vec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);environmentRefraction.rgb*=volumeAlbedo;
#else
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);
#endif
#ifdef SS_ALBEDOFORREFRACTIONTINT
environmentRefraction.rgb*=surfaceAlbedo.rgb;
#endif
outParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);
#ifdef REFLECTION
outParams.refractionFactorForIrradiance=(1.-refractionIntensity);
#endif
#ifdef UNUSED_MULTIPLEBOUNCES
vec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);
#endif
refractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;
#if DEBUGMODE>0
outParams.refractionTransmittance=refractionTransmittance;
#endif
outParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;
#if DEBUGMODE>0
outParams.environmentRefraction=environmentRefraction;
#endif
#endif
#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)
#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#else
vec3 irradianceVector=irradianceVector_;
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP)
#if defined(REALTIME_FILTERING)
vec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);
#else
vec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);
#endif
#elif defined(USEIRRADIANCEMAP)
#ifdef REFLECTIONMAP_3D
vec3 irradianceCoords=irradianceVector;
#else
vec2 irradianceCoords=irradianceVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
irradianceCoords/=irradianceVector.z;
#endif
irradianceCoords.y=1.0-irradianceCoords.y;
#endif
vec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);
#ifdef RGBDREFLECTION
refractionIrradiance.rgb=fromRGBD(refractionIrradiance);
#endif
#ifdef GAMMAREFLECTION
refractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);
#endif
#else
vec4 refractionIrradiance=vec4(0.);
#endif
refractionIrradiance.rgb*=transmittance;
#ifdef SS_ALBEDOFORTRANSLUCENCYTINT
refractionIrradiance.rgb*=surfaceAlbedo.rgb;
#endif
outParams.refractionIrradiance=refractionIrradiance.rgb;
#endif
}
#endif
`;Gi.IncludesShadersStore[uM]=pM;const h6={name:uM,shader:pM},_M="pbrBlockNormalGeometric",TM=`vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#endif
vec3 geometricNormalW=normalW;
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
geometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;
#endif
`;Gi.IncludesShadersStore[_M]=TM;const c6={name:_M,shader:TM},vM="bumpFragment",RM=`vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;Gi.IncludesShadersStore[vM]=RM;const u6={name:vM,shader:RM},MM="pbrBlockNormalFinal",wM=`#if defined(FORCENORMALFORWARD) && defined(NORMAL)
vec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#if defined(TWOSIDEDLIGHTING)
faceNormal=gl_FrontFacing ? faceNormal : -faceNormal;
#endif
normalW*=sign(dot(normalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
`;Gi.IncludesShadersStore[MM]=wM;const p6={name:MM,shader:wM},LM="depthPrePass",kM=`#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);return;
#endif
`;Gi.IncludesShadersStore[LM]=kM;const _6={name:LM,shader:kM},UM="pbrBlockLightmapInit",GM=`#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
#ifdef GAMMALIGHTMAP
lightmapColor.rgb=toLinearSpace(lightmapColor.rgb);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
`;Gi.IncludesShadersStore[UM]=GM;const T6={name:UM,shader:GM},zM="pbrBlockGeometryInfo",WM=`float NdotVUnclamped=dot(normalW,viewDirectionW);float NdotV=absEps(NdotVUnclamped);float alphaG=convertRoughnessToAverageSlope(roughness);vec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);
#ifdef SPECULARAA
alphaG+=AARoughnessFactors.y;
#endif
#if defined(ENVIRONMENTBRDF)
vec3 environmentBrdf=getBRDFLookup(NdotV,roughness);
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
#ifdef AMBIENTINGRAYSCALE
float ambientMonochrome=aoOut.ambientOcclusionColor.r;
#else
float ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);
#endif
float seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);
#endif
#endif
#endif
#endif
`;Gi.IncludesShadersStore[zM]=WM;const v6={name:zM,shader:WM},HM="pbrBlockReflectance0",XM=`float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);vec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);
#else 
vec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);
#endif
#ifdef ALPHAFRESNEL
float reflectance90=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;
#endif
`;Gi.IncludesShadersStore[HM]=XM;const R6={name:HM,shader:XM},KM="pbrBlockReflectance",YM=`#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);
#ifdef RADIANCEOCCLUSION
specularEnvironmentReflectance*=seo;
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
specularEnvironmentReflectance*=eho;
#endif
#endif
#endif
#else
vec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));
#endif
#ifdef CLEARCOAT
specularEnvironmentReflectance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
specularEnvironmentReflectance*=clearcoatOut.absorption;
#endif
#endif
`;Gi.IncludesShadersStore[KM]=YM;const M6={name:KM,shader:YM},jM="pbrBlockDirectLighting",qM=`vec3 diffuseBase=vec3(0.,0.,0.);
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
#ifdef CLEARCOAT
vec3 clearCoatBase=vec3(0.,0.,0.);
#endif
#ifdef SHEEN
vec3 sheenBase=vec3(0.,0.,0.);
#endif
preLightingInfo preInfo;lightingInfo info;float shadow=1.; 
float aggShadow=0.;float numLights=0.;
#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
vec3 absorption=vec3(0.);
#endif
`;Gi.IncludesShadersStore[jM]=qM;const w6={name:jM,shader:qM},$M="lightFragment",r1=`#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;Gi.IncludesShadersStore[$M]=r1;const L6={name:$M,shader:r1},n1="pbrBlockFinalLitComponents",a1=`aggShadow=aggShadow/numLights;
#if defined(ENVIRONMENTBRDF)
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);
#endif
#endif
#ifndef METALLICWORKFLOW
#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION
surfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;
#endif
#endif
#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)
surfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;
#endif
#ifdef REFLECTION
vec3 finalIrradiance=reflectionOut.environmentIrradiance;
#if defined(CLEARCOAT)
finalIrradiance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
finalIrradiance*=clearcoatOut.absorption;
#endif
#endif
#if defined(SS_REFRACTION)
finalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;
#endif
#if defined(SS_TRANSLUCENCY)
finalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;
#endif
finalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase;finalSpecular=max(finalSpecular,0.0);vec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalSpecularScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalSpecularScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef REFLECTION
vec3 finalRadiance=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;vec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalRadianceScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalRadianceScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef SHEEN
vec3 finalSheen=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,0.0);vec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;
#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef CLEARCOAT
vec3 finalClearCoat=clearCoatBase;finalClearCoat=max(finalClearCoat,0.0);vec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;
#ifdef CLEARCOAT_TINT
subSurfaceOut.finalRefraction*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef ALPHABLEND
float luminanceOverAlpha=0.0;
#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)
luminanceOverAlpha+=getLuminance(finalRadianceScaled);
#if defined(CLEARCOAT)
luminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);
#endif
#endif
#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)
luminanceOverAlpha+=getLuminance(finalSpecularScaled);
#endif
#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)
luminanceOverAlpha+=getLuminance(finalClearCoatScaled);
#endif
#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)
alpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);
#endif
#endif
`;Gi.IncludesShadersStore[n1]=a1;const k6={name:n1,shader:a1},x1="pbrBlockFinalUnlitComponents",l1=`vec3 finalDiffuse=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,0.0);finalDiffuse*=vLightingIntensity.x;vec3 finalAmbient=vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;vec3 finalEmissive=vEmissiveColor;
#ifdef EMISSIVE
vec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;
#ifdef GAMMAEMISSIVE
finalEmissive*=toLinearSpace(emissiveColorTex.rgb);
#else
finalEmissive*=emissiveColorTex.rgb;
#endif
finalEmissive*= vEmissiveInfos.y;
#endif
finalEmissive*=vLightingIntensity.y;
#ifdef AMBIENT
vec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);
#else
vec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;
#endif
finalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;
`;Gi.IncludesShadersStore[x1]=l1;const U6={name:x1,shader:l1},h1="pbrBlockFinalColorComposition",c1=`vec4 finalColor=vec4(
#ifndef UNLIT
#ifdef REFLECTION
finalIrradiance +
#endif
#ifdef SPECULARTERM
finalSpecularScaled +
#endif
#ifdef SHEEN
finalSheenScaled +
#endif
#ifdef CLEARCOAT
finalClearCoatScaled +
#endif
#ifdef REFLECTION
finalRadianceScaled +
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled +
#endif
#ifdef CLEARCOAT
clearcoatOut.finalClearCoatRadianceScaled +
#endif
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction +
#endif
#endif
finalAmbient +
finalDiffuse,
alpha);
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
finalColor.rgb*=lightmapColor.rgb;
#else
finalColor.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
finalColor.rgb+=finalEmissive;
#define CUSTOM_FRAGMENT_BEFORE_FOG
finalColor=max(finalColor,0.0);
`;Gi.IncludesShadersStore[h1]=c1;const G6={name:h1,shader:c1},u1="logDepthFragment",_1=`#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;Gi.IncludesShadersStore[u1]=_1;const z6={name:u1,shader:_1},T1="fogFragment",v1=`#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;Gi.IncludesShadersStore[T1]=v1;const W6={name:T1,shader:v1},R1="pbrBlockImageProcessing",M1=`#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)
#if !defined(SKIPFINALCOLORCLAMP)
finalColor.rgb=clamp(finalColor.rgb,0.,30.0);
#endif
#else
finalColor=applyImageProcessing(finalColor);
#endif
finalColor.a*=visibility;
#ifdef PREMULTIPLYALPHA
finalColor.rgb*=finalColor.a;
#endif
`;Gi.IncludesShadersStore[R1]=M1;const H6={name:R1,shader:M1},w1="oitFragment",L1=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);return;}
#endif
`;Gi.IncludesShadersStore[w1]=L1;const X6={name:w1,shader:L1},k1="pbrDebug",U1=`#if DEBUGMODE>0
if (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {
#if DEBUGMODE==1
gl_FragColor.rgb=vPositionW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==2 && defined(NORMAL)
gl_FragColor.rgb=vNormalW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==5
gl_FragColor.rgb=normalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==6 && defined(MAINUV1)
gl_FragColor.rgb=vec3(vMainUV1,0.0);
#elif DEBUGMODE==7 && defined(MAINUV2)
gl_FragColor.rgb=vec3(vMainUV2,0.0);
#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==10 && defined(CLEARCOAT)
gl_FragColor.rgb=clearcoatOut.clearCoatNormalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==11 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicNormal;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==12 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicTangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==13 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicBitangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==20 && defined(ALBEDO)
gl_FragColor.rgb=albedoTexture.rgb;
#ifndef GAMMAALBEDO
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==21 && defined(AMBIENT)
gl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;
#elif DEBUGMODE==22 && defined(OPACITY)
gl_FragColor.rgb=opacityMap.rgb;
#elif DEBUGMODE==23 && defined(EMISSIVE)
gl_FragColor.rgb=emissiveColorTex.rgb;
#ifndef GAMMAEMISSIVE
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==24 && defined(LIGHTMAP)
gl_FragColor.rgb=lightmapColor.rgb;
#ifndef GAMMALIGHTMAP
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;
#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);
#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
gl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;
#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)
gl_FragColor.rgb=sheenOut.sheenMapData.rgb;
#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)
gl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;
#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)
gl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;
#elif DEBUGMODE==32 && defined(BUMP)
gl_FragColor.rgb=texture2D(bumpSampler,vBumpUV).rgb;
#elif DEBUGMODE==40 && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==41 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)
gl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==50
gl_FragColor.rgb=diffuseBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==51 && defined(SPECULARTERM)
gl_FragColor.rgb=specularBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==52 && defined(CLEARCOAT)
gl_FragColor.rgb=clearCoatBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==53 && defined(SHEEN)
gl_FragColor.rgb=sheenBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==54 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==60
gl_FragColor.rgb=surfaceAlbedo.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==61
gl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);
#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.metallicF0;
#elif DEBUGMODE==63
gl_FragColor.rgb=vec3(roughness);
#elif DEBUGMODE==64
gl_FragColor.rgb=vec3(alphaG);
#elif DEBUGMODE==65
gl_FragColor.rgb=vec3(NdotV);
#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
gl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==67 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);
#elif DEBUGMODE==68 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);
#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)
gl_FragColor.rgb=subSurfaceOut.transmittance;
#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.refractionTransmittance;
#elif DEBUGMODE==72
gl_FragColor.rgb=vec3(microSurface);
#elif DEBUGMODE==73
gl_FragColor.rgb=vAlbedoColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=vReflectivityColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==75
gl_FragColor.rgb=vEmissiveColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)
gl_FragColor.rgb=vec3(seo);
#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION)
gl_FragColor.rgb=vec3(eho);
#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)
gl_FragColor.rgb=vec3(energyConservationFactor);
#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=specularEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)
gl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==86 && defined(ALPHABLEND)
gl_FragColor.rgb=vec3(luminanceOverAlpha);
#elif DEBUGMODE==87
gl_FragColor.rgb=vec3(alpha);
#elif DEBUGMODE==88 && defined(ALBEDO)
gl_FragColor.rgb=vec3(albedoTexture.a);
#else
float stripeWidth=30.;float stripePos=floor((gl_FragCoord.x+gl_FragCoord.y)/stripeWidth);float whichColor=mod(stripePos,2.);vec3 color1=vec3(.6,.2,.2);vec3 color2=vec3(.3,.1,.1);gl_FragColor.rgb=mix(color1,color2,whichColor);
#endif
gl_FragColor.rgb*=vDebugMode.y;
#ifdef DEBUGMODE_NORMALIZE
gl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;
#endif
#ifdef DEBUGMODE_GAMMA
gl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);
#endif
gl_FragColor.a=1.0;
#ifdef PREPASS
gl_FragData[0]=toLinearSpace(gl_FragColor); 
gl_FragData[1]=vec4(0.,0.,0.,0.); 
#endif
#ifdef DEBUGMODE_FORCERETURN
return;
#endif
}
#endif
`;Gi.IncludesShadersStore[k1]=U1;const K6={name:k1,shader:U1},G1="pbrPixelShader",z1=`#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#extension GL_OES_standard_derivatives : enable
#endif
#ifdef LODBASEDMICROSFURACE
#extension GL_EXT_shader_texture_lod : enable
#endif
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
precision highp float;
#include<oitDeclaration>
#ifndef FROMLINEARSPACE
#define FROMLINEARSPACE
#endif
#include<__decl__pbrFragment>
#include<pbrFragmentExtraDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<pbrFragmentSamplersDeclaration>
#include<imageProcessingDeclaration>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#include<helperFunctions>
#include<subSurfaceScatteringFunctions>
#include<importanceSampling>
#include<pbrHelperFunctions>
#include<imageProcessingFunctions>
#include<shadowsFragmentFunctions>
#include<harmonicsFunctions>
#include<pbrDirectLightingSetupFunctions>
#include<pbrDirectLightingFalloffFunctions>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
#include<pbrDirectLightingFunctions>
#include<pbrIBLFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#ifdef REFLECTION
#include<reflectionFunction>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
#include<pbrBlockAlbedoOpacity>
#include<pbrBlockReflectivity>
#include<pbrBlockAmbientOcclusion>
#include<pbrBlockAlphaFresnel>
#include<pbrBlockAnisotropic>
#include<pbrBlockReflection>
#include<pbrBlockSheen>
#include<pbrBlockClearcoat>
#include<pbrBlockIridescence>
#include<pbrBlockSubSurface>
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#include<pbrBlockNormalGeometric>
#include<bumpFragment>
#include<pbrBlockNormalFinal>
albedoOpacityOutParams albedoOpacityOut;
#ifdef ALBEDO
vec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#endif
#ifdef DECAL
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#endif
albedoOpacityBlock(
vAlbedoColor,
#ifdef ALBEDO
albedoTexture,
vAlbedoInfos,
#endif
#ifdef OPACITY
opacityMap,
vOpacityInfos,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
#ifdef DECAL
decalColor,
vDecalInfos,
#endif
albedoOpacityOut
);vec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;float alpha=albedoOpacityOut.alpha;
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
#include<depthPrePass>
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
ambientOcclusionOutParams aoOut;
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;
#endif
ambientOcclusionBlock(
#ifdef AMBIENT
ambientOcclusionColorMap,
vAmbientInfos,
#endif
aoOut
);
#include<pbrBlockLightmapInit>
#ifdef UNLIT
vec3 diffuseBase=vec3(1.,1.,1.);
#else
vec3 baseColor=surfaceAlbedo;reflectivityOutParams reflectivityOut;
#if defined(REFLECTIVITY)
vec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);vec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;
#ifndef METALLICWORKFLOW
#ifdef REFLECTIVITY_GAMMA
surfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);
#endif
surfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;
#endif
#endif
#if defined(MICROSURFACEMAP)
vec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;
#endif
#ifdef METALLICWORKFLOW
vec4 metallicReflectanceFactors=vMetallicReflectanceFactors;
#ifdef REFLECTANCE
vec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);
#ifdef REFLECTANCE_GAMMA
reflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);
#endif
metallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;
#endif
#ifdef METALLIC_REFLECTANCE
vec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);
#ifdef METALLIC_REFLECTANCE_GAMMA
metallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);
#endif
#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY
metallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;
#endif
metallicReflectanceFactors*=metallicReflectanceFactorsMap.a;
#endif
#endif
reflectivityBlock(
vReflectivityColor,
#ifdef METALLICWORKFLOW
surfaceAlbedo,
metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
vReflectivityInfos,
surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor,
#endif
#ifdef MICROSURFACEMAP
microSurfaceTexel,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
reflectivityOut
);float microSurface=reflectivityOut.microSurface;float roughness=reflectivityOut.roughness;
#ifdef METALLICWORKFLOW
surfaceAlbedo=reflectivityOut.surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;
#endif
#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
alphaFresnelOutParams alphaFresnelOut;alphaFresnelBlock(
normalW,
viewDirectionW,
alpha,
microSurface,
alphaFresnelOut
);alpha=alphaFresnelOut.alpha;
#endif
#endif
#include<pbrBlockGeometryInfo>
#ifdef ANISOTROPIC
anisotropicOutParams anisotropicOut;
#ifdef ANISOTROPIC_TEXTURE
vec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;
#endif
anisotropicBlock(
vAnisotropy,
roughness,
#ifdef ANISOTROPIC_TEXTURE
anisotropyMapData,
#endif
TBN,
normalW,
viewDirectionW,
anisotropicOut
);
#endif
#ifdef REFLECTION
reflectionOutParams reflectionOut;
#ifndef USE_CUSTOM_REFLECTION
reflectionBlock(
vPositionW,
normalW,
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
reflectionSampler,
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
reflectionOut
);
#else
#define CUSTOM_REFLECTION
#endif
#endif
#include<pbrBlockReflectance0>
#ifdef SHEEN
sheenOutParams sheenOut;
#ifdef SHEEN_TEXTURE
vec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);
#endif
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;
#endif
sheenBlock(
vSheenColor,
#ifdef SHEEN_ROUGHNESS
vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
sheenMapRoughnessData,
#endif
#endif
roughness,
#ifdef SHEEN_TEXTURE
sheenMapData,
vSheenInfos.y,
#endif
reflectance,
#ifdef SHEEN_LINKWITHALBEDO
baseColor,
surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
NdotV,
environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
AARoughnessFactors,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
reflectionOut.reflectionCoords,
NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
eho,
#endif
#endif
sheenOut
);
#ifdef SHEEN_LINKWITHALBEDO
surfaceAlbedo=sheenOut.surfaceAlbedo;
#endif
#endif
#ifdef CLEARCOAT
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;
#endif
#endif
#ifdef IRIDESCENCE
iridescenceOutParams iridescenceOut;
#ifdef IRIDESCENCE_TEXTURE
vec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
vec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;
#endif
iridescenceBlock(
vIridescenceParams,
NdotV,
specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#endif
iridescenceOut
);float iridescenceIntensity=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;
#endif
clearcoatOutParams clearcoatOut;
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);
#endif
#ifdef CLEARCOAT_BUMP
vec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);
#endif
clearcoatBlock(
vPositionW,
geometricNormalW,
viewDirectionW,
vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
clearCoatMapRoughnessData,
#endif
specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
vClearCoatTintParams,
clearCoatColorAtDistance,
vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
vClearCoatBumpInfos,
clearCoatBumpMapData,
vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
vTBN,
#else
vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
faceNormal,
#endif
#ifdef REFLECTION
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
(gl_FrontFacing ? 1. : -1.),
#endif
clearcoatOut
);
#else
clearcoatOut.specularEnvironmentR0=specularEnvironmentR0;
#endif
#include<pbrBlockReflectance>
subSurfaceOutParams subSurfaceOut;
#ifdef SUBSURFACE
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
vec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
vec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);
#endif
subSurfaceBlock(
vSubSurfaceIntensity,
vThicknessParam,
vTintColor,
normalW,
specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionOut.irradianceVector,
#endif
#if defined(REALTIME_FILTERING)
reflectionSampler,
vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
vPositionW,
viewDirectionW,
view,
vRefractionInfos,
refractionMatrix,
vRefractionMicrosurfaceInfos,
vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
roughness,
#endif
alphaG,
refractionSampler,
#ifndef LODBASEDMICROSFURACE
refractionSamplerLow,
refractionSamplerHigh,
#endif
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
vRefractionPosition,
vRefractionSize,
#endif
#ifdef SS_DISPERSION
dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
vDiffusionDistance,
#endif
subSurfaceOut
);
#ifdef SS_REFRACTION
surfaceAlbedo=subSurfaceOut.surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha=subSurfaceOut.alpha;
#endif
#endif
#else
subSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;
#endif
#include<pbrBlockDirectLighting>
#include<lightFragment>[0..maxSimultaneousLights]
#include<pbrBlockFinalLitComponents>
#endif 
#include<pbrBlockFinalUnlitComponents>
#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION
#include<pbrBlockFinalColorComposition>
#include<logDepthFragment>
#include<fogFragment>(color,finalColor)
#include<pbrBlockImageProcessing>
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO_SQRT
vec3 sqAlbedo=sqrt(surfaceAlbedo); 
#endif
#ifdef PREPASS_IRRADIANCE
vec3 irradiance=finalDiffuse;
#ifndef UNLIT
#ifdef REFLECTION
irradiance+=finalIrradiance;
#endif
#endif
#ifdef SS_SCATTERING
gl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); 
irradiance/=sqAlbedo;
#else
gl_FragData[0]=finalColor; 
float scatteringDiffusionProfile=255.;
#endif
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); 
#else
gl_FragData[0]=vec4(finalColor.rgb,finalColor.a);
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); 
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); 
#endif
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#ifndef UNLIT
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=finalColor;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);} else {backColor+=finalColor;}
#endif
#include<pbrDebug>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;Gi.ShadersStore[G1]=z1;const Y6={name:G1,shader:z1},W1="decalVertexDeclaration",X1=`#ifdef DECAL
uniform vec4 vDecalInfos;uniform mat4 decalMatrix;
#endif
`;Gi.IncludesShadersStore[W1]=X1;const j6={name:W1,shader:X1},K1="pbrVertexDeclaration",Y1=`uniform mat4 view;uniform mat4 viewProjection;
#ifdef ALBEDO
uniform mat4 albedoMatrix;uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec4 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#ifdef REFLECTIVITY 
uniform vec3 vReflectivityInfos;uniform mat4 reflectivityMatrix;
#endif
#ifdef METALLIC_REFLECTANCE
uniform vec2 vMetallicReflectanceInfos;uniform mat4 metallicReflectanceMatrix;
#endif
#ifdef REFLECTANCE
uniform vec2 vReflectanceInfos;uniform mat4 reflectanceMatrix;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;uniform mat4 microSurfaceSamplerMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;
#endif
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#ifdef IRIDESCENCE
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
#endif
#ifdef NORMAL
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`;Gi.IncludesShadersStore[K1]=Y1;const q6={name:K1,shader:Y1},j1="uvAttributeDeclaration",q1=`#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;Gi.IncludesShadersStore[j1]=q1;const $6={name:j1,shader:q1},$1="prePassVertexDeclaration",rP=`#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#endif
`;Gi.IncludesShadersStore[$1]=rP;const r8={name:$1,shader:rP},nP="samplerVertexDeclaration",aP=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;Gi.IncludesShadersStore[nP]=aP;const n8={name:nP,shader:aP},xP="bumpVertexDeclaration",lP=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;Gi.IncludesShadersStore[xP]=lP;const a8={name:xP,shader:lP},hP="fogVertexDeclaration",cP=`#ifdef FOG
varying vec3 vFogDistance;
#endif
`;Gi.IncludesShadersStore[hP]=cP;const x8={name:hP,shader:cP},uP="lightVxFragmentDeclaration",pP=`#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;Gi.IncludesShadersStore[uP]=pP;const l8={name:uP,shader:pP},_P="lightVxUboDeclaration",TP=`#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;Gi.IncludesShadersStore[_P]=TP;const h8={name:_P,shader:TP},vP="prePassVertex",RP=`#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;Gi.IncludesShadersStore[vP]=RP;const c8={name:vP,shader:RP},MP="uvVariableDeclaration",wP=`#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;Gi.IncludesShadersStore[MP]=wP;const u8={name:MP,shader:wP},LP="samplerVertexImplementation",kP=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}
#ifdef UV2
else if (v_INFONAME_==1.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}
#endif
#endif
`;Gi.IncludesShadersStore[LP]=kP;const p8={name:LP,shader:kP},UP="bumpVertex",GP=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;Gi.IncludesShadersStore[UP]=GP;const _8={name:UP,shader:GP},zP="fogVertex",WP=`#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;Gi.IncludesShadersStore[zP]=WP;const T8={name:zP,shader:WP},HP="shadowsVertex",XP=`#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;Gi.IncludesShadersStore[HP]=XP;const v8={name:HP,shader:XP},KP="vertexColorMixing",YP=`#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;Gi.IncludesShadersStore[KP]=YP;const R8={name:KP,shader:YP},jP="logDepthVertex",qP=`#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;Gi.IncludesShadersStore[jP]=qP;const M8={name:jP,shader:qP},$P="pbrVertexShader",rO=`precision highp float;
#include<__decl__pbrVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#include<mainUVVaryingDeclaration>[1..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)
#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)
#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
#ifdef CLEARCOAT
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)
#endif
#ifdef SUBSURFACE
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)
#endif
varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#include<harmonicsFunctions>
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vPositionW=vec3(worldPos);
#include<prePassVertex>
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
vec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
vEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#if DEBUGMODE>0
vClipSpacePosition=gl_Position;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#ifdef CLEARCOAT
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)
#endif
#ifdef SHEEN
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.z)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)
#endif
#ifdef SUBSURFACE
#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)
#endif
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;Gi.ShadersStore[$P]=rO;const w8={name:$P,shader:rO};class _L extends qh{constructor(){super(...arguments),this.CLEARCOAT=!1,this.CLEARCOAT_DEFAULTIOR=!1,this.CLEARCOAT_TEXTURE=!1,this.CLEARCOAT_TEXTURE_ROUGHNESS=!1,this.CLEARCOAT_TEXTUREDIRECTUV=0,this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV=0,this.CLEARCOAT_BUMP=!1,this.CLEARCOAT_BUMPDIRECTUV=0,this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,this.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL=!1,this.CLEARCOAT_REMAP_F0=!1,this.CLEARCOAT_TINT=!1,this.CLEARCOAT_TINT_TEXTURE=!1,this.CLEARCOAT_TINT_TEXTUREDIRECTUV=0,this.CLEARCOAT_TINT_GAMMATEXTURE=!1}}class ho extends ql{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(p,_=!0){super(p,"PBRClearCoat",100,new _L,_),this._isEnabled=!1,this.isEnabled=!1,this.intensity=1,this.roughness=0,this._indexOfRefraction=ho._DefaultIndexOfRefraction,this.indexOfRefraction=ho._DefaultIndexOfRefraction,this._texture=null,this.texture=null,this._useRoughnessFromMainTexture=!0,this.useRoughnessFromMainTexture=!0,this._textureRoughness=null,this.textureRoughness=null,this._remapF0OnInterfaceChange=!0,this.remapF0OnInterfaceChange=!0,this._bumpTexture=null,this.bumpTexture=null,this._isTintEnabled=!1,this.isTintEnabled=!1,this.tintColor=ws.White(),this.tintColorAtDistance=1,this.tintThickness=1,this._tintTexture=null,this.tintTexture=null,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1]}isReadyForSubMesh(p,_,E){if(!this._isEnabled)return!0;const A=this._material._disableBumpMap;return!(p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ls.ClearCoatTextureEnabled&&!this._texture.isReadyOrNotBlocking()||this._textureRoughness&&Ls.ClearCoatTextureEnabled&&!this._textureRoughness.isReadyOrNotBlocking()||E.getCaps().standardDerivatives&&this._bumpTexture&&Ls.ClearCoatBumpTextureEnabled&&!A&&!this._bumpTexture.isReady()||this._isTintEnabled&&this._tintTexture&&Ls.ClearCoatTintTextureEnabled&&!this._tintTexture.isReadyOrNotBlocking()))}prepareDefinesBeforeAttributes(p,_){this._isEnabled?(p.CLEARCOAT=!0,p.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE=this._useRoughnessFromMainTexture,p.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL=this._texture!==null&&this._texture._texture===this._textureRoughness?._texture&&this._texture.checkTransformsAreIdentical(this._textureRoughness),p.CLEARCOAT_REMAP_F0=this._remapF0OnInterfaceChange,p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ls.ClearCoatTextureEnabled?nr.PrepareDefinesForMergedUV(this._texture,p,"CLEARCOAT_TEXTURE"):p.CLEARCOAT_TEXTURE=!1,this._textureRoughness&&Ls.ClearCoatTextureEnabled?nr.PrepareDefinesForMergedUV(this._textureRoughness,p,"CLEARCOAT_TEXTURE_ROUGHNESS"):p.CLEARCOAT_TEXTURE_ROUGHNESS=!1,this._bumpTexture&&Ls.ClearCoatBumpTextureEnabled?nr.PrepareDefinesForMergedUV(this._bumpTexture,p,"CLEARCOAT_BUMP"):p.CLEARCOAT_BUMP=!1,p.CLEARCOAT_DEFAULTIOR=this._indexOfRefraction===ho._DefaultIndexOfRefraction,this._isTintEnabled?(p.CLEARCOAT_TINT=!0,this._tintTexture&&Ls.ClearCoatTintTextureEnabled?(nr.PrepareDefinesForMergedUV(this._tintTexture,p,"CLEARCOAT_TINT_TEXTURE"),p.CLEARCOAT_TINT_GAMMATEXTURE=this._tintTexture.gammaSpace):p.CLEARCOAT_TINT_TEXTURE=!1):(p.CLEARCOAT_TINT=!1,p.CLEARCOAT_TINT_TEXTURE=!1))):(p.CLEARCOAT=!1,p.CLEARCOAT_TEXTURE=!1,p.CLEARCOAT_TEXTURE_ROUGHNESS=!1,p.CLEARCOAT_BUMP=!1,p.CLEARCOAT_TINT=!1,p.CLEARCOAT_TINT_TEXTURE=!1,p.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,p.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL=!1,p.CLEARCOAT_DEFAULTIOR=!1,p.CLEARCOAT_TEXTUREDIRECTUV=0,p.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV=0,p.CLEARCOAT_BUMPDIRECTUV=0,p.CLEARCOAT_REMAP_F0=!1,p.CLEARCOAT_TINT_TEXTUREDIRECTUV=0,p.CLEARCOAT_TINT_GAMMATEXTURE=!1)}bindForSubMesh(p,_,E,A){if(!this._isEnabled)return;const $=A.materialDefines,ne=this._material.isFrozen,xe=this._material._disableBumpMap,ce=this._material._invertNormalMapX,Te=this._material._invertNormalMapY,Re=$.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;if(!p.useUbo||!ne||!p.isSync){Re&&Ls.ClearCoatTextureEnabled?(p.updateFloat4("vClearCoatInfos",this._texture.coordinatesIndex,this._texture.level,-1,-1),nr.BindTextureMatrix(this._texture,p,"clearCoat")):(this._texture||this._textureRoughness)&&Ls.ClearCoatTextureEnabled&&(p.updateFloat4("vClearCoatInfos",this._texture?.coordinatesIndex??0,this._texture?.level??0,this._textureRoughness?.coordinatesIndex??0,this._textureRoughness?.level??0),this._texture&&nr.BindTextureMatrix(this._texture,p,"clearCoat"),this._textureRoughness&&!Re&&!$.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE&&nr.BindTextureMatrix(this._textureRoughness,p,"clearCoatRoughness")),this._bumpTexture&&E.getCaps().standardDerivatives&&Ls.ClearCoatTextureEnabled&&!xe&&(p.updateFloat2("vClearCoatBumpInfos",this._bumpTexture.coordinatesIndex,this._bumpTexture.level),nr.BindTextureMatrix(this._bumpTexture,p,"clearCoatBump"),_._mirroredCameraPosition?p.updateFloat2("vClearCoatTangentSpaceParams",ce?1:-1,Te?1:-1):p.updateFloat2("vClearCoatTangentSpaceParams",ce?-1:1,Te?-1:1)),this._tintTexture&&Ls.ClearCoatTintTextureEnabled&&(p.updateFloat2("vClearCoatTintInfos",this._tintTexture.coordinatesIndex,this._tintTexture.level),nr.BindTextureMatrix(this._tintTexture,p,"clearCoatTint")),p.updateFloat2("vClearCoatParams",this.intensity,this.roughness);const ke=1-this._indexOfRefraction,We=1+this._indexOfRefraction,Xe=Math.pow(-ke/We,2),xt=1/this._indexOfRefraction;p.updateFloat4("vClearCoatRefractionParams",Xe,xt,ke,We),this._isTintEnabled&&(p.updateFloat4("vClearCoatTintParams",this.tintColor.r,this.tintColor.g,this.tintColor.b,Math.max(1e-5,this.tintThickness)),p.updateFloat("clearCoatColorAtDistance",Math.max(1e-5,this.tintColorAtDistance)))}_.texturesEnabled&&(this._texture&&Ls.ClearCoatTextureEnabled&&p.setTexture("clearCoatSampler",this._texture),this._textureRoughness&&!Re&&!$.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE&&Ls.ClearCoatTextureEnabled&&p.setTexture("clearCoatRoughnessSampler",this._textureRoughness),this._bumpTexture&&E.getCaps().standardDerivatives&&Ls.ClearCoatBumpTextureEnabled&&!xe&&p.setTexture("clearCoatBumpSampler",this._bumpTexture),this._isTintEnabled&&this._tintTexture&&Ls.ClearCoatTintTextureEnabled&&p.setTexture("clearCoatTintSampler",this._tintTexture))}hasTexture(p){return this._texture===p||this._textureRoughness===p||this._bumpTexture===p||this._tintTexture===p}getActiveTextures(p){this._texture&&p.push(this._texture),this._textureRoughness&&p.push(this._textureRoughness),this._bumpTexture&&p.push(this._bumpTexture),this._tintTexture&&p.push(this._tintTexture)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture),this._textureRoughness&&this._textureRoughness.animations&&this._textureRoughness.animations.length>0&&p.push(this._textureRoughness),this._bumpTexture&&this._bumpTexture.animations&&this._bumpTexture.animations.length>0&&p.push(this._bumpTexture),this._tintTexture&&this._tintTexture.animations&&this._tintTexture.animations.length>0&&p.push(this._tintTexture)}dispose(p){p&&(this._texture?.dispose(),this._textureRoughness?.dispose(),this._bumpTexture?.dispose(),this._tintTexture?.dispose())}getClassName(){return"PBRClearCoatConfiguration"}addFallbacks(p,_,E){return p.CLEARCOAT_BUMP&&_.addFallback(E++,"CLEARCOAT_BUMP"),p.CLEARCOAT_TINT&&_.addFallback(E++,"CLEARCOAT_TINT"),p.CLEARCOAT&&_.addFallback(E++,"CLEARCOAT"),E}getSamplers(p){p.push("clearCoatSampler","clearCoatRoughnessSampler","clearCoatBumpSampler","clearCoatTintSampler")}getUniforms(){return{ubo:[{name:"vClearCoatParams",size:2,type:"vec2"},{name:"vClearCoatRefractionParams",size:4,type:"vec4"},{name:"vClearCoatInfos",size:4,type:"vec4"},{name:"clearCoatMatrix",size:16,type:"mat4"},{name:"clearCoatRoughnessMatrix",size:16,type:"mat4"},{name:"vClearCoatBumpInfos",size:2,type:"vec2"},{name:"vClearCoatTangentSpaceParams",size:2,type:"vec2"},{name:"clearCoatBumpMatrix",size:16,type:"mat4"},{name:"vClearCoatTintParams",size:4,type:"vec4"},{name:"clearCoatColorAtDistance",size:1,type:"float"},{name:"vClearCoatTintInfos",size:2,type:"vec2"},{name:"clearCoatTintMatrix",size:16,type:"mat4"}]}}}ho._DefaultIndexOfRefraction=1.5,Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],ho.prototype,"isEnabled",void 0),Mt([Gt()],ho.prototype,"intensity",void 0),Mt([Gt()],ho.prototype,"roughness",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],ho.prototype,"indexOfRefraction",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],ho.prototype,"texture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],ho.prototype,"useRoughnessFromMainTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],ho.prototype,"textureRoughness",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],ho.prototype,"remapF0OnInterfaceChange",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],ho.prototype,"bumpTexture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],ho.prototype,"isTintEnabled",void 0),Mt([ja()],ho.prototype,"tintColor",void 0),Mt([Gt()],ho.prototype,"tintColorAtDistance",void 0),Mt([Gt()],ho.prototype,"tintThickness",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],ho.prototype,"tintTexture",void 0);class TL extends qh{constructor(){super(...arguments),this.IRIDESCENCE=!1,this.IRIDESCENCE_TEXTURE=!1,this.IRIDESCENCE_TEXTUREDIRECTUV=0,this.IRIDESCENCE_THICKNESS_TEXTURE=!1,this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV=0,this.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE=!1}}class hx extends ql{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(p,_=!0){super(p,"PBRIridescence",110,new TL,_),this._isEnabled=!1,this.isEnabled=!1,this.intensity=1,this.minimumThickness=hx._DefaultMinimumThickness,this.maximumThickness=hx._DefaultMaximumThickness,this.indexOfRefraction=hx._DefaultIndexOfRefraction,this._texture=null,this.texture=null,this._thicknessTexture=null,this.thicknessTexture=null,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1]}isReadyForSubMesh(p,_){return this._isEnabled?!(p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ls.IridescenceTextureEnabled&&!this._texture.isReadyOrNotBlocking()||this._thicknessTexture&&Ls.IridescenceTextureEnabled&&!this._thicknessTexture.isReadyOrNotBlocking())):!0}prepareDefinesBeforeAttributes(p,_){this._isEnabled?(p.IRIDESCENCE=!0,p.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE=this._texture!==null&&this._texture._texture===this._thicknessTexture?._texture&&this._texture.checkTransformsAreIdentical(this._thicknessTexture),p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ls.IridescenceTextureEnabled?nr.PrepareDefinesForMergedUV(this._texture,p,"IRIDESCENCE_TEXTURE"):p.IRIDESCENCE_TEXTURE=!1,!p.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE&&this._thicknessTexture&&Ls.IridescenceTextureEnabled?nr.PrepareDefinesForMergedUV(this._thicknessTexture,p,"IRIDESCENCE_THICKNESS_TEXTURE"):p.IRIDESCENCE_THICKNESS_TEXTURE=!1)):(p.IRIDESCENCE=!1,p.IRIDESCENCE_TEXTURE=!1,p.IRIDESCENCE_THICKNESS_TEXTURE=!1,p.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE=!1,p.IRIDESCENCE_TEXTUREDIRECTUV=0,p.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV=0)}bindForSubMesh(p,_,E,A){if(!this._isEnabled)return;const $=A.materialDefines,ne=this._material.isFrozen,xe=$.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE;(!p.useUbo||!ne||!p.isSync)&&(xe&&Ls.IridescenceTextureEnabled?(p.updateFloat4("vIridescenceInfos",this._texture.coordinatesIndex,this._texture.level,-1,-1),nr.BindTextureMatrix(this._texture,p,"iridescence")):(this._texture||this._thicknessTexture)&&Ls.IridescenceTextureEnabled&&(p.updateFloat4("vIridescenceInfos",this._texture?.coordinatesIndex??0,this._texture?.level??0,this._thicknessTexture?.coordinatesIndex??0,this._thicknessTexture?.level??0),this._texture&&nr.BindTextureMatrix(this._texture,p,"iridescence"),this._thicknessTexture&&!xe&&!$.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE&&nr.BindTextureMatrix(this._thicknessTexture,p,"iridescenceThickness")),p.updateFloat4("vIridescenceParams",this.intensity,this.indexOfRefraction,this.minimumThickness,this.maximumThickness)),_.texturesEnabled&&(this._texture&&Ls.IridescenceTextureEnabled&&p.setTexture("iridescenceSampler",this._texture),this._thicknessTexture&&!xe&&!$.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE&&Ls.IridescenceTextureEnabled&&p.setTexture("iridescenceThicknessSampler",this._thicknessTexture))}hasTexture(p){return this._texture===p||this._thicknessTexture===p}getActiveTextures(p){this._texture&&p.push(this._texture),this._thicknessTexture&&p.push(this._thicknessTexture)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture),this._thicknessTexture&&this._thicknessTexture.animations&&this._thicknessTexture.animations.length>0&&p.push(this._thicknessTexture)}dispose(p){p&&(this._texture?.dispose(),this._thicknessTexture?.dispose())}getClassName(){return"PBRIridescenceConfiguration"}addFallbacks(p,_,E){return p.IRIDESCENCE&&_.addFallback(E++,"IRIDESCENCE"),E}getSamplers(p){p.push("iridescenceSampler","iridescenceThicknessSampler")}getUniforms(){return{ubo:[{name:"vIridescenceParams",size:4,type:"vec4"},{name:"vIridescenceInfos",size:4,type:"vec4"},{name:"iridescenceMatrix",size:16,type:"mat4"},{name:"iridescenceThicknessMatrix",size:16,type:"mat4"}]}}}hx._DefaultMinimumThickness=100,hx._DefaultMaximumThickness=400,hx._DefaultIndexOfRefraction=1.3,Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],hx.prototype,"isEnabled",void 0),Mt([Gt()],hx.prototype,"intensity",void 0),Mt([Gt()],hx.prototype,"minimumThickness",void 0),Mt([Gt()],hx.prototype,"maximumThickness",void 0),Mt([Gt()],hx.prototype,"indexOfRefraction",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],hx.prototype,"texture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],hx.prototype,"thicknessTexture",void 0);class vL extends qh{constructor(){super(...arguments),this.ANISOTROPIC=!1,this.ANISOTROPIC_TEXTURE=!1,this.ANISOTROPIC_TEXTUREDIRECTUV=0,this.ANISOTROPIC_LEGACY=!1,this.MAINUV1=!1}}class ju extends ql{set angle(p){this.direction.x=Math.cos(p),this.direction.y=Math.sin(p)}get angle(){return Math.atan2(this.direction.y,this.direction.x)}_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}_markAllSubMeshesAsMiscDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsMiscDirty()}constructor(p,_=!0){super(p,"PBRAnisotropic",110,new vL,_),this._isEnabled=!1,this.isEnabled=!1,this.intensity=1,this.direction=new xr(1,0),this._texture=null,this.texture=null,this._legacy=!1,this.legacy=!1,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1],this._internalMarkAllSubMeshesAsMiscDirty=p._dirtyCallbacks[16]}isReadyForSubMesh(p,_){return this._isEnabled?!(p._areTexturesDirty&&_.texturesEnabled&&this._texture&&Ls.AnisotropicTextureEnabled&&!this._texture.isReadyOrNotBlocking()):!0}prepareDefinesBeforeAttributes(p,_,E){this._isEnabled?(p.ANISOTROPIC=this._isEnabled,this._isEnabled&&!E.isVerticesDataPresent(ut.TangentKind)&&(p._needUVs=!0,p.MAINUV1=!0),p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ls.AnisotropicTextureEnabled?nr.PrepareDefinesForMergedUV(this._texture,p,"ANISOTROPIC_TEXTURE"):p.ANISOTROPIC_TEXTURE=!1),p._areMiscDirty&&(p.ANISOTROPIC_LEGACY=this._legacy)):(p.ANISOTROPIC=!1,p.ANISOTROPIC_TEXTURE=!1,p.ANISOTROPIC_TEXTUREDIRECTUV=0,p.ANISOTROPIC_LEGACY=!1)}bindForSubMesh(p,_){if(!this._isEnabled)return;const E=this._material.isFrozen;(!p.useUbo||!E||!p.isSync)&&(this._texture&&Ls.AnisotropicTextureEnabled&&(p.updateFloat2("vAnisotropyInfos",this._texture.coordinatesIndex,this._texture.level),nr.BindTextureMatrix(this._texture,p,"anisotropy")),p.updateFloat3("vAnisotropy",this.direction.x,this.direction.y,this.intensity)),_.texturesEnabled&&this._texture&&Ls.AnisotropicTextureEnabled&&p.setTexture("anisotropySampler",this._texture)}hasTexture(p){return this._texture===p}getActiveTextures(p){this._texture&&p.push(this._texture)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture)}dispose(p){p&&this._texture&&this._texture.dispose()}getClassName(){return"PBRAnisotropicConfiguration"}addFallbacks(p,_,E){return p.ANISOTROPIC&&_.addFallback(E++,"ANISOTROPIC"),E}getSamplers(p){p.push("anisotropySampler")}getUniforms(){return{ubo:[{name:"vAnisotropy",size:3,type:"vec3"},{name:"vAnisotropyInfos",size:2,type:"vec2"},{name:"anisotropyMatrix",size:16,type:"mat4"}]}}parse(p,_,E){super.parse(p,_,E),p.legacy===void 0&&(this.legacy=!0)}}Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],ju.prototype,"isEnabled",void 0),Mt([Gt()],ju.prototype,"intensity",void 0),Mt([jc()],ju.prototype,"direction",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],ju.prototype,"texture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsMiscDirty")],ju.prototype,"legacy",void 0);class RL extends qh{constructor(){super(...arguments),this.SHEEN=!1,this.SHEEN_TEXTURE=!1,this.SHEEN_GAMMATEXTURE=!1,this.SHEEN_TEXTURE_ROUGHNESS=!1,this.SHEEN_TEXTUREDIRECTUV=0,this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV=0,this.SHEEN_LINKWITHALBEDO=!1,this.SHEEN_ROUGHNESS=!1,this.SHEEN_ALBEDOSCALING=!1,this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL=!1}}class L2 extends ql{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(p,_=!0){super(p,"Sheen",120,new RL,_),this._isEnabled=!1,this.isEnabled=!1,this._linkSheenWithAlbedo=!1,this.linkSheenWithAlbedo=!1,this.intensity=1,this.color=ws.White(),this._texture=null,this.texture=null,this._useRoughnessFromMainTexture=!0,this.useRoughnessFromMainTexture=!0,this._roughness=null,this.roughness=null,this._textureRoughness=null,this.textureRoughness=null,this._albedoScaling=!1,this.albedoScaling=!1,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1]}isReadyForSubMesh(p,_){return this._isEnabled?!(p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ls.SheenTextureEnabled&&!this._texture.isReadyOrNotBlocking()||this._textureRoughness&&Ls.SheenTextureEnabled&&!this._textureRoughness.isReadyOrNotBlocking())):!0}prepareDefinesBeforeAttributes(p,_){this._isEnabled?(p.SHEEN=!0,p.SHEEN_LINKWITHALBEDO=this._linkSheenWithAlbedo,p.SHEEN_ROUGHNESS=this._roughness!==null,p.SHEEN_ALBEDOSCALING=this._albedoScaling,p.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE=this._useRoughnessFromMainTexture,p.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL=this._texture!==null&&this._texture._texture===this._textureRoughness?._texture&&this._texture.checkTransformsAreIdentical(this._textureRoughness),p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ls.SheenTextureEnabled?(nr.PrepareDefinesForMergedUV(this._texture,p,"SHEEN_TEXTURE"),p.SHEEN_GAMMATEXTURE=this._texture.gammaSpace):p.SHEEN_TEXTURE=!1,this._textureRoughness&&Ls.SheenTextureEnabled?nr.PrepareDefinesForMergedUV(this._textureRoughness,p,"SHEEN_TEXTURE_ROUGHNESS"):p.SHEEN_TEXTURE_ROUGHNESS=!1)):(p.SHEEN=!1,p.SHEEN_TEXTURE=!1,p.SHEEN_TEXTURE_ROUGHNESS=!1,p.SHEEN_LINKWITHALBEDO=!1,p.SHEEN_ROUGHNESS=!1,p.SHEEN_ALBEDOSCALING=!1,p.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,p.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL=!1,p.SHEEN_GAMMATEXTURE=!1,p.SHEEN_TEXTUREDIRECTUV=0,p.SHEEN_TEXTURE_ROUGHNESSDIRECTUV=0)}bindForSubMesh(p,_,E,A){if(!this._isEnabled)return;const $=A.materialDefines,ne=this._material.isFrozen,xe=$.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;(!p.useUbo||!ne||!p.isSync)&&(xe&&Ls.SheenTextureEnabled?(p.updateFloat4("vSheenInfos",this._texture.coordinatesIndex,this._texture.level,-1,-1),nr.BindTextureMatrix(this._texture,p,"sheen")):(this._texture||this._textureRoughness)&&Ls.SheenTextureEnabled&&(p.updateFloat4("vSheenInfos",this._texture?.coordinatesIndex??0,this._texture?.level??0,this._textureRoughness?.coordinatesIndex??0,this._textureRoughness?.level??0),this._texture&&nr.BindTextureMatrix(this._texture,p,"sheen"),this._textureRoughness&&!xe&&!$.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE&&nr.BindTextureMatrix(this._textureRoughness,p,"sheenRoughness")),p.updateFloat4("vSheenColor",this.color.r,this.color.g,this.color.b,this.intensity),this._roughness!==null&&p.updateFloat("vSheenRoughness",this._roughness)),_.texturesEnabled&&(this._texture&&Ls.SheenTextureEnabled&&p.setTexture("sheenSampler",this._texture),this._textureRoughness&&!xe&&!$.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE&&Ls.SheenTextureEnabled&&p.setTexture("sheenRoughnessSampler",this._textureRoughness))}hasTexture(p){return this._texture===p||this._textureRoughness===p}getActiveTextures(p){this._texture&&p.push(this._texture),this._textureRoughness&&p.push(this._textureRoughness)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture),this._textureRoughness&&this._textureRoughness.animations&&this._textureRoughness.animations.length>0&&p.push(this._textureRoughness)}dispose(p){p&&(this._texture?.dispose(),this._textureRoughness?.dispose())}getClassName(){return"PBRSheenConfiguration"}addFallbacks(p,_,E){return p.SHEEN&&_.addFallback(E++,"SHEEN"),E}getSamplers(p){p.push("sheenSampler","sheenRoughnessSampler")}getUniforms(){return{ubo:[{name:"vSheenColor",size:4,type:"vec4"},{name:"vSheenRoughness",size:1,type:"float"},{name:"vSheenInfos",size:4,type:"vec4"},{name:"sheenMatrix",size:16,type:"mat4"},{name:"sheenRoughnessMatrix",size:16,type:"mat4"}]}}}Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],L2.prototype,"isEnabled",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],L2.prototype,"linkSheenWithAlbedo",void 0),Mt([Gt()],L2.prototype,"intensity",void 0),Mt([ja()],L2.prototype,"color",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],L2.prototype,"texture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],L2.prototype,"useRoughnessFromMainTexture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],L2.prototype,"roughness",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],L2.prototype,"textureRoughness",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],L2.prototype,"albedoScaling",void 0);class ML extends qh{constructor(){super(...arguments),this.SUBSURFACE=!1,this.SS_REFRACTION=!1,this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=!1,this.SS_TRANSLUCENCY=!1,this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=!1,this.SS_SCATTERING=!1,this.SS_DISPERSION=!1,this.SS_THICKNESSANDMASK_TEXTURE=!1,this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV=0,this.SS_HAS_THICKNESS=!1,this.SS_REFRACTIONINTENSITY_TEXTURE=!1,this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV=0,this.SS_TRANSLUCENCYINTENSITY_TEXTURE=!1,this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV=0,this.SS_REFRACTIONMAP_3D=!1,this.SS_REFRACTIONMAP_OPPOSITEZ=!1,this.SS_LODINREFRACTIONALPHA=!1,this.SS_GAMMAREFRACTION=!1,this.SS_RGBDREFRACTION=!1,this.SS_LINEARSPECULARREFRACTION=!1,this.SS_LINKREFRACTIONTOTRANSPARENCY=!1,this.SS_ALBEDOFORREFRACTIONTINT=!1,this.SS_ALBEDOFORTRANSLUCENCYTINT=!1,this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=!1,this.SS_USE_THICKNESS_AS_DEPTH=!1,this.SS_MASK_FROM_THICKNESS_TEXTURE=!1,this.SS_USE_GLTF_TEXTURES=!1}}class Wa extends ql{get scatteringDiffusionProfile(){return this._scene.subSurfaceConfiguration?this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex]:null}set scatteringDiffusionProfile(p){this._scene.enableSubSurfaceForPrePass()&&p&&(this._scatteringDiffusionProfileIndex=this._scene.subSurfaceConfiguration.addDiffusionProfile(p))}get volumeIndexOfRefraction(){return this._volumeIndexOfRefraction>=1?this._volumeIndexOfRefraction:this._indexOfRefraction}set volumeIndexOfRefraction(p){p>=1?this._volumeIndexOfRefraction=p:this._volumeIndexOfRefraction=-1}_markAllSubMeshesAsTexturesDirty(){this._enable(this._isRefractionEnabled||this._isTranslucencyEnabled||this._isScatteringEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}_markScenePrePassDirty(){this._internalMarkAllSubMeshesAsTexturesDirty(),this._internalMarkScenePrePassDirty()}constructor(p,_=!0){super(p,"PBRSubSurface",130,new ML,_),this._isRefractionEnabled=!1,this.isRefractionEnabled=!1,this._isTranslucencyEnabled=!1,this.isTranslucencyEnabled=!1,this._isDispersionEnabled=!1,this.isDispersionEnabled=!1,this._isScatteringEnabled=!1,this.isScatteringEnabled=!1,this._scatteringDiffusionProfileIndex=0,this.refractionIntensity=1,this.translucencyIntensity=1,this.useAlbedoToTintRefraction=!1,this.useAlbedoToTintTranslucency=!1,this._thicknessTexture=null,this.thicknessTexture=null,this._refractionTexture=null,this.refractionTexture=null,this._indexOfRefraction=1.5,this.indexOfRefraction=1.5,this._volumeIndexOfRefraction=-1,this._invertRefractionY=!1,this.invertRefractionY=!1,this._linkRefractionWithTransparency=!1,this.linkRefractionWithTransparency=!1,this.minimumThickness=0,this.maximumThickness=1,this.useThicknessAsDepth=!1,this.tintColor=ws.White(),this.tintColorAtDistance=1,this.dispersion=0,this.diffusionDistance=ws.White(),this._useMaskFromThicknessTexture=!1,this.useMaskFromThicknessTexture=!1,this._refractionIntensityTexture=null,this.refractionIntensityTexture=null,this._translucencyIntensityTexture=null,this.translucencyIntensityTexture=null,this._useGltfStyleTextures=!1,this.useGltfStyleTextures=!1,this._scene=p.getScene(),this.registerForExtraEvents=!0,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1],this._internalMarkScenePrePassDirty=p._dirtyCallbacks[32]}isReadyForSubMesh(p,_){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled)return!0;if(p._areTexturesDirty&&_.texturesEnabled){if(this._thicknessTexture&&Ls.ThicknessTextureEnabled&&!this._thicknessTexture.isReadyOrNotBlocking())return!1;const E=this._getRefractionTexture(_);if(E&&Ls.RefractionTextureEnabled&&!E.isReadyOrNotBlocking())return!1}return!0}prepareDefinesBeforeAttributes(p,_){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled){p.SUBSURFACE=!1,p.SS_DISPERSION=!1,p.SS_TRANSLUCENCY=!1,p.SS_SCATTERING=!1,p.SS_REFRACTION=!1,p.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=!1,p.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=!1,p.SS_THICKNESSANDMASK_TEXTURE=!1,p.SS_THICKNESSANDMASK_TEXTUREDIRECTUV=0,p.SS_HAS_THICKNESS=!1,p.SS_REFRACTIONINTENSITY_TEXTURE=!1,p.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV=0,p.SS_TRANSLUCENCYINTENSITY_TEXTURE=!1,p.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV=0,p.SS_REFRACTIONMAP_3D=!1,p.SS_REFRACTIONMAP_OPPOSITEZ=!1,p.SS_LODINREFRACTIONALPHA=!1,p.SS_GAMMAREFRACTION=!1,p.SS_RGBDREFRACTION=!1,p.SS_LINEARSPECULARREFRACTION=!1,p.SS_LINKREFRACTIONTOTRANSPARENCY=!1,p.SS_ALBEDOFORREFRACTIONTINT=!1,p.SS_ALBEDOFORTRANSLUCENCYTINT=!1,p.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=!1,p.SS_USE_THICKNESS_AS_DEPTH=!1,p.SS_MASK_FROM_THICKNESS_TEXTURE=!1,p.SS_USE_GLTF_TEXTURES=!1;return}if(p._areTexturesDirty){p.SUBSURFACE=!0,p.SS_DISPERSION=this._isDispersionEnabled,p.SS_TRANSLUCENCY=this._isTranslucencyEnabled,p.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=!1,p.SS_SCATTERING=this._isScatteringEnabled,p.SS_THICKNESSANDMASK_TEXTURE=!1,p.SS_REFRACTIONINTENSITY_TEXTURE=!1,p.SS_TRANSLUCENCYINTENSITY_TEXTURE=!1,p.SS_HAS_THICKNESS=!1,p.SS_MASK_FROM_THICKNESS_TEXTURE=!1,p.SS_USE_GLTF_TEXTURES=!1,p.SS_REFRACTION=!1,p.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=!1,p.SS_REFRACTIONMAP_3D=!1,p.SS_GAMMAREFRACTION=!1,p.SS_RGBDREFRACTION=!1,p.SS_LINEARSPECULARREFRACTION=!1,p.SS_REFRACTIONMAP_OPPOSITEZ=!1,p.SS_LODINREFRACTIONALPHA=!1,p.SS_LINKREFRACTIONTOTRANSPARENCY=!1,p.SS_ALBEDOFORREFRACTIONTINT=!1,p.SS_ALBEDOFORTRANSLUCENCYTINT=!1,p.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=!1,p.SS_USE_THICKNESS_AS_DEPTH=!1;const E=!!this._thicknessTexture&&!!this._refractionIntensityTexture&&this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture)&&this._refractionIntensityTexture._texture===this._thicknessTexture._texture,A=!!this._thicknessTexture&&!!this._translucencyIntensityTexture&&this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture)&&this._translucencyIntensityTexture._texture===this._thicknessTexture._texture,$=(E||!this._refractionIntensityTexture)&&(A||!this._translucencyIntensityTexture);if(p._areTexturesDirty&&_.texturesEnabled&&(this._thicknessTexture&&Ls.ThicknessTextureEnabled&&nr.PrepareDefinesForMergedUV(this._thicknessTexture,p,"SS_THICKNESSANDMASK_TEXTURE"),this._refractionIntensityTexture&&Ls.RefractionIntensityTextureEnabled&&!$&&nr.PrepareDefinesForMergedUV(this._refractionIntensityTexture,p,"SS_REFRACTIONINTENSITY_TEXTURE"),this._translucencyIntensityTexture&&Ls.TranslucencyIntensityTextureEnabled&&!$&&nr.PrepareDefinesForMergedUV(this._translucencyIntensityTexture,p,"SS_TRANSLUCENCYINTENSITY_TEXTURE")),p.SS_HAS_THICKNESS=this.maximumThickness-this.minimumThickness!==0,p.SS_MASK_FROM_THICKNESS_TEXTURE=(this._useMaskFromThicknessTexture||!!this._refractionIntensityTexture||!!this._translucencyIntensityTexture)&&$,p.SS_USE_GLTF_TEXTURES=this._useGltfStyleTextures,p.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=(this._useMaskFromThicknessTexture||!!this._refractionIntensityTexture)&&$,p.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=(this._useMaskFromThicknessTexture||!!this._translucencyIntensityTexture)&&$,this._isRefractionEnabled&&_.texturesEnabled){const ne=this._getRefractionTexture(_);ne&&Ls.RefractionTextureEnabled&&(p.SS_REFRACTION=!0,p.SS_REFRACTIONMAP_3D=ne.isCube,p.SS_GAMMAREFRACTION=ne.gammaSpace,p.SS_RGBDREFRACTION=ne.isRGBD,p.SS_LINEARSPECULARREFRACTION=ne.linearSpecularLOD,p.SS_REFRACTIONMAP_OPPOSITEZ=this._scene.useRightHandedSystem&&ne.isCube?!ne.invertZ:ne.invertZ,p.SS_LODINREFRACTIONALPHA=ne.lodLevelInAlpha,p.SS_LINKREFRACTIONTOTRANSPARENCY=this._linkRefractionWithTransparency,p.SS_ALBEDOFORREFRACTIONTINT=this.useAlbedoToTintRefraction,p.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=ne.isCube&&ne.boundingBoxSize,p.SS_USE_THICKNESS_AS_DEPTH=this.useThicknessAsDepth)}this._isTranslucencyEnabled&&(p.SS_ALBEDOFORTRANSLUCENCYTINT=this.useAlbedoToTintTranslucency)}}hardBindForSubMesh(p,_,E,A){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled)return;A.getRenderingMesh().getWorldMatrix().decompose(pi.Vector3[0]);const $=Math.max(Math.abs(pi.Vector3[0].x),Math.abs(pi.Vector3[0].y),Math.abs(pi.Vector3[0].z));p.updateFloat2("vThicknessParam",this.minimumThickness*$,(this.maximumThickness-this.minimumThickness)*$)}bindForSubMesh(p,_,E,A){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled)return;const $=A.materialDefines,ne=this._material.isFrozen,xe=this._material.realTimeFiltering,ce=$.LODBASEDMICROSFURACE,Te=this._getRefractionTexture(_);if(!p.useUbo||!ne||!p.isSync){if(this._thicknessTexture&&Ls.ThicknessTextureEnabled&&(p.updateFloat2("vThicknessInfos",this._thicknessTexture.coordinatesIndex,this._thicknessTexture.level),nr.BindTextureMatrix(this._thicknessTexture,p,"thickness")),this._refractionIntensityTexture&&Ls.RefractionIntensityTextureEnabled&&$.SS_REFRACTIONINTENSITY_TEXTURE&&(p.updateFloat2("vRefractionIntensityInfos",this._refractionIntensityTexture.coordinatesIndex,this._refractionIntensityTexture.level),nr.BindTextureMatrix(this._refractionIntensityTexture,p,"refractionIntensity")),this._translucencyIntensityTexture&&Ls.TranslucencyIntensityTextureEnabled&&$.SS_TRANSLUCENCYINTENSITY_TEXTURE&&(p.updateFloat2("vTranslucencyIntensityInfos",this._translucencyIntensityTexture.coordinatesIndex,this._translucencyIntensityTexture.level),nr.BindTextureMatrix(this._translucencyIntensityTexture,p,"translucencyIntensity")),Te&&Ls.RefractionTextureEnabled){p.updateMatrix("refractionMatrix",Te.getRefractionTextureMatrix());let Re=1;Te.isCube||Te.depth&&(Re=Te.depth);const ke=Te.getSize().width,We=this.volumeIndexOfRefraction;if(p.updateFloat4("vRefractionInfos",Te.level,1/We,Re,this._invertRefractionY?-1:1),p.updateFloat4("vRefractionMicrosurfaceInfos",ke,Te.lodGenerationScale,Te.lodGenerationOffset,1/this.indexOfRefraction),xe&&p.updateFloat2("vRefractionFilteringInfo",ke,ri.Log2(ke)),Te.boundingBoxSize){const Xe=Te;p.updateVector3("vRefractionPosition",Xe.boundingBoxPosition),p.updateVector3("vRefractionSize",Xe.boundingBoxSize)}}this._isScatteringEnabled&&p.updateFloat("scatteringDiffusionProfile",this._scatteringDiffusionProfileIndex),p.updateColor3("vDiffusionDistance",this.diffusionDistance),p.updateFloat4("vTintColor",this.tintColor.r,this.tintColor.g,this.tintColor.b,Math.max(1e-5,this.tintColorAtDistance)),p.updateFloat3("vSubSurfaceIntensity",this.refractionIntensity,this.translucencyIntensity,0),p.updateFloat("dispersion",this.dispersion)}_.texturesEnabled&&(this._thicknessTexture&&Ls.ThicknessTextureEnabled&&p.setTexture("thicknessSampler",this._thicknessTexture),this._refractionIntensityTexture&&Ls.RefractionIntensityTextureEnabled&&$.SS_REFRACTIONINTENSITY_TEXTURE&&p.setTexture("refractionIntensitySampler",this._refractionIntensityTexture),this._translucencyIntensityTexture&&Ls.TranslucencyIntensityTextureEnabled&&$.SS_TRANSLUCENCYINTENSITY_TEXTURE&&p.setTexture("translucencyIntensitySampler",this._translucencyIntensityTexture),Te&&Ls.RefractionTextureEnabled&&(ce?p.setTexture("refractionSampler",Te):(p.setTexture("refractionSampler",Te._lodTextureMid||Te),p.setTexture("refractionSamplerLow",Te._lodTextureLow||Te),p.setTexture("refractionSamplerHigh",Te._lodTextureHigh||Te))))}_getRefractionTexture(p){return this._refractionTexture?this._refractionTexture:this._isRefractionEnabled?p.environmentTexture:null}get disableAlphaBlending(){return this._isRefractionEnabled&&this._linkRefractionWithTransparency}fillRenderTargetTextures(p){Ls.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget&&p.push(this._refractionTexture)}hasTexture(p){return this._thicknessTexture===p||this._refractionTexture===p}hasRenderTargetTextures(){return!!(Ls.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget)}getActiveTextures(p){this._thicknessTexture&&p.push(this._thicknessTexture),this._refractionTexture&&p.push(this._refractionTexture)}getAnimatables(p){this._thicknessTexture&&this._thicknessTexture.animations&&this._thicknessTexture.animations.length>0&&p.push(this._thicknessTexture),this._refractionTexture&&this._refractionTexture.animations&&this._refractionTexture.animations.length>0&&p.push(this._refractionTexture)}dispose(p){p&&(this._thicknessTexture&&this._thicknessTexture.dispose(),this._refractionTexture&&this._refractionTexture.dispose())}getClassName(){return"PBRSubSurfaceConfiguration"}addFallbacks(p,_,E){return p.SS_SCATTERING&&_.addFallback(E++,"SS_SCATTERING"),p.SS_TRANSLUCENCY&&_.addFallback(E++,"SS_TRANSLUCENCY"),E}getSamplers(p){p.push("thicknessSampler","refractionIntensitySampler","translucencyIntensitySampler","refractionSampler","refractionSamplerLow","refractionSamplerHigh")}getUniforms(){return{ubo:[{name:"vRefractionMicrosurfaceInfos",size:4,type:"vec4"},{name:"vRefractionFilteringInfo",size:2,type:"vec2"},{name:"vTranslucencyIntensityInfos",size:2,type:"vec2"},{name:"vRefractionInfos",size:4,type:"vec4"},{name:"refractionMatrix",size:16,type:"mat4"},{name:"vThicknessInfos",size:2,type:"vec2"},{name:"vRefractionIntensityInfos",size:2,type:"vec2"},{name:"thicknessMatrix",size:16,type:"mat4"},{name:"refractionIntensityMatrix",size:16,type:"mat4"},{name:"translucencyIntensityMatrix",size:16,type:"mat4"},{name:"vThicknessParam",size:2,type:"vec2"},{name:"vDiffusionDistance",size:3,type:"vec3"},{name:"vTintColor",size:4,type:"vec4"},{name:"vSubSurfaceIntensity",size:3,type:"vec3"},{name:"vRefractionPosition",size:3,type:"vec3"},{name:"vRefractionSize",size:3,type:"vec3"},{name:"scatteringDiffusionProfile",size:1,type:"float"},{name:"dispersion",size:1,type:"float"}]}}}Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"isRefractionEnabled",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"isTranslucencyEnabled",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"isDispersionEnabled",void 0),Mt([Gt(),ks("_markScenePrePassDirty")],Wa.prototype,"isScatteringEnabled",void 0),Mt([Gt()],Wa.prototype,"_scatteringDiffusionProfileIndex",void 0),Mt([Gt()],Wa.prototype,"refractionIntensity",void 0),Mt([Gt()],Wa.prototype,"translucencyIntensity",void 0),Mt([Gt()],Wa.prototype,"useAlbedoToTintRefraction",void 0),Mt([Gt()],Wa.prototype,"useAlbedoToTintTranslucency",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"thicknessTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"refractionTexture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"indexOfRefraction",void 0),Mt([Gt()],Wa.prototype,"_volumeIndexOfRefraction",void 0),Mt([ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"volumeIndexOfRefraction",null),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"invertRefractionY",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"linkRefractionWithTransparency",void 0),Mt([Gt()],Wa.prototype,"minimumThickness",void 0),Mt([Gt()],Wa.prototype,"maximumThickness",void 0),Mt([Gt()],Wa.prototype,"useThicknessAsDepth",void 0),Mt([ja()],Wa.prototype,"tintColor",void 0),Mt([Gt()],Wa.prototype,"tintColorAtDistance",void 0),Mt([Gt()],Wa.prototype,"dispersion",void 0),Mt([ja()],Wa.prototype,"diffusionDistance",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"useMaskFromThicknessTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"refractionIntensityTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"translucencyIntensityTexture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Wa.prototype,"useGltfStyleTextures",void 0);class wL extends qh{constructor(){super(...arguments),this.DETAIL=!1,this.DETAILDIRECTUV=0,this.DETAIL_NORMALBLENDMETHOD=0}}class xu extends ql{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(p,_=!0){super(p,"DetailMap",140,new wL,_),this._texture=null,this.diffuseBlendLevel=1,this.roughnessBlendLevel=1,this.bumpLevel=1,this._normalBlendMethod=Xi.MATERIAL_NORMALBLENDMETHOD_WHITEOUT,this._isEnabled=!1,this.isEnabled=!1,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1]}isReadyForSubMesh(p,_,E){return this._isEnabled?!(p._areTexturesDirty&&_.texturesEnabled&&E.getCaps().standardDerivatives&&this._texture&&Ls.DetailTextureEnabled&&!this._texture.isReady()):!0}prepareDefines(p,_){if(this._isEnabled){p.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod;const E=_.getEngine();p._areTexturesDirty&&(E.getCaps().standardDerivatives&&this._texture&&Ls.DetailTextureEnabled&&this._isEnabled?(nr.PrepareDefinesForMergedUV(this._texture,p,"DETAIL"),p.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod):p.DETAIL=!1)}else p.DETAIL=!1}bindForSubMesh(p,_){if(!this._isEnabled)return;const E=this._material.isFrozen;(!p.useUbo||!E||!p.isSync)&&this._texture&&Ls.DetailTextureEnabled&&(p.updateFloat4("vDetailInfos",this._texture.coordinatesIndex,this.diffuseBlendLevel,this.bumpLevel,this.roughnessBlendLevel),nr.BindTextureMatrix(this._texture,p,"detail")),_.texturesEnabled&&this._texture&&Ls.DetailTextureEnabled&&p.setTexture("detailSampler",this._texture)}hasTexture(p){return this._texture===p}getActiveTextures(p){this._texture&&p.push(this._texture)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture)}dispose(p){p&&this._texture?.dispose()}getClassName(){return"DetailMapConfiguration"}getSamplers(p){p.push("detailSampler")}getUniforms(){return{ubo:[{name:"vDetailInfos",size:4,type:"vec4"},{name:"detailMatrix",size:16,type:"mat4"}]}}}Mt([Kn("detailTexture"),ks("_markAllSubMeshesAsTexturesDirty")],xu.prototype,"texture",void 0),Mt([Gt()],xu.prototype,"diffuseBlendLevel",void 0),Mt([Gt()],xu.prototype,"roughnessBlendLevel",void 0),Mt([Gt()],xu.prototype,"bumpLevel",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],xu.prototype,"normalBlendMethod",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],xu.prototype,"isEnabled",void 0);const qu={effect:null,subMesh:null};class nO extends qh{constructor(p){super(p),this.PBR=!0,this.NUM_SAMPLES="0",this.REALTIME_FILTERING=!1,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.ALBEDO=!1,this.GAMMAALBEDO=!1,this.ALBEDODIRECTUV=0,this.VERTEXCOLOR=!1,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.AMBIENT=!1,this.AMBIENTDIRECTUV=0,this.AMBIENTINGRAYSCALE=!1,this.OPACITY=!1,this.VERTEXALPHA=!1,this.OPACITYDIRECTUV=0,this.OPACITYRGB=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHABLEND=!1,this.ALPHAFROMALBEDO=!1,this.ALPHATESTVALUE="0.5",this.SPECULAROVERALPHA=!1,this.RADIANCEOVERALPHA=!1,this.ALPHAFRESNEL=!1,this.LINEARALPHAFRESNEL=!1,this.PREMULTIPLYALPHA=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.GAMMAEMISSIVE=!1,this.REFLECTIVITY=!1,this.REFLECTIVITY_GAMMA=!1,this.REFLECTIVITYDIRECTUV=0,this.SPECULARTERM=!1,this.MICROSURFACEFROMREFLECTIVITYMAP=!1,this.MICROSURFACEAUTOMATIC=!1,this.LODBASEDMICROSFURACE=!1,this.MICROSURFACEMAP=!1,this.MICROSURFACEMAPDIRECTUV=0,this.METALLICWORKFLOW=!1,this.ROUGHNESSSTOREINMETALMAPALPHA=!1,this.ROUGHNESSSTOREINMETALMAPGREEN=!1,this.METALLNESSSTOREINMETALMAPBLUE=!1,this.AOSTOREINMETALMAPRED=!1,this.METALLIC_REFLECTANCE=!1,this.METALLIC_REFLECTANCE_GAMMA=!1,this.METALLIC_REFLECTANCEDIRECTUV=0,this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY=!1,this.REFLECTANCE=!1,this.REFLECTANCE_GAMMA=!1,this.REFLECTANCEDIRECTUV=0,this.ENVIRONMENTBRDF=!1,this.ENVIRONMENTBRDF_RGBD=!1,this.NORMAL=!1,this.TANGENT=!1,this.BUMP=!1,this.BUMPDIRECTUV=0,this.OBJECTSPACE_NORMALMAP=!1,this.PARALLAX=!1,this.PARALLAX_RHS=!1,this.PARALLAXOCCLUSION=!1,this.NORMALXYSCALE=!0,this.LIGHTMAP=!1,this.LIGHTMAPDIRECTUV=0,this.USELIGHTMAPASSHADOWMAP=!1,this.GAMMALIGHTMAP=!1,this.RGBDLIGHTMAP=!1,this.REFLECTION=!1,this.REFLECTIONMAP_3D=!1,this.REFLECTIONMAP_SPHERICAL=!1,this.REFLECTIONMAP_PLANAR=!1,this.REFLECTIONMAP_CUBIC=!1,this.USE_LOCAL_REFLECTIONMAP_CUBIC=!1,this.REFLECTIONMAP_PROJECTION=!1,this.REFLECTIONMAP_SKYBOX=!1,this.REFLECTIONMAP_EXPLICIT=!1,this.REFLECTIONMAP_EQUIRECTANGULAR=!1,this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,this.INVERTCUBICMAP=!1,this.USESPHERICALFROMREFLECTIONMAP=!1,this.USEIRRADIANCEMAP=!1,this.USESPHERICALINVERTEX=!1,this.REFLECTIONMAP_OPPOSITEZ=!1,this.LODINREFLECTIONALPHA=!1,this.GAMMAREFLECTION=!1,this.RGBDREFLECTION=!1,this.LINEARSPECULARREFLECTION=!1,this.RADIANCEOCCLUSION=!1,this.HORIZONOCCLUSION=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.INSTANCESCOLOR=!1,this.PREPASS=!1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_NORMAL_WORLDSPACE=!1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.NONUNIFORMSCALING=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=!1,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.EXPOSURE=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.USEPHYSICALLIGHTFALLOFF=!1,this.USEGLTFLIGHTFALLOFF=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.POINTSIZE=!1,this.FOG=!1,this.LOGARITHMICDEPTH=!1,this.CAMERA_ORTHOGRAPHIC=!1,this.CAMERA_PERSPECTIVE=!1,this.FORCENORMALFORWARD=!1,this.SPECULARAA=!1,this.UNLIT=!1,this.DECAL_AFTER_DETAIL=!1,this.DEBUGMODE=0,this.rebuild()}reset(){super.reset(),this.ALPHATESTVALUE="0.5",this.PBR=!0,this.NORMALXYSCALE=!0}}class _a extends cE{get realTimeFiltering(){return this._realTimeFiltering}set realTimeFiltering(p){this._realTimeFiltering=p,this.markAsDirty(1)}get realTimeFilteringQuality(){return this._realTimeFilteringQuality}set realTimeFilteringQuality(p){this._realTimeFilteringQuality=p,this.markAsDirty(1)}get canRenderToMRT(){return!0}_attachImageProcessingConfiguration(p){p!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),p?this._imageProcessingConfiguration=p:this._imageProcessingConfiguration=this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add(()=>{this._markAllSubMeshesAsImageProcessingDirty()})))}constructor(p,_){super(p,_),this._directIntensity=1,this._emissiveIntensity=1,this._environmentIntensity=1,this._specularIntensity=1,this._lightingInfos=new Gr(this._directIntensity,this._emissiveIntensity,this._environmentIntensity,this._specularIntensity),this._disableBumpMap=!1,this._albedoTexture=null,this._ambientTexture=null,this._ambientTextureStrength=1,this._ambientTextureImpactOnAnalyticalLights=_a.DEFAULT_AO_ON_ANALYTICAL_LIGHTS,this._opacityTexture=null,this._reflectionTexture=null,this._emissiveTexture=null,this._reflectivityTexture=null,this._metallicTexture=null,this._metallic=null,this._roughness=null,this._metallicF0Factor=1,this._metallicReflectanceColor=ws.White(),this._useOnlyMetallicFromMetallicReflectanceTexture=!1,this._metallicReflectanceTexture=null,this._reflectanceTexture=null,this._microSurfaceTexture=null,this._bumpTexture=null,this._lightmapTexture=null,this._ambientColor=new ws(0,0,0),this._albedoColor=new ws(1,1,1),this._reflectivityColor=new ws(1,1,1),this._reflectionColor=new ws(1,1,1),this._emissiveColor=new ws(0,0,0),this._microSurface=.9,this._useLightmapAsShadowmap=!1,this._useHorizonOcclusion=!0,this._useRadianceOcclusion=!0,this._useAlphaFromAlbedoTexture=!1,this._useSpecularOverAlpha=!0,this._useMicroSurfaceFromReflectivityMapAlpha=!1,this._useRoughnessFromMetallicTextureAlpha=!0,this._useRoughnessFromMetallicTextureGreen=!1,this._useMetallnessFromMetallicTextureBlue=!1,this._useAmbientOcclusionFromMetallicTextureRed=!1,this._useAmbientInGrayScale=!1,this._useAutoMicroSurfaceFromReflectivityMap=!1,this._lightFalloff=_a.LIGHTFALLOFF_PHYSICAL,this._useRadianceOverAlpha=!0,this._useObjectSpaceNormalMap=!1,this._useParallax=!1,this._useParallaxOcclusion=!1,this._parallaxScaleBias=.05,this._disableLighting=!1,this._maxSimultaneousLights=4,this._invertNormalMapX=!1,this._invertNormalMapY=!1,this._twoSidedLighting=!1,this._alphaCutOff=.4,this._forceAlphaTest=!1,this._useAlphaFresnel=!1,this._useLinearAlphaFresnel=!1,this._environmentBRDFTexture=null,this._forceIrradianceInFragment=!1,this._realTimeFiltering=!1,this._realTimeFilteringQuality=8,this._forceNormalForward=!1,this._enableSpecularAntiAliasing=!1,this._imageProcessingObserver=null,this._renderTargets=new _t(16),this._globalAmbientColor=new ws(0,0,0),this._unlit=!1,this._applyDecalMapAfterDetailMap=!1,this._debugMode=0,this.debugMode=0,this.debugLimit=-1,this.debugFactor=1,this._cacheHasRenderTargetTextures=!1,this.brdf=new ko(this),this.clearCoat=new ho(this),this.iridescence=new hx(this),this.anisotropy=new ju(this),this.sheen=new L2(this),this.subSurface=new Wa(this),this.detailMap=new xu(this),this._attachImageProcessingConfiguration(null),this.getRenderTargetTextures=()=>(this._renderTargets.reset(),Ls.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget&&this._renderTargets.push(this._reflectionTexture),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets),this._environmentBRDFTexture=v_(this.getScene()),this.prePassConfiguration=new C_}get hasRenderTargetTextures(){return Ls.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget?!0:this._cacheHasRenderTargetTextures}get isPrePassCapable(){return!this.disableDepthWrite}getClassName(){return"PBRBaseMaterial"}get _disableAlphaBlending(){return this._transparencyMode===_a.PBRMATERIAL_OPAQUE||this._transparencyMode===_a.PBRMATERIAL_ALPHATEST||this.subSurface?.disableAlphaBlending}needAlphaBlending(){return this._disableAlphaBlending?!1:this.alpha<1||this._opacityTexture!=null||this._shouldUseAlphaFromAlbedoTexture()}needAlphaTesting(){return this._forceAlphaTest?!0:this.subSurface?.disableAlphaBlending?!1:this._hasAlphaChannel()&&(this._transparencyMode==null||this._transparencyMode===_a.PBRMATERIAL_ALPHATEST)}_shouldUseAlphaFromAlbedoTexture(){return this._albedoTexture!=null&&this._albedoTexture.hasAlpha&&this._useAlphaFromAlbedoTexture&&this._transparencyMode!==_a.PBRMATERIAL_OPAQUE}_hasAlphaChannel(){return this._albedoTexture!=null&&this._albedoTexture.hasAlpha||this._opacityTexture!=null}getAlphaTestTexture(){return this._albedoTexture}isReadyForSubMesh(p,_,E){this._uniformBufferLayoutBuilt||this.buildUniformLayout();const A=_._drawWrapper;if(A.effect&&this.isFrozen&&A._wasPreviouslyReady&&A._wasPreviouslyUsingInstances===E)return!0;_.materialDefines||(this._callbackPluginEventGeneric(wo.GetDefineNames,this._eventInfo),_.materialDefines=new nO(this._eventInfo.defineNames));const $=_.materialDefines;if(this._isReadyForSubMesh(_))return!0;const ne=this.getScene(),xe=ne.getEngine();if($._areTexturesDirty&&(this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,ne.texturesEnabled)){if(this._albedoTexture&&Ls.DiffuseTextureEnabled&&!this._albedoTexture.isReadyOrNotBlocking()||this._ambientTexture&&Ls.AmbientTextureEnabled&&!this._ambientTexture.isReadyOrNotBlocking()||this._opacityTexture&&Ls.OpacityTextureEnabled&&!this._opacityTexture.isReadyOrNotBlocking())return!1;const We=this._getReflectionTexture();if(We&&Ls.ReflectionTextureEnabled){if(!We.isReadyOrNotBlocking())return!1;if(We.irradianceTexture){if(!We.irradianceTexture.isReadyOrNotBlocking())return!1}else if(!We.sphericalPolynomial&&We.getInternalTexture()?._sphericalPolynomialPromise)return!1}if(this._lightmapTexture&&Ls.LightmapTextureEnabled&&!this._lightmapTexture.isReadyOrNotBlocking()||this._emissiveTexture&&Ls.EmissiveTextureEnabled&&!this._emissiveTexture.isReadyOrNotBlocking())return!1;if(Ls.SpecularTextureEnabled){if(this._metallicTexture){if(!this._metallicTexture.isReadyOrNotBlocking())return!1}else if(this._reflectivityTexture&&!this._reflectivityTexture.isReadyOrNotBlocking())return!1;if(this._metallicReflectanceTexture&&!this._metallicReflectanceTexture.isReadyOrNotBlocking()||this._reflectanceTexture&&!this._reflectanceTexture.isReadyOrNotBlocking()||this._microSurfaceTexture&&!this._microSurfaceTexture.isReadyOrNotBlocking())return!1}if(xe.getCaps().standardDerivatives&&this._bumpTexture&&Ls.BumpTextureEnabled&&!this._disableBumpMap&&!this._bumpTexture.isReady()||this._environmentBRDFTexture&&Ls.ReflectionTextureEnabled&&!this._environmentBRDFTexture.isReady())return!1}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=$,this._eventInfo.subMesh=_,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh||$._areImageProcessingDirty&&this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.isReady())return!1;!xe.getCaps().standardDerivatives&&!p.isVerticesDataPresent(ut.NormalKind)&&(p.createNormals(!0),vi.Warn("PBRMaterial: Normals have been created for the mesh: "+p.name));const ce=_.effect,Te=$._areLightsDisposed;let Re=this._prepareEffect(p,$,this.onCompiled,this.onError,E,null,_.getRenderingMesh().hasThinInstances),ke=!1;if(Re)if(this._onEffectCreatedObservable&&(qu.effect=Re,qu.subMesh=_,this._onEffectCreatedObservable.notifyObservers(qu)),this.allowShaderHotSwapping&&ce&&!Re.isReady()){if(Re=ce,$.markAsUnprocessed(),ke=this.isFrozen,Te)return $._areLightsDisposed=!0,!1}else ne.resetCachedMaterial(),_.setEffect(Re,$,this._materialContext);return!_.effect||!_.effect.isReady()?!1:($._renderId=ne.getRenderId(),A._wasPreviouslyReady=!ke,A._wasPreviouslyUsingInstances=!!E,this._checkScenePerformancePriority(),!0)}isMetallicWorkflow(){return!!(this._metallic!=null||this._roughness!=null||this._metallicTexture)}_prepareEffect(p,_,E=null,A=null,$=null,ne=null,xe){if(this._prepareDefines(p,_,$,ne,xe),!_.isDirty)return null;_.markAsProcessed();const Te=this.getScene().getEngine(),Re=new p_;let ke=0;_.USESPHERICALINVERTEX&&Re.addFallback(ke++,"USESPHERICALINVERTEX"),_.FOG&&Re.addFallback(ke,"FOG"),_.SPECULARAA&&Re.addFallback(ke,"SPECULARAA"),_.POINTSIZE&&Re.addFallback(ke,"POINTSIZE"),_.LOGARITHMICDEPTH&&Re.addFallback(ke,"LOGARITHMICDEPTH"),_.PARALLAX&&Re.addFallback(ke,"PARALLAX"),_.PARALLAX_RHS&&Re.addFallback(ke,"PARALLAX_RHS"),_.PARALLAXOCCLUSION&&Re.addFallback(ke++,"PARALLAXOCCLUSION"),_.ENVIRONMENTBRDF&&Re.addFallback(ke++,"ENVIRONMENTBRDF"),_.TANGENT&&Re.addFallback(ke++,"TANGENT"),_.BUMP&&Re.addFallback(ke++,"BUMP"),ke=nr.HandleFallbacksForShadows(_,Re,this._maxSimultaneousLights,ke++),_.SPECULARTERM&&Re.addFallback(ke++,"SPECULARTERM"),_.USESPHERICALFROMREFLECTIONMAP&&Re.addFallback(ke++,"USESPHERICALFROMREFLECTIONMAP"),_.USEIRRADIANCEMAP&&Re.addFallback(ke++,"USEIRRADIANCEMAP"),_.LIGHTMAP&&Re.addFallback(ke++,"LIGHTMAP"),_.NORMAL&&Re.addFallback(ke++,"NORMAL"),_.AMBIENT&&Re.addFallback(ke++,"AMBIENT"),_.EMISSIVE&&Re.addFallback(ke++,"EMISSIVE"),_.VERTEXCOLOR&&Re.addFallback(ke++,"VERTEXCOLOR"),_.MORPHTARGETS&&Re.addFallback(ke++,"MORPHTARGETS"),_.MULTIVIEW&&Re.addFallback(0,"MULTIVIEW");const We=[ut.PositionKind];_.NORMAL&&We.push(ut.NormalKind),_.TANGENT&&We.push(ut.TangentKind);for(let Wt=1;Wt<=6;++Wt)_["UV"+Wt]&&We.push(`uv${Wt===1?"":Wt}`);_.VERTEXCOLOR&&We.push(ut.ColorKind),nr.PrepareAttributesForBones(We,p,_,Re),nr.PrepareAttributesForInstances(We,_),nr.PrepareAttributesForMorphTargets(We,p,_),nr.PrepareAttributesForBakedVertexAnimation(We,p,_);let Xe="pbr";const xt=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vAlbedoColor","vReflectivityColor","vMetallicReflectanceFactors","vEmissiveColor","visibility","vReflectionColor","vFogInfos","vFogColor","pointSize","vAlbedoInfos","vAmbientInfos","vOpacityInfos","vReflectionInfos","vReflectionPosition","vReflectionSize","vEmissiveInfos","vReflectivityInfos","vReflectionFilteringInfo","vMetallicReflectanceInfos","vReflectanceInfos","vMicroSurfaceSamplerInfos","vBumpInfos","vLightmapInfos","mBones","albedoMatrix","ambientMatrix","opacityMatrix","reflectionMatrix","emissiveMatrix","reflectivityMatrix","normalMatrix","microSurfaceSamplerMatrix","bumpMatrix","lightmapMatrix","metallicReflectanceMatrix","reflectanceMatrix","vLightingIntensity","logarithmicDepthConstant","vSphericalX","vSphericalY","vSphericalZ","vSphericalXX_ZZ","vSphericalYY_ZZ","vSphericalZZ","vSphericalXY","vSphericalYZ","vSphericalZX","vSphericalL00","vSphericalL1_1","vSphericalL10","vSphericalL11","vSphericalL2_2","vSphericalL2_1","vSphericalL20","vSphericalL21","vSphericalL22","vReflectionMicrosurfaceInfos","vTangentSpaceParams","boneTextureWidth","vDebugMode","morphTargetTextureInfo","morphTargetTextureIndices"],qe=["albedoSampler","reflectivitySampler","ambientSampler","emissiveSampler","bumpSampler","lightmapSampler","opacitySampler","reflectionSampler","reflectionSamplerLow","reflectionSamplerHigh","irradianceSampler","microSurfaceSampler","environmentBrdfSampler","boneSampler","metallicReflectanceSampler","reflectanceSampler","morphTargets","oitDepthSampler","oitFrontColorSampler"],ht=["Material","Scene","Mesh"],Nt={maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:_.NUM_MORPH_INFLUENCERS};this._eventInfo.fallbacks=Re,this._eventInfo.fallbackRank=ke,this._eventInfo.defines=_,this._eventInfo.uniforms=xt,this._eventInfo.attributes=We,this._eventInfo.samplers=qe,this._eventInfo.uniformBuffersNames=ht,this._eventInfo.customCode=void 0,this._eventInfo.mesh=p,this._eventInfo.indexParameters=Nt,this._callbackPluginEventGeneric(wo.PrepareEffect,this._eventInfo),C_.AddUniforms(xt),C_.AddSamplers(qe),cg(xt),Hn&&(Hn.PrepareUniforms(xt,_),Hn.PrepareSamplers(qe,_)),nr.PrepareUniformsAndSamplersList({uniformsNames:xt,uniformBuffersNames:ht,samplers:qe,defines:_,maxSimultaneousLights:this._maxSimultaneousLights});const wt={};this.customShaderNameResolve&&(Xe=this.customShaderNameResolve(Xe,xt,ht,qe,_,We,wt));const Qt=_.toString(),Ht=Te.createEffect(Xe,{attributes:We,uniformsNames:xt,uniformBuffersNames:ht,samplers:qe,defines:Qt,fallbacks:Re,onCompiled:E,onError:A,indexParameters:Nt,processFinalCode:wt.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:_.PREPASS},Te);return this._eventInfo.customCode=void 0,Ht}_prepareDefines(p,_,E=null,A=null,$=!1){const ne=this.getScene(),xe=ne.getEngine();nr.PrepareDefinesForLights(ne,p,_,!0,this._maxSimultaneousLights,this._disableLighting),_._needNormals=!0,nr.PrepareDefinesForMultiview(ne,_);const ce=this.needAlphaBlendingForMesh(p)&&this.getScene().useOrderIndependentTransparency;if(nr.PrepareDefinesForPrePass(ne,_,this.canRenderToMRT&&!ce),nr.PrepareDefinesForOIT(ne,_,ce),_.METALLICWORKFLOW=this.isMetallicWorkflow(),_._areTexturesDirty){_._needUVs=!1;for(let Te=1;Te<=6;++Te)_["MAINUV"+Te]=!1;if(ne.texturesEnabled){_.ALBEDODIRECTUV=0,_.AMBIENTDIRECTUV=0,_.OPACITYDIRECTUV=0,_.EMISSIVEDIRECTUV=0,_.REFLECTIVITYDIRECTUV=0,_.MICROSURFACEMAPDIRECTUV=0,_.METALLIC_REFLECTANCEDIRECTUV=0,_.REFLECTANCEDIRECTUV=0,_.BUMPDIRECTUV=0,_.LIGHTMAPDIRECTUV=0,xe.getCaps().textureLOD&&(_.LODBASEDMICROSFURACE=!0),this._albedoTexture&&Ls.DiffuseTextureEnabled?(nr.PrepareDefinesForMergedUV(this._albedoTexture,_,"ALBEDO"),_.GAMMAALBEDO=this._albedoTexture.gammaSpace):_.ALBEDO=!1,this._ambientTexture&&Ls.AmbientTextureEnabled?(nr.PrepareDefinesForMergedUV(this._ambientTexture,_,"AMBIENT"),_.AMBIENTINGRAYSCALE=this._useAmbientInGrayScale):_.AMBIENT=!1,this._opacityTexture&&Ls.OpacityTextureEnabled?(nr.PrepareDefinesForMergedUV(this._opacityTexture,_,"OPACITY"),_.OPACITYRGB=this._opacityTexture.getAlphaFromRGB):_.OPACITY=!1;const Te=this._getReflectionTexture();if(Te&&Ls.ReflectionTextureEnabled){switch(_.REFLECTION=!0,_.GAMMAREFLECTION=Te.gammaSpace,_.RGBDREFLECTION=Te.isRGBD,_.LODINREFLECTIONALPHA=Te.lodLevelInAlpha,_.LINEARSPECULARREFLECTION=Te.linearSpecularLOD,this.realTimeFiltering&&this.realTimeFilteringQuality>0?(_.NUM_SAMPLES=""+this.realTimeFilteringQuality,xe._features.needTypeSuffixInShaderConstants&&(_.NUM_SAMPLES=_.NUM_SAMPLES+"u"),_.REALTIME_FILTERING=!0):_.REALTIME_FILTERING=!1,_.INVERTCUBICMAP=Te.coordinatesMode===Hi.INVCUBIC_MODE,_.REFLECTIONMAP_3D=Te.isCube,_.REFLECTIONMAP_OPPOSITEZ=_.REFLECTIONMAP_3D&&this.getScene().useRightHandedSystem?!Te.invertZ:Te.invertZ,_.REFLECTIONMAP_CUBIC=!1,_.REFLECTIONMAP_EXPLICIT=!1,_.REFLECTIONMAP_PLANAR=!1,_.REFLECTIONMAP_PROJECTION=!1,_.REFLECTIONMAP_SKYBOX=!1,_.REFLECTIONMAP_SPHERICAL=!1,_.REFLECTIONMAP_EQUIRECTANGULAR=!1,_.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,_.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,Te.coordinatesMode){case Hi.EXPLICIT_MODE:_.REFLECTIONMAP_EXPLICIT=!0;break;case Hi.PLANAR_MODE:_.REFLECTIONMAP_PLANAR=!0;break;case Hi.PROJECTION_MODE:_.REFLECTIONMAP_PROJECTION=!0;break;case Hi.SKYBOX_MODE:_.REFLECTIONMAP_SKYBOX=!0;break;case Hi.SPHERICAL_MODE:_.REFLECTIONMAP_SPHERICAL=!0;break;case Hi.EQUIRECTANGULAR_MODE:_.REFLECTIONMAP_EQUIRECTANGULAR=!0;break;case Hi.FIXED_EQUIRECTANGULAR_MODE:_.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!0;break;case Hi.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:_.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!0;break;case Hi.CUBIC_MODE:case Hi.INVCUBIC_MODE:default:_.REFLECTIONMAP_CUBIC=!0,_.USE_LOCAL_REFLECTIONMAP_CUBIC=!!Te.boundingBoxSize;break}Te.coordinatesMode!==Hi.SKYBOX_MODE&&(Te.irradianceTexture?(_.USEIRRADIANCEMAP=!0,_.USESPHERICALFROMREFLECTIONMAP=!1):Te.isCube&&(_.USESPHERICALFROMREFLECTIONMAP=!0,_.USEIRRADIANCEMAP=!1,this._forceIrradianceInFragment||this.realTimeFiltering||this._twoSidedLighting||xe.getCaps().maxVaryingVectors<=8?_.USESPHERICALINVERTEX=!1:_.USESPHERICALINVERTEX=!0))}else _.REFLECTION=!1,_.REFLECTIONMAP_3D=!1,_.REFLECTIONMAP_SPHERICAL=!1,_.REFLECTIONMAP_PLANAR=!1,_.REFLECTIONMAP_CUBIC=!1,_.USE_LOCAL_REFLECTIONMAP_CUBIC=!1,_.REFLECTIONMAP_PROJECTION=!1,_.REFLECTIONMAP_SKYBOX=!1,_.REFLECTIONMAP_EXPLICIT=!1,_.REFLECTIONMAP_EQUIRECTANGULAR=!1,_.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,_.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,_.INVERTCUBICMAP=!1,_.USESPHERICALFROMREFLECTIONMAP=!1,_.USEIRRADIANCEMAP=!1,_.USESPHERICALINVERTEX=!1,_.REFLECTIONMAP_OPPOSITEZ=!1,_.LODINREFLECTIONALPHA=!1,_.GAMMAREFLECTION=!1,_.RGBDREFLECTION=!1,_.LINEARSPECULARREFLECTION=!1;if(this._lightmapTexture&&Ls.LightmapTextureEnabled?(nr.PrepareDefinesForMergedUV(this._lightmapTexture,_,"LIGHTMAP"),_.USELIGHTMAPASSHADOWMAP=this._useLightmapAsShadowmap,_.GAMMALIGHTMAP=this._lightmapTexture.gammaSpace,_.RGBDLIGHTMAP=this._lightmapTexture.isRGBD):_.LIGHTMAP=!1,this._emissiveTexture&&Ls.EmissiveTextureEnabled?(nr.PrepareDefinesForMergedUV(this._emissiveTexture,_,"EMISSIVE"),_.GAMMAEMISSIVE=this._emissiveTexture.gammaSpace):_.EMISSIVE=!1,Ls.SpecularTextureEnabled){if(this._metallicTexture?(nr.PrepareDefinesForMergedUV(this._metallicTexture,_,"REFLECTIVITY"),_.ROUGHNESSSTOREINMETALMAPALPHA=this._useRoughnessFromMetallicTextureAlpha,_.ROUGHNESSSTOREINMETALMAPGREEN=!this._useRoughnessFromMetallicTextureAlpha&&this._useRoughnessFromMetallicTextureGreen,_.METALLNESSSTOREINMETALMAPBLUE=this._useMetallnessFromMetallicTextureBlue,_.AOSTOREINMETALMAPRED=this._useAmbientOcclusionFromMetallicTextureRed,_.REFLECTIVITY_GAMMA=!1):this._reflectivityTexture?(nr.PrepareDefinesForMergedUV(this._reflectivityTexture,_,"REFLECTIVITY"),_.MICROSURFACEFROMREFLECTIVITYMAP=this._useMicroSurfaceFromReflectivityMapAlpha,_.MICROSURFACEAUTOMATIC=this._useAutoMicroSurfaceFromReflectivityMap,_.REFLECTIVITY_GAMMA=this._reflectivityTexture.gammaSpace):_.REFLECTIVITY=!1,this._metallicReflectanceTexture||this._reflectanceTexture){const Re=this._metallicReflectanceTexture!==null&&this._metallicReflectanceTexture._texture===this._reflectanceTexture?._texture&&this._metallicReflectanceTexture.checkTransformsAreIdentical(this._reflectanceTexture);_.METALLIC_REFLECTANCE_USE_ALPHA_ONLY=this._useOnlyMetallicFromMetallicReflectanceTexture&&!Re,this._metallicReflectanceTexture?(nr.PrepareDefinesForMergedUV(this._metallicReflectanceTexture,_,"METALLIC_REFLECTANCE"),_.METALLIC_REFLECTANCE_GAMMA=this._metallicReflectanceTexture.gammaSpace):_.METALLIC_REFLECTANCE=!1,this._reflectanceTexture&&!Re&&(!this._metallicReflectanceTexture||this._metallicReflectanceTexture&&this._useOnlyMetallicFromMetallicReflectanceTexture)?(nr.PrepareDefinesForMergedUV(this._reflectanceTexture,_,"REFLECTANCE"),_.REFLECTANCE_GAMMA=this._reflectanceTexture.gammaSpace):_.REFLECTANCE=!1}else _.METALLIC_REFLECTANCE=!1,_.REFLECTANCE=!1;this._microSurfaceTexture?nr.PrepareDefinesForMergedUV(this._microSurfaceTexture,_,"MICROSURFACEMAP"):_.MICROSURFACEMAP=!1}else _.REFLECTIVITY=!1,_.MICROSURFACEMAP=!1;xe.getCaps().standardDerivatives&&this._bumpTexture&&Ls.BumpTextureEnabled&&!this._disableBumpMap?(nr.PrepareDefinesForMergedUV(this._bumpTexture,_,"BUMP"),this._useParallax&&this._albedoTexture&&Ls.DiffuseTextureEnabled?(_.PARALLAX=!0,_.PARALLAX_RHS=ne.useRightHandedSystem,_.PARALLAXOCCLUSION=!!this._useParallaxOcclusion):_.PARALLAX=!1,_.OBJECTSPACE_NORMALMAP=this._useObjectSpaceNormalMap):(_.BUMP=!1,_.PARALLAX=!1,_.PARALLAX_RHS=!1,_.PARALLAXOCCLUSION=!1,_.OBJECTSPACE_NORMALMAP=!1),this._environmentBRDFTexture&&Ls.ReflectionTextureEnabled?(_.ENVIRONMENTBRDF=!0,_.ENVIRONMENTBRDF_RGBD=this._environmentBRDFTexture.isRGBD):(_.ENVIRONMENTBRDF=!1,_.ENVIRONMENTBRDF_RGBD=!1),this._shouldUseAlphaFromAlbedoTexture()?_.ALPHAFROMALBEDO=!0:_.ALPHAFROMALBEDO=!1}_.SPECULAROVERALPHA=this._useSpecularOverAlpha,this._lightFalloff===_a.LIGHTFALLOFF_STANDARD?(_.USEPHYSICALLIGHTFALLOFF=!1,_.USEGLTFLIGHTFALLOFF=!1):this._lightFalloff===_a.LIGHTFALLOFF_GLTF?(_.USEPHYSICALLIGHTFALLOFF=!1,_.USEGLTFLIGHTFALLOFF=!0):(_.USEPHYSICALLIGHTFALLOFF=!0,_.USEGLTFLIGHTFALLOFF=!1),_.RADIANCEOVERALPHA=this._useRadianceOverAlpha,!this.backFaceCulling&&this._twoSidedLighting?_.TWOSIDEDLIGHTING=!0:_.TWOSIDEDLIGHTING=!1,_.SPECULARAA=xe.getCaps().standardDerivatives&&this._enableSpecularAntiAliasing}(_._areTexturesDirty||_._areMiscDirty)&&(_.ALPHATESTVALUE=`${this._alphaCutOff}${this._alphaCutOff%1===0?".":""}`,_.PREMULTIPLYALPHA=this.alphaMode===7||this.alphaMode===8,_.ALPHABLEND=this.needAlphaBlendingForMesh(p),_.ALPHAFRESNEL=this._useAlphaFresnel||this._useLinearAlphaFresnel,_.LINEARALPHAFRESNEL=this._useLinearAlphaFresnel),_._areImageProcessingDirty&&this._imageProcessingConfiguration&&this._imageProcessingConfiguration.prepareDefines(_),_.FORCENORMALFORWARD=this._forceNormalForward,_.RADIANCEOCCLUSION=this._useRadianceOcclusion,_.HORIZONOCCLUSION=this._useHorizonOcclusion,_._areMiscDirty&&(nr.PrepareDefinesForMisc(p,ne,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(p)||this._forceAlphaTest,_,this._applyDecalMapAfterDetailMap),_.UNLIT=this._unlit||(this.pointsCloud||this.wireframe)&&!p.isVerticesDataPresent(ut.NormalKind),_.DEBUGMODE=this._debugMode),nr.PrepareDefinesForFrameBoundValues(ne,xe,this,_,!!E,A,$),this._eventInfo.defines=_,this._eventInfo.mesh=p,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),nr.PrepareDefinesForAttributes(p,_,!0,!0,!0,this._transparencyMode!==_a.PBRMATERIAL_OPAQUE),this._callbackPluginEventPrepareDefines(this._eventInfo)}forceCompilation(p,_,E){const A={clipPlane:!1,useInstances:!1,...E};this._uniformBufferLayoutBuilt||this.buildUniformLayout(),this._callbackPluginEventGeneric(wo.GetDefineNames,this._eventInfo);const $=new nO(this._eventInfo.defineNames),ne=this._prepareEffect(p,$,void 0,void 0,A.useInstances,A.clipPlane,p.hasThinInstances);this._onEffectCreatedObservable&&(qu.effect=ne,qu.subMesh=null,this._onEffectCreatedObservable.notifyObservers(qu)),ne.isReady()?_&&_(this):ne.onCompileObservable.add(()=>{_&&_(this)})}buildUniformLayout(){const p=this._uniformBuffer;p.addUniform("vAlbedoInfos",2),p.addUniform("vAmbientInfos",4),p.addUniform("vOpacityInfos",2),p.addUniform("vEmissiveInfos",2),p.addUniform("vLightmapInfos",2),p.addUniform("vReflectivityInfos",3),p.addUniform("vMicroSurfaceSamplerInfos",2),p.addUniform("vReflectionInfos",2),p.addUniform("vReflectionFilteringInfo",2),p.addUniform("vReflectionPosition",3),p.addUniform("vReflectionSize",3),p.addUniform("vBumpInfos",3),p.addUniform("albedoMatrix",16),p.addUniform("ambientMatrix",16),p.addUniform("opacityMatrix",16),p.addUniform("emissiveMatrix",16),p.addUniform("lightmapMatrix",16),p.addUniform("reflectivityMatrix",16),p.addUniform("microSurfaceSamplerMatrix",16),p.addUniform("bumpMatrix",16),p.addUniform("vTangentSpaceParams",2),p.addUniform("reflectionMatrix",16),p.addUniform("vReflectionColor",3),p.addUniform("vAlbedoColor",4),p.addUniform("vLightingIntensity",4),p.addUniform("vReflectionMicrosurfaceInfos",3),p.addUniform("pointSize",1),p.addUniform("vReflectivityColor",4),p.addUniform("vEmissiveColor",3),p.addUniform("vAmbientColor",3),p.addUniform("vDebugMode",2),p.addUniform("vMetallicReflectanceFactors",4),p.addUniform("vMetallicReflectanceInfos",2),p.addUniform("metallicReflectanceMatrix",16),p.addUniform("vReflectanceInfos",2),p.addUniform("reflectanceMatrix",16),p.addUniform("vSphericalL00",3),p.addUniform("vSphericalL1_1",3),p.addUniform("vSphericalL10",3),p.addUniform("vSphericalL11",3),p.addUniform("vSphericalL2_2",3),p.addUniform("vSphericalL2_1",3),p.addUniform("vSphericalL20",3),p.addUniform("vSphericalL21",3),p.addUniform("vSphericalL22",3),p.addUniform("vSphericalX",3),p.addUniform("vSphericalY",3),p.addUniform("vSphericalZ",3),p.addUniform("vSphericalXX_ZZ",3),p.addUniform("vSphericalYY_ZZ",3),p.addUniform("vSphericalZZ",3),p.addUniform("vSphericalXY",3),p.addUniform("vSphericalYZ",3),p.addUniform("vSphericalZX",3),super.buildUniformLayout()}bindForSubMesh(p,_,E){const A=this.getScene(),$=E.materialDefines;if(!$)return;const ne=E.effect;if(!ne)return;this._activeEffect=ne,_.getMeshUniformBuffer().bindToEffect(ne,"Mesh"),_.transferToEffect(p);const xe=A.getEngine();this._uniformBuffer.bindToEffect(ne,"Material"),this.prePassConfiguration.bindForSubMesh(this._activeEffect,A,_,p,this.isFrozen),this._eventInfo.subMesh=E,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),$.OBJECTSPACE_NORMALMAP&&(p.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const ce=this._mustRebind(A,ne,E,_.visibility);nr.BindBonesParameters(_,this._activeEffect,this.prePassConfiguration);let Te=null;const Re=this._uniformBuffer;if(ce){if(this.bindViewProjection(ne),Te=this._getReflectionTexture(),!Re.useUbo||!this.isFrozen||!Re.isSync||E._drawWrapper._forceRebindOnNextCall){if(A.texturesEnabled){if(this._albedoTexture&&Ls.DiffuseTextureEnabled&&(Re.updateFloat2("vAlbedoInfos",this._albedoTexture.coordinatesIndex,this._albedoTexture.level),nr.BindTextureMatrix(this._albedoTexture,Re,"albedo")),this._ambientTexture&&Ls.AmbientTextureEnabled&&(Re.updateFloat4("vAmbientInfos",this._ambientTexture.coordinatesIndex,this._ambientTexture.level,this._ambientTextureStrength,this._ambientTextureImpactOnAnalyticalLights),nr.BindTextureMatrix(this._ambientTexture,Re,"ambient")),this._opacityTexture&&Ls.OpacityTextureEnabled&&(Re.updateFloat2("vOpacityInfos",this._opacityTexture.coordinatesIndex,this._opacityTexture.level),nr.BindTextureMatrix(this._opacityTexture,Re,"opacity")),Te&&Ls.ReflectionTextureEnabled){if(Re.updateMatrix("reflectionMatrix",Te.getReflectionTextureMatrix()),Re.updateFloat2("vReflectionInfos",Te.level,0),Te.boundingBoxSize){const ke=Te;Re.updateVector3("vReflectionPosition",ke.boundingBoxPosition),Re.updateVector3("vReflectionSize",ke.boundingBoxSize)}if(this.realTimeFiltering){const ke=Te.getSize().width;Re.updateFloat2("vReflectionFilteringInfo",ke,ri.Log2(ke))}if(!$.USEIRRADIANCEMAP){const ke=Te.sphericalPolynomial;if($.USESPHERICALFROMREFLECTIONMAP&&ke)if($.SPHERICAL_HARMONICS){const We=ke.preScaledHarmonics;Re.updateVector3("vSphericalL00",We.l00),Re.updateVector3("vSphericalL1_1",We.l1_1),Re.updateVector3("vSphericalL10",We.l10),Re.updateVector3("vSphericalL11",We.l11),Re.updateVector3("vSphericalL2_2",We.l2_2),Re.updateVector3("vSphericalL2_1",We.l2_1),Re.updateVector3("vSphericalL20",We.l20),Re.updateVector3("vSphericalL21",We.l21),Re.updateVector3("vSphericalL22",We.l22)}else Re.updateFloat3("vSphericalX",ke.x.x,ke.x.y,ke.x.z),Re.updateFloat3("vSphericalY",ke.y.x,ke.y.y,ke.y.z),Re.updateFloat3("vSphericalZ",ke.z.x,ke.z.y,ke.z.z),Re.updateFloat3("vSphericalXX_ZZ",ke.xx.x-ke.zz.x,ke.xx.y-ke.zz.y,ke.xx.z-ke.zz.z),Re.updateFloat3("vSphericalYY_ZZ",ke.yy.x-ke.zz.x,ke.yy.y-ke.zz.y,ke.yy.z-ke.zz.z),Re.updateFloat3("vSphericalZZ",ke.zz.x,ke.zz.y,ke.zz.z),Re.updateFloat3("vSphericalXY",ke.xy.x,ke.xy.y,ke.xy.z),Re.updateFloat3("vSphericalYZ",ke.yz.x,ke.yz.y,ke.yz.z),Re.updateFloat3("vSphericalZX",ke.zx.x,ke.zx.y,ke.zx.z)}Re.updateFloat3("vReflectionMicrosurfaceInfos",Te.getSize().width,Te.lodGenerationScale,Te.lodGenerationOffset)}this._emissiveTexture&&Ls.EmissiveTextureEnabled&&(Re.updateFloat2("vEmissiveInfos",this._emissiveTexture.coordinatesIndex,this._emissiveTexture.level),nr.BindTextureMatrix(this._emissiveTexture,Re,"emissive")),this._lightmapTexture&&Ls.LightmapTextureEnabled&&(Re.updateFloat2("vLightmapInfos",this._lightmapTexture.coordinatesIndex,this._lightmapTexture.level),nr.BindTextureMatrix(this._lightmapTexture,Re,"lightmap")),Ls.SpecularTextureEnabled&&(this._metallicTexture?(Re.updateFloat3("vReflectivityInfos",this._metallicTexture.coordinatesIndex,this._metallicTexture.level,this._ambientTextureStrength),nr.BindTextureMatrix(this._metallicTexture,Re,"reflectivity")):this._reflectivityTexture&&(Re.updateFloat3("vReflectivityInfos",this._reflectivityTexture.coordinatesIndex,this._reflectivityTexture.level,1),nr.BindTextureMatrix(this._reflectivityTexture,Re,"reflectivity")),this._metallicReflectanceTexture&&(Re.updateFloat2("vMetallicReflectanceInfos",this._metallicReflectanceTexture.coordinatesIndex,this._metallicReflectanceTexture.level),nr.BindTextureMatrix(this._metallicReflectanceTexture,Re,"metallicReflectance")),this._reflectanceTexture&&$.REFLECTANCE&&(Re.updateFloat2("vReflectanceInfos",this._reflectanceTexture.coordinatesIndex,this._reflectanceTexture.level),nr.BindTextureMatrix(this._reflectanceTexture,Re,"reflectance")),this._microSurfaceTexture&&(Re.updateFloat2("vMicroSurfaceSamplerInfos",this._microSurfaceTexture.coordinatesIndex,this._microSurfaceTexture.level),nr.BindTextureMatrix(this._microSurfaceTexture,Re,"microSurfaceSampler"))),this._bumpTexture&&xe.getCaps().standardDerivatives&&Ls.BumpTextureEnabled&&!this._disableBumpMap&&(Re.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,this._bumpTexture.level,this._parallaxScaleBias),nr.BindTextureMatrix(this._bumpTexture,Re,"bump"),A._mirroredCameraPosition?Re.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):Re.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1))}if(this.pointsCloud&&Re.updateFloat("pointSize",this.pointSize),$.METALLICWORKFLOW){na.Color3[0].r=this._metallic===void 0||this._metallic===null?1:this._metallic,na.Color3[0].g=this._roughness===void 0||this._roughness===null?1:this._roughness,Re.updateColor4("vReflectivityColor",na.Color3[0],1);const ke=this.subSurface?._indexOfRefraction??1.5,We=1,Xe=Math.pow((ke-We)/(ke+We),2);this._metallicReflectanceColor.scaleToRef(Xe*this._metallicF0Factor,na.Color3[0]);const xt=this._metallicF0Factor;Re.updateColor4("vMetallicReflectanceFactors",na.Color3[0],xt)}else Re.updateColor4("vReflectivityColor",this._reflectivityColor,this._microSurface);Re.updateColor3("vEmissiveColor",Ls.EmissiveTextureEnabled?this._emissiveColor:ws.BlackReadOnly),Re.updateColor3("vReflectionColor",this._reflectionColor),!$.SS_REFRACTION&&this.subSurface?._linkRefractionWithTransparency?Re.updateColor4("vAlbedoColor",this._albedoColor,1):Re.updateColor4("vAlbedoColor",this._albedoColor,this.alpha),this._lightingInfos.x=this._directIntensity,this._lightingInfos.y=this._emissiveIntensity,this._lightingInfos.z=this._environmentIntensity*A.environmentIntensity,this._lightingInfos.w=this._specularIntensity,Re.updateVector4("vLightingIntensity",this._lightingInfos),A.ambientColor.multiplyToRef(this._ambientColor,this._globalAmbientColor),Re.updateColor3("vAmbientColor",this._globalAmbientColor),Re.updateFloat2("vDebugMode",this.debugLimit,this.debugFactor)}A.texturesEnabled&&(this._albedoTexture&&Ls.DiffuseTextureEnabled&&Re.setTexture("albedoSampler",this._albedoTexture),this._ambientTexture&&Ls.AmbientTextureEnabled&&Re.setTexture("ambientSampler",this._ambientTexture),this._opacityTexture&&Ls.OpacityTextureEnabled&&Re.setTexture("opacitySampler",this._opacityTexture),Te&&Ls.ReflectionTextureEnabled&&($.LODBASEDMICROSFURACE?Re.setTexture("reflectionSampler",Te):(Re.setTexture("reflectionSampler",Te._lodTextureMid||Te),Re.setTexture("reflectionSamplerLow",Te._lodTextureLow||Te),Re.setTexture("reflectionSamplerHigh",Te._lodTextureHigh||Te)),$.USEIRRADIANCEMAP&&Re.setTexture("irradianceSampler",Te.irradianceTexture)),$.ENVIRONMENTBRDF&&Re.setTexture("environmentBrdfSampler",this._environmentBRDFTexture),this._emissiveTexture&&Ls.EmissiveTextureEnabled&&Re.setTexture("emissiveSampler",this._emissiveTexture),this._lightmapTexture&&Ls.LightmapTextureEnabled&&Re.setTexture("lightmapSampler",this._lightmapTexture),Ls.SpecularTextureEnabled&&(this._metallicTexture?Re.setTexture("reflectivitySampler",this._metallicTexture):this._reflectivityTexture&&Re.setTexture("reflectivitySampler",this._reflectivityTexture),this._metallicReflectanceTexture&&Re.setTexture("metallicReflectanceSampler",this._metallicReflectanceTexture),this._reflectanceTexture&&$.REFLECTANCE&&Re.setTexture("reflectanceSampler",this._reflectanceTexture),this._microSurfaceTexture&&Re.setTexture("microSurfaceSampler",this._microSurfaceTexture)),this._bumpTexture&&xe.getCaps().standardDerivatives&&Ls.BumpTextureEnabled&&!this._disableBumpMap&&Re.setTexture("bumpSampler",this._bumpTexture)),this.getScene().useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(_)&&this.getScene().depthPeelingRenderer.bind(ne),this._eventInfo.subMesh=E,this._callbackPluginEventBindForSubMesh(this._eventInfo),ug(this._activeEffect,this,A),this.bindEyePosition(ne)}else A.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);(ce||!this.isFrozen)&&(A.lightsEnabled&&!this._disableLighting&&nr.BindLights(A,_,this._activeEffect,$,this._maxSimultaneousLights),(A.fogEnabled&&_.applyFog&&A.fogMode!==W0.FOGMODE_NONE||Te||this.subSurface.refractionTexture||_.receiveShadows||$.PREPASS)&&this.bindView(ne),nr.BindFogParameters(A,_,this._activeEffect,!0),$.NUM_MORPH_INFLUENCERS&&nr.BindMorphTargetParameters(_,this._activeEffect),$.BAKED_VERTEX_ANIMATION_TEXTURE&&_.bakedVertexAnimationManager?.bind(ne,$.INSTANCES),this._imageProcessingConfiguration.bind(this._activeEffect),nr.BindLogDepth($,this._activeEffect,A)),this._afterBind(_,this._activeEffect,E),Re.update()}getAnimatables(){const p=super.getAnimatables();return this._albedoTexture&&this._albedoTexture.animations&&this._albedoTexture.animations.length>0&&p.push(this._albedoTexture),this._ambientTexture&&this._ambientTexture.animations&&this._ambientTexture.animations.length>0&&p.push(this._ambientTexture),this._opacityTexture&&this._opacityTexture.animations&&this._opacityTexture.animations.length>0&&p.push(this._opacityTexture),this._reflectionTexture&&this._reflectionTexture.animations&&this._reflectionTexture.animations.length>0&&p.push(this._reflectionTexture),this._emissiveTexture&&this._emissiveTexture.animations&&this._emissiveTexture.animations.length>0&&p.push(this._emissiveTexture),this._metallicTexture&&this._metallicTexture.animations&&this._metallicTexture.animations.length>0?p.push(this._metallicTexture):this._reflectivityTexture&&this._reflectivityTexture.animations&&this._reflectivityTexture.animations.length>0&&p.push(this._reflectivityTexture),this._bumpTexture&&this._bumpTexture.animations&&this._bumpTexture.animations.length>0&&p.push(this._bumpTexture),this._lightmapTexture&&this._lightmapTexture.animations&&this._lightmapTexture.animations.length>0&&p.push(this._lightmapTexture),this._metallicReflectanceTexture&&this._metallicReflectanceTexture.animations&&this._metallicReflectanceTexture.animations.length>0&&p.push(this._metallicReflectanceTexture),this._reflectanceTexture&&this._reflectanceTexture.animations&&this._reflectanceTexture.animations.length>0&&p.push(this._reflectanceTexture),this._microSurfaceTexture&&this._microSurfaceTexture.animations&&this._microSurfaceTexture.animations.length>0&&p.push(this._microSurfaceTexture),p}_getReflectionTexture(){return this._reflectionTexture?this._reflectionTexture:this.getScene().environmentTexture}getActiveTextures(){const p=super.getActiveTextures();return this._albedoTexture&&p.push(this._albedoTexture),this._ambientTexture&&p.push(this._ambientTexture),this._opacityTexture&&p.push(this._opacityTexture),this._reflectionTexture&&p.push(this._reflectionTexture),this._emissiveTexture&&p.push(this._emissiveTexture),this._reflectivityTexture&&p.push(this._reflectivityTexture),this._metallicTexture&&p.push(this._metallicTexture),this._metallicReflectanceTexture&&p.push(this._metallicReflectanceTexture),this._reflectanceTexture&&p.push(this._reflectanceTexture),this._microSurfaceTexture&&p.push(this._microSurfaceTexture),this._bumpTexture&&p.push(this._bumpTexture),this._lightmapTexture&&p.push(this._lightmapTexture),p}hasTexture(p){return!!(super.hasTexture(p)||this._albedoTexture===p||this._ambientTexture===p||this._opacityTexture===p||this._reflectionTexture===p||this._emissiveTexture===p||this._reflectivityTexture===p||this._metallicTexture===p||this._metallicReflectanceTexture===p||this._reflectanceTexture===p||this._microSurfaceTexture===p||this._bumpTexture===p||this._lightmapTexture===p)}setPrePassRenderer(){if(!this.subSurface?.isScatteringEnabled)return!1;const p=this.getScene().enableSubSurfaceForPrePass();return p&&(p.enabled=!0),!0}dispose(p,_){_&&(this._environmentBRDFTexture&&this.getScene().environmentBRDFTexture!==this._environmentBRDFTexture&&this._environmentBRDFTexture.dispose(),this._albedoTexture?.dispose(),this._ambientTexture?.dispose(),this._opacityTexture?.dispose(),this._reflectionTexture?.dispose(),this._emissiveTexture?.dispose(),this._metallicTexture?.dispose(),this._reflectivityTexture?.dispose(),this._bumpTexture?.dispose(),this._lightmapTexture?.dispose(),this._metallicReflectanceTexture?.dispose(),this._reflectanceTexture?.dispose(),this._microSurfaceTexture?.dispose()),this._renderTargets.dispose(),this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(p,_)}}_a.PBRMATERIAL_OPAQUE=Xi.MATERIAL_OPAQUE,_a.PBRMATERIAL_ALPHATEST=Xi.MATERIAL_ALPHATEST,_a.PBRMATERIAL_ALPHABLEND=Xi.MATERIAL_ALPHABLEND,_a.PBRMATERIAL_ALPHATESTANDBLEND=Xi.MATERIAL_ALPHATESTANDBLEND,_a.DEFAULT_AO_ON_ANALYTICAL_LIGHTS=0,_a.LIGHTFALLOFF_PHYSICAL=0,_a.LIGHTFALLOFF_GLTF=1,_a.LIGHTFALLOFF_STANDARD=2,Mt([XO()],_a.prototype,"_imageProcessingConfiguration",void 0),Mt([ks("_markAllSubMeshesAsMiscDirty")],_a.prototype,"debugMode",void 0);class Ys extends _a{get refractionTexture(){return this.subSurface.refractionTexture}set refractionTexture(p){this.subSurface.refractionTexture=p,p?this.subSurface.isRefractionEnabled=!0:this.subSurface.linkRefractionWithTransparency||(this.subSurface.isRefractionEnabled=!1)}get indexOfRefraction(){return this.subSurface.indexOfRefraction}set indexOfRefraction(p){this.subSurface.indexOfRefraction=p}get invertRefractionY(){return this.subSurface.invertRefractionY}set invertRefractionY(p){this.subSurface.invertRefractionY=p}get linkRefractionWithTransparency(){return this.subSurface.linkRefractionWithTransparency}set linkRefractionWithTransparency(p){this.subSurface.linkRefractionWithTransparency=p,p&&(this.subSurface.isRefractionEnabled=!0)}get usePhysicalLightFalloff(){return this._lightFalloff===_a.LIGHTFALLOFF_PHYSICAL}set usePhysicalLightFalloff(p){p!==this.usePhysicalLightFalloff&&(this._markAllSubMeshesAsTexturesDirty(),p?this._lightFalloff=_a.LIGHTFALLOFF_PHYSICAL:this._lightFalloff=_a.LIGHTFALLOFF_STANDARD)}get useGLTFLightFalloff(){return this._lightFalloff===_a.LIGHTFALLOFF_GLTF}set useGLTFLightFalloff(p){p!==this.useGLTFLightFalloff&&(this._markAllSubMeshesAsTexturesDirty(),p?this._lightFalloff=_a.LIGHTFALLOFF_GLTF:this._lightFalloff=_a.LIGHTFALLOFF_STANDARD)}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(p){this._attachImageProcessingConfiguration(p),this._markAllSubMeshesAsTexturesDirty()}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(p){this.imageProcessingConfiguration.colorCurvesEnabled=p}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(p){this.imageProcessingConfiguration.colorGradingEnabled=p}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(p){this._imageProcessingConfiguration.toneMappingEnabled=p}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(p){this._imageProcessingConfiguration.exposure=p}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(p){this._imageProcessingConfiguration.contrast=p}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(p){this._imageProcessingConfiguration.colorGradingTexture=p}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(p){this._imageProcessingConfiguration.colorCurves=p}constructor(p,_){super(p,_),this.directIntensity=1,this.emissiveIntensity=1,this.environmentIntensity=1,this.specularIntensity=1,this.disableBumpMap=!1,this.ambientTextureStrength=1,this.ambientTextureImpactOnAnalyticalLights=Ys.DEFAULT_AO_ON_ANALYTICAL_LIGHTS,this.metallicF0Factor=1,this.metallicReflectanceColor=ws.White(),this.useOnlyMetallicFromMetallicReflectanceTexture=!1,this.ambientColor=new ws(0,0,0),this.albedoColor=new ws(1,1,1),this.reflectivityColor=new ws(1,1,1),this.reflectionColor=new ws(1,1,1),this.emissiveColor=new ws(0,0,0),this.microSurface=1,this.useLightmapAsShadowmap=!1,this.useAlphaFromAlbedoTexture=!1,this.forceAlphaTest=!1,this.alphaCutOff=.4,this.useSpecularOverAlpha=!0,this.useMicroSurfaceFromReflectivityMapAlpha=!1,this.useRoughnessFromMetallicTextureAlpha=!0,this.useRoughnessFromMetallicTextureGreen=!1,this.useMetallnessFromMetallicTextureBlue=!1,this.useAmbientOcclusionFromMetallicTextureRed=!1,this.useAmbientInGrayScale=!1,this.useAutoMicroSurfaceFromReflectivityMap=!1,this.useRadianceOverAlpha=!0,this.useObjectSpaceNormalMap=!1,this.useParallax=!1,this.useParallaxOcclusion=!1,this.parallaxScaleBias=.05,this.disableLighting=!1,this.forceIrradianceInFragment=!1,this.maxSimultaneousLights=4,this.invertNormalMapX=!1,this.invertNormalMapY=!1,this.twoSidedLighting=!1,this.useAlphaFresnel=!1,this.useLinearAlphaFresnel=!1,this.environmentBRDFTexture=null,this.forceNormalForward=!1,this.enableSpecularAntiAliasing=!1,this.useHorizonOcclusion=!0,this.useRadianceOcclusion=!0,this.unlit=!1,this.applyDecalMapAfterDetailMap=!1,this._environmentBRDFTexture=v_(this.getScene())}getClassName(){return"PBRMaterial"}clone(p,_=!0,E=""){const A=Xr.Clone(()=>new Ys(p,this.getScene()),this,{cloneTexturesOnlyOnce:_});return A.id=p,A.name=p,this.stencil.copyTo(A.stencil),this._clonePlugins(A,E),A}serialize(){const p=super.serialize();return p.customType="BABYLON.PBRMaterial",p}static Parse(p,_,E){const A=Xr.Parse(()=>new Ys(p.name,_),p,_,E);return p.stencil&&A.stencil.parse(p.stencil,_,E),Xi._ParsePlugins(p,A,_,E),p.clearCoat&&A.clearCoat.parse(p.clearCoat,_,E),p.anisotropy&&A.anisotropy.parse(p.anisotropy,_,E),p.brdf&&A.brdf.parse(p.brdf,_,E),p.sheen&&A.sheen.parse(p.sheen,_,E),p.subSurface&&A.subSurface.parse(p.subSurface,_,E),p.iridescence&&A.iridescence.parse(p.iridescence,_,E),A}}Ys.PBRMATERIAL_OPAQUE=_a.PBRMATERIAL_OPAQUE,Ys.PBRMATERIAL_ALPHATEST=_a.PBRMATERIAL_ALPHATEST,Ys.PBRMATERIAL_ALPHABLEND=_a.PBRMATERIAL_ALPHABLEND,Ys.PBRMATERIAL_ALPHATESTANDBLEND=_a.PBRMATERIAL_ALPHATESTANDBLEND,Ys.DEFAULT_AO_ON_ANALYTICAL_LIGHTS=_a.DEFAULT_AO_ON_ANALYTICAL_LIGHTS,Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"directIntensity",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"emissiveIntensity",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"environmentIntensity",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"specularIntensity",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"disableBumpMap",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"albedoTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"ambientTexture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"ambientTextureStrength",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"ambientTextureImpactOnAnalyticalLights",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesAndMiscDirty")],Ys.prototype,"opacityTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectionTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"emissiveTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectivityTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallicTexture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallic",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"roughness",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallicF0Factor",void 0),Mt([ja(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallicReflectanceColor",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useOnlyMetallicFromMetallicReflectanceTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallicReflectanceTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectanceTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"microSurfaceTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"bumpTexture",void 0),Mt([Kn(),ks("_markAllSubMeshesAsTexturesDirty",null)],Ys.prototype,"lightmapTexture",void 0),Mt([ja("ambient"),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"ambientColor",void 0),Mt([ja("albedo"),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"albedoColor",void 0),Mt([ja("reflectivity"),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectivityColor",void 0),Mt([ja("reflection"),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectionColor",void 0),Mt([ja("emissive"),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"emissiveColor",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"microSurface",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useLightmapAsShadowmap",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesAndMiscDirty")],Ys.prototype,"useAlphaFromAlbedoTexture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesAndMiscDirty")],Ys.prototype,"forceAlphaTest",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesAndMiscDirty")],Ys.prototype,"alphaCutOff",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useSpecularOverAlpha",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useMicroSurfaceFromReflectivityMapAlpha",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useRoughnessFromMetallicTextureAlpha",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useRoughnessFromMetallicTextureGreen",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useMetallnessFromMetallicTextureBlue",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useAmbientOcclusionFromMetallicTextureRed",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useAmbientInGrayScale",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useAutoMicroSurfaceFromReflectivityMap",void 0),Mt([Gt()],Ys.prototype,"usePhysicalLightFalloff",null),Mt([Gt()],Ys.prototype,"useGLTFLightFalloff",null),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useRadianceOverAlpha",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useObjectSpaceNormalMap",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useParallax",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useParallaxOcclusion",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"parallaxScaleBias",void 0),Mt([Gt(),ks("_markAllSubMeshesAsLightsDirty")],Ys.prototype,"disableLighting",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"forceIrradianceInFragment",void 0),Mt([Gt(),ks("_markAllSubMeshesAsLightsDirty")],Ys.prototype,"maxSimultaneousLights",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"invertNormalMapX",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"invertNormalMapY",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"twoSidedLighting",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useAlphaFresnel",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useLinearAlphaFresnel",void 0),Mt([ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"environmentBRDFTexture",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"forceNormalForward",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"enableSpecularAntiAliasing",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useHorizonOcclusion",void 0),Mt([Gt(),ks("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useRadianceOcclusion",void 0),Mt([Gt(),ks("_markAllSubMeshesAsMiscDirty")],Ys.prototype,"unlit",void 0),Mt([Gt(),ks("_markAllSubMeshesAsMiscDirty")],Ys.prototype,"applyDecalMapAfterDetailMap",void 0),zs("BABYLON.PBRMaterial",Ys);class vo{get boundingBias(){return this._boundingBias}set boundingBias(p){this._boundingBias?this._boundingBias.copyFrom(p):this._boundingBias=p.clone(),this._updateBoundingInfo(!0,null)}static CreateGeometryForMesh(p){const _=new vo(vo.RandomId(),p.getScene());return _.applyToMesh(p),_}get meshes(){return this._meshes}constructor(p,_,E,A=!1,$=null){this.delayLoadState=0,this._totalVertices=0,this._isDisposed=!1,this._indexBufferIsUpdatable=!1,this._positionsCache=[],this._parentContainer=null,this.useBoundingInfoFromGeometry=!1,this._scene=_||wr.LastCreatedScene,this._scene&&(this.id=p,this.uniqueId=this._scene.getUniqueId(),this._engine=this._scene.getEngine(),this._meshes=[],this._vertexBuffers={},this._indices=[],this._updatable=A,E?this.setAllVerticesData(E,A):this._totalVertices=0,this._engine.getCaps().vertexArrayObject&&(this._vertexArrayObjects={}),$&&(this.applyToMesh($),$.computeWorldMatrix(!0)))}get extend(){return this._extend}getScene(){return this._scene}getEngine(){return this._engine}isReady(){return this.delayLoadState===1||this.delayLoadState===0}get doNotSerialize(){for(let p=0;p<this._meshes.length;p++)if(!this._meshes[p].doNotSerialize)return!1;return!0}_rebuild(){this._vertexArrayObjects&&(this._vertexArrayObjects={}),this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer"));const p=new Set;for(const _ in this._vertexBuffers)p.add(this._vertexBuffers[_].getWrapperBuffer());p.forEach(_=>{_._rebuild()})}setAllVerticesData(p,_){p.applyToGeometry(this,_),this._notifyUpdate()}setVerticesData(p,_,E=!1,A){E&&Array.isArray(_)&&(_=new Float32Array(_));const $=new ut(this._engine,_,p,{updatable:E,postponeInternalCreation:this._meshes.length===0,stride:A,label:"Geometry_"+this.id+"_"+p});this.setVerticesBuffer($)}removeVerticesData(p){this._vertexBuffers[p]&&(this._vertexBuffers[p].dispose(),delete this._vertexBuffers[p]),this._vertexArrayObjects&&this._disposeVertexArrayObjects()}setVerticesBuffer(p,_=null,E=!0){const A=p.getKind();this._vertexBuffers[A]&&E&&this._vertexBuffers[A].dispose(),p._buffer&&p._buffer._increaseReferences(),this._vertexBuffers[A]=p;const $=this._meshes,ne=$.length;if(A===ut.PositionKind){this._totalVertices=_??p._maxVerticesCount,this._updateExtend(p.getFloatData(this._totalVertices)),this._resetPointsArrayCache();const xe=this._extend&&this._extend.minimum||new nt(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),ce=this._extend&&this._extend.maximum||new nt(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);for(let Te=0;Te<ne;Te++){const Re=$[Te];Re.buildBoundingInfo(xe,ce),Re._createGlobalSubMesh(Re.isUnIndexed),Re.computeWorldMatrix(!0),Re.synchronizeInstances()}}this._notifyUpdate(A)}updateVerticesDataDirectly(p,_,E,A=!1){const $=this.getVertexBuffer(p);$&&($.updateDirectly(_,E,A),this._notifyUpdate(p))}updateVerticesData(p,_,E=!1){const A=this.getVertexBuffer(p);A&&(A.update(_),p===ut.PositionKind&&this._updateBoundingInfo(E,_),this._notifyUpdate(p))}_updateBoundingInfo(p,_){if(p&&this._updateExtend(_),this._resetPointsArrayCache(),p){const E=this._meshes;for(const A of E){A.hasBoundingInfo?A.getBoundingInfo().reConstruct(this._extend.minimum,this._extend.maximum):A.buildBoundingInfo(this._extend.minimum,this._extend.maximum);const $=A.subMeshes;for(const ne of $)ne.refreshBoundingInfo()}}}_bind(p,_,E,A){if(!p)return;_===void 0&&(_=this._indexBuffer);const $=this.getVertexBuffers();if(!$)return;if(_!=this._indexBuffer||!this._vertexArrayObjects&&!A){this._engine.bindBuffers($,_,p,E);return}const ne=A||this._vertexArrayObjects;ne[p.key]||(ne[p.key]=this._engine.recordVertexArrayObject($,_,p,E)),this._engine.bindVertexArrayObject(ne[p.key],_)}getTotalVertices(){return this.isReady()?this._totalVertices:0}getVerticesData(p,_,E){const A=this.getVertexBuffer(p);return A?A.getFloatData(this._totalVertices,E||_&&this._meshes.length!==1):null}isVertexBufferUpdatable(p){const _=this._vertexBuffers[p];return _?_.isUpdatable():!1}getVertexBuffer(p){return this.isReady()?this._vertexBuffers[p]:null}getVertexBuffers(){return this.isReady()?this._vertexBuffers:null}isVerticesDataPresent(p){return this._vertexBuffers?this._vertexBuffers[p]!==void 0:this._delayInfo?this._delayInfo.indexOf(p)!==-1:!1}getVerticesDataKinds(){const p=[];let _;if(!this._vertexBuffers&&this._delayInfo)for(_ in this._delayInfo)p.push(_);else for(_ in this._vertexBuffers)p.push(_);return p}updateIndices(p,_,E=!1){if(this._indexBuffer)if(!this._indexBufferIsUpdatable)this.setIndices(p,null,!0);else{const A=p.length!==this._indices.length;if(E||(this._indices=p.slice()),this._engine.updateDynamicIndexBuffer(this._indexBuffer,p,_),A)for(const $ of this._meshes)$._createGlobalSubMesh(!0)}}setIndexBuffer(p,_,E){this._indices=[],this._indexBufferIsUpdatable=!1,this._indexBuffer=p,this._totalVertices=_,this._totalIndices=E,p.is32Bits||(p.is32Bits=this._totalIndices>65535);for(const A of this._meshes)A._createGlobalSubMesh(!0),A.synchronizeInstances();this._notifyUpdate()}setIndices(p,_=null,E=!1){this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indices=p,this._indexBufferIsUpdatable=E,this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,E,"Geometry_"+this.id+"_IndexBuffer")),_!=null&&(this._totalVertices=_);for(const A of this._meshes)A._createGlobalSubMesh(!0),A.synchronizeInstances();this._notifyUpdate()}getTotalIndices(){return this.isReady()?this._totalIndices!==void 0?this._totalIndices:this._indices.length:0}getIndices(p,_){if(!this.isReady())return null;const E=this._indices;return!_&&(!p||this._meshes.length===1)?E:E.slice()}getIndexBuffer(){return this.isReady()?this._indexBuffer:null}_releaseVertexArrayObject(p=null){!p||!this._vertexArrayObjects||this._vertexArrayObjects[p.key]&&(this._engine.releaseVertexArrayObject(this._vertexArrayObjects[p.key]),delete this._vertexArrayObjects[p.key])}releaseForMesh(p,_){const E=this._meshes,A=E.indexOf(p);A!==-1&&(E.splice(A,1),this._vertexArrayObjects&&p._invalidateInstanceVertexArrayObject(),p._geometry=null,E.length===0&&_&&this.dispose())}applyToMesh(p){if(p._geometry===this)return;const _=p._geometry;_&&_.releaseForMesh(p),this._vertexArrayObjects&&p._invalidateInstanceVertexArrayObject();const E=this._meshes;p._geometry=this,p._internalAbstractMeshDataInfo._positions=null,this._scene.pushGeometry(this),E.push(p),this.isReady()?this._applyToMesh(p):this._boundingInfo&&p.setBoundingInfo(this._boundingInfo)}_updateExtend(p=null){if(this.useBoundingInfoFromGeometry&&this._boundingInfo)this._extend={minimum:this._boundingInfo.minimum.clone(),maximum:this._boundingInfo.maximum.clone()};else{if(!p&&(p=this.getVerticesData(ut.PositionKind),!p))return;this._extend=Kb(p,0,this._totalVertices,this.boundingBias,3)}}_applyToMesh(p){const _=this._meshes.length;for(const E in this._vertexBuffers)_===1&&this._vertexBuffers[E].create(),E===ut.PositionKind&&(this._extend||this._updateExtend(),p.buildBoundingInfo(this._extend.minimum,this._extend.maximum),p._createGlobalSubMesh(p.isUnIndexed),p._updateBoundingInfo());_===1&&this._indices&&this._indices.length>0&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer")),p._syncGeometryWithMorphTargetManager(),p.synchronizeInstances()}_notifyUpdate(p){this.onGeometryUpdated&&this.onGeometryUpdated(this,p),this._vertexArrayObjects&&this._disposeVertexArrayObjects();for(const _ of this._meshes)_._markSubMeshesAsAttributesDirty()}load(p,_){if(this.delayLoadState!==2){if(this.isReady()){_&&_();return}this.delayLoadState=2,this._queueLoad(p,_)}}_queueLoad(p,_){this.delayLoadingFile&&(p.addPendingData(this),p._loadFile(this.delayLoadingFile,E=>{if(!this._delayLoadingFunction)return;this._delayLoadingFunction(JSON.parse(E),this),this.delayLoadState=1,this._delayInfo=[],p.removePendingData(this);const A=this._meshes,$=A.length;for(let ne=0;ne<$;ne++)this._applyToMesh(A[ne]);_&&_()},void 0,!0))}toLeftHanded(){const p=this.getIndices(!1);if(p!=null&&p.length>0){for(let A=0;A<p.length;A+=3){const $=p[A+0];p[A+0]=p[A+2],p[A+2]=$}this.setIndices(p)}const _=this.getVerticesData(ut.PositionKind,!1);if(_!=null&&_.length>0){for(let A=0;A<_.length;A+=3)_[A+2]=-_[A+2];this.setVerticesData(ut.PositionKind,_,!1)}const E=this.getVerticesData(ut.NormalKind,!1);if(E!=null&&E.length>0){for(let A=0;A<E.length;A+=3)E[A+2]=-E[A+2];this.setVerticesData(ut.NormalKind,E,!1)}}_resetPointsArrayCache(){this._positions=null}_generatePointsArray(){if(this._positions)return!0;const p=this.getVerticesData(ut.PositionKind);if(!p||p.length===0)return!1;for(let _=this._positionsCache.length*3,E=this._positionsCache.length;_<p.length;_+=3,++E)this._positionsCache[E]=nt.FromArray(p,_);for(let _=0,E=0;_<p.length;_+=3,++E)this._positionsCache[E].set(p[0+_],p[1+_],p[2+_]);return this._positionsCache.length=p.length/3,this._positions=this._positionsCache,!0}isDisposed(){return this._isDisposed}_disposeVertexArrayObjects(){if(this._vertexArrayObjects){for(const E in this._vertexArrayObjects)this._engine.releaseVertexArrayObject(this._vertexArrayObjects[E]);this._vertexArrayObjects={};const p=this._meshes,_=p.length;for(let E=0;E<_;E++)p[E]._invalidateInstanceVertexArrayObject()}}dispose(){const p=this._meshes,_=p.length;let E;for(E=0;E<_;E++)this.releaseForMesh(p[E]);this._meshes.length=0,this._disposeVertexArrayObjects();for(const A in this._vertexBuffers)this._vertexBuffers[A].dispose();if(this._vertexBuffers={},this._totalVertices=0,this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null,this._indices=[],this.delayLoadState=0,this.delayLoadingFile=null,this._delayLoadingFunction=null,this._delayInfo=[],this._boundingInfo=null,this._scene.removeGeometry(this),this._parentContainer){const A=this._parentContainer.geometries.indexOf(this);A>-1&&this._parentContainer.geometries.splice(A,1),this._parentContainer=null}this._isDisposed=!0}copy(p){const _=new Yr;_.indices=[];const E=this.getIndices();if(E)for(let ce=0;ce<E.length;ce++)_.indices.push(E[ce]);let A=!1,$=!1,ne;for(ne in this._vertexBuffers){const ce=this.getVerticesData(ne);if(ce&&(ce instanceof Float32Array?_.set(new Float32Array(ce),ne):_.set(ce.slice(0),ne),!$)){const Te=this.getVertexBuffer(ne);Te&&(A=Te.isUpdatable(),$=!A)}}const xe=new vo(p,this._scene,_,A);xe.delayLoadState=this.delayLoadState,xe.delayLoadingFile=this.delayLoadingFile,xe._delayLoadingFunction=this._delayLoadingFunction;for(ne in this._delayInfo)xe._delayInfo=xe._delayInfo||[],xe._delayInfo.push(ne);return xe._boundingInfo=new lx(this._extend.minimum,this._extend.maximum),xe}serialize(){const p={};return p.id=this.id,p.uniqueId=this.uniqueId,p.updatable=this._updatable,ni&&ni.HasTags(this)&&(p.tags=ni.GetTags(this)),p}_toNumberArray(p){return Array.isArray(p)?p:Array.prototype.slice.call(p)}clearCachedData(){this._indices=[],this._resetPointsArrayCache();for(const p in this._vertexBuffers)Object.prototype.hasOwnProperty.call(this._vertexBuffers,p)&&(this._vertexBuffers[p]._buffer._data=null)}serializeVerticeData(){const p=this.serialize();return this.isVerticesDataPresent(ut.PositionKind)&&(p.positions=this._toNumberArray(this.getVerticesData(ut.PositionKind)),this.isVertexBufferUpdatable(ut.PositionKind)&&(p.positions._updatable=!0)),this.isVerticesDataPresent(ut.NormalKind)&&(p.normals=this._toNumberArray(this.getVerticesData(ut.NormalKind)),this.isVertexBufferUpdatable(ut.NormalKind)&&(p.normals._updatable=!0)),this.isVerticesDataPresent(ut.TangentKind)&&(p.tangents=this._toNumberArray(this.getVerticesData(ut.TangentKind)),this.isVertexBufferUpdatable(ut.TangentKind)&&(p.tangents._updatable=!0)),this.isVerticesDataPresent(ut.UVKind)&&(p.uvs=this._toNumberArray(this.getVerticesData(ut.UVKind)),this.isVertexBufferUpdatable(ut.UVKind)&&(p.uvs._updatable=!0)),this.isVerticesDataPresent(ut.UV2Kind)&&(p.uvs2=this._toNumberArray(this.getVerticesData(ut.UV2Kind)),this.isVertexBufferUpdatable(ut.UV2Kind)&&(p.uvs2._updatable=!0)),this.isVerticesDataPresent(ut.UV3Kind)&&(p.uvs3=this._toNumberArray(this.getVerticesData(ut.UV3Kind)),this.isVertexBufferUpdatable(ut.UV3Kind)&&(p.uvs3._updatable=!0)),this.isVerticesDataPresent(ut.UV4Kind)&&(p.uvs4=this._toNumberArray(this.getVerticesData(ut.UV4Kind)),this.isVertexBufferUpdatable(ut.UV4Kind)&&(p.uvs4._updatable=!0)),this.isVerticesDataPresent(ut.UV5Kind)&&(p.uvs5=this._toNumberArray(this.getVerticesData(ut.UV5Kind)),this.isVertexBufferUpdatable(ut.UV5Kind)&&(p.uvs5._updatable=!0)),this.isVerticesDataPresent(ut.UV6Kind)&&(p.uvs6=this._toNumberArray(this.getVerticesData(ut.UV6Kind)),this.isVertexBufferUpdatable(ut.UV6Kind)&&(p.uvs6._updatable=!0)),this.isVerticesDataPresent(ut.ColorKind)&&(p.colors=this._toNumberArray(this.getVerticesData(ut.ColorKind)),this.isVertexBufferUpdatable(ut.ColorKind)&&(p.colors._updatable=!0)),this.isVerticesDataPresent(ut.MatricesIndicesKind)&&(p.matricesIndices=this._toNumberArray(this.getVerticesData(ut.MatricesIndicesKind)),p.matricesIndices._isExpanded=!0,this.isVertexBufferUpdatable(ut.MatricesIndicesKind)&&(p.matricesIndices._updatable=!0)),this.isVerticesDataPresent(ut.MatricesWeightsKind)&&(p.matricesWeights=this._toNumberArray(this.getVerticesData(ut.MatricesWeightsKind)),this.isVertexBufferUpdatable(ut.MatricesWeightsKind)&&(p.matricesWeights._updatable=!0)),p.indices=this._toNumberArray(this.getIndices()),p}static ExtractFromMesh(p,_){const E=p._geometry;return E?E.copy(_):null}static RandomId(){return ct.RandomId()}static _GetGeometryByLoadedUniqueId(p,_){for(let E=0;E<_.geometries.length;E++)if(_.geometries[E]._loadedUniqueId===p)return _.geometries[E];return null}static _ImportGeometry(p,_){const E=_.getScene(),A=p.geometryUniqueId,$=p.geometryId;if(A||$){const ne=A?this._GetGeometryByLoadedUniqueId(A,E):E.getGeometryById($);ne&&ne.applyToMesh(_)}else if(p instanceof ArrayBuffer){const ne=_._binaryInfo;if(ne.positionsAttrDesc&&ne.positionsAttrDesc.count>0){const xe=new Float32Array(p,ne.positionsAttrDesc.offset,ne.positionsAttrDesc.count);_.setVerticesData(ut.PositionKind,xe,!1)}if(ne.normalsAttrDesc&&ne.normalsAttrDesc.count>0){const xe=new Float32Array(p,ne.normalsAttrDesc.offset,ne.normalsAttrDesc.count);_.setVerticesData(ut.NormalKind,xe,!1)}if(ne.tangetsAttrDesc&&ne.tangetsAttrDesc.count>0){const xe=new Float32Array(p,ne.tangetsAttrDesc.offset,ne.tangetsAttrDesc.count);_.setVerticesData(ut.TangentKind,xe,!1)}if(ne.uvsAttrDesc&&ne.uvsAttrDesc.count>0){const xe=new Float32Array(p,ne.uvsAttrDesc.offset,ne.uvsAttrDesc.count);if(lh.UseOpenGLOrientationForUV)for(let ce=1;ce<xe.length;ce+=2)xe[ce]=1-xe[ce];_.setVerticesData(ut.UVKind,xe,!1)}if(ne.uvs2AttrDesc&&ne.uvs2AttrDesc.count>0){const xe=new Float32Array(p,ne.uvs2AttrDesc.offset,ne.uvs2AttrDesc.count);if(lh.UseOpenGLOrientationForUV)for(let ce=1;ce<xe.length;ce+=2)xe[ce]=1-xe[ce];_.setVerticesData(ut.UV2Kind,xe,!1)}if(ne.uvs3AttrDesc&&ne.uvs3AttrDesc.count>0){const xe=new Float32Array(p,ne.uvs3AttrDesc.offset,ne.uvs3AttrDesc.count);if(lh.UseOpenGLOrientationForUV)for(let ce=1;ce<xe.length;ce+=2)xe[ce]=1-xe[ce];_.setVerticesData(ut.UV3Kind,xe,!1)}if(ne.uvs4AttrDesc&&ne.uvs4AttrDesc.count>0){const xe=new Float32Array(p,ne.uvs4AttrDesc.offset,ne.uvs4AttrDesc.count);if(lh.UseOpenGLOrientationForUV)for(let ce=1;ce<xe.length;ce+=2)xe[ce]=1-xe[ce];_.setVerticesData(ut.UV4Kind,xe,!1)}if(ne.uvs5AttrDesc&&ne.uvs5AttrDesc.count>0){const xe=new Float32Array(p,ne.uvs5AttrDesc.offset,ne.uvs5AttrDesc.count);if(lh.UseOpenGLOrientationForUV)for(let ce=1;ce<xe.length;ce+=2)xe[ce]=1-xe[ce];_.setVerticesData(ut.UV5Kind,xe,!1)}if(ne.uvs6AttrDesc&&ne.uvs6AttrDesc.count>0){const xe=new Float32Array(p,ne.uvs6AttrDesc.offset,ne.uvs6AttrDesc.count);if(lh.UseOpenGLOrientationForUV)for(let ce=1;ce<xe.length;ce+=2)xe[ce]=1-xe[ce];_.setVerticesData(ut.UV6Kind,xe,!1)}if(ne.colorsAttrDesc&&ne.colorsAttrDesc.count>0){const xe=new Float32Array(p,ne.colorsAttrDesc.offset,ne.colorsAttrDesc.count);_.setVerticesData(ut.ColorKind,xe,!1,ne.colorsAttrDesc.stride)}if(ne.matricesIndicesAttrDesc&&ne.matricesIndicesAttrDesc.count>0){const xe=new Int32Array(p,ne.matricesIndicesAttrDesc.offset,ne.matricesIndicesAttrDesc.count),ce=[];for(let Te=0;Te<xe.length;Te++){const Re=xe[Te];ce.push(Re&255),ce.push((Re&65280)>>8),ce.push((Re&16711680)>>16),ce.push(Re>>24&255)}_.setVerticesData(ut.MatricesIndicesKind,ce,!1)}if(ne.matricesIndicesExtraAttrDesc&&ne.matricesIndicesExtraAttrDesc.count>0){const xe=new Int32Array(p,ne.matricesIndicesExtraAttrDesc.offset,ne.matricesIndicesExtraAttrDesc.count),ce=[];for(let Te=0;Te<xe.length;Te++){const Re=xe[Te];ce.push(Re&255),ce.push((Re&65280)>>8),ce.push((Re&16711680)>>16),ce.push(Re>>24&255)}_.setVerticesData(ut.MatricesIndicesExtraKind,ce,!1)}if(ne.matricesWeightsAttrDesc&&ne.matricesWeightsAttrDesc.count>0){const xe=new Float32Array(p,ne.matricesWeightsAttrDesc.offset,ne.matricesWeightsAttrDesc.count);_.setVerticesData(ut.MatricesWeightsKind,xe,!1)}if(ne.indicesAttrDesc&&ne.indicesAttrDesc.count>0){const xe=new Int32Array(p,ne.indicesAttrDesc.offset,ne.indicesAttrDesc.count);_.setIndices(xe,null)}if(ne.subMeshesAttrDesc&&ne.subMeshesAttrDesc.count>0){const xe=new Int32Array(p,ne.subMeshesAttrDesc.offset,ne.subMeshesAttrDesc.count*5);_.subMeshes=[];for(let ce=0;ce<ne.subMeshesAttrDesc.count;ce++){const Te=xe[ce*5+0],Re=xe[ce*5+1],ke=xe[ce*5+2],We=xe[ce*5+3],Xe=xe[ce*5+4];_l.AddToMesh(Te,Re,ke,We,Xe,_)}}}else if(p.positions&&p.normals&&p.indices){if(_.setVerticesData(ut.PositionKind,p.positions,p.positions._updatable),_.setVerticesData(ut.NormalKind,p.normals,p.normals._updatable),p.tangents&&_.setVerticesData(ut.TangentKind,p.tangents,p.tangents._updatable),p.uvs&&_.setVerticesData(ut.UVKind,p.uvs,p.uvs._updatable),p.uvs2&&_.setVerticesData(ut.UV2Kind,p.uvs2,p.uvs2._updatable),p.uvs3&&_.setVerticesData(ut.UV3Kind,p.uvs3,p.uvs3._updatable),p.uvs4&&_.setVerticesData(ut.UV4Kind,p.uvs4,p.uvs4._updatable),p.uvs5&&_.setVerticesData(ut.UV5Kind,p.uvs5,p.uvs5._updatable),p.uvs6&&_.setVerticesData(ut.UV6Kind,p.uvs6,p.uvs6._updatable),p.colors&&_.setVerticesData(ut.ColorKind,vr.CheckColors4(p.colors,p.positions.length/3),p.colors._updatable),p.matricesIndices)if(p.matricesIndices._isExpanded)delete p.matricesIndices._isExpanded,_.setVerticesData(ut.MatricesIndicesKind,p.matricesIndices,p.matricesIndices._updatable);else{const ne=[];for(let xe=0;xe<p.matricesIndices.length;xe++){const ce=p.matricesIndices[xe];ne.push(ce&255),ne.push((ce&65280)>>8),ne.push((ce&16711680)>>16),ne.push(ce>>24&255)}_.setVerticesData(ut.MatricesIndicesKind,ne,p.matricesIndices._updatable)}if(p.matricesIndicesExtra)if(p.matricesIndicesExtra._isExpanded)delete p.matricesIndices._isExpanded,_.setVerticesData(ut.MatricesIndicesExtraKind,p.matricesIndicesExtra,p.matricesIndicesExtra._updatable);else{const ne=[];for(let xe=0;xe<p.matricesIndicesExtra.length;xe++){const ce=p.matricesIndicesExtra[xe];ne.push(ce&255),ne.push((ce&65280)>>8),ne.push((ce&16711680)>>16),ne.push(ce>>24&255)}_.setVerticesData(ut.MatricesIndicesExtraKind,ne,p.matricesIndicesExtra._updatable)}p.matricesWeights&&(vo._CleanMatricesWeights(p,_),_.setVerticesData(ut.MatricesWeightsKind,p.matricesWeights,p.matricesWeights._updatable)),p.matricesWeightsExtra&&_.setVerticesData(ut.MatricesWeightsExtraKind,p.matricesWeightsExtra,p.matricesWeights._updatable),_.setIndices(p.indices,null)}if(p.subMeshes){_.subMeshes=[];for(let ne=0;ne<p.subMeshes.length;ne++){const xe=p.subMeshes[ne];_l.AddToMesh(xe.materialIndex,xe.verticesStart,xe.verticesCount,xe.indexStart,xe.indexCount,_)}}_._shouldGenerateFlatShading&&(_.convertToFlatShadedMesh(),_._shouldGenerateFlatShading=!1),_.computeWorldMatrix(!0),E.onMeshImportedObservable.notifyObservers(_)}static _CleanMatricesWeights(p,_){if(!M0.CleanBoneMatrixWeights)return;let A=0;if(p.skeletonId>-1){const ke=_.getScene().getLastSkeletonById(p.skeletonId);if(!ke)return;A=ke.bones.length}else return;const $=_.getVerticesData(ut.MatricesIndicesKind),ne=_.getVerticesData(ut.MatricesIndicesExtraKind),xe=p.matricesWeights,ce=p.matricesWeightsExtra,Te=p.numBoneInfluencer,Re=xe.length;for(let ke=0;ke<Re;ke+=4){let We=0,Xe=-1;for(let xt=0;xt<4;xt++){const qe=xe[ke+xt];We+=qe,qe<.001&&Xe<0&&(Xe=xt)}if(ce)for(let xt=0;xt<4;xt++){const qe=ce[ke+xt];We+=qe,qe<.001&&Xe<0&&(Xe=xt+4)}if((Xe<0||Xe>Te-1)&&(Xe=Te-1),We>.001){const xt=1/We;for(let qe=0;qe<4;qe++)xe[ke+qe]*=xt;if(ce)for(let qe=0;qe<4;qe++)ce[ke+qe]*=xt}else Xe>=4?(ce[ke+Xe-4]=1-We,ne[ke+Xe-4]=A):(xe[ke+Xe]=1-We,$[ke+Xe]=A)}_.setVerticesData(ut.MatricesIndicesKind,$),p.matricesWeightsExtra&&_.setVerticesData(ut.MatricesIndicesExtraKind,ne)}static Parse(p,_,E){const A=new vo(p.id,_,void 0,p.updatable);return A._loadedUniqueId=p.uniqueId,ni&&ni.AddTagsTo(A,p.tags),p.delayLoadingFile?(A.delayLoadState=4,A.delayLoadingFile=E+p.delayLoadingFile,A._boundingInfo=new lx(nt.FromArray(p.boundingBoxMinimum),nt.FromArray(p.boundingBoxMaximum)),A._delayInfo=[],p.hasUVs&&A._delayInfo.push(ut.UVKind),p.hasUVs2&&A._delayInfo.push(ut.UV2Kind),p.hasUVs3&&A._delayInfo.push(ut.UV3Kind),p.hasUVs4&&A._delayInfo.push(ut.UV4Kind),p.hasUVs5&&A._delayInfo.push(ut.UV5Kind),p.hasUVs6&&A._delayInfo.push(ut.UV6Kind),p.hasColors&&A._delayInfo.push(ut.ColorKind),p.hasMatricesIndices&&A._delayInfo.push(ut.MatricesIndicesKind),p.hasMatricesWeights&&A._delayInfo.push(ut.MatricesWeightsKind),A._delayLoadingFunction=Yr.ImportVertexData):Yr.ImportVertexData(p,A),_.pushGeometry(A,!0),A}}class $u extends Xi{get subMaterials(){return this._subMaterials}set subMaterials(p){this._subMaterials=p,this._hookArray(p)}getChildren(){return this.subMaterials}constructor(p,_){super(p,_,!0),this._waitingSubMaterialsUniqueIds=[],this.getScene().addMultiMaterial(this),this.subMaterials=[],this._storeEffectOnSubMeshes=!0}_hookArray(p){const _=p.push;p.push=(...A)=>{const $=_.apply(p,A);return this._markAllSubMeshesAsTexturesDirty(),$};const E=p.splice;p.splice=(A,$)=>{const ne=E.apply(p,[A,$]);return this._markAllSubMeshesAsTexturesDirty(),ne}}getSubMaterial(p){return p<0||p>=this.subMaterials.length?this.getScene().defaultMaterial:this.subMaterials[p]}getActiveTextures(){return super.getActiveTextures().concat(...this.subMaterials.map(p=>p?p.getActiveTextures():[]))}hasTexture(p){if(super.hasTexture(p))return!0;for(let _=0;_<this.subMaterials.length;_++)if(this.subMaterials[_]?.hasTexture(p))return!0;return!1}getClassName(){return"MultiMaterial"}isReadyForSubMesh(p,_,E){for(let A=0;A<this.subMaterials.length;A++){const $=this.subMaterials[A];if($){if($._storeEffectOnSubMeshes){if(!$.isReadyForSubMesh(p,_,E))return!1;continue}if(!$.isReady(p))return!1}}return!0}clone(p,_){const E=new $u(p,this.getScene());for(let A=0;A<this.subMaterials.length;A++){let $=null;const ne=this.subMaterials[A];_&&ne?$=ne.clone(p+"-"+ne.name):$=this.subMaterials[A],E.subMaterials.push($)}return E}serialize(){const p={};p.name=this.name,p.id=this.id,p.uniqueId=this.uniqueId,ni&&(p.tags=ni.GetTags(this)),p.materialsUniqueIds=[],p.materials=[];for(let _=0;_<this.subMaterials.length;_++){const E=this.subMaterials[_];E?(p.materialsUniqueIds.push(E.uniqueId),p.materials.push(E.id)):(p.materialsUniqueIds.push(null),p.materials.push(null))}return p}dispose(p,_,E){const A=this.getScene();if(!A)return;if(E)for(let ne=0;ne<this.subMaterials.length;ne++){const xe=this.subMaterials[ne];xe&&xe.dispose(p,_)}const $=A.multiMaterials.indexOf(this);$>=0&&A.multiMaterials.splice($,1),super.dispose(p,_)}static ParseMultiMaterial(p,_){const E=new $u(p.name,_);return E.id=p.id,E._loadedUniqueId=p.uniqueId,ni&&ni.AddTagsTo(E,p.tags),p.materialsUniqueIds?E._waitingSubMaterialsUniqueIds=p.materialsUniqueIds:p.materials.forEach(A=>E.subMaterials.push(_.getLastMaterialById(A))),E}}zs("BABYLON.MultiMaterial",$u);class LL{constructor(p,_){this.distanceOrScreenCoverage=p,this.mesh=_}}class L8{}class kL{constructor(){this.visibleInstances={},this.batchCache=new aO,this.batchCacheReplacementModeInFrozenMode=new aO,this.instancesBufferSize=32*16*4}}class aO{constructor(){this.mustReturn=!1,this.visibleInstances=new Array,this.renderSelf=[],this.hardwareInstancedRendering=[]}}class UL{constructor(){this.instancesCount=0,this.matrixBuffer=null,this.previousMatrixBuffer=null,this.matrixBufferSize=32*16,this.matrixData=null,this.boundingVectors=[],this.worldMatrices=null}}class GL{constructor(){this._areNormalsFrozen=!1,this._source=null,this.meshMap=null,this._preActivateId=-1,this._LODLevels=new Array,this._useLODScreenCoverage=!1,this._effectiveMaterial=null,this._forcedInstanceCount=0,this._overrideRenderingFillMode=null}}class Lr extends zo{static _GetDefaultSideOrientation(p){return p||Lr.FRONTSIDE}get useLODScreenCoverage(){return this._internalMeshDataInfo._useLODScreenCoverage}set useLODScreenCoverage(p){this._internalMeshDataInfo._useLODScreenCoverage=p,this._sortLODLevels()}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(p){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==p&&(p&&this._internalMeshDataInfo._sourcePositions&&(this.setVerticesData(ut.PositionKind,this._internalMeshDataInfo._sourcePositions,!0),this._internalMeshDataInfo._sourceNormals&&this.setVerticesData(ut.NormalKind,this._internalMeshDataInfo._sourceNormals,!0),this._internalMeshDataInfo._sourcePositions=null,this._internalMeshDataInfo._sourceNormals=null),this._internalAbstractMeshDataInfo._computeBonesUsingShaders=p,this._markSubMeshesAsAttributesDirty())}get onBeforeRenderObservable(){return this._internalMeshDataInfo._onBeforeRenderObservable||(this._internalMeshDataInfo._onBeforeRenderObservable=new Mi),this._internalMeshDataInfo._onBeforeRenderObservable}get onBeforeBindObservable(){return this._internalMeshDataInfo._onBeforeBindObservable||(this._internalMeshDataInfo._onBeforeBindObservable=new Mi),this._internalMeshDataInfo._onBeforeBindObservable}get onAfterRenderObservable(){return this._internalMeshDataInfo._onAfterRenderObservable||(this._internalMeshDataInfo._onAfterRenderObservable=new Mi),this._internalMeshDataInfo._onAfterRenderObservable}get onBetweenPassObservable(){return this._internalMeshDataInfo._onBetweenPassObservable||(this._internalMeshDataInfo._onBetweenPassObservable=new Mi),this._internalMeshDataInfo._onBetweenPassObservable}get onBeforeDrawObservable(){return this._internalMeshDataInfo._onBeforeDrawObservable||(this._internalMeshDataInfo._onBeforeDrawObservable=new Mi),this._internalMeshDataInfo._onBeforeDrawObservable}set onBeforeDraw(p){this._onBeforeDrawObserver&&this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver),this._onBeforeDrawObserver=this.onBeforeDrawObservable.add(p)}get hasInstances(){return this.instances.length>0}get hasThinInstances(){return(this.forcedInstanceCount||this._thinInstanceDataStorage.instancesCount||0)>0}get forcedInstanceCount(){return this._internalMeshDataInfo._forcedInstanceCount}set forcedInstanceCount(p){this._internalMeshDataInfo._forcedInstanceCount=p}get overrideRenderingFillMode(){return this._internalMeshDataInfo._overrideRenderingFillMode}set overrideRenderingFillMode(p){this._internalMeshDataInfo._overrideRenderingFillMode=p}get source(){return this._internalMeshDataInfo._source}get cloneMeshMap(){return this._internalMeshDataInfo.meshMap}get isUnIndexed(){return this._unIndexed}set isUnIndexed(p){this._unIndexed!==p&&(this._unIndexed=p,this._markSubMeshesAsAttributesDirty())}get worldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesData}get previousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesPreviousData}get manualUpdateOfWorldMatrixInstancedBuffer(){return this._instanceDataStorage.manualUpdate}set manualUpdateOfWorldMatrixInstancedBuffer(p){this._instanceDataStorage.manualUpdate=p}get manualUpdateOfPreviousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.previousManualUpdate}set manualUpdateOfPreviousWorldMatrixInstancedBuffer(p){this._instanceDataStorage.previousManualUpdate=p}get forceWorldMatrixInstancedBufferUpdate(){return this._instanceDataStorage.forceMatrixUpdates}set forceWorldMatrixInstancedBufferUpdate(p){this._instanceDataStorage.forceMatrixUpdates=p}constructor(p,_=null,E=null,A=null,$,ne=!0){if(super(p,_),this._internalMeshDataInfo=new GL,this.delayLoadState=0,this.instances=[],this._creationDataStorage=null,this._geometry=null,this._instanceDataStorage=new kL,this._thinInstanceDataStorage=new UL,this._shouldGenerateFlatShading=!1,this._originalBuilderSideOrientation=Lr.DEFAULTSIDE,this.overrideMaterialSideOrientation=null,this.ignoreCameraMaxZ=!1,_=this.getScene(),this._onBeforeDraw=(xe,ce,Te)=>{xe&&Te&&(this._uniformBuffer?this.transferToEffect(ce):Te.bindOnlyWorldMatrix(ce))},A){if(A._geometry&&A._geometry.applyToMesh(this),al.DeepCopy(A,this,["name","material","skeleton","instances","parent","uniqueId","source","metadata","morphTargetManager","hasInstances","worldMatrixInstancedBuffer","previousWorldMatrixInstancedBuffer","hasLODLevels","geometry","isBlocked","areNormalsFrozen","facetNb","isFacetDataEnabled","lightSources","useBones","isAnInstance","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","cloneMeshMap","hasBoundingInfo","physicsBody","physicsImpostor"],["_poseMatrix"]),this._internalMeshDataInfo._source=A,_.useClonedMeshMap&&(A._internalMeshDataInfo.meshMap||(A._internalMeshDataInfo.meshMap={}),A._internalMeshDataInfo.meshMap[this.uniqueId]=this),this._originalBuilderSideOrientation=A._originalBuilderSideOrientation,this._creationDataStorage=A._creationDataStorage,A._ranges){const xe=A._ranges;for(const ce in xe)Object.prototype.hasOwnProperty.call(xe,ce)&&xe[ce]&&this.createAnimationRange(ce,xe[ce].from,xe[ce].to)}if(A.metadata&&A.metadata.clone?this.metadata=A.metadata.clone():this.metadata=A.metadata,this._internalMetadata=A._internalMetadata,ni&&ni.HasTags(A)&&ni.AddTagsTo(this,ni.GetTags(A,!0)),this.setEnabled(A.isEnabled(!1)),this.parent=A.parent,this.setPivotMatrix(A.getPivotMatrix()),this.id=p+"."+A.id,this.material=A.material,!$){const xe=A.getDescendants(!0);for(let ce=0;ce<xe.length;ce++){const Te=xe[ce];Te.clone&&Te.clone(p+"."+Te.name,this)}}if(A.morphTargetManager&&(this.morphTargetManager=A.morphTargetManager),_.getPhysicsEngine){const xe=_.getPhysicsEngine();if(ne&&xe)if(xe.getPluginVersion()===1){const ce=xe.getImpostorForPhysicsObject(A);ce&&(this.physicsImpostor=ce.clone(this))}else xe.getPluginVersion()===2&&A.physicsBody&&A.physicsBody.clone(this)}for(let xe=0;xe<_.particleSystems.length;xe++){const ce=_.particleSystems[xe];ce.emitter===A&&ce.clone(ce.name,this)}this.skeleton=A.skeleton,this.refreshBoundingInfo(!0,!0),this.computeWorldMatrix(!0)}E!==null&&(this.parent=E),this._instanceDataStorage.hardwareInstancedRendering=this.getEngine().getCaps().instancedArrays,this._internalMeshDataInfo._onMeshReadyObserverAdded=xe=>{xe.unregisterOnNextCall=!0,this.isReady(!0)?this.onMeshReadyObservable.notifyObservers(this):this._internalMeshDataInfo._checkReadinessObserver||(this._internalMeshDataInfo._checkReadinessObserver=this._scene.onBeforeRenderObservable.add(()=>{this.isReady(!0)&&(this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),this._internalMeshDataInfo._checkReadinessObserver=null,this.onMeshReadyObservable.notifyObservers(this))}))},this.onMeshReadyObservable=new Mi(this._internalMeshDataInfo._onMeshReadyObserverAdded),A&&A.onClonedObservable.notifyObservers(this)}instantiateHierarchy(p=null,_,E){const A=this.getTotalVertices()===0||_&&_.doNotInstantiate&&(_.doNotInstantiate===!0||_.doNotInstantiate(this))?this.clone("Clone of "+(this.name||this.id),p||this.parent,!0):this.createInstance("instance of "+(this.name||this.id));A.parent=p||this.parent,A.position=this.position.clone(),A.scaling=this.scaling.clone(),this.rotationQuaternion?A.rotationQuaternion=this.rotationQuaternion.clone():A.rotation=this.rotation.clone(),E&&E(this,A);for(const $ of this.getChildTransformNodes(!0))$.getClassName()==="InstancedMesh"&&A.getClassName()==="Mesh"&&$.sourceMesh===this?$.instantiateHierarchy(A,{doNotInstantiate:_&&_.doNotInstantiate||!1,newSourcedMesh:A},E):$.instantiateHierarchy(A,_,E);return A}getClassName(){return"Mesh"}get _isMesh(){return!0}toString(p){let _=super.toString(p);if(_+=", n vertices: "+this.getTotalVertices(),_+=", parent: "+(this._waitingParentId?this._waitingParentId:this.parent?this.parent.name:"NONE"),this.animations)for(let E=0;E<this.animations.length;E++)_+=", animation[0]: "+this.animations[E].toString(p);if(p)if(this._geometry){const E=this.getIndices(),A=this.getVerticesData(ut.PositionKind);A&&E&&(_+=", flat shading: "+(A.length/3===E.length?"YES":"NO"))}else _+=", flat shading: UNKNOWN";return _}_unBindEffect(){super._unBindEffect();for(const p of this.instances)p._unBindEffect()}get hasLODLevels(){return this._internalMeshDataInfo._LODLevels.length>0}getLODLevels(){return this._internalMeshDataInfo._LODLevels}_sortLODLevels(){const p=this._internalMeshDataInfo._useLODScreenCoverage?-1:1;this._internalMeshDataInfo._LODLevels.sort((_,E)=>_.distanceOrScreenCoverage<E.distanceOrScreenCoverage?p:_.distanceOrScreenCoverage>E.distanceOrScreenCoverage?-p:0)}addLODLevel(p,_){if(_&&_._masterMesh)return vi.Warn("You cannot use a mesh as LOD level twice"),this;const E=new LL(p,_);return this._internalMeshDataInfo._LODLevels.push(E),_&&(_._masterMesh=this),this._sortLODLevels(),this}getLODLevelAtDistance(p){const _=this._internalMeshDataInfo;for(let E=0;E<_._LODLevels.length;E++){const A=_._LODLevels[E];if(A.distanceOrScreenCoverage===p)return A.mesh}return null}removeLODLevel(p){const _=this._internalMeshDataInfo;for(let E=0;E<_._LODLevels.length;E++)_._LODLevels[E].mesh===p&&(_._LODLevels.splice(E,1),p&&(p._masterMesh=null));return this._sortLODLevels(),this}getLOD(p,_){const E=this._internalMeshDataInfo;if(!E._LODLevels||E._LODLevels.length===0)return this;const A=_||this.getBoundingInfo().boundingSphere,$=p.mode===Hr.ORTHOGRAPHIC_CAMERA?p.minZ:A.centerWorld.subtract(p.globalPosition).length();let ne=$,xe=1;if(E._useLODScreenCoverage){const ce=p.screenArea;let Te=A.radiusWorld*p.minZ/$;Te=Te*Te*Math.PI,ne=Te/ce,xe=-1}if(xe*E._LODLevels[E._LODLevels.length-1].distanceOrScreenCoverage>xe*ne)return this.onLODLevelSelection&&this.onLODLevelSelection(ne,this,this),this;for(let ce=0;ce<E._LODLevels.length;ce++){const Te=E._LODLevels[ce];if(xe*Te.distanceOrScreenCoverage<xe*ne){if(Te.mesh){if(Te.mesh.delayLoadState===4)return Te.mesh._checkDelayState(),this;if(Te.mesh.delayLoadState===2)return this;Te.mesh._preActivate(),Te.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)}return this.onLODLevelSelection&&this.onLODLevelSelection(ne,this,Te.mesh),Te.mesh}}return this.onLODLevelSelection&&this.onLODLevelSelection(ne,this,this),this}get geometry(){return this._geometry}getTotalVertices(){return this._geometry===null||this._geometry===void 0?0:this._geometry.getTotalVertices()}getVerticesData(p,_,E,A){if(!this._geometry)return null;let $=A?void 0:this._userInstancedBuffersStorage?.vertexBuffers[p]?.getFloatData(this.instances.length+1,E||_&&this._geometry.meshes.length!==1);return $||($=this._geometry.getVerticesData(p,_,E)),$}getVertexBuffer(p,_){return this._geometry?(_?void 0:this._userInstancedBuffersStorage?.vertexBuffers[p])??this._geometry.getVertexBuffer(p):null}isVerticesDataPresent(p,_){return this._geometry?!_&&this._userInstancedBuffersStorage?.vertexBuffers[p]!==void 0||this._geometry.isVerticesDataPresent(p):this._delayInfo?this._delayInfo.indexOf(p)!==-1:!1}isVertexBufferUpdatable(p,_){if(!this._geometry)return this._delayInfo?this._delayInfo.indexOf(p)!==-1:!1;if(!_){const E=this._userInstancedBuffersStorage?.vertexBuffers[p];if(E)return E.isUpdatable()}return this._geometry.isVertexBufferUpdatable(p)}getVerticesDataKinds(p){if(!this._geometry){const E=[];return this._delayInfo&&this._delayInfo.forEach(function(A){E.push(A)}),E}const _=this._geometry.getVerticesDataKinds();if(!p&&this._userInstancedBuffersStorage)for(const E in this._userInstancedBuffersStorage.vertexBuffers)_.indexOf(E)===-1&&_.push(E);return _}getTotalIndices(){return this._geometry?this._geometry.getTotalIndices():0}getIndices(p,_){return this._geometry?this._geometry.getIndices(p,_):[]}get isBlocked(){return this._masterMesh!==null&&this._masterMesh!==void 0}isReady(p=!1,_=!1){if(this.delayLoadState===2||!super.isReady(p))return!1;if(!this.subMeshes||this.subMeshes.length===0||!p)return!0;const E=this.getEngine(),A=this.getScene(),$=_||E.getCaps().instancedArrays&&(this.instances.length>0||this.hasThinInstances);this.computeWorldMatrix();const ne=this.material||A.defaultMaterial;if(ne){if(ne._storeEffectOnSubMeshes)for(const ce of this.subMeshes){const Te=ce.getMaterial();if(Te){if(Te._storeEffectOnSubMeshes){if(!Te.isReadyForSubMesh(this,ce,$))return!1}else if(!Te.isReady(this,$))return!1}}else if(!ne.isReady(this,$))return!1}const xe=E.currentRenderPassId;for(const ce of this.lightSources){const Te=ce.getShadowGenerators();if(!Te)continue;const Re=Te.values();for(let ke=Re.next();ke.done!==!0;ke=Re.next()){const We=ke.value;if(We&&(!We.getShadowMap()?.renderList||We.getShadowMap()?.renderList&&We.getShadowMap()?.renderList?.indexOf(this)!==-1)){const xt=We.getShadowMap().renderPassIds??[E.currentRenderPassId];for(let qe=0;qe<xt.length;++qe){E.currentRenderPassId=xt[qe];for(const ht of this.subMeshes)if(!We.isReady(ht,$,ht.getMaterial()?.needAlphaBlendingForMesh(this)??!1))return E.currentRenderPassId=xe,!1}E.currentRenderPassId=xe}}}for(const ce of this._internalMeshDataInfo._LODLevels)if(ce.mesh&&!ce.mesh.isReady($))return!1;return!0}get areNormalsFrozen(){return this._internalMeshDataInfo._areNormalsFrozen}freezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!0,this}unfreezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!1,this}set overridenInstanceCount(p){this._instanceDataStorage.overridenInstanceCount=p}_preActivate(){const p=this._internalMeshDataInfo,_=this.getScene().getRenderId();return p._preActivateId===_?this:(p._preActivateId=_,this._instanceDataStorage.visibleInstances=null,this)}_preActivateForIntermediateRendering(p){return this._instanceDataStorage.visibleInstances&&(this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId=p),this}_registerInstanceForRenderId(p,_){return this._instanceDataStorage.visibleInstances||(this._instanceDataStorage.visibleInstances={defaultRenderId:_,selfDefaultRenderId:this._renderId}),this._instanceDataStorage.visibleInstances[_]||(this._instanceDataStorage.previousRenderId!==void 0&&this._instanceDataStorage.isFrozen&&(this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId]=null),this._instanceDataStorage.previousRenderId=_,this._instanceDataStorage.visibleInstances[_]=new Array),this._instanceDataStorage.visibleInstances[_].push(p),this}_afterComputeWorldMatrix(){super._afterComputeWorldMatrix(),this.hasThinInstances&&(this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1))}_postActivate(){this.edgesShareWithInstances&&this.edgesRenderer&&this.edgesRenderer.isEnabled&&this._renderingGroup&&(this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer),this.edgesRenderer.customInstances.push(this.getWorldMatrix()))}refreshBoundingInfo(p=!1,_=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const E=this.geometry?this.geometry.boundingBias:null;return this._refreshBoundingInfo(this._getPositionData(p,_),E),this}_createGlobalSubMesh(p){const _=this.getTotalVertices();if(!_||!this.getIndices())return null;if(this.subMeshes&&this.subMeshes.length>0){const E=this.getIndices();if(!E)return null;const A=E.length;let $=!1;if(p)$=!0;else for(const ne of this.subMeshes){if(ne.indexStart+ne.indexCount>A){$=!0;break}if(ne.verticesStart+ne.verticesCount>_){$=!0;break}}if(!$)return this.subMeshes[0]}return this.releaseSubMeshes(),new _l(0,0,_,0,this.getTotalIndices(),this)}subdivide(p){if(p<1)return;const _=this.getTotalIndices();let E=_/p|0,A=0;for(;E%3!==0;)E++;this.releaseSubMeshes();for(let $=0;$<p&&!(A>=_);$++)_l.CreateFromIndices(0,A,$===p-1?_-A:E,this,void 0,!1),A+=E;this.refreshBoundingInfo(),this.synchronizeInstances()}setVerticesData(p,_,E=!1,A){if(this._geometry)this._geometry.setVerticesData(p,_,E,A);else{const $=new Yr;$.set(_,p);const ne=this.getScene();new vo(vo.RandomId(),ne,$,E,this)}return this}removeVerticesData(p){this._geometry&&this._geometry.removeVerticesData(p)}markVerticesDataAsUpdatable(p,_=!0){const E=this.getVertexBuffer(p);!E||E.isUpdatable()===_||this.setVerticesData(p,this.getVerticesData(p),_)}setVerticesBuffer(p,_=!0){return this._geometry||(this._geometry=vo.CreateGeometryForMesh(this)),this._geometry.setVerticesBuffer(p,null,_),this}updateVerticesData(p,_,E,A){return this._geometry?(A?(this.makeGeometryUnique(),this.updateVerticesData(p,_,E,!1)):this._geometry.updateVerticesData(p,_,E),this):this}updateMeshPositions(p,_=!0){const E=this.getVerticesData(ut.PositionKind);if(!E)return this;if(p(E),this.updateVerticesData(ut.PositionKind,E,!1,!1),_){const A=this.getIndices(),$=this.getVerticesData(ut.NormalKind);if(!$)return this;Yr.ComputeNormals(E,A,$),this.updateVerticesData(ut.NormalKind,$,!1,!1)}return this}makeGeometryUnique(){if(!this._geometry)return this;if(this._geometry.meshes.length===1)return this;const p=this._geometry,_=this._geometry.copy(vo.RandomId());return p.releaseForMesh(this,!0),_.applyToMesh(this),this}setIndexBuffer(p,_,E){let A=this._geometry;A||(A=new vo(vo.RandomId(),this.getScene(),void 0,void 0,this)),A.setIndexBuffer(p,_,E)}setIndices(p,_=null,E=!1){if(this._geometry)this._geometry.setIndices(p,_,E);else{const A=new Yr;A.indices=p;const $=this.getScene();new vo(vo.RandomId(),$,A,E,this)}return this}updateIndices(p,_,E=!1){return this._geometry?(this._geometry.updateIndices(p,_,E),this):this}toLeftHanded(){return this._geometry?(this._geometry.toLeftHanded(),this):this}_bind(p,_,E,A=!0){if(!this._geometry)return this;const $=this.getScene().getEngine();this.morphTargetManager&&this.morphTargetManager.isUsingTextureForTargets&&this.morphTargetManager._bind(_);let ne;if(this._unIndexed)ne=null;else switch(this._getRenderingFillMode(E)){case Xi.PointFillMode:ne=null;break;case Xi.WireFrameFillMode:ne=p._getLinesIndexBuffer(this.getIndices(),$);break;default:case Xi.TriangleFillMode:ne=this._geometry.getIndexBuffer();break}return!A||!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(_,ne):this._geometry._bind(_,ne,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),this}_draw(p,_,E){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;this._internalMeshDataInfo._onBeforeDrawObservable&&this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);const $=this.getScene().getEngine();return this._unIndexed||_==Xi.PointFillMode?$.drawArraysType(_,p.verticesStart,p.verticesCount,this.forcedInstanceCount||E):_==Xi.WireFrameFillMode?$.drawElementsType(_,0,p._linesIndexCount,this.forcedInstanceCount||E):$.drawElementsType(_,p.indexStart,p.indexCount,this.forcedInstanceCount||E),this}registerBeforeRender(p){return this.onBeforeRenderObservable.add(p),this}unregisterBeforeRender(p){return this.onBeforeRenderObservable.removeCallback(p),this}registerAfterRender(p){return this.onAfterRenderObservable.add(p),this}unregisterAfterRender(p){return this.onAfterRenderObservable.removeCallback(p),this}_getInstancesRenderList(p,_=!1){if(this._instanceDataStorage.isFrozen){if(_)return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[p]=!1,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[p]=!0,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;if(this._instanceDataStorage.previousBatch)return this._instanceDataStorage.previousBatch}const E=this.getScene(),A=E._isInIntermediateRendering(),$=A?this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate:this._internalAbstractMeshDataInfo._onlyForInstances,ne=this._instanceDataStorage.batchCache;if(ne.mustReturn=!1,ne.renderSelf[p]=_||!$&&this.isEnabled()&&this.isVisible,ne.visibleInstances[p]=null,this._instanceDataStorage.visibleInstances&&!_){const xe=this._instanceDataStorage.visibleInstances,ce=E.getRenderId(),Te=A?xe.intermediateDefaultRenderId:xe.defaultRenderId;ne.visibleInstances[p]=xe[ce],!ne.visibleInstances[p]&&Te&&(ne.visibleInstances[p]=xe[Te])}return ne.hardwareInstancedRendering[p]=!_&&this._instanceDataStorage.hardwareInstancedRendering&&ne.visibleInstances[p]!==null&&ne.visibleInstances[p]!==void 0,this._instanceDataStorage.previousBatch=ne,ne}_renderWithInstances(p,_,E,A,$){const ne=E.visibleInstances[p._id],xe=ne?ne.length:0,ce=this._instanceDataStorage,Te=ce.instancesBufferSize;let Re=ce.instancesBuffer,ke=ce.instancesPreviousBuffer;const Xe=(xe+1)*16*4;for(;ce.instancesBufferSize<Xe;)ce.instancesBufferSize*=2;(!ce.instancesData||Te!=ce.instancesBufferSize)&&(ce.instancesData=new Float32Array(ce.instancesBufferSize/4)),(this._scene.needsPreviousWorldMatrices&&!ce.instancesPreviousData||Te!=ce.instancesBufferSize)&&(ce.instancesPreviousData=new Float32Array(ce.instancesBufferSize/4));let xt=0,qe=0;const ht=E.renderSelf[p._id],Nt=!Re||Te!==ce.instancesBufferSize||this._scene.needsPreviousWorldMatrices&&!ce.instancesPreviousBuffer;if(!this._instanceDataStorage.manualUpdate&&(!ce.isFrozen||Nt)){const wt=this.getWorldMatrix();if(ht&&(this._scene.needsPreviousWorldMatrices&&(ce.masterMeshPreviousWorldMatrix?(ce.masterMeshPreviousWorldMatrix.copyToArray(ce.instancesPreviousData,xt),ce.masterMeshPreviousWorldMatrix.copyFrom(wt)):(ce.masterMeshPreviousWorldMatrix=wt.clone(),ce.masterMeshPreviousWorldMatrix.copyToArray(ce.instancesPreviousData,xt))),wt.copyToArray(ce.instancesData,xt),xt+=16,qe++),ne){if(Lr.INSTANCEDMESH_SORT_TRANSPARENT&&this._scene.activeCamera&&p.getMaterial()?.needAlphaBlendingForMesh(p.getRenderingMesh())){const Qt=this._scene.activeCamera.globalPosition;for(let Ht=0;Ht<ne.length;Ht++){const Wt=ne[Ht];Wt._distanceToCamera=nt.Distance(Wt.getBoundingInfo().boundingSphere.centerWorld,Qt)}ne.sort((Ht,Wt)=>Ht._distanceToCamera>Wt._distanceToCamera?-1:Ht._distanceToCamera<Wt._distanceToCamera?1:0)}for(let Qt=0;Qt<ne.length;Qt++){const Ht=ne[Qt],Wt=Ht.getWorldMatrix();Wt.copyToArray(ce.instancesData,xt),this._scene.needsPreviousWorldMatrices&&(Ht._previousWorldMatrix?(Ht._previousWorldMatrix.copyToArray(ce.instancesPreviousData,xt),Ht._previousWorldMatrix.copyFrom(Wt)):(Ht._previousWorldMatrix=Wt.clone(),Ht._previousWorldMatrix.copyToArray(ce.instancesPreviousData,xt))),xt+=16,qe++}}}else qe=(ht?1:0)+xe;return Nt?(Re&&Re.dispose(),ke&&ke.dispose(),Re=new vu($,ce.instancesData,!0,16,!1,!0),ce.instancesBuffer=Re,this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this._userInstancedBuffersStorage.vertexBuffers.world0=Re.createVertexBuffer("world0",0,4),this._userInstancedBuffersStorage.vertexBuffers.world1=Re.createVertexBuffer("world1",4,4),this._userInstancedBuffersStorage.vertexBuffers.world2=Re.createVertexBuffer("world2",8,4),this._userInstancedBuffersStorage.vertexBuffers.world3=Re.createVertexBuffer("world3",12,4),this._scene.needsPreviousWorldMatrices&&(ke=new vu($,ce.instancesPreviousData,!0,16,!1,!0),ce.instancesPreviousBuffer=ke,this._userInstancedBuffersStorage.vertexBuffers.previousWorld0=ke.createVertexBuffer("previousWorld0",0,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld1=ke.createVertexBuffer("previousWorld1",4,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld2=ke.createVertexBuffer("previousWorld2",8,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld3=ke.createVertexBuffer("previousWorld3",12,4)),this._invalidateInstanceVertexArrayObject()):(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&(Re.updateDirectly(ce.instancesData,0,qe),this._scene.needsPreviousWorldMatrices&&(!this._instanceDataStorage.manualUpdate||this._instanceDataStorage.previousManualUpdate)&&ke.updateDirectly(ce.instancesPreviousData,0,qe)),this._processInstancedBuffers(ne,ht),this.getScene()._activeIndices.addCount(p.indexCount*qe,!1),$._currentDrawContext&&($._currentDrawContext.useInstancing=!0),this._bind(p,A,_),this._draw(p,_,qe),this._scene.needsPreviousWorldMatrices&&!Nt&&this._instanceDataStorage.manualUpdate&&(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&!this._instanceDataStorage.previousManualUpdate&&ke.updateDirectly(ce.instancesData,0,qe),$.unbindInstanceAttributes(),this}_renderWithThinInstances(p,_,E,A){const $=this._thinInstanceDataStorage?.instancesCount??0;this.getScene()._activeIndices.addCount(p.indexCount*$,!1),A._currentDrawContext&&(A._currentDrawContext.useInstancing=!0),this._bind(p,E,_),this._draw(p,_,$),this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&this._thinInstanceDataStorage.matrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData,0,$):this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.matrixData,!1)),A.unbindInstanceAttributes()}_processInstancedBuffers(p,_){}_processRendering(p,_,E,A,$,ne,xe,ce){const Te=this.getScene(),Re=Te.getEngine();if(A=this._getRenderingFillMode(A),ne&&_.getRenderingMesh().hasThinInstances)return this._renderWithThinInstances(_,A,E,Re),this;if(ne)this._renderWithInstances(_,A,$,E,Re);else{Re._currentDrawContext&&(Re._currentDrawContext.useInstancing=!1);let ke=0;$.renderSelf[_._id]&&(xe&&xe(!1,p.getWorldMatrix(),ce),ke++,this._draw(_,A,this._instanceDataStorage.overridenInstanceCount));const We=$.visibleInstances[_._id];if(We){const Xe=We.length;ke+=Xe;for(let xt=0;xt<Xe;xt++){const ht=We[xt].getWorldMatrix();xe&&xe(!0,ht,ce),this._draw(_,A)}}Te._activeIndices.addCount(_.indexCount*ke,!1)}return this}_rebuild(p=!1){if(this._instanceDataStorage.instancesBuffer&&(p&&this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null),this._userInstancedBuffersStorage){for(const _ in this._userInstancedBuffersStorage.vertexBuffers){const E=this._userInstancedBuffersStorage.vertexBuffers[_];E&&(p&&E.dispose(),this._userInstancedBuffersStorage.vertexBuffers[_]=null)}this._userInstancedBuffersStorage.vertexArrayObjects&&(this._userInstancedBuffersStorage.vertexArrayObjects={})}this._internalMeshDataInfo._effectiveMaterial=null,super._rebuild(p)}_freeze(){if(this.subMeshes){for(let p=0;p<this.subMeshes.length;p++)this._getInstancesRenderList(p);this._internalMeshDataInfo._effectiveMaterial=null,this._instanceDataStorage.isFrozen=!0}}_unFreeze(){this._instanceDataStorage.isFrozen=!1,this._instanceDataStorage.previousBatch=null}renderWithRenderPassId(p,_,E,A,$=!0){const ne=this._scene.getEngine(),xe=ne.currentRenderPassId;if(p!==void 0&&(ne.currentRenderPassId=p),A)(!$||$&&A.isInFrustum(this._scene._frustumPlanes))&&this.render(A,!!_,E);else for(let ce=0;ce<this.subMeshes.length;ce++){const Te=this.subMeshes[ce];(!$||$&&Te.isInFrustum(this._scene._frustumPlanes))&&this.render(Te,!!_,E)}return p!==void 0&&(ne.currentRenderPassId=xe),this}render(p,_,E){const A=this.getScene();this._internalAbstractMeshDataInfo._isActiveIntermediate?this._internalAbstractMeshDataInfo._isActiveIntermediate=!1:this._internalAbstractMeshDataInfo._isActive=!1;const $=A.activeCameras?.length??0;if(($>1&&A.activeCamera===A.activeCameras[0]||$<=1)&&this._checkOcclusionQuery()&&!this._occlusionDataStorage.forceRenderingWhenOccluded)return this;const xe=this._getInstancesRenderList(p._id,!!E);if(xe.mustReturn)return this;if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const ce=A.getEngine();let Te=0,Re=null;this.ignoreCameraMaxZ&&A.activeCamera&&!A._isInIntermediateRendering()&&(Te=A.activeCamera.maxZ,Re=A.activeCamera,A.activeCamera.maxZ=0,A.updateTransformMatrix(!0)),this._internalMeshDataInfo._onBeforeRenderObservable&&this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);const ke=p.getRenderingMesh(),We=xe.hardwareInstancedRendering[p._id]||ke.hasThinInstances||!!this._userInstancedBuffersStorage&&!p.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh,Xe=this._instanceDataStorage,xt=p.getMaterial();if(!xt)return Re&&(Re.maxZ=Te,A.updateTransformMatrix(!0)),this;if(!Xe.isFrozen||!this._internalMeshDataInfo._effectiveMaterial||this._internalMeshDataInfo._effectiveMaterial!==xt){if(xt._storeEffectOnSubMeshes){if(!xt.isReadyForSubMesh(this,p,We))return Re&&(Re.maxZ=Te,A.updateTransformMatrix(!0)),this}else if(!xt.isReady(this,We))return Re&&(Re.maxZ=Te,A.updateTransformMatrix(!0)),this;this._internalMeshDataInfo._effectiveMaterial=xt}else if(xt._storeEffectOnSubMeshes&&!p._drawWrapper?._wasPreviouslyReady||!xt._storeEffectOnSubMeshes&&!xt._getDrawWrapper()._wasPreviouslyReady)return Re&&(Re.maxZ=Te,A.updateTransformMatrix(!0)),this;_&&ce.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);let qe;this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes?qe=p._drawWrapper:qe=this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();const ht=qe?.effect??null;for(const xi of A._beforeRenderingMeshStage)xi.action(this,p,xe,ht);if(!qe||!ht)return Re&&(Re.maxZ=Te,A.updateTransformMatrix(!0)),this;const Nt=E||this;let wt;if(!Xe.isFrozen&&(this._internalMeshDataInfo._effectiveMaterial.backFaceCulling||this.overrideMaterialSideOrientation!==null||this._internalMeshDataInfo._effectiveMaterial.twoSidedLighting)){const xi=Nt._getWorldMatrixDeterminant();wt=this.overrideMaterialSideOrientation,wt==null&&(wt=this._internalMeshDataInfo._effectiveMaterial.sideOrientation),xi<0&&(wt=wt===Xi.ClockWiseSideOrientation?Xi.CounterClockWiseSideOrientation:Xi.ClockWiseSideOrientation),Xe.sideOrientation=wt}else wt=Xe.sideOrientation;const Qt=this._internalMeshDataInfo._effectiveMaterial._preBind(qe,wt);this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite&&ce.setDepthWrite(!0);const Ht=this._internalMeshDataInfo._effectiveMaterial,Wt=Ht.fillMode;this._internalMeshDataInfo._onBeforeBindObservable&&this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this),We||this._bind(p,ht,Wt,!1);const zt=Nt.getWorldMatrix();Ht._storeEffectOnSubMeshes?Ht.bindForSubMesh(zt,this,p):Ht.bind(zt,this),!Ht.backFaceCulling&&Ht.separateCullingPass&&(ce.setState(!0,Ht.zOffset,!1,!Qt,Ht.cullBackFaces,Ht.stencil,Ht.zOffsetUnits),this._processRendering(this,p,ht,Wt,xe,We,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),ce.setState(!0,Ht.zOffset,!1,Qt,Ht.cullBackFaces,Ht.stencil,Ht.zOffsetUnits),this._internalMeshDataInfo._onBetweenPassObservable&&this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(p)),this._processRendering(this,p,ht,Wt,xe,We,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),this._internalMeshDataInfo._effectiveMaterial.unbind();for(const xi of A._afterRenderingMeshStage)xi.action(this,p,xe,ht);return this._internalMeshDataInfo._onAfterRenderObservable&&this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this),Re&&(Re.maxZ=Te,A.updateTransformMatrix(!0)),A.performancePriority===R2.Aggressive&&!Xe.isFrozen&&this._freeze(),this}cleanMatrixWeights(){this.isVerticesDataPresent(ut.MatricesWeightsKind)&&(this.isVerticesDataPresent(ut.MatricesWeightsExtraKind)?this._normalizeSkinWeightsAndExtra():this._normalizeSkinFourWeights())}_normalizeSkinFourWeights(){const p=this.getVerticesData(ut.MatricesWeightsKind),_=p.length;for(let E=0;E<_;E+=4){const A=p[E]+p[E+1]+p[E+2]+p[E+3];if(A===0)p[E]=1;else{const $=1/A;p[E]*=$,p[E+1]*=$,p[E+2]*=$,p[E+3]*=$}}this.setVerticesData(ut.MatricesWeightsKind,p)}_normalizeSkinWeightsAndExtra(){const p=this.getVerticesData(ut.MatricesWeightsExtraKind),_=this.getVerticesData(ut.MatricesWeightsKind),E=_.length;for(let A=0;A<E;A+=4){let $=_[A]+_[A+1]+_[A+2]+_[A+3];if($+=p[A]+p[A+1]+p[A+2]+p[A+3],$===0)_[A]=1;else{const ne=1/$;_[A]*=ne,_[A+1]*=ne,_[A+2]*=ne,_[A+3]*=ne,p[A]*=ne,p[A+1]*=ne,p[A+2]*=ne,p[A+3]*=ne}}this.setVerticesData(ut.MatricesWeightsKind,_),this.setVerticesData(ut.MatricesWeightsKind,p)}validateSkinning(){const p=this.getVerticesData(ut.MatricesWeightsExtraKind),_=this.getVerticesData(ut.MatricesWeightsKind);if(_===null||this.skeleton==null)return{skinned:!1,valid:!0,report:"not skinned"};const E=_.length;let A=0,$=0,ne=0,xe=0;const ce=p===null?4:8,Te=[];for(let ht=0;ht<=ce;ht++)Te[ht]=0;const Re=.001;for(let ht=0;ht<E;ht+=4){let Nt=_[ht],wt=Nt,Qt=wt===0?0:1;for(let Ht=1;Ht<ce;Ht++){const Wt=Ht<4?_[ht+Ht]:p[ht+Ht-4];Wt>Nt&&A++,Wt!==0&&Qt++,wt+=Wt,Nt=Wt}if(Te[Qt]++,Qt>ne&&(ne=Qt),wt===0)$++;else{const Ht=1/wt;let Wt=0;for(let zt=0;zt<ce;zt++)zt<4?Wt+=Math.abs(_[ht+zt]-_[ht+zt]*Ht):Wt+=Math.abs(p[ht+zt-4]-p[ht+zt-4]*Ht);Wt>Re&&xe++}}const ke=this.skeleton.bones.length,We=this.getVerticesData(ut.MatricesIndicesKind),Xe=this.getVerticesData(ut.MatricesIndicesExtraKind);let xt=0;for(let ht=0;ht<E;ht+=4)for(let Nt=0;Nt<ce;Nt++){const wt=Nt<4?We[ht+Nt]:Xe[ht+Nt-4];(wt>=ke||wt<0)&&xt++}const qe="Number of Weights = "+E/4+`
Maximum influences = `+ne+`
Missing Weights = `+$+`
Not Sorted = `+A+`
Not Normalized = `+xe+`
WeightCounts = [`+Te+`]
Number of bones = `+ke+`
Bad Bone Indices = `+xt;return{skinned:!0,valid:$===0&&xe===0&&xt===0,report:qe}}_checkDelayState(){const p=this.getScene();return this._geometry?this._geometry.load(p):this.delayLoadState===4&&(this.delayLoadState=2,this._queueLoad(p)),this}_queueLoad(p){p.addPendingData(this);const _=this.delayLoadingFile.indexOf(".babylonbinarymeshdata")!==-1;return ct.LoadFile(this.delayLoadingFile,E=>{E instanceof ArrayBuffer?this._delayLoadingFunction(E,this):this._delayLoadingFunction(JSON.parse(E),this),this.instances.forEach(A=>{A.refreshBoundingInfo(),A._syncSubMeshes()}),this.delayLoadState=1,p.removePendingData(this)},()=>{},p.offlineProvider,_),this}isInFrustum(p){return this.delayLoadState===2||!super.isInFrustum(p)?!1:(this._checkDelayState(),!0)}setMaterialById(p){const _=this.getScene().materials;let E;for(E=_.length-1;E>-1;E--)if(_[E].id===p)return this.material=_[E],this;const A=this.getScene().multiMaterials;for(E=A.length-1;E>-1;E--)if(A[E].id===p)return this.material=A[E],this;return this}getAnimatables(){const p=[];return this.material&&p.push(this.material),this.skeleton&&p.push(this.skeleton),p}bakeTransformIntoVertices(p){if(!this.isVerticesDataPresent(ut.PositionKind))return this;const _=this.subMeshes.splice(0);this._resetPointsArrayCache();let E=this.getVerticesData(ut.PositionKind);const A=nt.Zero();let $;for($=0;$<E.length;$+=3)nt.TransformCoordinatesFromFloatsToRef(E[$],E[$+1],E[$+2],p,A).toArray(E,$);if(this.setVerticesData(ut.PositionKind,E,this.getVertexBuffer(ut.PositionKind).isUpdatable()),this.isVerticesDataPresent(ut.NormalKind)){for(E=this.getVerticesData(ut.NormalKind),$=0;$<E.length;$+=3)nt.TransformNormalFromFloatsToRef(E[$],E[$+1],E[$+2],p,A).normalize().toArray(E,$);this.setVerticesData(ut.NormalKind,E,this.getVertexBuffer(ut.NormalKind).isUpdatable())}return p.determinant()<0&&this.flipFaces(),this.releaseSubMeshes(),this.subMeshes=_,this}bakeCurrentTransformIntoVertices(p=!0){return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)),this.resetLocalMatrix(p),this}get _positions(){return this._internalAbstractMeshDataInfo._positions?this._internalAbstractMeshDataInfo._positions:this._geometry?this._geometry._positions:null}_resetPointsArrayCache(){return this._geometry&&this._geometry._resetPointsArrayCache(),this}_generatePointsArray(){return this._geometry?this._geometry._generatePointsArray():!1}clone(p="",_=null,E,A=!0){return new Lr(p,this.getScene(),_,this,E,A)}dispose(p,_=!1){this.morphTargetManager=null,this._geometry&&this._geometry.releaseForMesh(this,!0);const E=this._internalMeshDataInfo;if(E._onBeforeDrawObservable&&E._onBeforeDrawObservable.clear(),E._onBeforeBindObservable&&E._onBeforeBindObservable.clear(),E._onBeforeRenderObservable&&E._onBeforeRenderObservable.clear(),E._onAfterRenderObservable&&E._onAfterRenderObservable.clear(),E._onBetweenPassObservable&&E._onBetweenPassObservable.clear(),this._scene.useClonedMeshMap){if(E.meshMap)for(const A in E.meshMap){const $=E.meshMap[A];$&&($._internalMeshDataInfo._source=null,E.meshMap[A]=void 0)}E._source&&E._source._internalMeshDataInfo.meshMap&&(E._source._internalMeshDataInfo.meshMap[this.uniqueId]=void 0)}else{const A=this.getScene().meshes;for(const $ of A){const ne=$;ne._internalMeshDataInfo&&ne._internalMeshDataInfo._source&&ne._internalMeshDataInfo._source===this&&(ne._internalMeshDataInfo._source=null)}}E._source=null,this._instanceDataStorage.visibleInstances={},this._disposeInstanceSpecificData(),this._disposeThinInstanceSpecificData(),this._internalMeshDataInfo._checkReadinessObserver&&this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),super.dispose(p,_)}_disposeInstanceSpecificData(){}_disposeThinInstanceSpecificData(){}_invalidateInstanceVertexArrayObject(){}applyDisplacementMap(p,_,E,A,$,ne,xe=!1,ce){const Te=this.getScene(),Re=ke=>{const We=ke.width,Xe=ke.height,qe=this.getEngine().createCanvas(We,Xe).getContext("2d");qe.drawImage(ke,0,0);const ht=qe.getImageData(0,0,We,Xe).data;this.applyDisplacementMapFromBuffer(ht,We,Xe,_,E,$,ne,xe),A&&A(this)};return ct.LoadImage(p,Re,ce||(()=>{}),Te.offlineProvider),this}applyDisplacementMapFromBuffer(p,_,E,A,$,ne,xe,ce=!1){if(!this.isVerticesDataPresent(ut.PositionKind)||!this.isVerticesDataPresent(ut.NormalKind)||!this.isVerticesDataPresent(ut.UVKind))return vi.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"),this;const Te=this.getVerticesData(ut.PositionKind,!0,!0),Re=this.getVerticesData(ut.NormalKind),ke=this.getVerticesData(ut.UVKind);let We=nt.Zero();const Xe=nt.Zero(),xt=xr.Zero();ne=ne||xr.Zero(),xe=xe||new xr(1,1);for(let qe=0;qe<Te.length;qe+=3){nt.FromArrayToRef(Te,qe,We),nt.FromArrayToRef(Re,qe,Xe),xr.FromArrayToRef(ke,qe/3*2,xt);const ht=Math.abs(xt.x*xe.x+ne.x%1)*(_-1)%_|0,Nt=Math.abs(xt.y*xe.y+ne.y%1)*(E-1)%E|0,wt=(ht+Nt*_)*4,Qt=p[wt]/255,Ht=p[wt+1]/255,Wt=p[wt+2]/255,zt=Qt*.3+Ht*.59+Wt*.11;Xe.normalize(),Xe.scaleInPlace(A+($-A)*zt),We=We.add(Xe),We.toArray(Te,qe)}return Yr.ComputeNormals(Te,this.getIndices(),Re),ce?(this.setVerticesData(ut.PositionKind,Te),this.setVerticesData(ut.NormalKind,Re),this.setVerticesData(ut.UVKind,ke)):(this.updateVerticesData(ut.PositionKind,Te),this.updateVerticesData(ut.NormalKind,Re)),this}_getFlattenedNormals(p,_){const E=new Float32Array(p.length*3);let A=0;const $=this.overrideMaterialSideOrientation===(this._scene.useRightHandedSystem?1:0);for(let ne=0;ne<p.length;ne+=3){const xe=nt.FromArray(_,p[ne]*3),ce=nt.FromArray(_,p[ne+1]*3),Te=nt.FromArray(_,p[ne+2]*3),Re=xe.subtract(ce),ke=Te.subtract(ce),We=nt.Normalize(nt.Cross(Re,ke));$&&We.scaleInPlace(-1);for(let Xe=0;Xe<3;Xe++)E[A++]=We.x,E[A++]=We.y,E[A++]=We.z}return E}_convertToUnIndexedMesh(p=!1){const _=this.getVerticesDataKinds(),E=this.getIndices(),A={},$=(xe,ce)=>{const Te=new Float32Array(E.length*ce);let Re=0;for(let ke=0;ke<E.length;ke++)for(let We=0;We<ce;We++)Te[Re++]=xe[E[ke]*ce+We];return Te},ne=this.geometry?this.subMeshes.slice(0):[];for(const xe of _)A[xe]=this.getVerticesData(xe);for(const xe of _){const ce=this.getVertexBuffer(xe),Te=ce.getStrideSize();if(p&&xe===ut.NormalKind){const Re=this._getFlattenedNormals(E,A[ut.PositionKind]);this.setVerticesData(ut.NormalKind,Re,ce.isUpdatable(),Te)}else this.setVerticesData(xe,$(A[xe],Te),ce.isUpdatable(),Te)}if(this.morphTargetManager){for(let xe=0;xe<this.morphTargetManager.numTargets;xe++){const ce=this.morphTargetManager.getTarget(xe),Te=ce.getPositions();ce.setPositions($(Te,3));const Re=ce.getNormals();Re&&ce.setNormals(p?this._getFlattenedNormals(E,Te):$(Re,3));const ke=ce.getTangents();ke&&ce.setTangents($(ke,3));const We=ce.getUVs();We&&ce.setUVs($(We,2))}this.morphTargetManager.synchronize()}for(let xe=0;xe<E.length;xe++)E[xe]=xe;this.setIndices(E),this._unIndexed=!0,this.releaseSubMeshes();for(const xe of ne)_l.AddToMesh(xe.materialIndex,xe.indexStart,xe.indexCount,xe.indexStart,xe.indexCount,this);return this.synchronizeInstances(),this}convertToFlatShadedMesh(){return this._convertToUnIndexedMesh(!0)}convertToUnIndexedMesh(){return this._convertToUnIndexedMesh()}flipFaces(p=!1){const _=Yr.ExtractFromMesh(this);let E;if(p&&this.isVerticesDataPresent(ut.NormalKind)&&_.normals)for(E=0;E<_.normals.length;E++)_.normals[E]*=-1;if(_.indices){let A;for(E=0;E<_.indices.length;E+=3)A=_.indices[E+1],_.indices[E+1]=_.indices[E+2],_.indices[E+2]=A}return _.applyToMesh(this,this.isVertexBufferUpdatable(ut.PositionKind)),this}increaseVertices(p=1){const _=Yr.ExtractFromMesh(this),E=_.indices&&!Array.isArray(_.indices)&&Array.from?Array.from(_.indices):_.indices,A=_.positions&&!Array.isArray(_.positions)&&Array.from?Array.from(_.positions):_.positions,$=_.uvs&&!Array.isArray(_.uvs)&&Array.from?Array.from(_.uvs):_.uvs,ne=_.normals&&!Array.isArray(_.normals)&&Array.from?Array.from(_.normals):_.normals;if(!E||!A)vi.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");else{_.indices=E,_.positions=A,$&&(_.uvs=$),ne&&(_.normals=ne);const xe=p+1,ce=new Array;for(let Wt=0;Wt<xe+1;Wt++)ce[Wt]=new Array;let Te,Re;const ke=new nt(0,0,0),We=new nt(0,0,0),Xe=new xr(0,0),xt=new Array,qe=new Array,ht=new Array;let Nt,wt=A.length,Qt;$&&(Qt=$.length);let Ht;ne&&(Ht=ne.length);for(let Wt=0;Wt<E.length;Wt+=3){qe[0]=E[Wt],qe[1]=E[Wt+1],qe[2]=E[Wt+2];for(let zt=0;zt<3;zt++)if(Te=qe[zt],Re=qe[(zt+1)%3],ht[Te]===void 0&&ht[Re]===void 0?(ht[Te]=new Array,ht[Re]=new Array):(ht[Te]===void 0&&(ht[Te]=new Array),ht[Re]===void 0&&(ht[Re]=new Array)),ht[Te][Re]===void 0&&ht[Re][Te]===void 0){ht[Te][Re]=[],ke.x=(A[3*Re]-A[3*Te])/xe,ke.y=(A[3*Re+1]-A[3*Te+1])/xe,ke.z=(A[3*Re+2]-A[3*Te+2])/xe,ne&&(We.x=(ne[3*Re]-ne[3*Te])/xe,We.y=(ne[3*Re+1]-ne[3*Te+1])/xe,We.z=(ne[3*Re+2]-ne[3*Te+2])/xe),$&&(Xe.x=($[2*Re]-$[2*Te])/xe,Xe.y=($[2*Re+1]-$[2*Te+1])/xe),ht[Te][Re].push(Te);for(let xi=1;xi<xe;xi++)ht[Te][Re].push(A.length/3),A[wt++]=A[3*Te]+xi*ke.x,A[wt++]=A[3*Te+1]+xi*ke.y,A[wt++]=A[3*Te+2]+xi*ke.z,ne&&(ne[Ht++]=ne[3*Te]+xi*We.x,ne[Ht++]=ne[3*Te+1]+xi*We.y,ne[Ht++]=ne[3*Te+2]+xi*We.z),$&&($[Qt++]=$[2*Te]+xi*Xe.x,$[Qt++]=$[2*Te+1]+xi*Xe.y);ht[Te][Re].push(Re),ht[Re][Te]=new Array,Nt=ht[Te][Re].length;for(let xi=0;xi<Nt;xi++)ht[Re][Te][xi]=ht[Te][Re][Nt-1-xi]}ce[0][0]=E[Wt],ce[1][0]=ht[E[Wt]][E[Wt+1]][1],ce[1][1]=ht[E[Wt]][E[Wt+2]][1];for(let zt=2;zt<xe;zt++){ce[zt][0]=ht[E[Wt]][E[Wt+1]][zt],ce[zt][zt]=ht[E[Wt]][E[Wt+2]][zt],ke.x=(A[3*ce[zt][zt]]-A[3*ce[zt][0]])/zt,ke.y=(A[3*ce[zt][zt]+1]-A[3*ce[zt][0]+1])/zt,ke.z=(A[3*ce[zt][zt]+2]-A[3*ce[zt][0]+2])/zt,ne&&(We.x=(ne[3*ce[zt][zt]]-ne[3*ce[zt][0]])/zt,We.y=(ne[3*ce[zt][zt]+1]-ne[3*ce[zt][0]+1])/zt,We.z=(ne[3*ce[zt][zt]+2]-ne[3*ce[zt][0]+2])/zt),$&&(Xe.x=($[2*ce[zt][zt]]-$[2*ce[zt][0]])/zt,Xe.y=($[2*ce[zt][zt]+1]-$[2*ce[zt][0]+1])/zt);for(let xi=1;xi<zt;xi++)ce[zt][xi]=A.length/3,A[wt++]=A[3*ce[zt][0]]+xi*ke.x,A[wt++]=A[3*ce[zt][0]+1]+xi*ke.y,A[wt++]=A[3*ce[zt][0]+2]+xi*ke.z,ne&&(ne[Ht++]=ne[3*ce[zt][0]]+xi*We.x,ne[Ht++]=ne[3*ce[zt][0]+1]+xi*We.y,ne[Ht++]=ne[3*ce[zt][0]+2]+xi*We.z),$&&($[Qt++]=$[2*ce[zt][0]]+xi*Xe.x,$[Qt++]=$[2*ce[zt][0]+1]+xi*Xe.y)}ce[xe]=ht[E[Wt+1]][E[Wt+2]],xt.push(ce[0][0],ce[1][0],ce[1][1]);for(let zt=1;zt<xe;zt++){let xi;for(xi=0;xi<zt;xi++)xt.push(ce[zt][xi],ce[zt+1][xi],ce[zt+1][xi+1]),xt.push(ce[zt][xi],ce[zt+1][xi+1],ce[zt][xi+1]);xt.push(ce[zt][xi],ce[zt+1][xi],ce[zt+1][xi+1])}}_.indices=xt,_.applyToMesh(this,this.isVertexBufferUpdatable(ut.PositionKind))}}forceSharedVertices(){const p=Yr.ExtractFromMesh(this),_=p.uvs,E=p.indices,A=p.positions,$=p.colors,ne=p.matricesIndices,xe=p.matricesWeights,ce=p.matricesIndicesExtra,Te=p.matricesWeightsExtra;if(E===void 0||A===void 0||E===null||A===null)vi.Warn("VertexData contains empty entries");else{const Re=new Array,ke=new Array,We=new Array,Xe=new Array,xt=new Array,qe=new Array,ht=new Array,Nt=new Array;let wt=new Array,Qt=0;const Ht={};let Wt,zt;for(let wi=0;wi<E.length;wi+=3){zt=[E[wi],E[wi+1],E[wi+2]],wt=[];for(let vs=0;vs<3;vs++){wt[vs]="";for(let cs=0;cs<3;cs++)Math.abs(A[3*zt[vs]+cs])<1e-8&&(A[3*zt[vs]+cs]=0),wt[vs]+=A[3*zt[vs]+cs]+"|"}if(!(wt[0]==wt[1]||wt[0]==wt[2]||wt[1]==wt[2]))for(let vs=0;vs<3;vs++){if(Wt=Ht[wt[vs]],Wt===void 0){Ht[wt[vs]]=Qt,Wt=Qt++;for(let cs=0;cs<3;cs++)Re.push(A[3*zt[vs]+cs]);if($!=null)for(let cs=0;cs<4;cs++)Xe.push($[4*zt[vs]+cs]);if(_!=null)for(let cs=0;cs<2;cs++)We.push(_[2*zt[vs]+cs]);if(ne!=null)for(let cs=0;cs<4;cs++)xt.push(ne[4*zt[vs]+cs]);if(xe!=null)for(let cs=0;cs<4;cs++)qe.push(xe[4*zt[vs]+cs]);if(ce!=null)for(let cs=0;cs<4;cs++)ht.push(ce[4*zt[vs]+cs]);if(Te!=null)for(let cs=0;cs<4;cs++)Nt.push(Te[4*zt[vs]+cs])}ke.push(Wt)}}const xi=new Array;Yr.ComputeNormals(Re,ke,xi),p.positions=Re,p.indices=ke,p.normals=xi,_!=null&&(p.uvs=We),$!=null&&(p.colors=Xe),ne!=null&&(p.matricesIndices=xt),xe!=null&&(p.matricesWeights=qe),ce!=null&&(p.matricesIndicesExtra=ht),xe!=null&&(p.matricesWeightsExtra=Nt),p.applyToMesh(this,this.isVertexBufferUpdatable(ut.PositionKind))}}static _instancedMeshFactory(p,_){throw Tr("InstancedMesh")}static _PhysicsImpostorParser(p,_,E){throw Tr("PhysicsImpostor")}createInstance(p){return Lr._instancedMeshFactory(p,this)}synchronizeInstances(){for(let p=0;p<this.instances.length;p++)this.instances[p]._syncSubMeshes();return this}optimizeIndices(p){const _=this.getIndices(),E=this.getVerticesData(ut.PositionKind);if(!E||!_)return this;const A=[];for(let ne=0;ne<E.length;ne=ne+3)A.push(nt.FromArray(E,ne));const $=[];return ki.SyncAsyncForLoop(A.length,40,ne=>{const xe=A.length-1-ne,ce=A[xe];for(let Te=0;Te<xe;++Te){const Re=A[Te];if(ce.equals(Re)){$[xe]=Te;break}}},()=>{for(let xe=0;xe<_.length;++xe)_[xe]=$[_[xe]]||_[xe];const ne=this.subMeshes.slice(0);this.setIndices(_),this.subMeshes=ne,p&&p(this)}),this}serialize(p={}){p.name=this.name,p.id=this.id,p.uniqueId=this.uniqueId,p.type=this.getClassName(),ni&&ni.HasTags(this)&&(p.tags=ni.GetTags(this)),p.position=this.position.asArray(),this.rotationQuaternion?p.rotationQuaternion=this.rotationQuaternion.asArray():this.rotation&&(p.rotation=this.rotation.asArray()),p.scaling=this.scaling.asArray(),this._postMultiplyPivotMatrix?p.pivotMatrix=this.getPivotMatrix().asArray():p.localMatrix=this.getPivotMatrix().asArray(),p.isEnabled=this.isEnabled(!1),p.isVisible=this.isVisible,p.infiniteDistance=this.infiniteDistance,p.pickable=this.isPickable,p.receiveShadows=this.receiveShadows,p.billboardMode=this.billboardMode,p.visibility=this.visibility,p.checkCollisions=this.checkCollisions,p.isBlocker=this.isBlocker,p.overrideMaterialSideOrientation=this.overrideMaterialSideOrientation,this.parent&&this.parent._serializeAsParent(p),p.isUnIndexed=this.isUnIndexed;const _=this._geometry;if(_&&this.subMeshes){p.geometryUniqueId=_.uniqueId,p.geometryId=_.id,p.subMeshes=[];for(let E=0;E<this.subMeshes.length;E++){const A=this.subMeshes[E];p.subMeshes.push({materialIndex:A.materialIndex,verticesStart:A.verticesStart,verticesCount:A.verticesCount,indexStart:A.indexStart,indexCount:A.indexCount})}}if(this.material?this.material.doNotSerialize||(p.materialUniqueId=this.material.uniqueId,p.materialId=this.material.id):(this.material=null,p.materialUniqueId=this._scene.defaultMaterial.uniqueId,p.materialId=this._scene.defaultMaterial.id),this.morphTargetManager&&(p.morphTargetManagerId=this.morphTargetManager.uniqueId),this.skeleton&&(p.skeletonId=this.skeleton.id,p.numBoneInfluencers=this.numBoneInfluencers),this.getScene()._getComponent(_r.NAME_PHYSICSENGINE)){const E=this.getPhysicsImpostor();E&&(p.physicsMass=E.getParam("mass"),p.physicsFriction=E.getParam("friction"),p.physicsRestitution=E.getParam("mass"),p.physicsImpostor=E.type)}this.metadata&&(p.metadata=this.metadata),p.instances=[];for(let E=0;E<this.instances.length;E++){const A=this.instances[E];if(A.doNotSerialize)continue;const $={name:A.name,id:A.id,isEnabled:A.isEnabled(!1),isVisible:A.isVisible,isPickable:A.isPickable,checkCollisions:A.checkCollisions,position:A.position.asArray(),scaling:A.scaling.asArray()};if(A.parent&&A.parent._serializeAsParent($),A.rotationQuaternion?$.rotationQuaternion=A.rotationQuaternion.asArray():A.rotation&&($.rotation=A.rotation.asArray()),this.getScene()._getComponent(_r.NAME_PHYSICSENGINE)){const ne=A.getPhysicsImpostor();ne&&($.physicsMass=ne.getParam("mass"),$.physicsFriction=ne.getParam("friction"),$.physicsRestitution=ne.getParam("mass"),$.physicsImpostor=ne.type)}A.metadata&&($.metadata=A.metadata),A.actionManager&&($.actions=A.actionManager.serialize(A.name)),p.instances.push($),Xr.AppendSerializedAnimations(A,$),$.ranges=A.serializeAnimationRanges()}if(this._thinInstanceDataStorage.instancesCount&&this._thinInstanceDataStorage.matrixData&&(p.thinInstances={instancesCount:this._thinInstanceDataStorage.instancesCount,matrixData:Array.from(this._thinInstanceDataStorage.matrixData),matrixBufferSize:this._thinInstanceDataStorage.matrixBufferSize,enablePicking:this.thinInstanceEnablePicking},this._userThinInstanceBuffersStorage)){const E={data:{},sizes:{},strides:{}};for(const A in this._userThinInstanceBuffersStorage.data)E.data[A]=Array.from(this._userThinInstanceBuffersStorage.data[A]),E.sizes[A]=this._userThinInstanceBuffersStorage.sizes[A],E.strides[A]=this._userThinInstanceBuffersStorage.strides[A];p.thinInstances.userThinInstance=E}return Xr.AppendSerializedAnimations(this,p),p.ranges=this.serializeAnimationRanges(),p.layerMask=this.layerMask,p.alphaIndex=this.alphaIndex,p.hasVertexAlpha=this.hasVertexAlpha,p.overlayAlpha=this.overlayAlpha,p.overlayColor=this.overlayColor.asArray(),p.renderOverlay=this.renderOverlay,p.applyFog=this.applyFog,this.actionManager&&(p.actions=this.actionManager.serialize(this.name)),p}_syncGeometryWithMorphTargetManager(){if(!this.geometry)return;this._markSubMeshesAsAttributesDirty();const p=this._internalAbstractMeshDataInfo._morphTargetManager;if(p&&p.vertexCount){if(p.vertexCount!==this.getTotalVertices()){vi.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."),this.morphTargetManager=null;return}if(p.isUsingTextureForTargets)return;for(let _=0;_<p.numInfluencers;_++){const E=p.getActiveTarget(_),A=E.getPositions();if(!A){vi.Error("Invalid morph target. Target must have positions.");return}this.geometry.setVerticesData(ut.PositionKind+_,A,!1,3);const $=E.getNormals();$&&this.geometry.setVerticesData(ut.NormalKind+_,$,!1,3);const ne=E.getTangents();ne&&this.geometry.setVerticesData(ut.TangentKind+_,ne,!1,3);const xe=E.getUVs();xe&&this.geometry.setVerticesData(ut.UVKind+"_"+_,xe,!1,2)}}else{let _=0;for(;this.geometry.isVerticesDataPresent(ut.PositionKind+_);)this.geometry.removeVerticesData(ut.PositionKind+_),this.geometry.isVerticesDataPresent(ut.NormalKind+_)&&this.geometry.removeVerticesData(ut.NormalKind+_),this.geometry.isVerticesDataPresent(ut.TangentKind+_)&&this.geometry.removeVerticesData(ut.TangentKind+_),this.geometry.isVerticesDataPresent(ut.UVKind+_)&&this.geometry.removeVerticesData(ut.UVKind+"_"+_),_++}}static Parse(p,_,E){let A;if(p.type&&p.type==="LinesMesh"?A=Lr._LinesMeshParser(p,_):p.type&&p.type==="GroundMesh"?A=Lr._GroundMeshParser(p,_):p.type&&p.type==="GoldbergMesh"?A=Lr._GoldbergMeshParser(p,_):p.type&&p.type==="GreasedLineMesh"?A=Lr._GreasedLineMeshParser(p,_):p.type&&p.type==="TrailMesh"?A=Lr._TrailMeshParser(p,_):A=new Lr(p.name,_),A.id=p.id,A._waitingParsedUniqueId=p.uniqueId,ni&&ni.AddTagsTo(A,p.tags),A.position=nt.FromArray(p.position),p.metadata!==void 0&&(A.metadata=p.metadata),p.rotationQuaternion?A.rotationQuaternion=_s.FromArray(p.rotationQuaternion):p.rotation&&(A.rotation=nt.FromArray(p.rotation)),A.scaling=nt.FromArray(p.scaling),p.localMatrix?A.setPreTransformMatrix(Yt.FromArray(p.localMatrix)):p.pivotMatrix&&A.setPivotMatrix(Yt.FromArray(p.pivotMatrix)),A.setEnabled(p.isEnabled),A.isVisible=p.isVisible,A.infiniteDistance=p.infiniteDistance,A.showBoundingBox=p.showBoundingBox,A.showSubMeshesBoundingBox=p.showSubMeshesBoundingBox,p.applyFog!==void 0&&(A.applyFog=p.applyFog),p.pickable!==void 0&&(A.isPickable=p.pickable),p.alphaIndex!==void 0&&(A.alphaIndex=p.alphaIndex),A.receiveShadows=p.receiveShadows,p.billboardMode!==void 0&&(A.billboardMode=p.billboardMode),p.visibility!==void 0&&(A.visibility=p.visibility),A.checkCollisions=p.checkCollisions,p.overrideMaterialSideOrientation!==void 0&&(A.overrideMaterialSideOrientation=p.overrideMaterialSideOrientation),p.isBlocker!==void 0&&(A.isBlocker=p.isBlocker),A._shouldGenerateFlatShading=p.useFlatShading,p.freezeWorldMatrix&&(A._waitingData.freezeWorldMatrix=p.freezeWorldMatrix),p.parentId!==void 0&&(A._waitingParentId=p.parentId),p.parentInstanceIndex!==void 0&&(A._waitingParentInstanceIndex=p.parentInstanceIndex),p.actions!==void 0&&(A._waitingData.actions=p.actions),p.overlayAlpha!==void 0&&(A.overlayAlpha=p.overlayAlpha),p.overlayColor!==void 0&&(A.overlayColor=ws.FromArray(p.overlayColor)),p.renderOverlay!==void 0&&(A.renderOverlay=p.renderOverlay),A.isUnIndexed=!!p.isUnIndexed,A.hasVertexAlpha=p.hasVertexAlpha,p.delayLoadingFile?(A.delayLoadState=4,A.delayLoadingFile=E+p.delayLoadingFile,A.buildBoundingInfo(nt.FromArray(p.boundingBoxMinimum),nt.FromArray(p.boundingBoxMaximum)),p._binaryInfo&&(A._binaryInfo=p._binaryInfo),A._delayInfo=[],p.hasUVs&&A._delayInfo.push(ut.UVKind),p.hasUVs2&&A._delayInfo.push(ut.UV2Kind),p.hasUVs3&&A._delayInfo.push(ut.UV3Kind),p.hasUVs4&&A._delayInfo.push(ut.UV4Kind),p.hasUVs5&&A._delayInfo.push(ut.UV5Kind),p.hasUVs6&&A._delayInfo.push(ut.UV6Kind),p.hasColors&&A._delayInfo.push(ut.ColorKind),p.hasMatricesIndices&&A._delayInfo.push(ut.MatricesIndicesKind),p.hasMatricesWeights&&A._delayInfo.push(ut.MatricesWeightsKind),A._delayLoadingFunction=vo._ImportGeometry,M0.ForceFullSceneLoadingForIncremental&&A._checkDelayState()):vo._ImportGeometry(p,A),p.materialUniqueId?A._waitingMaterialId=p.materialUniqueId:p.materialId&&(A._waitingMaterialId=p.materialId),p.morphTargetManagerId>-1&&(A.morphTargetManager=_.getMorphTargetManagerById(p.morphTargetManagerId)),p.skeletonId!==void 0&&p.skeletonId!==null&&(A.skeleton=_.getLastSkeletonById(p.skeletonId),p.numBoneInfluencers&&(A.numBoneInfluencers=p.numBoneInfluencers)),p.animations){for(let $=0;$<p.animations.length;$++){const ne=p.animations[$],xe=a0("BABYLON.Animation");xe&&A.animations.push(xe.Parse(ne))}Ka.ParseAnimationRanges(A,p,_)}if(p.autoAnimate&&_.beginAnimation(A,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1),p.layerMask&&!isNaN(p.layerMask)?A.layerMask=Math.abs(parseInt(p.layerMask)):A.layerMask=268435455,p.physicsImpostor&&Lr._PhysicsImpostorParser(_,A,p),p.lodMeshIds&&(A._waitingData.lods={ids:p.lodMeshIds,distances:p.lodDistances?p.lodDistances:null,coverages:p.lodCoverages?p.lodCoverages:null}),p.instances)for(let $=0;$<p.instances.length;$++){const ne=p.instances[$],xe=A.createInstance(ne.name);if(ne.id&&(xe.id=ne.id),ni&&(ne.tags?ni.AddTagsTo(xe,ne.tags):ni.AddTagsTo(xe,p.tags)),xe.position=nt.FromArray(ne.position),ne.metadata!==void 0&&(xe.metadata=ne.metadata),ne.parentId!==void 0&&(xe._waitingParentId=ne.parentId),ne.parentInstanceIndex!==void 0&&(xe._waitingParentInstanceIndex=ne.parentInstanceIndex),ne.isEnabled!==void 0&&ne.isEnabled!==null&&xe.setEnabled(ne.isEnabled),ne.isVisible!==void 0&&ne.isVisible!==null&&(xe.isVisible=ne.isVisible),ne.isPickable!==void 0&&ne.isPickable!==null&&(xe.isPickable=ne.isPickable),ne.rotationQuaternion?xe.rotationQuaternion=_s.FromArray(ne.rotationQuaternion):ne.rotation&&(xe.rotation=nt.FromArray(ne.rotation)),xe.scaling=nt.FromArray(ne.scaling),ne.checkCollisions!=null&&ne.checkCollisions!=null&&(xe.checkCollisions=ne.checkCollisions),ne.pickable!=null&&ne.pickable!=null&&(xe.isPickable=ne.pickable),ne.showBoundingBox!=null&&ne.showBoundingBox!=null&&(xe.showBoundingBox=ne.showBoundingBox),ne.showSubMeshesBoundingBox!=null&&ne.showSubMeshesBoundingBox!=null&&(xe.showSubMeshesBoundingBox=ne.showSubMeshesBoundingBox),ne.alphaIndex!=null&&ne.showSubMeshesBoundingBox!=null&&(xe.alphaIndex=ne.alphaIndex),ne.physicsImpostor&&Lr._PhysicsImpostorParser(_,xe,ne),ne.actions!==void 0&&(xe._waitingData.actions=ne.actions),ne.animations){for(let ce=0;ce<ne.animations.length;ce++){const Te=ne.animations[ce],Re=a0("BABYLON.Animation");Re&&xe.animations.push(Re.Parse(Te))}Ka.ParseAnimationRanges(xe,ne,_),ne.autoAnimate&&_.beginAnimation(xe,ne.autoAnimateFrom,ne.autoAnimateTo,ne.autoAnimateLoop,ne.autoAnimateSpeed||1)}}if(p.thinInstances){const $=p.thinInstances;if(A.thinInstanceEnablePicking=!!$.enablePicking,$.matrixData?(A.thinInstanceSetBuffer("matrix",new Float32Array($.matrixData),16,!1),A._thinInstanceDataStorage.matrixBufferSize=$.matrixBufferSize,A._thinInstanceDataStorage.instancesCount=$.instancesCount):A._thinInstanceDataStorage.matrixBufferSize=$.matrixBufferSize,p.thinInstances.userThinInstance){const ne=p.thinInstances.userThinInstance;for(const xe in ne.data)A.thinInstanceSetBuffer(xe,new Float32Array(ne.data[xe]),ne.strides[xe],!1),A._userThinInstanceBuffersStorage.sizes[xe]=ne.sizes[xe]}}return A}setPositionsForCPUSkinning(){const p=this._internalMeshDataInfo;if(!p._sourcePositions){const _=this.getVerticesData(ut.PositionKind);if(!_)return p._sourcePositions;p._sourcePositions=new Float32Array(_),this.isVertexBufferUpdatable(ut.PositionKind)||this.setVerticesData(ut.PositionKind,_,!0)}return p._sourcePositions}setNormalsForCPUSkinning(){const p=this._internalMeshDataInfo;if(!p._sourceNormals){const _=this.getVerticesData(ut.NormalKind);if(!_)return p._sourceNormals;p._sourceNormals=new Float32Array(_),this.isVertexBufferUpdatable(ut.NormalKind)||this.setVerticesData(ut.NormalKind,_,!0)}return p._sourceNormals}applySkeleton(p){if(!this.geometry)return this;if(this.geometry._softwareSkinningFrameId==this.getScene().getFrameId())return this;if(this.geometry._softwareSkinningFrameId=this.getScene().getFrameId(),!this.isVerticesDataPresent(ut.PositionKind))return this;if(!this.isVerticesDataPresent(ut.MatricesIndicesKind))return this;if(!this.isVerticesDataPresent(ut.MatricesWeightsKind))return this;const _=this.isVerticesDataPresent(ut.NormalKind),E=this._internalMeshDataInfo;if(!E._sourcePositions){const Nt=this.subMeshes.slice();this.setPositionsForCPUSkinning(),this.subMeshes=Nt}_&&!E._sourceNormals&&this.setNormalsForCPUSkinning();let A=this.getVerticesData(ut.PositionKind);if(!A)return this;A instanceof Float32Array||(A=new Float32Array(A));let $=this.getVerticesData(ut.NormalKind);if(_){if(!$)return this;$ instanceof Float32Array||($=new Float32Array($))}const ne=this.getVerticesData(ut.MatricesIndicesKind),xe=this.getVerticesData(ut.MatricesWeightsKind);if(!xe||!ne)return this;const ce=this.numBoneInfluencers>4,Te=ce?this.getVerticesData(ut.MatricesIndicesExtraKind):null,Re=ce?this.getVerticesData(ut.MatricesWeightsExtraKind):null,ke=p.getTransformMatrices(this),We=nt.Zero(),Xe=new Yt,xt=new Yt;let qe=0,ht;for(let Nt=0;Nt<A.length;Nt+=3,qe+=4){let wt;for(ht=0;ht<4;ht++)wt=xe[qe+ht],wt>0&&(Yt.FromFloat32ArrayToRefScaled(ke,Math.floor(ne[qe+ht]*16),wt,xt),Xe.addToSelf(xt));if(ce)for(ht=0;ht<4;ht++)wt=Re[qe+ht],wt>0&&(Yt.FromFloat32ArrayToRefScaled(ke,Math.floor(Te[qe+ht]*16),wt,xt),Xe.addToSelf(xt));nt.TransformCoordinatesFromFloatsToRef(E._sourcePositions[Nt],E._sourcePositions[Nt+1],E._sourcePositions[Nt+2],Xe,We),We.toArray(A,Nt),_&&(nt.TransformNormalFromFloatsToRef(E._sourceNormals[Nt],E._sourceNormals[Nt+1],E._sourceNormals[Nt+2],Xe,We),We.toArray($,Nt)),Xe.reset()}return this.updateVerticesData(ut.PositionKind,A),_&&this.updateVerticesData(ut.NormalKind,$),this}static MinMax(p){let _=null,E=null;return p.forEach(function(A){const ne=A.getBoundingInfo().boundingBox;!_||!E?(_=ne.minimumWorld,E=ne.maximumWorld):(_.minimizeInPlace(ne.minimumWorld),E.maximizeInPlace(ne.maximumWorld))}),!_||!E?{min:nt.Zero(),max:nt.Zero()}:{min:_,max:E}}static Center(p){const _=p instanceof Array?Lr.MinMax(p):p;return nt.Center(_.min,_.max)}static MergeMeshes(p,_=!0,E,A,$,ne){return d_(Lr._MergeMeshesCoroutine(p,_,E,A,$,ne,!1))}static MergeMeshesAsync(p,_=!0,E,A,$,ne){return hE(Lr._MergeMeshesCoroutine(p,_,E,A,$,ne,!0),Lw())}static*_MergeMeshesCoroutine(p,_=!0,E,A,$,ne,xe){if(p=p.filter(Boolean),p.length===0)return null;let ce;if(!E){let xi=0;for(ce=0;ce<p.length;ce++)if(xi+=p[ce].getTotalVertices(),xi>=65536)return vi.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"),null}ne&&($=!1);const Te=new Array,Re=new Array,ke=new Array,We=p[0].overrideMaterialSideOrientation;for(ce=0;ce<p.length;ce++){const xi=p[ce];if(xi.isAnInstance)return vi.Warn("Cannot merge instance meshes."),null;if(We!==xi.overrideMaterialSideOrientation)return vi.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."),null;if($&&ke.push(xi.getTotalIndices()),ne)if(xi.material){const wi=xi.material;if(wi instanceof $u){for(let vs=0;vs<wi.subMaterials.length;vs++)Te.indexOf(wi.subMaterials[vs])<0&&Te.push(wi.subMaterials[vs]);for(let vs=0;vs<xi.subMeshes.length;vs++)Re.push(Te.indexOf(wi.subMaterials[xi.subMeshes[vs].materialIndex])),ke.push(xi.subMeshes[vs].indexCount)}else{Te.indexOf(wi)<0&&Te.push(wi);for(let vs=0;vs<xi.subMeshes.length;vs++)Re.push(Te.indexOf(wi)),ke.push(xi.subMeshes[vs].indexCount)}}else for(let wi=0;wi<xi.subMeshes.length;wi++)Re.push(0),ke.push(xi.subMeshes[wi].indexCount)}const Xe=p[0],xt=xi=>{const wi=xi.computeWorldMatrix(!0);return{vertexData:Yr.ExtractFromMesh(xi,!1,!1),transform:wi}},{vertexData:qe,transform:ht}=xt(Xe);xe&&(yield);const Nt=new Array(p.length-1);for(let xi=1;xi<p.length;xi++)Nt[xi-1]=xt(p[xi]),xe&&(yield);const wt=qe._mergeCoroutine(ht,Nt,E,xe,!_);let Qt=wt.next();for(;!Qt.done;)xe&&(yield),Qt=wt.next();const Ht=Qt.value;A||(A=new Lr(Xe.name+"_merged",Xe.getScene()));const Wt=Ht._applyToCoroutine(A,void 0,xe);let zt=Wt.next();for(;!zt.done;)xe&&(yield),zt=Wt.next();if(A.checkCollisions=Xe.checkCollisions,A.overrideMaterialSideOrientation=Xe.overrideMaterialSideOrientation,_)for(ce=0;ce<p.length;ce++)p[ce].dispose();if($||ne){A.releaseSubMeshes(),ce=0;let xi=0;for(;ce<ke.length;)_l.CreateFromIndices(0,xi,ke[ce],A,void 0,!1),xi+=ke[ce],ce++;for(const wi of A.subMeshes)wi.refreshBoundingInfo();A.computeWorldMatrix(!0)}if(ne){const xi=new $u(Xe.name+"_merged",Xe.getScene());xi.subMaterials=Te;for(let wi=0;wi<A.subMeshes.length;wi++)A.subMeshes[wi].materialIndex=Re[wi];A.material=xi}else A.material=Xe.material;return A}addInstance(p){p._indexInSourceMeshInstanceArray=this.instances.length,this.instances.push(p)}removeInstance(p){const _=p._indexInSourceMeshInstanceArray;if(_!=-1){if(_!==this.instances.length-1){const E=this.instances[this.instances.length-1];this.instances[_]=E,E._indexInSourceMeshInstanceArray=_}p._indexInSourceMeshInstanceArray=-1,this.instances.pop()}}_shouldConvertRHS(){return this.overrideMaterialSideOrientation===Xi.CounterClockWiseSideOrientation}_getRenderingFillMode(p){const _=this.getScene();return _.forcePointsCloud?Xi.PointFillMode:_.forceWireframe?Xi.WireFrameFillMode:this.overrideRenderingFillMode??p}setMaterialByID(p){return this.setMaterialById(p)}static CreateRibbon(p,_,E,A,$,ne,xe,ce,Te){throw new Error("Import MeshBuilder to populate this function")}static CreateDisc(p,_,E,A,$,ne){throw new Error("Import MeshBuilder to populate this function")}static CreateBox(p,_,E,A,$){throw new Error("Import MeshBuilder to populate this function")}static CreateSphere(p,_,E,A,$,ne){throw new Error("Import MeshBuilder to populate this function")}static CreateHemisphere(p,_,E,A){throw new Error("Import MeshBuilder to populate this function")}static CreateCylinder(p,_,E,A,$,ne,xe,ce,Te){throw new Error("Import MeshBuilder to populate this function")}static CreateTorus(p,_,E,A,$,ne,xe){throw new Error("Import MeshBuilder to populate this function")}static CreateTorusKnot(p,_,E,A,$,ne,xe,ce,Te,Re){throw new Error("Import MeshBuilder to populate this function")}static CreateLines(p,_,E,A,$){throw new Error("Import MeshBuilder to populate this function")}static CreateDashedLines(p,_,E,A,$,ne,xe,ce){throw new Error("Import MeshBuilder to populate this function")}static CreatePolygon(p,_,E,A,$,ne,xe){throw new Error("Import MeshBuilder to populate this function")}static ExtrudePolygon(p,_,E,A,$,ne,xe,ce){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShape(p,_,E,A,$,ne,xe,ce,Te,Re){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShapeCustom(p,_,E,A,$,ne,xe,ce,Te,Re,ke,We){throw new Error("Import MeshBuilder to populate this function")}static CreateLathe(p,_,E,A,$,ne,xe){throw new Error("Import MeshBuilder to populate this function")}static CreatePlane(p,_,E,A,$){throw new Error("Import MeshBuilder to populate this function")}static CreateGround(p,_,E,A,$,ne){throw new Error("Import MeshBuilder to populate this function")}static CreateTiledGround(p,_,E,A,$,ne,xe,ce,Te){throw new Error("Import MeshBuilder to populate this function")}static CreateGroundFromHeightMap(p,_,E,A,$,ne,xe,ce,Te,Re,ke){throw new Error("Import MeshBuilder to populate this function")}static CreateTube(p,_,E,A,$,ne,xe,ce,Te,Re){throw new Error("Import MeshBuilder to populate this function")}static CreatePolyhedron(p,_,E){throw new Error("Import MeshBuilder to populate this function")}static CreateIcoSphere(p,_,E){throw new Error("Import MeshBuilder to populate this function")}static CreateDecal(p,_,E,A,$,ne){throw new Error("Import MeshBuilder to populate this function")}static CreateCapsule(p,_,E){throw new Error("Import MeshBuilder to populate this function")}static ExtendToGoldberg(p){throw new Error("Import MeshBuilder to populate this function")}}Lr.FRONTSIDE=Yr.FRONTSIDE,Lr.BACKSIDE=Yr.BACKSIDE,Lr.DOUBLESIDE=Yr.DOUBLESIDE,Lr.DEFAULTSIDE=Yr.DEFAULTSIDE,Lr.NO_CAP=0,Lr.CAP_START=1,Lr.CAP_END=2,Lr.CAP_ALL=3,Lr.NO_FLIP=0,Lr.FLIP_TILE=1,Lr.ROTATE_TILE=2,Lr.FLIP_ROW=3,Lr.ROTATE_ROW=4,Lr.FLIP_N_ROTATE_TILE=5,Lr.FLIP_N_ROTATE_ROW=6,Lr.CENTER=0,Lr.LEFT=1,Lr.RIGHT=2,Lr.TOP=3,Lr.BOTTOM=4,Lr.INSTANCEDMESH_SORT_TRANSPARENT=!1,Lr._GroundMeshParser=(_e,p)=>{throw Tr("GroundMesh")},Lr._GoldbergMeshParser=(_e,p)=>{throw Tr("GoldbergMesh")},Lr._LinesMeshParser=(_e,p)=>{throw Tr("LinesMesh")},Lr._GreasedLineMeshParser=(_e,p)=>{throw Tr("GreasedLineMesh")},Lr._GreasedLineRibbonMeshParser=(_e,p)=>{throw Tr("GreasedLineRibbonMesh")},Lr._TrailMeshParser=(_e,p)=>{throw Tr("TrailMesh")},zs("BABYLON.Mesh",Lr);class lu{get influence(){return this._influence}set influence(p){if(this._influence===p)return;const _=this._influence;this._influence=p,this.onInfluenceChanged.hasObservers()&&this.onInfluenceChanged.notifyObservers(_===0||p===0)}get animationPropertiesOverride(){return!this._animationPropertiesOverride&&this._scene?this._scene.animationPropertiesOverride:this._animationPropertiesOverride}set animationPropertiesOverride(p){this._animationPropertiesOverride=p}constructor(p,_=0,E=null){this.name=p,this.animations=[],this._positions=null,this._normals=null,this._tangents=null,this._uvs=null,this._uniqueId=0,this.onInfluenceChanged=new Mi,this._onDataLayoutChanged=new Mi,this._animationPropertiesOverride=null,this._scene=E||wr.LastCreatedScene,this.influence=_,this._scene&&(this._uniqueId=this._scene.getUniqueId())}get uniqueId(){return this._uniqueId}get hasPositions(){return!!this._positions}get hasNormals(){return!!this._normals}get hasTangents(){return!!this._tangents}get hasUVs(){return!!this._uvs}setPositions(p){const _=this.hasPositions;this._positions=p,_!==this.hasPositions&&this._onDataLayoutChanged.notifyObservers(void 0)}getPositions(){return this._positions}setNormals(p){const _=this.hasNormals;this._normals=p,_!==this.hasNormals&&this._onDataLayoutChanged.notifyObservers(void 0)}getNormals(){return this._normals}setTangents(p){const _=this.hasTangents;this._tangents=p,_!==this.hasTangents&&this._onDataLayoutChanged.notifyObservers(void 0)}getTangents(){return this._tangents}setUVs(p){const _=this.hasUVs;this._uvs=p,_!==this.hasUVs&&this._onDataLayoutChanged.notifyObservers(void 0)}getUVs(){return this._uvs}clone(){const p=Xr.Clone(()=>new lu(this.name,this.influence,this._scene),this);return p._positions=this._positions,p._normals=this._normals,p._tangents=this._tangents,p._uvs=this._uvs,p}serialize(){const p={};return p.name=this.name,p.influence=this.influence,p.positions=Array.prototype.slice.call(this.getPositions()),this.id!=null&&(p.id=this.id),this.hasNormals&&(p.normals=Array.prototype.slice.call(this.getNormals())),this.hasTangents&&(p.tangents=Array.prototype.slice.call(this.getTangents())),this.hasUVs&&(p.uvs=Array.prototype.slice.call(this.getUVs())),Xr.AppendSerializedAnimations(this,p),p}getClassName(){return"MorphTarget"}static Parse(p,_){const E=new lu(p.name,p.influence);if(E.setPositions(p.positions),p.id!=null&&(E.id=p.id),p.normals&&E.setNormals(p.normals),p.tangents&&E.setTangents(p.tangents),p.uvs&&E.setUVs(p.uvs),p.animations){for(let A=0;A<p.animations.length;A++){const $=p.animations[A],ne=a0("BABYLON.Animation");ne&&E.animations.push(ne.Parse($))}p.autoAnimate&&_&&_.beginAnimation(E,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1)}return E}static FromMesh(p,_,E){_||(_=p.name);const A=new lu(_,E,p.getScene());return A.setPositions(p.getVerticesData(ut.PositionKind)),p.isVerticesDataPresent(ut.NormalKind)&&A.setNormals(p.getVerticesData(ut.NormalKind)),p.isVerticesDataPresent(ut.TangentKind)&&A.setTangents(p.getVerticesData(ut.TangentKind)),p.isVerticesDataPresent(ut.UVKind)&&A.setUVs(p.getVerticesData(ut.UVKind)),A}}Mt([Gt()],lu.prototype,"id",void 0);class R_ extends Hi{get depth(){return this._depth}constructor(p,_,E,A,$,ne,xe=!0,ce=!1,Te=Hi.TRILINEAR_SAMPLINGMODE,Re=0,ke){super(null,ne,!xe,ce),this.format=$,this._texture=ne.getEngine().createRawTexture2DArray(p,_,E,A,$,xe,ce,Te,null,Re,ke),this._depth=A,this.is2DArray=!0}update(p){this._texture&&this._getEngine().updateRawTexture2DArray(this._texture,p,this._texture.format,this._texture.invertY,null,this._texture.type)}static CreateRGBATexture(p,_,E,A,$,ne=!0,xe=!1,ce=3,Te=0){return new R_(p,_,E,A,5,$,ne,xe,ce,Te)}}class cc{set areUpdatesFrozen(p){p?this._blockCounter++:(this._blockCounter--,this._blockCounter<=0&&(this._blockCounter=0,this._syncActiveTargets(!0)))}get areUpdatesFrozen(){return this._blockCounter>0}constructor(p=null){if(this._targets=new Array,this._targetInfluenceChangedObservers=new Array,this._targetDataLayoutChangedObservers=new Array,this._activeTargets=new _t(16),this._supportsNormals=!1,this._supportsTangents=!1,this._supportsUVs=!1,this._vertexCount=0,this._textureVertexStride=0,this._textureWidth=0,this._textureHeight=1,this._uniqueId=0,this._tempInfluences=new Array,this._canUseTextureForTargets=!1,this._blockCounter=0,this._parentContainer=null,this.optimizeInfluencers=!0,this.enableNormalMorphing=!0,this.enableTangentMorphing=!0,this.enableUVMorphing=!0,this._numMaxInfluencers=0,this._useTextureToStoreTargets=!0,p||(p=wr.LastCreatedScene),this._scene=p,this._scene){this._scene.addMorphTargetManager(this),this._uniqueId=this._scene.getUniqueId();const _=this._scene.getEngine().getCaps();this._canUseTextureForTargets=_.canUseGLVertexID&&_.textureFloat&&_.maxVertexTextureImageUnits>0&&_.texture2DArrayMaxLayerCount>1}}get numMaxInfluencers(){return this._numMaxInfluencers}set numMaxInfluencers(p){this._numMaxInfluencers!==p&&(this._numMaxInfluencers=p,this._syncActiveTargets(!0))}get uniqueId(){return this._uniqueId}get vertexCount(){return this._vertexCount}get supportsNormals(){return this._supportsNormals&&this.enableNormalMorphing}get supportsTangents(){return this._supportsTangents&&this.enableTangentMorphing}get supportsUVs(){return this._supportsUVs&&this.enableUVMorphing}get numTargets(){return this._targets.length}get numInfluencers(){return this._activeTargets.length}get influences(){return this._influences}get useTextureToStoreTargets(){return this._useTextureToStoreTargets}set useTextureToStoreTargets(p){this._useTextureToStoreTargets=p}get isUsingTextureForTargets(){return cc.EnableTextureStorage&&this.useTextureToStoreTargets&&this._canUseTextureForTargets&&!this._scene?.getEngine().getCaps().disableMorphTargetTexture}getActiveTarget(p){return this._activeTargets.data[p]}getTarget(p){return this._targets[p]}addTarget(p){this._targets.push(p),this._targetInfluenceChangedObservers.push(p.onInfluenceChanged.add(_=>{this._syncActiveTargets(_)})),this._targetDataLayoutChangedObservers.push(p._onDataLayoutChanged.add(()=>{this._syncActiveTargets(!0)})),this._syncActiveTargets(!0)}removeTarget(p){const _=this._targets.indexOf(p);_>=0&&(this._targets.splice(_,1),p.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(_,1)[0]),p._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(_,1)[0]),this._syncActiveTargets(!0)),this._scene&&this._scene.stopAnimation(p)}_bind(p){p.setFloat3("morphTargetTextureInfo",this._textureVertexStride,this._textureWidth,this._textureHeight),p.setFloatArray("morphTargetTextureIndices",this._morphTargetTextureIndices),p.setTexture("morphTargets",this._targetStoreTexture),p.setInt("morphTargetCount",this.numInfluencers)}clone(){const p=new cc(this._scene);for(const _ of this._targets)p.addTarget(_.clone());return p.enableNormalMorphing=this.enableNormalMorphing,p.enableTangentMorphing=this.enableTangentMorphing,p.enableUVMorphing=this.enableUVMorphing,p}serialize(){const p={};p.id=this.uniqueId,p.targets=[];for(const _ of this._targets)p.targets.push(_.serialize());return p}_syncActiveTargets(p){if(this.areUpdatesFrozen)return;let _=0;this._activeTargets.reset(),this._supportsNormals=!0,this._supportsTangents=!0,this._supportsUVs=!0,this._vertexCount=0,this._scene&&this._targets.length>this._scene.getEngine().getCaps().texture2DArrayMaxLayerCount&&(this.useTextureToStoreTargets=!1),(!this._morphTargetTextureIndices||this._morphTargetTextureIndices.length!==this._targets.length)&&(this._morphTargetTextureIndices=new Float32Array(this._targets.length));let E=-1;for(const A of this._targets){if(E++,A.influence===0&&this.optimizeInfluencers)continue;if(this._activeTargets.length>=cc.MaxActiveMorphTargetsInVertexAttributeMode&&!this.isUsingTextureForTargets)break;this._activeTargets.push(A),this._morphTargetTextureIndices[_]=E,this._tempInfluences[_++]=A.influence,this._supportsNormals=this._supportsNormals&&A.hasNormals,this._supportsTangents=this._supportsTangents&&A.hasTangents,this._supportsUVs=this._supportsUVs&&A.hasUVs;const $=A.getPositions();if($){const ne=$.length/3;if(this._vertexCount===0)this._vertexCount=ne;else if(this._vertexCount!==ne){vi.Error("Incompatible target. Targets must all have the same vertices count.");return}}}this._morphTargetTextureIndices.length!==_&&(this._morphTargetTextureIndices=this._morphTargetTextureIndices.slice(0,_)),(!this._influences||this._influences.length!==_)&&(this._influences=new Float32Array(_));for(let A=0;A<_;A++)this._influences[A]=this._tempInfluences[A];p&&this.synchronize()}synchronize(){if(!(!this._scene||this.areUpdatesFrozen)){if(this.isUsingTextureForTargets&&(this._vertexCount||this.numMaxInfluencers>0)){this._textureVertexStride=1,this._supportsNormals&&this._textureVertexStride++,this._supportsTangents&&this._textureVertexStride++,this._supportsUVs&&this._textureVertexStride++,this._textureWidth=this._vertexCount*this._textureVertexStride||1,this._textureHeight=1;const p=this._scene.getEngine().getCaps().maxTextureSize;this._textureWidth>p&&(this._textureHeight=Math.ceil(this._textureWidth/p),this._textureWidth=p);let _=!0;if(this._targetStoreTexture){const E=this._targetStoreTexture.getSize();E.width===this._textureWidth&&E.height===this._textureHeight&&this._targetStoreTexture.depth===this._targets.length&&(_=!1)}if(_){this._targetStoreTexture&&this._targetStoreTexture.dispose();const E=this._targets.length,A=new Float32Array(E*this._textureWidth*this._textureHeight*4);let $=0;for(let ne=0;ne<E;ne++){const xe=this._targets[ne],ce=xe.getPositions(),Te=xe.getNormals(),Re=xe.getUVs(),ke=xe.getTangents();if(!ce){ne===0&&vi.Error("Invalid morph target. Target must have positions.");return}$=ne*this._textureWidth*this._textureHeight*4;for(let We=0;We<this._vertexCount;We++)A[$]=ce[We*3],A[$+1]=ce[We*3+1],A[$+2]=ce[We*3+2],$+=4,this._supportsNormals&&Te&&(A[$]=Te[We*3],A[$+1]=Te[We*3+1],A[$+2]=Te[We*3+2],$+=4),this._supportsUVs&&Re&&(A[$]=Re[We*2],A[$+1]=Re[We*2+1],$+=4),this._supportsTangents&&ke&&(A[$]=ke[We*3],A[$+1]=ke[We*3+1],A[$+2]=ke[We*3+2],$+=4)}this._targetStoreTexture=R_.CreateRGBATexture(A,this._textureWidth,this._textureHeight,E,this._scene,!1,!1,1,1)}}for(const p of this._scene.meshes)p.morphTargetManager===this&&p._syncGeometryWithMorphTargetManager()}}dispose(){if(this._targetStoreTexture&&this._targetStoreTexture.dispose(),this._targetStoreTexture=null,this._scene){if(this._scene.removeMorphTargetManager(this),this._parentContainer){const p=this._parentContainer.morphTargetManagers.indexOf(this);p>-1&&this._parentContainer.morphTargetManagers.splice(p,1),this._parentContainer=null}for(const p of this._targets)this._scene.stopAnimation(p)}}static Parse(p,_){const E=new cc(_);E._uniqueId=p.id;for(const A of p.targets)E.addTarget(lu.Parse(A,_));return E}}cc.EnableTextureStorage=!0,cc.MaxActiveMorphTargetsInVertexAttributeMode=8,Lr._instancedMeshFactory=(_e,p)=>{const _=new xO(_e,p);if(p.instancedBuffers){_.instancedBuffers={};for(const E in p.instancedBuffers)_.instancedBuffers[E]=p.instancedBuffers[E]}return _};class xO extends zo{constructor(p,_){super(p,_.getScene()),this._indexInSourceMeshInstanceArray=-1,this._distanceToCamera=0,_.addInstance(this),this._sourceMesh=_,this._unIndexed=_._unIndexed,this.position.copyFrom(_.position),this.rotation.copyFrom(_.rotation),this.scaling.copyFrom(_.scaling),_.rotationQuaternion&&(this.rotationQuaternion=_.rotationQuaternion.clone()),this.animations=_.animations.slice();for(const E of _.getAnimationRanges())E!=null&&this.createAnimationRange(E.name,E.from,E.to);this.infiniteDistance=_.infiniteDistance,this.setPivotMatrix(_.getPivotMatrix()),this.refreshBoundingInfo(!0,!0),this._syncSubMeshes()}getClassName(){return"InstancedMesh"}get lightSources(){return this._sourceMesh._lightSources}_resyncLightSources(){}_resyncLightSource(){}_removeLightSource(){}get receiveShadows(){return this._sourceMesh.receiveShadows}set receiveShadows(p){this._sourceMesh?.receiveShadows!==p&&ct.Warn("Setting receiveShadows on an instanced mesh has no effect")}get material(){return this._sourceMesh.material}set material(p){this._sourceMesh?.material!==p&&ct.Warn("Setting material on an instanced mesh has no effect")}get visibility(){return this._sourceMesh.visibility}set visibility(p){this._sourceMesh?.visibility!==p&&ct.Warn("Setting visibility on an instanced mesh has no effect")}get skeleton(){return this._sourceMesh.skeleton}set skeleton(p){this._sourceMesh?.skeleton!==p&&ct.Warn("Setting skeleton on an instanced mesh has no effect")}get renderingGroupId(){return this._sourceMesh.renderingGroupId}set renderingGroupId(p){!this._sourceMesh||p===this._sourceMesh.renderingGroupId||vi.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")}getTotalVertices(){return this._sourceMesh?this._sourceMesh.getTotalVertices():0}getTotalIndices(){return this._sourceMesh.getTotalIndices()}get sourceMesh(){return this._sourceMesh}createInstance(p){return this._sourceMesh.createInstance(p)}isReady(p=!1){return this._sourceMesh.isReady(p,!0)}getVerticesData(p,_,E){return this._sourceMesh.getVerticesData(p,_,E)}setVerticesData(p,_,E,A){return this.sourceMesh&&this.sourceMesh.setVerticesData(p,_,E,A),this.sourceMesh}updateVerticesData(p,_,E,A){return this.sourceMesh&&this.sourceMesh.updateVerticesData(p,_,E,A),this.sourceMesh}setIndices(p,_=null){return this.sourceMesh&&this.sourceMesh.setIndices(p,_),this.sourceMesh}isVerticesDataPresent(p){return this._sourceMesh.isVerticesDataPresent(p)}getIndices(){return this._sourceMesh.getIndices()}get _positions(){return this._sourceMesh._positions}refreshBoundingInfo(p=!1,_=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const E=this._sourceMesh.geometry?this._sourceMesh.geometry.boundingBias:null;return this._refreshBoundingInfo(this._sourceMesh._getPositionData(p,_),E),this}_preActivate(){return this._currentLOD&&this._currentLOD._preActivate(),this}_activate(p,_){if(super._activate(p,_),this._sourceMesh.subMeshes||vi.Warn("Instances should only be created for meshes with geometry."),this._currentLOD){if(this._currentLOD._getWorldMatrixDeterminant()>=0!=this._getWorldMatrixDeterminant()>=0)return this._internalAbstractMeshDataInfo._actAsRegularMesh=!0,!0;if(this._internalAbstractMeshDataInfo._actAsRegularMesh=!1,this._currentLOD._registerInstanceForRenderId(this,p),_){if(!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!0,!0}else if(!this._currentLOD._internalAbstractMeshDataInfo._isActive)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances=!0,!0}return!1}_postActivate(){this._sourceMesh.edgesShareWithInstances&&this._sourceMesh._edgesRenderer&&this._sourceMesh._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup?(this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())):this._edgesRenderer&&this._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup&&this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)}getWorldMatrix(){if(this._currentLOD&&this._currentLOD.billboardMode!==zr.BILLBOARDMODE_NONE&&this._currentLOD._masterMesh!==this){this._billboardWorldMatrix||(this._billboardWorldMatrix=new Yt);const p=this._currentLOD._masterMesh;return this._currentLOD._masterMesh=this,pi.Vector3[7].copyFrom(this._currentLOD.position),this._currentLOD.position.set(0,0,0),this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),this._currentLOD.position.copyFrom(pi.Vector3[7]),this._currentLOD._masterMesh=p,this._billboardWorldMatrix}return super.getWorldMatrix()}get isAnInstance(){return!0}getLOD(p){if(!p)return this;const _=this.sourceMesh.getLODLevels();if(!_||_.length===0)this._currentLOD=this.sourceMesh;else{const E=this.getBoundingInfo();this._currentLOD=this.sourceMesh.getLOD(p,E.boundingSphere)}return this._currentLOD}_preActivateForIntermediateRendering(p){return this.sourceMesh._preActivateForIntermediateRendering(p)}_syncSubMeshes(){if(this.releaseSubMeshes(),this._sourceMesh.subMeshes)for(let p=0;p<this._sourceMesh.subMeshes.length;p++)this._sourceMesh.subMeshes[p].clone(this,this._sourceMesh);return this}_generatePointsArray(){return this._sourceMesh._generatePointsArray()}_updateBoundingInfo(){return this.hasBoundingInfo?this.getBoundingInfo().update(this.worldMatrixFromCache):this.buildBoundingInfo(this.absolutePosition,this.absolutePosition,this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}clone(p,_=null,E,A){const $=(A||this._sourceMesh).createInstance(p);if(al.DeepCopy(this,$,["name","subMeshes","uniqueId","parent","lightSources","receiveShadows","material","visibility","skeleton","sourceMesh","isAnInstance","facetNb","isFacetDataEnabled","isBlocked","useBones","hasInstances","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","hasBoundingInfo"],[]),this.refreshBoundingInfo(),_&&($.parent=_),!E)for(let ne=0;ne<this.getScene().meshes.length;ne++){const xe=this.getScene().meshes[ne];xe.parent===this&&xe.clone(xe.name,$)}return $.computeWorldMatrix(!0),this.onClonedObservable.notifyObservers($),$}dispose(p,_=!1){this._sourceMesh.removeInstance(this),super.dispose(p,_)}_serializeAsParent(p){super._serializeAsParent(p),p.parentId=this._sourceMesh.uniqueId,p.parentInstanceIndex=this._indexInSourceMeshInstanceArray}instantiateHierarchy(p=null,_,E){const A=this.clone("Clone of "+(this.name||this.id),p||this.parent,!0,_&&_.newSourcedMesh);A&&E&&E(this,A);for(const $ of this.getChildTransformNodes(!0))$.instantiateHierarchy(A,_,E);return A}}Lr.prototype.registerInstancedBuffer=function(_e,p){if(this._userInstancedBuffersStorage?.vertexBuffers[_e]?.dispose(),!this.instancedBuffers){this.instancedBuffers={};for(const _ of this.instances)_.instancedBuffers={}}this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this.instancedBuffers[_e]=null,this._userInstancedBuffersStorage.strides[_e]=p,this._userInstancedBuffersStorage.sizes[_e]=p*32,this._userInstancedBuffersStorage.data[_e]=new Float32Array(this._userInstancedBuffersStorage.sizes[_e]),this._userInstancedBuffersStorage.vertexBuffers[_e]=new ut(this.getEngine(),this._userInstancedBuffersStorage.data[_e],_e,!0,!1,p,!0);for(const _ of this.instances)_.instancedBuffers[_e]=null;this._invalidateInstanceVertexArrayObject(),this._markSubMeshesAsAttributesDirty()},Lr.prototype._processInstancedBuffers=function(_e,p){const _=_e?_e.length:0;for(const E in this.instancedBuffers){let A=this._userInstancedBuffersStorage.sizes[E];const $=this._userInstancedBuffersStorage.strides[E],ne=(_+1)*$;for(;A<ne;)A*=2;this._userInstancedBuffersStorage.data[E].length!=A&&(this._userInstancedBuffersStorage.data[E]=new Float32Array(A),this._userInstancedBuffersStorage.sizes[E]=A,this._userInstancedBuffersStorage.vertexBuffers[E]&&(this._userInstancedBuffersStorage.vertexBuffers[E].dispose(),this._userInstancedBuffersStorage.vertexBuffers[E]=null));const xe=this._userInstancedBuffersStorage.data[E];let ce=0;if(p){const Te=this.instancedBuffers[E];Te.toArray?Te.toArray(xe,ce):Te.copyToArray?Te.copyToArray(xe,ce):xe[ce]=Te,ce+=$}for(let Te=0;Te<_;Te++){const ke=_e[Te].instancedBuffers[E];ke.toArray?ke.toArray(xe,ce):ke.copyToArray?ke.copyToArray(xe,ce):xe[ce]=ke,ce+=$}this._userInstancedBuffersStorage.vertexBuffers[E]?this._userInstancedBuffersStorage.vertexBuffers[E].updateDirectly(xe,0):(this._userInstancedBuffersStorage.vertexBuffers[E]=new ut(this.getEngine(),this._userInstancedBuffersStorage.data[E],E,!0,!1,$,!0),this._invalidateInstanceVertexArrayObject())}},Lr.prototype._invalidateInstanceVertexArrayObject=function(){if(!(!this._userInstancedBuffersStorage||this._userInstancedBuffersStorage.vertexArrayObjects===void 0)){for(const _e in this._userInstancedBuffersStorage.vertexArrayObjects)this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[_e]);this._userInstancedBuffersStorage.vertexArrayObjects={}}},Lr.prototype._disposeInstanceSpecificData=function(){for(this._instanceDataStorage.instancesBuffer&&(this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null);this.instances.length;)this.instances[0].dispose();for(const _e in this.instancedBuffers)this._userInstancedBuffersStorage.vertexBuffers[_e]&&this._userInstancedBuffersStorage.vertexBuffers[_e].dispose();this._invalidateInstanceVertexArrayObject(),this.instancedBuffers={}};class zL extends Mx{}class WL{constructor(){this.rootNodes=[],this.skeletons=[],this.animationGroups=[]}dispose(){this.rootNodes.slice(0).forEach(p=>{p.dispose()}),this.rootNodes.length=0,this.skeletons.slice(0).forEach(p=>{p.dispose()}),this.skeletons.length=0,this.animationGroups.slice(0).forEach(p=>{p.dispose()}),this.animationGroups.length=0}}class HL extends Mx{constructor(p){super(),this._wasAddedToScene=!1,p=p||wr.LastCreatedScene,p&&(this.scene=p,this.sounds=[],this.effectLayers=[],this.layers=[],this.lensFlareSystems=[],this.proceduralTextures=[],this.reflectionProbes=[],p.onDisposeObservable.add(()=>{this._wasAddedToScene||this.dispose()}),this._onContextRestoredObserver=p.getEngine().onContextRestoredObservable.add(()=>{for(const _ of this.geometries)_._rebuild();for(const _ of this.meshes)_._rebuild();for(const _ of this.particleSystems)_.rebuild();for(const _ of this.textures)_._rebuild()}))}_topologicalSort(p){const _=new Map;for(const xe of p)_.set(xe.uniqueId,xe);const E={dependsOn:new Map,dependedBy:new Map};for(const xe of p){const ce=xe.uniqueId;E.dependsOn.set(ce,new Set),E.dependedBy.set(ce,new Set)}for(const xe of p){const ce=xe.uniqueId,Te=E.dependsOn.get(ce);if(xe instanceof xO){const ke=xe.sourceMesh;_.has(ke.uniqueId)&&(Te.add(ke.uniqueId),E.dependedBy.get(ke.uniqueId).add(ce))}const Re=E.dependedBy.get(ce);for(const ke of xe.getDescendants()){const We=ke.uniqueId;_.has(We)&&(Re.add(We),E.dependsOn.get(We).add(ce))}}const A=[],$=[];for(const xe of p){const ce=xe.uniqueId;E.dependsOn.get(ce).size===0&&($.push(xe),_.delete(ce))}const ne=$;for(;ne.length>0;){const xe=ne.shift();A.push(xe);const ce=E.dependedBy.get(xe.uniqueId);for(const Te of Array.from(ce.values())){const Re=E.dependsOn.get(Te);Re.delete(xe.uniqueId),Re.size===0&&_.get(Te)&&(ne.push(_.get(Te)),_.delete(Te))}}return _.size>0&&(vi.Error("SceneSerializer._topologicalSort: There were unvisited nodes:"),_.forEach(xe=>vi.Error(xe.name))),A}_addNodeAndDescendantsToList(p,_,E,A){if(!(!E||A&&!A(E)||_.has(E.uniqueId))){p.push(E),_.add(E.uniqueId);for(const $ of E.getDescendants(!0))this._addNodeAndDescendantsToList(p,_,$,A)}}_isNodeInContainer(p){return p instanceof Lr&&this.meshes.indexOf(p)!==-1||p instanceof zr&&this.transformNodes.indexOf(p)!==-1||p instanceof vn&&this.lights.indexOf(p)!==-1||p instanceof Hr&&this.cameras.indexOf(p)!==-1}_isValidHierarchy(){for(const p of this.meshes)if(p.parent&&!this._isNodeInContainer(p.parent))return vi.Warn(`Node ${p.name} has a parent that is not in the container.`),!1;for(const p of this.transformNodes)if(p.parent&&!this._isNodeInContainer(p.parent))return vi.Warn(`Node ${p.name} has a parent that is not in the container.`),!1;for(const p of this.lights)if(p.parent&&!this._isNodeInContainer(p.parent))return vi.Warn(`Node ${p.name} has a parent that is not in the container.`),!1;for(const p of this.cameras)if(p.parent&&!this._isNodeInContainer(p.parent))return vi.Warn(`Node ${p.name} has a parent that is not in the container.`),!1;return!0}instantiateModelsToScene(p,_=!1,E){this._isValidHierarchy()||ct.Warn("SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.");const A={},$={},ne=new WL,xe=[],ce=[],Te={doNotInstantiate:!0,...E},Re=(qe,ht)=>{if(A[qe.uniqueId]=ht.uniqueId,$[ht.uniqueId]=ht,p&&(ht.name=p(qe.name)),ht instanceof Lr){const Nt=ht;if(Nt.morphTargetManager){const wt=qe.morphTargetManager;Nt.morphTargetManager=wt.clone();for(let Qt=0;Qt<wt.numTargets;Qt++){const Ht=wt.getTarget(Qt),Wt=Nt.morphTargetManager.getTarget(Qt);A[Ht.uniqueId]=Wt.uniqueId,$[Wt.uniqueId]=Wt}}}},ke=[],We=new Set;for(const qe of this.transformNodes)qe.parent===null&&this._addNodeAndDescendantsToList(ke,We,qe,Te.predicate);for(const qe of this.meshes)qe.parent===null&&this._addNodeAndDescendantsToList(ke,We,qe,Te.predicate);const Xe=this._topologicalSort(ke),xt=(qe,ht)=>{if(Re(qe,ht),qe.parent){const Nt=A[qe.parent.uniqueId],wt=$[Nt];wt?ht.parent=wt:ht.parent=qe.parent}if(ht.position&&qe.position&&ht.position.copyFrom(qe.position),ht.rotationQuaternion&&qe.rotationQuaternion&&ht.rotationQuaternion.copyFrom(qe.rotationQuaternion),ht.rotation&&qe.rotation&&ht.rotation.copyFrom(qe.rotation),ht.scaling&&qe.scaling&&ht.scaling.copyFrom(qe.scaling),ht.material){const Nt=ht;if(Nt.material)if(_){const wt=qe.material;if(ce.indexOf(wt)===-1){let Qt=wt.clone(p?p(wt.name):"Clone of "+wt.name);if(ce.push(wt),A[wt.uniqueId]=Qt.uniqueId,$[Qt.uniqueId]=Qt,wt.getClassName()==="MultiMaterial"){const Ht=wt;for(const Wt of Ht.subMaterials)Wt&&(Qt=Wt.clone(p?p(Wt.name):"Clone of "+Wt.name),ce.push(Wt),A[Wt.uniqueId]=Qt.uniqueId,$[Qt.uniqueId]=Qt);Ht.subMaterials=Ht.subMaterials.map(Wt=>Wt&&$[A[Wt.uniqueId]])}}Nt.getClassName()!=="InstancedMesh"&&(Nt.material=$[A[wt.uniqueId]])}else Nt.material.getClassName()==="MultiMaterial"?this.scene.multiMaterials.indexOf(Nt.material)===-1&&this.scene.addMultiMaterial(Nt.material):this.scene.materials.indexOf(Nt.material)===-1&&this.scene.addMaterial(Nt.material)}ht.parent===null&&ne.rootNodes.push(ht)};return Xe.forEach(qe=>{if(qe.getClassName()==="InstancedMesh"){const ht=qe,Nt=ht.sourceMesh,wt=A[Nt.uniqueId],Ht=(typeof wt=="number"?$[wt]:Nt).createInstance(ht.name);xt(ht,Ht)}else{let ht=!0;qe.getClassName()==="TransformNode"||qe.getClassName()==="Node"||qe.skeleton||!qe.getTotalVertices||qe.getTotalVertices()===0?ht=!1:Te.doNotInstantiate&&(typeof Te.doNotInstantiate=="function"?ht=!Te.doNotInstantiate(qe):ht=!Te.doNotInstantiate);const Nt=ht?qe.createInstance(`instance of ${qe.name}`):qe.clone(`Clone of ${qe.name}`,null,!0);if(!Nt)throw new Error(`Could not clone or instantiate node on Asset Container ${qe.name}`);xt(qe,Nt)}}),this.skeletons.forEach(qe=>{if(Te.predicate&&!Te.predicate(qe))return;const ht=qe.clone(p?p(qe.name):"Clone of "+qe.name);for(const Nt of this.meshes)if(Nt.skeleton===qe&&!Nt.isAnInstance){const wt=$[A[Nt.uniqueId]];if(!wt||wt.isAnInstance||(wt.skeleton=ht,xe.indexOf(ht)!==-1))continue;xe.push(ht);for(const Qt of ht.bones)Qt._linkedTransformNode&&(Qt._linkedTransformNode=$[A[Qt._linkedTransformNode.uniqueId]])}ne.skeletons.push(ht)}),this.animationGroups.forEach(qe=>{if(Te.predicate&&!Te.predicate(qe))return;const ht=qe.clone(p?p(qe.name):"Clone of "+qe.name,Nt=>$[A[Nt.uniqueId]]||Nt);ne.animationGroups.push(ht)}),ne}addAllToScene(){if(!this._wasAddedToScene){this._isValidHierarchy()||ct.Warn("SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid."),this._wasAddedToScene=!0,this.addToScene(null),this.environmentTexture&&(this.scene.environmentTexture=this.environmentTexture);for(const p of this.scene._serializableComponents)p.addFromContainer(this);this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null}}addToScene(p=null){const _=[];this.cameras.forEach(E=>{p&&!p(E)||(this.scene.addCamera(E),_.push(E))}),this.lights.forEach(E=>{p&&!p(E)||(this.scene.addLight(E),_.push(E))}),this.meshes.forEach(E=>{p&&!p(E)||(this.scene.addMesh(E),_.push(E))}),this.skeletons.forEach(E=>{p&&!p(E)||this.scene.addSkeleton(E)}),this.animations.forEach(E=>{p&&!p(E)||this.scene.addAnimation(E)}),this.animationGroups.forEach(E=>{p&&!p(E)||this.scene.addAnimationGroup(E)}),this.multiMaterials.forEach(E=>{p&&!p(E)||this.scene.addMultiMaterial(E)}),this.materials.forEach(E=>{p&&!p(E)||this.scene.addMaterial(E)}),this.morphTargetManagers.forEach(E=>{p&&!p(E)||this.scene.addMorphTargetManager(E)}),this.geometries.forEach(E=>{p&&!p(E)||this.scene.addGeometry(E)}),this.transformNodes.forEach(E=>{p&&!p(E)||(this.scene.addTransformNode(E),_.push(E))}),this.actionManagers.forEach(E=>{p&&!p(E)||this.scene.addActionManager(E)}),this.textures.forEach(E=>{p&&!p(E)||this.scene.addTexture(E)}),this.reflectionProbes.forEach(E=>{p&&!p(E)||this.scene.addReflectionProbe(E)});for(const E of _)E.parent&&this.scene.getNodes().indexOf(E.parent)===-1&&(E.setParent?E.setParent(null):E.parent=null)}removeAllFromScene(){this._isValidHierarchy()||ct.Warn("SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid."),this._wasAddedToScene=!1,this.removeFromScene(null),this.environmentTexture===this.scene.environmentTexture&&(this.scene.environmentTexture=null);for(const p of this.scene._serializableComponents)p.removeFromContainer(this)}removeFromScene(p=null){this.cameras.forEach(_=>{p&&!p(_)||this.scene.removeCamera(_)}),this.lights.forEach(_=>{p&&!p(_)||this.scene.removeLight(_)}),this.meshes.forEach(_=>{p&&!p(_)||this.scene.removeMesh(_,!0)}),this.skeletons.forEach(_=>{p&&!p(_)||this.scene.removeSkeleton(_)}),this.animations.forEach(_=>{p&&!p(_)||this.scene.removeAnimation(_)}),this.animationGroups.forEach(_=>{p&&!p(_)||this.scene.removeAnimationGroup(_)}),this.multiMaterials.forEach(_=>{p&&!p(_)||this.scene.removeMultiMaterial(_)}),this.materials.forEach(_=>{p&&!p(_)||this.scene.removeMaterial(_)}),this.morphTargetManagers.forEach(_=>{p&&!p(_)||this.scene.removeMorphTargetManager(_)}),this.geometries.forEach(_=>{p&&!p(_)||this.scene.removeGeometry(_)}),this.transformNodes.forEach(_=>{p&&!p(_)||this.scene.removeTransformNode(_)}),this.actionManagers.forEach(_=>{p&&!p(_)||this.scene.removeActionManager(_)}),this.textures.forEach(_=>{p&&!p(_)||this.scene.removeTexture(_)}),this.reflectionProbes.forEach(_=>{p&&!p(_)||this.scene.removeReflectionProbe(_)})}dispose(){this.cameras.slice(0).forEach(p=>{p.dispose()}),this.cameras.length=0,this.lights.slice(0).forEach(p=>{p.dispose()}),this.lights.length=0,this.meshes.slice(0).forEach(p=>{p.dispose()}),this.meshes.length=0,this.skeletons.slice(0).forEach(p=>{p.dispose()}),this.skeletons.length=0,this.animationGroups.slice(0).forEach(p=>{p.dispose()}),this.animationGroups.length=0,this.multiMaterials.slice(0).forEach(p=>{p.dispose()}),this.multiMaterials.length=0,this.materials.slice(0).forEach(p=>{p.dispose()}),this.materials.length=0,this.geometries.slice(0).forEach(p=>{p.dispose()}),this.geometries.length=0,this.transformNodes.slice(0).forEach(p=>{p.dispose()}),this.transformNodes.length=0,this.actionManagers.slice(0).forEach(p=>{p.dispose()}),this.actionManagers.length=0,this.textures.slice(0).forEach(p=>{p.dispose()}),this.textures.length=0,this.reflectionProbes.slice(0).forEach(p=>{p.dispose()}),this.reflectionProbes.length=0,this.morphTargetManagers.slice(0).forEach(p=>{p.dispose()}),this.morphTargetManagers.length=0,this.environmentTexture&&(this.environmentTexture.dispose(),this.environmentTexture=null);for(const p of this.scene._serializableComponents)p.removeFromContainer(this,!0);this._onContextRestoredObserver&&(this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}_moveAssets(p,_,E){if(!(!p||!_))for(const A of p){let $=!0;if(E){for(const ne of E)if(A===ne){$=!1;break}}$&&(_.push(A),A._parentContainer=this)}}moveAllFromScene(p){this._wasAddedToScene=!1,p===void 0&&(p=new zL);for(const _ in this)Object.prototype.hasOwnProperty.call(this,_)&&(this[_]=this[_]||(_==="_environmentTexture"?null:[]),this._moveAssets(this.scene[_],this[_],p[_]));this.environmentTexture=this.scene.environmentTexture,this.removeAllFromScene()}createRootMesh(){const p=new Lr("assetContainerRootMesh",this.scene);return this.meshes.forEach(_=>{_.parent||p.addChild(_)}),this.meshes.unshift(p),p}mergeAnimationsTo(p=wr.LastCreatedScene,_,E=null){if(!p)return vi.Error("No scene available to merge animations to"),[];const A=E||(xe=>{let ce=null;const Te=xe.animations.length?xe.animations[0].targetProperty:"",Re=xe.name.split(".").join("").split("_primitive")[0];switch(Te){case"position":case"rotationQuaternion":ce=p.getTransformNodeByName(xe.name)||p.getTransformNodeByName(Re);break;case"influence":ce=p.getMorphTargetByName(xe.name)||p.getMorphTargetByName(Re);break;default:ce=p.getNodeByName(xe.name)||p.getNodeByName(Re)}return ce});this.getNodes().forEach(xe=>{const ce=A(xe);if(ce!==null){for(const Te of xe.animations){const Re=ce.animations.filter(ke=>ke.targetProperty===Te.targetProperty);for(const ke of Re){const We=ce.animations.indexOf(ke,0);We>-1&&ce.animations.splice(We,1)}}ce.animations=ce.animations.concat(xe.animations)}});const ne=[];return this.animationGroups.slice().forEach(xe=>{ne.push(xe.clone(xe.name,A)),xe.animatables.forEach(ce=>{ce.stop()})}),_.forEach(xe=>{const ce=A(xe.target);ce&&(p.beginAnimation(ce,xe.fromFrame,xe.toFrame,xe.loopAnimation,xe.speedRatio,xe.onAnimationEnd?xe.onAnimationEnd:void 0,void 0,!0,void 0,xe.onAnimationLoop?xe.onAnimationLoop:void 0),p.stopAnimation(xe.target))}),ne}populateRootNodes(){this.rootNodes.length=0,this.meshes.forEach(p=>{!p.parent&&this.rootNodes.indexOf(p)===-1&&this.rootNodes.push(p)}),this.transformNodes.forEach(p=>{!p.parent&&this.rootNodes.indexOf(p)===-1&&this.rootNodes.push(p)}),this.lights.forEach(p=>{!p.parent&&this.rootNodes.indexOf(p)===-1&&this.rootNodes.push(p)}),this.cameras.forEach(p=>{!p.parent&&this.rootNodes.indexOf(p)===-1&&this.rootNodes.push(p)})}addAllAssetsToContainer(p){if(!p)return;const _=[],E=new Set;for(_.push(p);_.length>0;){const A=_.pop();if(A instanceof Lr?(A.geometry&&this.geometries.indexOf(A.geometry)===-1&&this.geometries.push(A.geometry),this.meshes.push(A)):A instanceof zr?this.transformNodes.push(A):A instanceof vn?this.lights.push(A):A instanceof Hr&&this.cameras.push(A),A instanceof zo){if(A.material&&this.materials.indexOf(A.material)===-1){this.materials.push(A.material);for(const $ of A.material.getActiveTextures())this.textures.indexOf($)===-1&&this.textures.push($)}A.skeleton&&this.skeletons.indexOf(A.skeleton)===-1&&this.skeletons.push(A.skeleton),A.morphTargetManager&&this.morphTargetManagers.indexOf(A.morphTargetManager)===-1&&this.morphTargetManagers.push(A.morphTargetManager)}for(const $ of A.getChildren())E.has($)||_.push($);E.add(A)}this.populateRootNodes()}}class Gg{constructor(p){this.byteOffset=0,this.buffer=p}loadAsync(p){return this.buffer.readAsync(this.byteOffset,p).then(_=>{this._dataView=new DataView(_.buffer,_.byteOffset,_.byteLength),this._dataByteOffset=0})}readUint32(){const p=this._dataView.getUint32(this._dataByteOffset,!0);return this._dataByteOffset+=4,this.byteOffset+=4,p}readUint8Array(p){const _=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._dataByteOffset,p);return this._dataByteOffset+=p,this.byteOffset+=p,_}readString(p){return Wh(this.readUint8Array(p))}skipBytes(p){this._dataByteOffset+=p,this.byteOffset+=p}}function I_(_e,p,_,E){const A={externalResourceFunction:E};return _&&(A.uri=p==="file:"?_:p+_),ArrayBuffer.isView(_e)?GLTFValidator.validateBytes(_e,A):GLTFValidator.validateString(_e,A)}function XL(){const _e=[];onmessage=p=>{const _=p.data;switch(_.id){case"init":{importScripts(_.url);break}case"validate":{I_(_.data,_.rootUrl,_.fileName,E=>new Promise((A,$)=>{const ne=_e.length;_e.push({resolve:A,reject:$}),postMessage({id:"getExternalResource",index:ne,uri:E})})).then(E=>{postMessage({id:"validate.resolve",value:E})},E=>{postMessage({id:"validate.reject",reason:E})});break}case"getExternalResource.resolve":{_e[_.index].resolve(_.value);break}case"getExternalResource.reject":{_e[_.index].reject(_.reason);break}}}}class lO{static ValidateAsync(p,_,E,A){return typeof Worker=="function"?new Promise(($,ne)=>{const xe=`${I_}(${XL})()`,ce=URL.createObjectURL(new Blob([xe],{type:"application/javascript"})),Te=new Worker(ce),Re=We=>{Te.removeEventListener("error",Re),Te.removeEventListener("message",ke),ne(We)},ke=We=>{const Xe=We.data;switch(Xe.id){case"getExternalResource":{A(Xe.uri).then(xt=>{Te.postMessage({id:"getExternalResource.resolve",index:Xe.index,value:xt},[xt])},xt=>{Te.postMessage({id:"getExternalResource.reject",index:Xe.index,reason:xt})});break}case"validate.resolve":{Te.removeEventListener("error",Re),Te.removeEventListener("message",ke),$(Xe.value),Te.terminate();break}case"validate.reject":Te.removeEventListener("error",Re),Te.removeEventListener("message",ke),ne(Xe.reason),Te.terminate()}};if(Te.addEventListener("error",Re),Te.addEventListener("message",ke),Te.postMessage({id:"init",url:ct.GetBabylonScriptURL(this.Configuration.url)}),ArrayBuffer.isView(p)){const We=p.slice();Te.postMessage({id:"validate",data:We,rootUrl:_,fileName:E},[We.buffer])}else Te.postMessage({id:"validate",data:p,rootUrl:_,fileName:E})}):(this._LoadScriptPromise||(this._LoadScriptPromise=ct.LoadBabylonScriptAsync(this.Configuration.url)),this._LoadScriptPromise.then(()=>I_(p,_,E,A)))}}lO.Configuration={url:`${ct._DefaultCdnUrl}/gltf_validator.js`};function hO(_e,p,_){try{return Promise.resolve(new Uint8Array(_e,p,_))}catch(E){return Promise.reject(E)}}function KL(_e,p,_){try{if(p<0||p>=_e.byteLength)throw new RangeError("Offset is out of range.");if(p+_>_e.byteLength)throw new RangeError("Length is out of range.");return Promise.resolve(new Uint8Array(_e.buffer,_e.byteOffset+p,_))}catch(E){return Promise.reject(E)}}var _m;(function(_e){_e[_e.AUTO=0]="AUTO",_e[_e.FORCE_RIGHT_HANDED=1]="FORCE_RIGHT_HANDED"})(_m||(_m={}));var rd;(function(_e){_e[_e.NONE=0]="NONE",_e[_e.FIRST=1]="FIRST",_e[_e.ALL=2]="ALL"})(rd||(rd={}));var wx;(function(_e){_e[_e.LOADING=0]="LOADING",_e[_e.READY=1]="READY",_e[_e.COMPLETE=2]="COMPLETE"})(wx||(wx={}));class H0{constructor(){this.onParsedObservable=new Mi,this.coordinateSystemMode=_m.AUTO,this.animationStartMode=rd.FIRST,this.compileMaterials=!1,this.useClipPlane=!1,this.compileShadowGenerators=!1,this.transparencyAsCoverage=!1,this.useRangeRequests=!1,this.createInstances=!0,this.alwaysComputeBoundingBox=!1,this.loadAllMaterials=!1,this.loadOnlyMaterials=!1,this.skipMaterials=!1,this.useSRGBBuffers=!0,this.targetFps=60,this.alwaysComputeSkeletonRootNode=!1,this.preprocessUrlAsync=p=>Promise.resolve(p),this.onMeshLoadedObservable=new Mi,this.onSkinLoadedObservable=new Mi,this.onTextureLoadedObservable=new Mi,this.onMaterialLoadedObservable=new Mi,this.onCameraLoadedObservable=new Mi,this.onCompleteObservable=new Mi,this.onErrorObservable=new Mi,this.onDisposeObservable=new Mi,this.onExtensionLoadedObservable=new Mi,this.validate=!1,this.onValidatedObservable=new Mi,this._loader=null,this._state=null,this._requests=new Array,this.name="gltf",this.extensions={".gltf":{isBinary:!1},".glb":{isBinary:!0}},this.onLoaderStateChangedObservable=new Mi,this._logIndentLevel=0,this._loggingEnabled=!1,this._log=this._logDisabled,this._capturePerformanceCounters=!1,this._startPerformanceCounter=this._startPerformanceCounterDisabled,this._endPerformanceCounter=this._endPerformanceCounterDisabled}set onParsed(p){this._onParsedObserver&&this.onParsedObservable.remove(this._onParsedObserver),this._onParsedObserver=this.onParsedObservable.add(p)}set onMeshLoaded(p){this._onMeshLoadedObserver&&this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver),this._onMeshLoadedObserver=this.onMeshLoadedObservable.add(p)}set onTextureLoaded(p){this._onTextureLoadedObserver&&this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver),this._onTextureLoadedObserver=this.onTextureLoadedObservable.add(p)}set onMaterialLoaded(p){this._onMaterialLoadedObserver&&this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver),this._onMaterialLoadedObserver=this.onMaterialLoadedObservable.add(p)}set onCameraLoaded(p){this._onCameraLoadedObserver&&this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver),this._onCameraLoadedObserver=this.onCameraLoadedObservable.add(p)}set onComplete(p){this._onCompleteObserver&&this.onCompleteObservable.remove(this._onCompleteObserver),this._onCompleteObserver=this.onCompleteObservable.add(p)}set onError(p){this._onErrorObserver&&this.onErrorObservable.remove(this._onErrorObserver),this._onErrorObserver=this.onErrorObservable.add(p)}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}set onExtensionLoaded(p){this._onExtensionLoadedObserver&&this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver),this._onExtensionLoadedObserver=this.onExtensionLoadedObservable.add(p)}get loggingEnabled(){return this._loggingEnabled}set loggingEnabled(p){this._loggingEnabled!==p&&(this._loggingEnabled=p,this._loggingEnabled?this._log=this._logEnabled:this._log=this._logDisabled)}get capturePerformanceCounters(){return this._capturePerformanceCounters}set capturePerformanceCounters(p){this._capturePerformanceCounters!==p&&(this._capturePerformanceCounters=p,this._capturePerformanceCounters?(this._startPerformanceCounter=this._startPerformanceCounterEnabled,this._endPerformanceCounter=this._endPerformanceCounterEnabled):(this._startPerformanceCounter=this._startPerformanceCounterDisabled,this._endPerformanceCounter=this._endPerformanceCounterDisabled))}set onValidated(p){this._onValidatedObserver&&this.onValidatedObservable.remove(this._onValidatedObserver),this._onValidatedObserver=this.onValidatedObservable.add(p)}dispose(){this._loader&&(this._loader.dispose(),this._loader=null);for(const p of this._requests)p.abort();this._requests.length=0,delete this._progressCallback,this.preprocessUrlAsync=p=>Promise.resolve(p),this.onMeshLoadedObservable.clear(),this.onSkinLoadedObservable.clear(),this.onTextureLoadedObservable.clear(),this.onMaterialLoadedObservable.clear(),this.onCameraLoadedObservable.clear(),this.onCompleteObservable.clear(),this.onExtensionLoadedObservable.clear(),this.onDisposeObservable.notifyObservers(void 0),this.onDisposeObservable.clear()}loadFile(p,_,E,A,$,ne,xe,ce){if(ArrayBuffer.isView(_))return this._loadBinary(p,_,E,A,xe,ce),null;this._progressCallback=$;const Te=_.name||ct.GetFilename(_);if(ne){if(this.useRangeRequests){this.validate&&vi.Warn("glTF validation is not supported when range requests are enabled");const Re={abort:()=>{},onCompleteObservable:new Mi},ke={readAsync:(We,Xe)=>new Promise((xt,qe)=>{this._loadFile(p,_,ht=>{xt(new Uint8Array(ht))},!0,ht=>{qe(ht)},ht=>{ht.setRequestHeader("Range",`bytes=${We}-${We+Xe-1}`)})}),byteLength:0};return this._unpackBinaryAsync(new Gg(ke)).then(We=>{Re.onCompleteObservable.notifyObservers(Re),A(We)},xe?We=>xe(void 0,We):void 0),Re}return this._loadFile(p,_,Re=>{this._validate(p,new Uint8Array(Re,0,Re.byteLength),E,Te),this._unpackBinaryAsync(new Gg({readAsync:(ke,We)=>hO(Re,ke,We),byteLength:Re.byteLength})).then(ke=>{A(ke)},xe?ke=>xe(void 0,ke):void 0)},!0,xe)}else return this._loadFile(p,_,Re=>{this._validate(p,Re,E,Te),A({json:this._parseJson(Re)})},!1,xe)}_loadBinary(p,_,E,A,$,ne){this._validate(p,new Uint8Array(_.buffer,_.byteOffset,_.byteLength),E,ne),this._unpackBinaryAsync(new Gg({readAsync:(xe,ce)=>KL(_,xe,ce),byteLength:_.byteLength})).then(xe=>{A(xe)},$?xe=>$(void 0,xe):void 0)}importMeshAsync(p,_,E,A,$,ne){return Promise.resolve().then(()=>(this.onParsedObservable.notifyObservers(E),this.onParsedObservable.clear(),this._log(`Loading ${ne||""}`),this._loader=this._getLoader(E),this._loader.importMeshAsync(p,_,null,E,A,$,ne)))}loadAsync(p,_,E,A,$){return Promise.resolve().then(()=>(this.onParsedObservable.notifyObservers(_),this.onParsedObservable.clear(),this._log(`Loading ${$||""}`),this._loader=this._getLoader(_),this._loader.loadAsync(p,_,E,A,$)))}loadAssetContainerAsync(p,_,E,A,$){return Promise.resolve().then(()=>{this.onParsedObservable.notifyObservers(_),this.onParsedObservable.clear(),this._log(`Loading ${$||""}`),this._loader=this._getLoader(_);const ne=new HL(p),xe=[];this.onMaterialLoadedObservable.add(ke=>{xe.push(ke)});const ce=[];this.onTextureLoadedObservable.add(ke=>{ce.push(ke)});const Te=[];this.onCameraLoadedObservable.add(ke=>{Te.push(ke)});const Re=[];return this.onMeshLoadedObservable.add(ke=>{ke.morphTargetManager&&Re.push(ke.morphTargetManager)}),this._loader.importMeshAsync(null,p,ne,_,E,A,$).then(ke=>(Array.prototype.push.apply(ne.geometries,ke.geometries),Array.prototype.push.apply(ne.meshes,ke.meshes),Array.prototype.push.apply(ne.particleSystems,ke.particleSystems),Array.prototype.push.apply(ne.skeletons,ke.skeletons),Array.prototype.push.apply(ne.animationGroups,ke.animationGroups),Array.prototype.push.apply(ne.materials,xe),Array.prototype.push.apply(ne.textures,ce),Array.prototype.push.apply(ne.lights,ke.lights),Array.prototype.push.apply(ne.transformNodes,ke.transformNodes),Array.prototype.push.apply(ne.cameras,Te),Array.prototype.push.apply(ne.morphTargetManagers,Re),ne))})}canDirectLoad(p){return p.indexOf("asset")!==-1&&p.indexOf("version")!==-1||p.startsWith("data:base64,"+H0._MagicBase64Encoded)||p.startsWith("data:;base64,"+H0._MagicBase64Encoded)||p.startsWith("data:application/octet-stream;base64,"+H0._MagicBase64Encoded)||p.startsWith("data:model/gltf-binary;base64,"+H0._MagicBase64Encoded)}directLoad(p,_){if(_.startsWith("base64,"+H0._MagicBase64Encoded)||_.startsWith(";base64,"+H0._MagicBase64Encoded)||_.startsWith("application/octet-stream;base64,"+H0._MagicBase64Encoded)||_.startsWith("model/gltf-binary;base64,"+H0._MagicBase64Encoded)){const E=Ul(_);return this._validate(p,new Uint8Array(E,0,E.byteLength)),this._unpackBinaryAsync(new Gg({readAsync:(A,$)=>hO(E,A,$),byteLength:E.byteLength}))}return this._validate(p,_),Promise.resolve({json:this._parseJson(_)})}createPlugin(){return new H0}get loaderState(){return this._state}whenCompleteAsync(){return new Promise((p,_)=>{this.onCompleteObservable.addOnce(()=>{p()}),this.onErrorObservable.addOnce(E=>{_(E)})})}_setState(p){this._state!==p&&(this._state=p,this.onLoaderStateChangedObservable.notifyObservers(this._state),this._log(wx[this._state]))}_loadFile(p,_,E,A,$,ne){const xe=p._loadFile(_,E,ce=>{this._onProgress(ce,xe)},!0,A,$,ne);return xe.onCompleteObservable.add(ce=>{this._requests.splice(this._requests.indexOf(ce),1)}),this._requests.push(xe),xe}_onProgress(p,_){if(!this._progressCallback)return;_._lengthComputable=p.lengthComputable,_._loaded=p.loaded,_._total=p.total;let E=!0,A=0,$=0;for(const ne of this._requests){if(ne._lengthComputable===void 0||ne._loaded===void 0||ne._total===void 0)return;E=E&&ne._lengthComputable,A+=ne._loaded,$+=ne._total}this._progressCallback({lengthComputable:E,loaded:A,total:E?$:0})}_validate(p,_,E="",A=""){this.validate&&(this._startPerformanceCounter("Validate JSON"),lO.ValidateAsync(_,E,A,$=>this.preprocessUrlAsync(E+$).then(ne=>p._loadFileAsync(ne,void 0,!0,!0).then(xe=>new Uint8Array(xe,0,xe.byteLength)))).then($=>{this._endPerformanceCounter("Validate JSON"),this.onValidatedObservable.notifyObservers($),this.onValidatedObservable.clear()},$=>{this._endPerformanceCounter("Validate JSON"),ct.Warn(`Failed to validate: ${$.message}`),this.onValidatedObservable.clear()}))}_getLoader(p){const _=p.json.asset||{};this._log(`Asset version: ${_.version}`),_.minVersion&&this._log(`Asset minimum version: ${_.minVersion}`),_.generator&&this._log(`Asset generator: ${_.generator}`);const E=H0._parseVersion(_.version);if(!E)throw new Error("Invalid version: "+_.version);if(_.minVersion!==void 0){const ne=H0._parseVersion(_.minVersion);if(!ne)throw new Error("Invalid minimum version: "+_.minVersion);if(H0._compareVersion(ne,{major:2,minor:0})>0)throw new Error("Incompatible minimum version: "+_.minVersion)}const $={1:H0._CreateGLTF1Loader,2:H0._CreateGLTF2Loader}[E.major];if(!$)throw new Error("Unsupported version: "+_.version);return $(this)}_parseJson(p){this._startPerformanceCounter("Parse JSON"),this._log(`JSON length: ${p.length}`);const _=JSON.parse(p);return this._endPerformanceCounter("Parse JSON"),_}_unpackBinaryAsync(p){return this._startPerformanceCounter("Unpack Binary"),p.loadAsync(20).then(()=>{const _={Magic:1179937895},E=p.readUint32();if(E!==_.Magic)throw new jo("Unexpected magic: "+E,Yo.GLTFLoaderUnexpectedMagicError);const A=p.readUint32();this.loggingEnabled&&this._log(`Binary version: ${A}`);const $=p.readUint32();!this.useRangeRequests&&$!==p.buffer.byteLength&&vi.Warn(`Length in header does not match actual data length: ${$} != ${p.buffer.byteLength}`);let ne;switch(A){case 1:{ne=this._unpackBinaryV1Async(p,$);break}case 2:{ne=this._unpackBinaryV2Async(p,$);break}default:throw new Error("Unsupported version: "+A)}return this._endPerformanceCounter("Unpack Binary"),ne})}_unpackBinaryV1Async(p,_){const E={JSON:0},A=p.readUint32(),$=p.readUint32();if($!==E.JSON)throw new Error(`Unexpected content format: ${$}`);const ne=_-p.byteOffset,xe={json:this._parseJson(p.readString(A)),bin:null};if(ne!==0){const ce=p.byteOffset;xe.bin={readAsync:(Te,Re)=>p.buffer.readAsync(ce+Te,Re),byteLength:ne}}return Promise.resolve(xe)}_unpackBinaryV2Async(p,_){const E={JSON:1313821514,BIN:5130562},A=p.readUint32();if(p.readUint32()!==E.JSON)throw new Error("First chunk format is not JSON");return p.byteOffset+A===_?p.loadAsync(A).then(()=>({json:this._parseJson(p.readString(A)),bin:null})):p.loadAsync(A+8).then(()=>{const ne={json:this._parseJson(p.readString(A)),bin:null},xe=()=>{const ce=p.readUint32();switch(p.readUint32()){case E.JSON:throw new Error("Unexpected JSON chunk");case E.BIN:{const Re=p.byteOffset;ne.bin={readAsync:(ke,We)=>p.buffer.readAsync(Re+ke,We),byteLength:ce},p.skipBytes(ce);break}default:{p.skipBytes(ce);break}}return p.byteOffset!==_?p.loadAsync(8).then(xe):Promise.resolve(ne)};return xe()})}static _parseVersion(p){if(p==="1.0"||p==="1.0.1")return{major:1,minor:0};const _=(p+"").match(/^(\d+)\.(\d+)/);return _?{major:parseInt(_[1]),minor:parseInt(_[2])}:null}static _compareVersion(p,_){return p.major>_.major?1:p.major<_.major?-1:p.minor>_.minor?1:p.minor<_.minor?-1:0}_logOpen(p){this._log(p),this._logIndentLevel++}_logClose(){--this._logIndentLevel}_logEnabled(p){const _=H0._logSpaces.substr(0,this._logIndentLevel*2);vi.Log(`${_}${p}`)}_logDisabled(p){}_startPerformanceCounterEnabled(p){ct.StartPerformanceCounter(p)}_startPerformanceCounterDisabled(p){}_endPerformanceCounterEnabled(p){ct.EndPerformanceCounter(p)}_endPerformanceCounterDisabled(p){}}H0.IncrementalLoading=!0,H0.HomogeneousCoordinates=!1,H0._MagicBase64Encoded="Z2xURg",H0._logSpaces="                                ",kn&&kn.RegisterPlugin(new H0);function cO(_e,p,_,E){return nt.FromArray(p,_).scaleInPlace(E)}function YL(_e,p,_,E){return _s.FromArray(p,_).scaleInPlace(E)}function jL(_e,p,_,E){const A=new Array(_e._numMorphTargets);for(let $=0;$<A.length;$++)A[$]=p[_++]*E;return A}class Tm{constructor(p,_,E,A){this.type=p,this.name=_,this.getValue=E,this.getStride=A}_buildAnimation(p,_,E){const A=new Ui(p,this.name,_,this.type);return A.setKeys(E),A}}class M_ extends Tm{buildAnimations(p,_,E,A,$){$(p._babylonTransformNode,this._buildAnimation(_,E,A))}}class qL extends Tm{buildAnimations(p,_,E,A,$){if(p._numMorphTargets)for(let ne=0;ne<p._numMorphTargets;ne++){const xe=new Ui(`${_}_${ne}`,this.name,E,this.type);if(xe.setKeys(A.map(ce=>({frame:ce.frame,inTangent:ce.inTangent?ce.inTangent[ne]:void 0,value:ce.value[ne],outTangent:ce.outTangent?ce.outTangent[ne]:void 0,interpolation:ce.interpolation}))),p._primitiveBabylonMeshes){for(const ce of p._primitiveBabylonMeshes)if(ce.morphTargetManager){const Te=ce.morphTargetManager.getTarget(ne),Re=xe.clone();Te.animations.push(Re),$(Te,Re)}}}}}const vm={translation:[new M_(Ui.ANIMATIONTYPE_VECTOR3,"position",cO,()=>3)],rotation:[new M_(Ui.ANIMATIONTYPE_QUATERNION,"rotationQuaternion",YL,()=>4)],scale:[new M_(Ui.ANIMATIONTYPE_VECTOR3,"scaling",cO,()=>3)],weights:[new qL(Ui.ANIMATIONTYPE_FLOAT,"influence",jL,_e=>_e._numMorphTargets)]};function uO(..._e){const p=_=>_&&typeof _=="object";return _e.reduce((_,E)=>(Object.keys(E).forEach(A=>{const $=_[A],ne=E[A];Array.isArray($)&&Array.isArray(ne)?_[A]=$.concat(...ne):p($)&&p(ne)?_[A]=uO($,ne):_[A]=ne}),_),{})}class Wr{static Get(p,_,E){if(!_||E==null||!_[E])throw new Error(`${p}: Failed to find index (${E})`);return _[E]}static TryGet(p,_){return!p||_==null||!p[_]?null:p[_]}static Assign(p){if(p)for(let _=0;_<p.length;_++)p[_].index=_}}class qs{static RegisterExtension(p,_){qs.UnregisterExtension(p)&&vi.Warn(`Extension with the name '${p}' already exists`),qs._RegisteredExtensions[p]={factory:_}}static UnregisterExtension(p){return qs._RegisteredExtensions[p]?(delete qs._RegisteredExtensions[p],!0):!1}get gltf(){if(!this._gltf)throw new Error("glTF JSON is not available");return this._gltf}get bin(){return this._bin}get parent(){return this._parent}get babylonScene(){if(!this._babylonScene)throw new Error("Scene is not available");return this._babylonScene}get rootBabylonMesh(){return this._rootBabylonMesh}get rootUrl(){return this._rootUrl}constructor(p){this._completePromises=new Array,this._assetContainer=null,this._babylonLights=[],this._disableInstancedMesh=0,this._allMaterialsDirtyRequired=!1,this._extensions=new Array,this._disposed=!1,this._rootUrl=null,this._fileName=null,this._uniqueRootUrl=null,this._bin=null,this._rootBabylonMesh=null,this._defaultBabylonMaterialData={},this._postSceneLoadActions=new Array,this._parent=p}dispose(){this._disposed||(this._disposed=!0,this._completePromises.length=0,this._extensions.forEach(p=>p.dispose&&p.dispose()),this._extensions.length=0,this._gltf=null,this._bin=null,this._babylonScene=null,this._rootBabylonMesh=null,this._defaultBabylonMaterialData={},this._postSceneLoadActions.length=0,this._parent.dispose())}importMeshAsync(p,_,E,A,$,ne,xe=""){return Promise.resolve().then(()=>{this._babylonScene=_,this._assetContainer=E,this._loadData(A);let ce=null;if(p){const Te={};if(this._gltf.nodes)for(const ke of this._gltf.nodes)ke.name&&(Te[ke.name]=ke.index);ce=(p instanceof Array?p:[p]).map(ke=>{const We=Te[ke];if(We===void 0)throw new Error(`Failed to find node '${ke}'`);return We})}return this._loadAsync($,xe,ce,()=>({meshes:this._getMeshes(),particleSystems:[],skeletons:this._getSkeletons(),animationGroups:this._getAnimationGroups(),lights:this._babylonLights,transformNodes:this._getTransformNodes(),geometries:this._getGeometries()}))})}loadAsync(p,_,E,A,$=""){return Promise.resolve().then(()=>(this._babylonScene=p,this._loadData(_),this._loadAsync(E,$,null,()=>{})))}_loadAsync(p,_,E,A){return Promise.resolve().then(()=>{this._rootUrl=p,this._uniqueRootUrl=!p.startsWith("file:")&&_?p:`${p}${Date.now()}/`,this._fileName=_,this._allMaterialsDirtyRequired=!1,this._loadExtensions(),this._checkExtensions();const $=`${wx[wx.LOADING]} => ${wx[wx.READY]}`,ne=`${wx[wx.LOADING]} => ${wx[wx.COMPLETE]}`;this._parent._startPerformanceCounter($),this._parent._startPerformanceCounter(ne),this._parent._setState(wx.LOADING),this._extensionsOnLoading();const xe=new Array,ce=this._babylonScene.blockMaterialDirtyMechanism;if(this._babylonScene.blockMaterialDirtyMechanism=!0,!this.parent.loadOnlyMaterials){if(E)xe.push(this.loadSceneAsync("/nodes",{nodes:E,index:-1}));else if(this._gltf.scene!=null||this._gltf.scenes&&this._gltf.scenes[0]){const Re=Wr.Get("/scene",this._gltf.scenes,this._gltf.scene||0);xe.push(this.loadSceneAsync(`/scenes/${Re.index}`,Re))}}if(!this.parent.skipMaterials&&this.parent.loadAllMaterials&&this._gltf.materials)for(let Re=0;Re<this._gltf.materials.length;++Re){const ke=this._gltf.materials[Re],We="/materials/"+Re,Xe=Xi.TriangleFillMode;xe.push(this._loadMaterialAsync(We,ke,null,Xe,()=>{}))}return this._allMaterialsDirtyRequired?this._babylonScene.blockMaterialDirtyMechanism=ce:this._babylonScene._forceBlockMaterialDirtyMechanism(ce),this._parent.compileMaterials&&xe.push(this._compileMaterialsAsync()),this._parent.compileShadowGenerators&&xe.push(this._compileShadowGeneratorsAsync()),Promise.all(xe).then(()=>(this._rootBabylonMesh&&this._rootBabylonMesh!==this._parent.customRootNode&&this._rootBabylonMesh.setEnabled(!0),this._extensionsOnReady(),this._parent._setState(wx.READY),this._startAnimations(),A())).then(Re=>(this._parent._endPerformanceCounter($),ct.SetImmediate(()=>{this._disposed||Promise.all(this._completePromises).then(()=>{this._parent._endPerformanceCounter(ne),this._parent._setState(wx.COMPLETE),this._parent.onCompleteObservable.notifyObservers(void 0),this._parent.onCompleteObservable.clear(),this.dispose()},ke=>{this._parent.onErrorObservable.notifyObservers(ke),this._parent.onErrorObservable.clear(),this.dispose()})}),Re))}).catch($=>{throw this._disposed||(this._parent.onErrorObservable.notifyObservers($),this._parent.onErrorObservable.clear(),this.dispose()),$})}_loadData(p){if(this._gltf=p.json,this._setupData(),p.bin){const _=this._gltf.buffers;if(_&&_[0]&&!_[0].uri){const E=_[0];(E.byteLength<p.bin.byteLength-3||E.byteLength>p.bin.byteLength)&&vi.Warn(`Binary buffer length (${E.byteLength}) from JSON does not match chunk length (${p.bin.byteLength})`),this._bin=p.bin}else vi.Warn("Unexpected BIN chunk")}}_setupData(){if(Wr.Assign(this._gltf.accessors),Wr.Assign(this._gltf.animations),Wr.Assign(this._gltf.buffers),Wr.Assign(this._gltf.bufferViews),Wr.Assign(this._gltf.cameras),Wr.Assign(this._gltf.images),Wr.Assign(this._gltf.materials),Wr.Assign(this._gltf.meshes),Wr.Assign(this._gltf.nodes),Wr.Assign(this._gltf.samplers),Wr.Assign(this._gltf.scenes),Wr.Assign(this._gltf.skins),Wr.Assign(this._gltf.textures),this._gltf.nodes){const p={};for(const E of this._gltf.nodes)if(E.children)for(const A of E.children)p[A]=E.index;const _=this._createRootNode();for(const E of this._gltf.nodes){const A=p[E.index];E.parent=A===void 0?_:this._gltf.nodes[A]}}}_loadExtensions(){for(const p in qs._RegisteredExtensions){const _=qs._RegisteredExtensions[p].factory(this);_.name!==p&&vi.Warn(`The name of the glTF loader extension instance does not match the registered name: ${_.name} !== ${p}`),this._extensions.push(_),this._parent.onExtensionLoadedObservable.notifyObservers(_)}this._extensions.sort((p,_)=>(p.order||Number.MAX_VALUE)-(_.order||Number.MAX_VALUE)),this._parent.onExtensionLoadedObservable.clear()}_checkExtensions(){if(this._gltf.extensionsRequired){for(const p of this._gltf.extensionsRequired)if(!this._extensions.some(E=>E.name===p&&E.enabled))throw new Error(`Required extension ${p} is not available`)}}_createRootNode(){if(this._parent.customRootNode!==void 0)return this._rootBabylonMesh=this._parent.customRootNode,{_babylonTransformNode:this._rootBabylonMesh===null?void 0:this._rootBabylonMesh,index:-1};this._babylonScene._blockEntityCollection=!!this._assetContainer;const p=new Lr("__root__",this._babylonScene);this._rootBabylonMesh=p,this._rootBabylonMesh._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,this._rootBabylonMesh.setEnabled(!1);const _={_babylonTransformNode:this._rootBabylonMesh,index:-1};switch(this._parent.coordinateSystemMode){case _m.AUTO:{this._babylonScene.useRightHandedSystem||(_.rotation=[0,1,0,0],_.scale=[1,1,-1],qs._LoadTransform(_,this._rootBabylonMesh));break}case _m.FORCE_RIGHT_HANDED:{this._babylonScene.useRightHandedSystem=!0;break}default:throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`)}return this._parent.onMeshLoadedObservable.notifyObservers(p),_}loadSceneAsync(p,_){const E=this._extensionsLoadSceneAsync(p,_);if(E)return E;const A=new Array;if(this.logOpen(`${p} ${_.name||""}`),_.nodes)for(const $ of _.nodes){const ne=Wr.Get(`${p}/nodes/${$}`,this._gltf.nodes,$);A.push(this.loadNodeAsync(`/nodes/${ne.index}`,ne,xe=>{xe.parent=this._rootBabylonMesh}))}for(const $ of this._postSceneLoadActions)$();return A.push(this._loadAnimationsAsync()),this.logClose(),Promise.all(A).then(()=>{})}_forEachPrimitive(p,_){if(p._primitiveBabylonMeshes)for(const E of p._primitiveBabylonMeshes)_(E)}_getGeometries(){const p=[],_=this._gltf.nodes;if(_)for(const E of _)this._forEachPrimitive(E,A=>{const $=A.geometry;$&&p.indexOf($)===-1&&p.push($)});return p}_getMeshes(){const p=[];this._rootBabylonMesh instanceof zo&&p.push(this._rootBabylonMesh);const _=this._gltf.nodes;if(_)for(const E of _)this._forEachPrimitive(E,A=>{p.push(A)});return p}_getTransformNodes(){const p=[],_=this._gltf.nodes;if(_)for(const E of _)E._babylonTransformNode&&E._babylonTransformNode.getClassName()==="TransformNode"&&p.push(E._babylonTransformNode),E._babylonTransformNodeForSkin&&p.push(E._babylonTransformNodeForSkin);return p}_getSkeletons(){const p=[],_=this._gltf.skins;if(_)for(const E of _)E._data&&p.push(E._data.babylonSkeleton);return p}_getAnimationGroups(){const p=[],_=this._gltf.animations;if(_)for(const E of _)E._babylonAnimationGroup&&p.push(E._babylonAnimationGroup);return p}_startAnimations(){switch(this._parent.animationStartMode){case rd.NONE:break;case rd.FIRST:{const p=this._getAnimationGroups();p.length!==0&&p[0].start(!0);break}case rd.ALL:{const p=this._getAnimationGroups();for(const _ of p)_.start(!0);break}default:{vi.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);return}}}loadNodeAsync(p,_,E=()=>{}){const A=this._extensionsLoadNodeAsync(p,_,E);if(A)return A;if(_._babylonTransformNode)throw new Error(`${p}: Invalid recursive node hierarchy`);const $=new Array;this.logOpen(`${p} ${_.name||""}`);const ne=xe=>{if(qs.AddPointerMetadata(xe,p),qs._LoadTransform(_,xe),_.camera!=null){const ce=Wr.Get(`${p}/camera`,this._gltf.cameras,_.camera);$.push(this.loadCameraAsync(`/cameras/${ce.index}`,ce,Te=>{Te.parent=xe}))}if(_.children)for(const ce of _.children){const Te=Wr.Get(`${p}/children/${ce}`,this._gltf.nodes,ce);$.push(this.loadNodeAsync(`/nodes/${Te.index}`,Te,Re=>{Re.parent=xe}))}E(xe)};if(_.mesh==null||_.skin!=null){const xe=_.name||`node${_.index}`;this._babylonScene._blockEntityCollection=!!this._assetContainer;const ce=new zr(xe,this._babylonScene);ce._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,_.mesh==null?_._babylonTransformNode=ce:_._babylonTransformNodeForSkin=ce,ne(ce)}if(_.mesh!=null)if(_.skin==null){const xe=Wr.Get(`${p}/mesh`,this._gltf.meshes,_.mesh);$.push(this._loadMeshAsync(`/meshes/${xe.index}`,_,xe,ne))}else{const xe=Wr.Get(`${p}/mesh`,this._gltf.meshes,_.mesh);$.push(this._loadMeshAsync(`/meshes/${xe.index}`,_,xe,ce=>{const Te=_._babylonTransformNodeForSkin;ce.metadata=uO(Te.metadata,ce.metadata||{});const Re=Wr.Get(`${p}/skin`,this._gltf.skins,_.skin);$.push(this._loadSkinAsync(`/skins/${Re.index}`,_,Re,ke=>{this._forEachPrimitive(_,We=>{We.skeleton=ke}),this._postSceneLoadActions.push(()=>{if(Re.skeleton!=null){const We=Wr.Get(`/skins/${Re.index}/skeleton`,this._gltf.nodes,Re.skeleton).parent;_.index===We.index?ce.parent=Te.parent:ce.parent=We._babylonTransformNode}else ce.parent=this._rootBabylonMesh;this._parent.onSkinLoadedObservable.notifyObservers({node:Te,skinnedNode:ce})})}))}))}return this.logClose(),Promise.all($).then(()=>(this._forEachPrimitive(_,xe=>{xe.geometry&&xe.geometry.useBoundingInfoFromGeometry?xe._updateBoundingInfo():xe.refreshBoundingInfo(!0)}),_._babylonTransformNode))}_loadMeshAsync(p,_,E,A){const $=E.primitives;if(!$||!$.length)throw new Error(`${p}: Primitives are missing`);$[0].index==null&&Wr.Assign($);const ne=new Array;this.logOpen(`${p} ${E.name||""}`);const xe=_.name||`node${_.index}`;if($.length===1){const ce=E.primitives[0];ne.push(this._loadMeshPrimitiveAsync(`${p}/primitives/${ce.index}`,xe,_,E,ce,Te=>{_._babylonTransformNode=Te,_._primitiveBabylonMeshes=[Te]}))}else{this._babylonScene._blockEntityCollection=!!this._assetContainer,_._babylonTransformNode=new zr(xe,this._babylonScene),_._babylonTransformNode._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,_._primitiveBabylonMeshes=[];for(const ce of $)ne.push(this._loadMeshPrimitiveAsync(`${p}/primitives/${ce.index}`,`${xe}_primitive${ce.index}`,_,E,ce,Te=>{Te.parent=_._babylonTransformNode,_._primitiveBabylonMeshes.push(Te)}))}return A(_._babylonTransformNode),this.logClose(),Promise.all(ne).then(()=>_._babylonTransformNode)}_loadMeshPrimitiveAsync(p,_,E,A,$,ne){const xe=this._extensionsLoadMeshPrimitiveAsync(p,_,E,A,$,ne);if(xe)return xe;this.logOpen(`${p}`);const ce=this._disableInstancedMesh===0&&this._parent.createInstances&&E.skin==null&&!A.primitives[0].targets;let Te,Re;if(ce&&$._instanceData)this._babylonScene._blockEntityCollection=!!this._assetContainer,Te=$._instanceData.babylonSourceMesh.createInstance(_),Te._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,Re=$._instanceData.promise;else{const ke=new Array;this._babylonScene._blockEntityCollection=!!this._assetContainer;const We=new Lr(_,this._babylonScene);We._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,We.overrideMaterialSideOrientation=this._babylonScene.useRightHandedSystem?Xi.CounterClockWiseSideOrientation:Xi.ClockWiseSideOrientation,this._createMorphTargets(p,E,A,$,We),ke.push(this._loadVertexDataAsync(p,$,We).then(xt=>this._loadMorphTargetsAsync(p,$,We,xt).then(()=>{this._disposed||(this._babylonScene._blockEntityCollection=!!this._assetContainer,xt.applyToMesh(We),xt._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1)})));const Xe=qs._GetDrawMode(p,$.mode);if($.material==null){let xt=this._defaultBabylonMaterialData[Xe];xt||(xt=this._createDefaultMaterial("__GLTFLoader._default",Xe),this._parent.onMaterialLoadedObservable.notifyObservers(xt),this._defaultBabylonMaterialData[Xe]=xt),We.material=xt}else if(!this.parent.skipMaterials){const xt=Wr.Get(`${p}/material`,this._gltf.materials,$.material);ke.push(this._loadMaterialAsync(`/materials/${xt.index}`,xt,We,Xe,qe=>{We.material=qe}))}Re=Promise.all(ke),ce&&($._instanceData={babylonSourceMesh:We,promise:Re}),Te=We}return qs.AddPointerMetadata(Te,p),this._parent.onMeshLoadedObservable.notifyObservers(Te),ne(Te),this.logClose(),Re.then(()=>Te)}_loadVertexDataAsync(p,_,E){const A=this._extensionsLoadVertexDataAsync(p,_,E);if(A)return A;const $=_.attributes;if(!$)throw new Error(`${p}: Attributes are missing`);const ne=new Array,xe=new vo(E.name,this._babylonScene);if(_.indices==null)E.isUnIndexed=!0;else{const Te=Wr.Get(`${p}/indices`,this._gltf.accessors,_.indices);ne.push(this._loadIndicesAccessorAsync(`/accessors/${Te.index}`,Te).then(Re=>{xe.setIndices(Re)}))}const ce=(Te,Re,ke)=>{if($[Te]==null)return;E._delayInfo=E._delayInfo||[],E._delayInfo.indexOf(Re)===-1&&E._delayInfo.push(Re);const We=Wr.Get(`${p}/attributes/${Te}`,this._gltf.accessors,$[Te]);ne.push(this._loadVertexAccessorAsync(`/accessors/${We.index}`,We,Re).then(Xe=>{if(Xe.getKind()===ut.PositionKind&&!this.parent.alwaysComputeBoundingBox&&!E.skeleton&&We.min&&We.max){const xt=pi.Vector3[0].copyFromFloats(...We.min),qe=pi.Vector3[1].copyFromFloats(...We.max);if(We.normalized&&We.componentType!==5126){let ht=1;switch(We.componentType){case 5120:ht=127;break;case 5121:ht=255;break;case 5122:ht=32767;break;case 5123:ht=65535;break}const Nt=1/ht;xt.scaleInPlace(Nt),qe.scaleInPlace(Nt)}xe._boundingInfo=new lx(xt,qe),xe.useBoundingInfoFromGeometry=!0}xe.setVerticesBuffer(Xe,We.count)})),Re==ut.MatricesIndicesExtraKind&&(E.numBoneInfluencers=8),ke&&ke(We)};return ce("POSITION",ut.PositionKind),ce("NORMAL",ut.NormalKind),ce("TANGENT",ut.TangentKind),ce("TEXCOORD_0",ut.UVKind),ce("TEXCOORD_1",ut.UV2Kind),ce("TEXCOORD_2",ut.UV3Kind),ce("TEXCOORD_3",ut.UV4Kind),ce("TEXCOORD_4",ut.UV5Kind),ce("TEXCOORD_5",ut.UV6Kind),ce("JOINTS_0",ut.MatricesIndicesKind),ce("WEIGHTS_0",ut.MatricesWeightsKind),ce("JOINTS_1",ut.MatricesIndicesExtraKind),ce("WEIGHTS_1",ut.MatricesWeightsExtraKind),ce("COLOR_0",ut.ColorKind,Te=>{Te.type==="VEC4"&&(E.hasVertexAlpha=!0)}),Promise.all(ne).then(()=>xe)}_createMorphTargets(p,_,E,A,$){if(!A.targets)return;if(_._numMorphTargets==null)_._numMorphTargets=A.targets.length;else if(A.targets.length!==_._numMorphTargets)throw new Error(`${p}: Primitives do not have the same number of targets`);const ne=E.extras?E.extras.targetNames:null;this._babylonScene._blockEntityCollection=!!this._assetContainer,$.morphTargetManager=new cc(this._babylonScene),$.morphTargetManager._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,$.morphTargetManager.areUpdatesFrozen=!0;for(let xe=0;xe<A.targets.length;xe++){const ce=_.weights?_.weights[xe]:E.weights?E.weights[xe]:0,Te=ne?ne[xe]:`morphTarget${xe}`;$.morphTargetManager.addTarget(new lu(Te,ce,$.getScene()))}}_loadMorphTargetsAsync(p,_,E,A){if(!_.targets)return Promise.resolve();const $=new Array,ne=E.morphTargetManager;for(let xe=0;xe<ne.numTargets;xe++){const ce=ne.getTarget(xe);$.push(this._loadMorphTargetVertexDataAsync(`${p}/targets/${xe}`,A,_.targets[xe],ce))}return Promise.all($).then(()=>{ne.areUpdatesFrozen=!1})}_loadMorphTargetVertexDataAsync(p,_,E,A){const $=new Array,ne=(xe,ce,Te)=>{if(E[xe]==null)return;const Re=_.getVertexBuffer(ce);if(!Re)return;const ke=Wr.Get(`${p}/${xe}`,this._gltf.accessors,E[xe]);$.push(this._loadFloatAccessorAsync(`/accessors/${ke.index}`,ke).then(We=>{Te(Re,We)}))};return ne("POSITION",ut.PositionKind,(xe,ce)=>{const Te=new Float32Array(ce.length);xe.forEach(ce.length,(Re,ke)=>{Te[ke]=ce[ke]+Re}),A.setPositions(Te)}),ne("NORMAL",ut.NormalKind,(xe,ce)=>{const Te=new Float32Array(ce.length);xe.forEach(Te.length,(Re,ke)=>{Te[ke]=ce[ke]+Re}),A.setNormals(Te)}),ne("TANGENT",ut.TangentKind,(xe,ce)=>{const Te=new Float32Array(ce.length/3*4);let Re=0;xe.forEach(ce.length/3*4,(ke,We)=>{(We+1)%4!==0&&(Te[Re]=ce[Re]+ke,Re++)}),A.setTangents(Te)}),Promise.all($).then(()=>{})}static _LoadTransform(p,_){if(p.skin!=null)return;let E=nt.Zero(),A=_s.Identity(),$=nt.One();p.matrix?Yt.FromArray(p.matrix).decompose($,A,E):(p.translation&&(E=nt.FromArray(p.translation)),p.rotation&&(A=_s.FromArray(p.rotation)),p.scale&&($=nt.FromArray(p.scale))),_.position=E,_.rotationQuaternion=A,_.scaling=$}_loadSkinAsync(p,_,E,A){const $=this._extensionsLoadSkinAsync(p,_,E);if($)return $;if(E._data)return A(E._data.babylonSkeleton),E._data.promise;const ne=`skeleton${E.index}`;this._babylonScene._blockEntityCollection=!!this._assetContainer;const xe=new Ug(E.name||ne,ne,this._babylonScene);xe._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,this._loadBones(p,E,xe);const ce=this._loadSkinInverseBindMatricesDataAsync(p,E).then(Te=>{this._updateBoneMatrices(xe,Te)});return E._data={babylonSkeleton:xe,promise:ce},A(xe),ce}_loadBones(p,_,E){if(_.skeleton==null||this._parent.alwaysComputeSkeletonRootNode){const $=this._findSkeletonRootNode(`${p}/joints`,_.joints);if($)if(_.skeleton===void 0)_.skeleton=$.index;else{const ne=(ce,Te)=>{for(;Te.parent;Te=Te.parent)if(Te.parent===ce)return!0;return!1},xe=Wr.Get(`${p}/skeleton`,this._gltf.nodes,_.skeleton);xe!==$&&!ne(xe,$)&&(vi.Warn(`${p}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`),_.skeleton=$.index)}else vi.Warn(`${p}: Failed to find common root`)}const A={};for(const $ of _.joints){const ne=Wr.Get(`${p}/joints/${$}`,this._gltf.nodes,$);this._loadBone(ne,_,E,A)}}_findSkeletonRootNode(p,_){if(_.length===0)return null;const E={};for(const $ of _){const ne=[];let xe=Wr.Get(`${p}/${$}`,this._gltf.nodes,$);for(;xe.index!==-1;)ne.unshift(xe),xe=xe.parent;E[$]=ne}let A=null;for(let $=0;;++$){let ne=E[_[0]];if($>=ne.length)return A;const xe=ne[$];for(let ce=1;ce<_.length;++ce)if(ne=E[_[ce]],$>=ne.length||xe!==ne[$])return A;A=xe}}_loadBone(p,_,E,A){let $=A[p.index];if($)return $;let ne=null;p.index!==_.skeleton&&(p.parent&&p.parent.index!==-1?ne=this._loadBone(p.parent,_,E,A):_.skeleton!==void 0&&vi.Warn(`/skins/${_.index}/skeleton: Skeleton node is not a common root`));const xe=_.joints.indexOf(p.index);return $=new pa(p.name||`joint${p.index}`,E,ne,this._getNodeMatrix(p),null,null,xe),A[p.index]=$,this._postSceneLoadActions.push(()=>{$.linkTransformNode(p._babylonTransformNode)}),$}_loadSkinInverseBindMatricesDataAsync(p,_){if(_.inverseBindMatrices==null)return Promise.resolve(null);const E=Wr.Get(`${p}/inverseBindMatrices`,this._gltf.accessors,_.inverseBindMatrices);return this._loadFloatAccessorAsync(`/accessors/${E.index}`,E)}_updateBoneMatrices(p,_){for(const E of p.bones){const A=Yt.Identity(),$=E._index;_&&$!==-1&&(Yt.FromArrayToRef(_,$*16,A),A.invertToRef(A));const ne=E.getParent();ne&&A.multiplyToRef(ne.getAbsoluteInverseBindMatrix(),A),E.updateMatrix(A,!1,!1),E._updateAbsoluteBindMatrices(void 0,!1)}}_getNodeMatrix(p){return p.matrix?Yt.FromArray(p.matrix):Yt.Compose(p.scale?nt.FromArray(p.scale):nt.One(),p.rotation?_s.FromArray(p.rotation):_s.Identity(),p.translation?nt.FromArray(p.translation):nt.Zero())}loadCameraAsync(p,_,E=()=>{}){const A=this._extensionsLoadCameraAsync(p,_,E);if(A)return A;const $=new Array;this.logOpen(`${p} ${_.name||""}`),this._babylonScene._blockEntityCollection=!!this._assetContainer;const ne=new wu(_.name||`camera${_.index}`,nt.Zero(),this._babylonScene,!1);switch(ne._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,ne.ignoreParentScaling=!0,_._babylonCamera=ne,ne.rotation.set(0,Math.PI,0),_.type){case"perspective":{const xe=_.perspective;if(!xe)throw new Error(`${p}: Camera perspective properties are missing`);ne.fov=xe.yfov,ne.minZ=xe.znear,ne.maxZ=xe.zfar||0;break}case"orthographic":{if(!_.orthographic)throw new Error(`${p}: Camera orthographic properties are missing`);ne.mode=Hr.ORTHOGRAPHIC_CAMERA,ne.orthoLeft=-_.orthographic.xmag,ne.orthoRight=_.orthographic.xmag,ne.orthoBottom=-_.orthographic.ymag,ne.orthoTop=_.orthographic.ymag,ne.minZ=_.orthographic.znear,ne.maxZ=_.orthographic.zfar;break}default:throw new Error(`${p}: Invalid camera type (${_.type})`)}return qs.AddPointerMetadata(ne,p),this._parent.onCameraLoadedObservable.notifyObservers(ne),E(ne),this.logClose(),Promise.all($).then(()=>ne)}_loadAnimationsAsync(){const p=this._gltf.animations;if(!p)return Promise.resolve();const _=new Array;for(let E=0;E<p.length;E++){const A=p[E];_.push(this.loadAnimationAsync(`/animations/${A.index}`,A).then($=>{$.targetedAnimations.length===0&&$.dispose()}))}return Promise.all(_).then(()=>{})}loadAnimationAsync(p,_){const E=this._extensionsLoadAnimationAsync(p,_);if(E)return E;this._babylonScene._blockEntityCollection=!!this._assetContainer;const A=new uh(_.name||`animation${_.index}`,this._babylonScene);A._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,_._babylonAnimationGroup=A;const $=new Array;Wr.Assign(_.channels),Wr.Assign(_.samplers);for(const ne of _.channels)$.push(this._loadAnimationChannelAsync(`${p}/channels/${ne.index}`,p,_,ne,(xe,ce)=>{xe.animations=xe.animations||[],xe.animations.push(ce),A.addTargetedAnimation(ce,xe)}));return Promise.all($).then(()=>(A.normalize(0),A))}_loadAnimationChannelAsync(p,_,E,A,$){const ne=this._extensionsLoadAnimationChannelAsync(p,_,E,A,$);if(ne)return ne;if(A.target.node==null)return Promise.resolve();const xe=Wr.Get(`${p}/target/node`,this._gltf.nodes,A.target.node);if(A.target.path==="weights"&&!xe._numMorphTargets||A.target.path!=="weights"&&!xe._babylonTransformNode)return Promise.resolve();let ce;switch(A.target.path){case"translation":{ce=vm.translation;break}case"rotation":{ce=vm.rotation;break}case"scale":{ce=vm.scale;break}case"weights":{ce=vm.weights;break}default:throw new Error(`${p}/target/path: Invalid value (${A.target.path})`)}const Te={object:xe,info:ce};return this._loadAnimationChannelFromTargetInfoAsync(p,_,E,A,Te,$)}_loadAnimationChannelFromTargetInfoAsync(p,_,E,A,$,ne){const xe=this.parent.targetFps,ce=1/xe,Te=Wr.Get(`${p}/sampler`,E.samplers,A.sampler);return this._loadAnimationSamplerAsync(`${_}/samplers/${A.sampler}`,Te).then(Re=>{let ke=0;const We=$.object,Xe=$.info;for(const xt of Xe){const qe=xt.getStride(We),ht=Re.input,Nt=Re.output,wt=new Array(ht.length);let Qt=0;switch(Re.interpolation){case"STEP":{for(let Ht=0;Ht<ht.length;Ht++){const Wt=xt.getValue(We,Nt,Qt,1);Qt+=qe,wt[Ht]={frame:ht[Ht]*xe,value:Wt,interpolation:kg.STEP}}break}case"CUBICSPLINE":{for(let Ht=0;Ht<ht.length;Ht++){const Wt=xt.getValue(We,Nt,Qt,ce);Qt+=qe;const zt=xt.getValue(We,Nt,Qt,1);Qt+=qe;const xi=xt.getValue(We,Nt,Qt,ce);Qt+=qe,wt[Ht]={frame:ht[Ht]*xe,inTangent:Wt,value:zt,outTangent:xi}}break}case"LINEAR":{for(let Ht=0;Ht<ht.length;Ht++){const Wt=xt.getValue(We,Nt,Qt,1);Qt+=qe,wt[Ht]={frame:ht[Ht]*xe,value:Wt}}break}}if(Qt>0){const Ht=`${E.name||`animation${E.index}`}_channel${A.index}_${ke}`;xt.buildAnimations(We,Ht,xe,wt,(Wt,zt)=>{++ke,ne(Wt,zt)})}}})}_loadAnimationSamplerAsync(p,_){if(_._data)return _._data;const E=_.interpolation||"LINEAR";switch(E){case"STEP":case"LINEAR":case"CUBICSPLINE":break;default:throw new Error(`${p}/interpolation: Invalid value (${_.interpolation})`)}const A=Wr.Get(`${p}/input`,this._gltf.accessors,_.input),$=Wr.Get(`${p}/output`,this._gltf.accessors,_.output);return _._data=Promise.all([this._loadFloatAccessorAsync(`/accessors/${A.index}`,A),this._loadFloatAccessorAsync(`/accessors/${$.index}`,$)]).then(([ne,xe])=>({input:ne,interpolation:E,output:xe})),_._data}loadBufferAsync(p,_,E,A){const $=this._extensionsLoadBufferAsync(p,_,E,A);if($)return $;if(!_._data)if(_.uri)_._data=this.loadUriAsync(`${p}/uri`,_,_.uri);else{if(!this._bin)throw new Error(`${p}: Uri is missing or the binary glTF is missing its binary chunk`);_._data=this._bin.readAsync(0,_.byteLength)}return _._data.then(ne=>{try{return new Uint8Array(ne.buffer,ne.byteOffset+E,A)}catch(xe){throw new Error(`${p}: ${xe.message}`)}})}loadBufferViewAsync(p,_){const E=this._extensionsLoadBufferViewAsync(p,_);if(E)return E;if(_._data)return _._data;const A=Wr.Get(`${p}/buffer`,this._gltf.buffers,_.buffer);return _._data=this.loadBufferAsync(`/buffers/${A.index}`,A,_.byteOffset||0,_.byteLength),_._data}_loadAccessorAsync(p,_,E){if(_._data)return _._data;const A=qs._GetNumComponents(p,_.type),$=A*ut.GetTypeByteLength(_.componentType),ne=A*_.count;if(_.bufferView==null)_._data=Promise.resolve(new E(ne));else{const xe=Wr.Get(`${p}/bufferView`,this._gltf.bufferViews,_.bufferView);_._data=this.loadBufferViewAsync(`/bufferViews/${xe.index}`,xe).then(ce=>{if(_.componentType===5126&&!_.normalized&&(!xe.byteStride||xe.byteStride===$))return qs._GetTypedArray(p,_.componentType,ce,_.byteOffset,ne);{const Te=new E(ne);return ut.ForEach(ce,_.byteOffset||0,xe.byteStride||$,A,_.componentType,Te.length,_.normalized||!1,(Re,ke)=>{Te[ke]=Re}),Te}})}if(_.sparse){const xe=_.sparse;_._data=_._data.then(ce=>{const Te=ce,Re=Wr.Get(`${p}/sparse/indices/bufferView`,this._gltf.bufferViews,xe.indices.bufferView),ke=Wr.Get(`${p}/sparse/values/bufferView`,this._gltf.bufferViews,xe.values.bufferView);return Promise.all([this.loadBufferViewAsync(`/bufferViews/${Re.index}`,Re),this.loadBufferViewAsync(`/bufferViews/${ke.index}`,ke)]).then(([We,Xe])=>{const xt=qs._GetTypedArray(`${p}/sparse/indices`,xe.indices.componentType,We,xe.indices.byteOffset,xe.count),qe=A*xe.count;let ht;if(_.componentType===5126&&!_.normalized)ht=qs._GetTypedArray(`${p}/sparse/values`,_.componentType,Xe,xe.values.byteOffset,qe);else{const wt=qs._GetTypedArray(`${p}/sparse/values`,_.componentType,Xe,xe.values.byteOffset,qe);ht=new E(qe),ut.ForEach(wt,0,$,A,_.componentType,ht.length,_.normalized||!1,(Qt,Ht)=>{ht[Ht]=Qt})}let Nt=0;for(let wt=0;wt<xt.length;wt++){let Qt=xt[wt]*A;for(let Ht=0;Ht<A;Ht++)Te[Qt++]=ht[Nt++]}return Te})})}return _._data}_loadFloatAccessorAsync(p,_){return this._loadAccessorAsync(p,_,Float32Array)}_loadIndicesAccessorAsync(p,_){if(_.type!=="SCALAR")throw new Error(`${p}/type: Invalid value ${_.type}`);if(_.componentType!==5121&&_.componentType!==5123&&_.componentType!==5125)throw new Error(`${p}/componentType: Invalid value ${_.componentType}`);if(_._data)return _._data;if(_.sparse){const E=qs._GetTypedArrayConstructor(`${p}/componentType`,_.componentType);_._data=this._loadAccessorAsync(p,_,E)}else{const E=Wr.Get(`${p}/bufferView`,this._gltf.bufferViews,_.bufferView);_._data=this.loadBufferViewAsync(`/bufferViews/${E.index}`,E).then(A=>qs._GetTypedArray(p,_.componentType,A,_.byteOffset,_.count))}return _._data}_loadVertexBufferViewAsync(p){if(p._babylonBuffer)return p._babylonBuffer;const _=this._babylonScene.getEngine();return p._babylonBuffer=this.loadBufferViewAsync(`/bufferViews/${p.index}`,p).then(E=>new vu(_,E,!1)),p._babylonBuffer}_loadVertexAccessorAsync(p,_,E){if(_._babylonVertexBuffer?.[E])return _._babylonVertexBuffer[E];_._babylonVertexBuffer||(_._babylonVertexBuffer={});const A=this._babylonScene.getEngine();if(_.sparse||_.bufferView==null)_._babylonVertexBuffer[E]=this._loadFloatAccessorAsync(p,_).then($=>new ut(A,$,E,!1));else if(E===ut.MatricesIndicesKind||E===ut.MatricesIndicesExtraKind)_._babylonVertexBuffer[E]=this._loadFloatAccessorAsync(p,_).then($=>new ut(A,$,E,!1));else{const $=Wr.Get(`${p}/bufferView`,this._gltf.bufferViews,_.bufferView);_._babylonVertexBuffer[E]=this._loadVertexBufferViewAsync($).then(ne=>{const xe=qs._GetNumComponents(p,_.type);return new ut(A,ne,E,!1,void 0,$.byteStride,void 0,_.byteOffset,xe,_.componentType,_.normalized,!0,void 0,!0)})}return _._babylonVertexBuffer[E]}_loadMaterialMetallicRoughnessPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const A=new Array;return _&&(_.baseColorFactor?(E.albedoColor=ws.FromArray(_.baseColorFactor),E.alpha=_.baseColorFactor[3]):E.albedoColor=ws.White(),E.metallic=_.metallicFactor==null?1:_.metallicFactor,E.roughness=_.roughnessFactor==null?1:_.roughnessFactor,_.baseColorTexture&&A.push(this.loadTextureInfoAsync(`${p}/baseColorTexture`,_.baseColorTexture,$=>{$.name=`${E.name} (Base Color)`,E.albedoTexture=$})),_.metallicRoughnessTexture&&(_.metallicRoughnessTexture.nonColorData=!0,A.push(this.loadTextureInfoAsync(`${p}/metallicRoughnessTexture`,_.metallicRoughnessTexture,$=>{$.name=`${E.name} (Metallic Roughness)`,E.metallicTexture=$})),E.useMetallnessFromMetallicTextureBlue=!0,E.useRoughnessFromMetallicTextureGreen=!0,E.useRoughnessFromMetallicTextureAlpha=!1)),Promise.all(A).then(()=>{})}_loadMaterialAsync(p,_,E,A,$=()=>{}){const ne=this._extensionsLoadMaterialAsync(p,_,E,A,$);if(ne)return ne;_._data=_._data||{};let xe=_._data[A];if(!xe){this.logOpen(`${p} ${_.name||""}`);const ce=this.createMaterial(p,_,A);xe={babylonMaterial:ce,babylonMeshes:[],promise:this.loadMaterialPropertiesAsync(p,_,ce)},_._data[A]=xe,qs.AddPointerMetadata(ce,p),this._parent.onMaterialLoadedObservable.notifyObservers(ce),this.logClose()}return E&&(xe.babylonMeshes.push(E),E.onDisposeObservable.addOnce(()=>{const ce=xe.babylonMeshes.indexOf(E);ce!==-1&&xe.babylonMeshes.splice(ce,1)})),$(xe.babylonMaterial),xe.promise.then(()=>xe.babylonMaterial)}_createDefaultMaterial(p,_){this._babylonScene._blockEntityCollection=!!this._assetContainer;const E=new Ys(p,this._babylonScene);return E._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,E.fillMode=_,E.enableSpecularAntiAliasing=!0,E.useRadianceOverAlpha=!this._parent.transparencyAsCoverage,E.useSpecularOverAlpha=!this._parent.transparencyAsCoverage,E.transparencyMode=Ys.PBRMATERIAL_OPAQUE,E.metallic=1,E.roughness=1,E}createMaterial(p,_,E){const A=this._extensionsCreateMaterial(p,_,E);if(A)return A;const $=_.name||`material${_.index}`;return this._createDefaultMaterial($,E)}loadMaterialPropertiesAsync(p,_,E){const A=this._extensionsLoadMaterialPropertiesAsync(p,_,E);if(A)return A;const $=new Array;return $.push(this.loadMaterialBasePropertiesAsync(p,_,E)),_.pbrMetallicRoughness&&$.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${p}/pbrMetallicRoughness`,_.pbrMetallicRoughness,E)),this.loadMaterialAlphaProperties(p,_,E),Promise.all($).then(()=>{})}loadMaterialBasePropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const A=new Array;return E.emissiveColor=_.emissiveFactor?ws.FromArray(_.emissiveFactor):new ws(0,0,0),_.doubleSided&&(E.backFaceCulling=!1,E.twoSidedLighting=!0),_.normalTexture&&(_.normalTexture.nonColorData=!0,A.push(this.loadTextureInfoAsync(`${p}/normalTexture`,_.normalTexture,$=>{$.name=`${E.name} (Normal)`,E.bumpTexture=$})),E.invertNormalMapX=!this._babylonScene.useRightHandedSystem,E.invertNormalMapY=this._babylonScene.useRightHandedSystem,_.normalTexture.scale!=null&&E.bumpTexture&&(E.bumpTexture.level=_.normalTexture.scale),E.forceIrradianceInFragment=!0),_.occlusionTexture&&(_.occlusionTexture.nonColorData=!0,A.push(this.loadTextureInfoAsync(`${p}/occlusionTexture`,_.occlusionTexture,$=>{$.name=`${E.name} (Occlusion)`,E.ambientTexture=$})),E.useAmbientInGrayScale=!0,_.occlusionTexture.strength!=null&&(E.ambientTextureStrength=_.occlusionTexture.strength)),_.emissiveTexture&&A.push(this.loadTextureInfoAsync(`${p}/emissiveTexture`,_.emissiveTexture,$=>{$.name=`${E.name} (Emissive)`,E.emissiveTexture=$})),Promise.all(A).then(()=>{})}loadMaterialAlphaProperties(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);switch(_.alphaMode||"OPAQUE"){case"OPAQUE":{E.transparencyMode=Ys.PBRMATERIAL_OPAQUE,E.alpha=1;break}case"MASK":{E.transparencyMode=Ys.PBRMATERIAL_ALPHATEST,E.alphaCutOff=_.alphaCutoff==null?.5:_.alphaCutoff,E.albedoTexture&&(E.albedoTexture.hasAlpha=!0);break}case"BLEND":{E.transparencyMode=Ys.PBRMATERIAL_ALPHABLEND,E.albedoTexture&&(E.albedoTexture.hasAlpha=!0,E.useAlphaFromAlbedoTexture=!0);break}default:throw new Error(`${p}/alphaMode: Invalid value (${_.alphaMode})`)}}loadTextureInfoAsync(p,_,E=()=>{}){const A=this._extensionsLoadTextureInfoAsync(p,_,E);if(A)return A;if(this.logOpen(`${p}`),_.texCoord>=6)throw new Error(`${p}/texCoord: Invalid value (${_.texCoord})`);const $=Wr.Get(`${p}/index`,this._gltf.textures,_.index);$._textureInfo=_;const ne=this._loadTextureAsync(`/textures/${_.index}`,$,xe=>{xe.coordinatesIndex=_.texCoord||0,qs.AddPointerMetadata(xe,p),this._parent.onTextureLoadedObservable.notifyObservers(xe),E(xe)});return this.logClose(),ne}_loadTextureAsync(p,_,E=()=>{}){const A=this._extensionsLoadTextureAsync(p,_,E);if(A)return A;this.logOpen(`${p} ${_.name||""}`);const $=_.sampler==null?qs.DefaultSampler:Wr.Get(`${p}/sampler`,this._gltf.samplers,_.sampler),ne=Wr.Get(`${p}/source`,this._gltf.images,_.source),xe=this._createTextureAsync(p,$,ne,E,void 0,!_._textureInfo.nonColorData);return this.logClose(),xe}_createTextureAsync(p,_,E,A=()=>{},$,ne){const xe=this._loadSampler(`/samplers/${_.index}`,_),ce=new Array,Te=new um;this._babylonScene._blockEntityCollection=!!this._assetContainer;const Re={noMipmap:xe.noMipMaps,invertY:!1,samplingMode:xe.samplingMode,onLoad:()=>{this._disposed||Te.resolve()},onError:(We,Xe)=>{this._disposed||Te.reject(new Error(`${p}: ${Xe&&Xe.message?Xe.message:We||"Failed to load texture"}`))},mimeType:E.mimeType,loaderOptions:$,useSRGBBuffer:!!ne&&this._parent.useSRGBBuffers},ke=new Hi(null,this._babylonScene,Re);return ke._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,ce.push(Te.promise),ce.push(this.loadImageAsync(`/images/${E.index}`,E).then(We=>{const Xe=E.uri||`${this._fileName}#image${E.index}`,xt=`data:${this._uniqueRootUrl}${Xe}`;ke.updateURL(xt,We)})),ke.wrapU=xe.wrapU,ke.wrapV=xe.wrapV,A(ke),Promise.all(ce).then(()=>ke)}_loadSampler(p,_){return _._data||(_._data={noMipMaps:_.minFilter===9728||_.minFilter===9729,samplingMode:qs._GetTextureSamplingMode(p,_),wrapU:qs._GetTextureWrapMode(`${p}/wrapS`,_.wrapS),wrapV:qs._GetTextureWrapMode(`${p}/wrapT`,_.wrapT)}),_._data}loadImageAsync(p,_){if(!_._data){if(this.logOpen(`${p} ${_.name||""}`),_.uri)_._data=this.loadUriAsync(`${p}/uri`,_,_.uri);else{const E=Wr.Get(`${p}/bufferView`,this._gltf.bufferViews,_.bufferView);_._data=this.loadBufferViewAsync(`/bufferViews/${E.index}`,E)}this.logClose()}return _._data}loadUriAsync(p,_,E){const A=this._extensionsLoadUriAsync(p,_,E);if(A)return A;if(!qs._ValidateUri(E))throw new Error(`${p}: '${E}' is invalid`);if(kl(E)){const $=new Uint8Array(Ul(E));return this.log(`${p}: Decoded ${E.substr(0,64)}... (${$.length} bytes)`),Promise.resolve($)}return this.log(`${p}: Loading ${E}`),this._parent.preprocessUrlAsync(this._rootUrl+E).then($=>new Promise((ne,xe)=>{this._parent._loadFile(this._babylonScene,$,ce=>{this._disposed||(this.log(`${p}: Loaded ${E} (${ce.byteLength} bytes)`),ne(new Uint8Array(ce)))},!0,ce=>{xe(new Ml(`${p}: Failed to load '${E}'${ce?": "+ce.status+" "+ce.statusText:""}`,ce))})}))}static AddPointerMetadata(p,_){p.metadata=p.metadata||{};const E=p._internalMetadata=p._internalMetadata||{},A=E.gltf=E.gltf||{};(A.pointers=A.pointers||[]).push(_)}static _GetTextureWrapMode(p,_){switch(_=_??10497,_){case 33071:return Hi.CLAMP_ADDRESSMODE;case 33648:return Hi.MIRROR_ADDRESSMODE;case 10497:return Hi.WRAP_ADDRESSMODE;default:return vi.Warn(`${p}: Invalid value (${_})`),Hi.WRAP_ADDRESSMODE}}static _GetTextureSamplingMode(p,_){const E=_.magFilter==null?9729:_.magFilter,A=_.minFilter==null?9987:_.minFilter;if(E===9729)switch(A){case 9728:return Hi.LINEAR_NEAREST;case 9729:return Hi.LINEAR_LINEAR;case 9984:return Hi.LINEAR_NEAREST_MIPNEAREST;case 9985:return Hi.LINEAR_LINEAR_MIPNEAREST;case 9986:return Hi.LINEAR_NEAREST_MIPLINEAR;case 9987:return Hi.LINEAR_LINEAR_MIPLINEAR;default:return vi.Warn(`${p}/minFilter: Invalid value (${A})`),Hi.LINEAR_LINEAR_MIPLINEAR}else switch(E!==9728&&vi.Warn(`${p}/magFilter: Invalid value (${E})`),A){case 9728:return Hi.NEAREST_NEAREST;case 9729:return Hi.NEAREST_LINEAR;case 9984:return Hi.NEAREST_NEAREST_MIPNEAREST;case 9985:return Hi.NEAREST_LINEAR_MIPNEAREST;case 9986:return Hi.NEAREST_NEAREST_MIPLINEAR;case 9987:return Hi.NEAREST_LINEAR_MIPLINEAR;default:return vi.Warn(`${p}/minFilter: Invalid value (${A})`),Hi.NEAREST_NEAREST_MIPNEAREST}}static _GetTypedArrayConstructor(p,_){switch(_){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:throw new Error(`${p}: Invalid component type ${_}`)}}static _GetTypedArray(p,_,E,A,$){const ne=E.buffer;A=E.byteOffset+(A||0);const xe=qs._GetTypedArrayConstructor(`${p}/componentType`,_),ce=ut.GetTypeByteLength(_);return A%ce!==0?(vi.Warn(`${p}: Copying buffer as byte offset (${A}) is not a multiple of component type byte length (${ce})`),new xe(ne.slice(A,A+$*ce),0)):new xe(ne,A,$)}static _GetNumComponents(p,_){switch(_){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16}throw new Error(`${p}: Invalid type (${_})`)}static _ValidateUri(p){return ct.IsBase64(p)||p.indexOf("..")===-1}static _GetDrawMode(p,_){switch(_==null&&(_=4),_){case 0:return Xi.PointListDrawMode;case 1:return Xi.LineListDrawMode;case 2:return Xi.LineLoopDrawMode;case 3:return Xi.LineStripDrawMode;case 4:return Xi.TriangleFillMode;case 5:return Xi.TriangleStripDrawMode;case 6:return Xi.TriangleFanDrawMode}throw new Error(`${p}: Invalid mesh primitive mode (${_})`)}_compileMaterialsAsync(){this._parent._startPerformanceCounter("Compile materials");const p=new Array;if(this._gltf.materials){for(const _ of this._gltf.materials)if(_._data)for(const E in _._data){const A=_._data[E];for(const $ of A.babylonMeshes){$.computeWorldMatrix(!0);const ne=A.babylonMaterial;p.push(ne.forceCompilationAsync($)),p.push(ne.forceCompilationAsync($,{useInstances:!0})),this._parent.useClipPlane&&(p.push(ne.forceCompilationAsync($,{clipPlane:!0})),p.push(ne.forceCompilationAsync($,{clipPlane:!0,useInstances:!0})))}}}return Promise.all(p).then(()=>{this._parent._endPerformanceCounter("Compile materials")})}_compileShadowGeneratorsAsync(){this._parent._startPerformanceCounter("Compile shadow generators");const p=new Array,_=this._babylonScene.lights;for(const E of _){const A=E.getShadowGenerator();A&&p.push(A.forceCompilationAsync())}return Promise.all(p).then(()=>{this._parent._endPerformanceCounter("Compile shadow generators")})}_forEachExtensions(p){for(const _ of this._extensions)_.enabled&&p(_)}_applyExtensions(p,_,E){for(const A of this._extensions)if(A.enabled){const $=`${A.name}.${_}`,ne=p;ne._activeLoaderExtensionFunctions=ne._activeLoaderExtensionFunctions||{};const xe=ne._activeLoaderExtensionFunctions;if(!xe[$]){xe[$]=!0;try{const ce=E(A);if(ce)return ce}finally{delete xe[$]}}}return null}_extensionsOnLoading(){this._forEachExtensions(p=>p.onLoading&&p.onLoading())}_extensionsOnReady(){this._forEachExtensions(p=>p.onReady&&p.onReady())}_extensionsLoadSceneAsync(p,_){return this._applyExtensions(_,"loadScene",E=>E.loadSceneAsync&&E.loadSceneAsync(p,_))}_extensionsLoadNodeAsync(p,_,E){return this._applyExtensions(_,"loadNode",A=>A.loadNodeAsync&&A.loadNodeAsync(p,_,E))}_extensionsLoadCameraAsync(p,_,E){return this._applyExtensions(_,"loadCamera",A=>A.loadCameraAsync&&A.loadCameraAsync(p,_,E))}_extensionsLoadVertexDataAsync(p,_,E){return this._applyExtensions(_,"loadVertexData",A=>A._loadVertexDataAsync&&A._loadVertexDataAsync(p,_,E))}_extensionsLoadMeshPrimitiveAsync(p,_,E,A,$,ne){return this._applyExtensions($,"loadMeshPrimitive",xe=>xe._loadMeshPrimitiveAsync&&xe._loadMeshPrimitiveAsync(p,_,E,A,$,ne))}_extensionsLoadMaterialAsync(p,_,E,A,$){return this._applyExtensions(_,"loadMaterial",ne=>ne._loadMaterialAsync&&ne._loadMaterialAsync(p,_,E,A,$))}_extensionsCreateMaterial(p,_,E){return this._applyExtensions(_,"createMaterial",A=>A.createMaterial&&A.createMaterial(p,_,E))}_extensionsLoadMaterialPropertiesAsync(p,_,E){return this._applyExtensions(_,"loadMaterialProperties",A=>A.loadMaterialPropertiesAsync&&A.loadMaterialPropertiesAsync(p,_,E))}_extensionsLoadTextureInfoAsync(p,_,E){return this._applyExtensions(_,"loadTextureInfo",A=>A.loadTextureInfoAsync&&A.loadTextureInfoAsync(p,_,E))}_extensionsLoadTextureAsync(p,_,E){return this._applyExtensions(_,"loadTexture",A=>A._loadTextureAsync&&A._loadTextureAsync(p,_,E))}_extensionsLoadAnimationAsync(p,_){return this._applyExtensions(_,"loadAnimation",E=>E.loadAnimationAsync&&E.loadAnimationAsync(p,_))}_extensionsLoadAnimationChannelAsync(p,_,E,A,$){return this._applyExtensions(E,"loadAnimationChannel",ne=>ne._loadAnimationChannelAsync&&ne._loadAnimationChannelAsync(p,_,E,A,$))}_extensionsLoadSkinAsync(p,_,E){return this._applyExtensions(E,"loadSkin",A=>A._loadSkinAsync&&A._loadSkinAsync(p,_,E))}_extensionsLoadUriAsync(p,_,E){return this._applyExtensions(_,"loadUri",A=>A._loadUriAsync&&A._loadUriAsync(p,_,E))}_extensionsLoadBufferViewAsync(p,_){return this._applyExtensions(_,"loadBufferView",E=>E.loadBufferViewAsync&&E.loadBufferViewAsync(p,_))}_extensionsLoadBufferAsync(p,_,E,A){return this._applyExtensions(_,"loadBuffer",$=>$.loadBufferAsync&&$.loadBufferAsync(p,_,E,A))}static LoadExtensionAsync(p,_,E,A){if(!_.extensions)return null;const ne=_.extensions[E];return ne?A(`${p}/extensions/${E}`,ne):null}static LoadExtraAsync(p,_,E,A){if(!_.extras)return null;const ne=_.extras[E];return ne?A(`${p}/extras/${E}`,ne):null}isExtensionUsed(p){return!!this._gltf.extensionsUsed&&this._gltf.extensionsUsed.indexOf(p)!==-1}logOpen(p){this._parent._logOpen(p)}logClose(){this._parent._logClose()}log(p){this._parent._log(p)}startPerformanceCounter(p){this._parent._startPerformanceCounter(p)}endPerformanceCounter(p){this._parent._endPerformanceCounter(p)}}qs._RegisteredExtensions={},qs.DefaultSampler={index:-1},H0._CreateGLTF2Loader=_e=>new qs(_e);class P_ extends Lo{constructor(p,_,E,A=5,$=0,ne=!1,xe=!1,ce=3,Te=null){super("",p),this._texture=p.getEngine().createRawCubeTexture(_,E,A,$,ne,xe,ce,Te)}update(p,_,E,A,$=null){this._texture.getEngine().updateRawCubeTexture(this._texture,p,_,E,A,$)}updateRGBDAsync(p,_=null,E=.8,A=0){return YF(this._texture,p,_,E,A).then(()=>{})}clone(){return Xr.Clone(()=>{const p=this.getScene(),_=this._texture,E=new P_(p,_._bufferViewArray,_.width,_.format,_.type,_.generateMipMaps,_.invertY,_.samplingMode,_._compression);return _.source===Gn.CubeRawRGBD&&E.updateRGBDAsync(_._bufferViewArrayArray,_._sphericalPolynomial,_._lodGenerationScale,_._lodGenerationOffset),E},this)}}const O_="EXT_lights_image_based";class $L{constructor(p){this.name=O_,this._loader=p,this.enabled=this._loader.isExtensionUsed(O_)}dispose(){this._loader=null,delete this._lights}onLoading(){const p=this._loader.gltf.extensions;if(p&&p[this.name]){const _=p[this.name];this._lights=_.lights}}loadSceneAsync(p,_){return qs.LoadExtensionAsync(p,_,this.name,(E,A)=>{this._loader._allMaterialsDirtyRequired=!0;const $=new Array;$.push(this._loader.loadSceneAsync(p,_)),this._loader.logOpen(`${E}`);const ne=Wr.Get(`${E}/light`,this._lights,A.light);return $.push(this._loadLightAsync(`/extensions/${this.name}/lights/${A.light}`,ne).then(xe=>{this._loader.babylonScene.environmentTexture=xe})),this._loader.logClose(),Promise.all($).then(()=>{})})}_loadLightAsync(p,_){if(!_._loaded){const E=new Array;this._loader.logOpen(`${p}`);const A=new Array(_.specularImages.length);for(let $=0;$<_.specularImages.length;$++){const ne=_.specularImages[$];A[$]=new Array(ne.length);for(let xe=0;xe<ne.length;xe++){const ce=`${p}/specularImages/${$}/${xe}`;this._loader.logOpen(`${ce}`);const Te=ne[xe],Re=Wr.Get(ce,this._loader.gltf.images,Te);E.push(this._loader.loadImageAsync(`/images/${Te}`,Re).then(ke=>{A[$][xe]=ke})),this._loader.logClose()}}this._loader.logClose(),_._loaded=Promise.all(E).then(()=>{const $=new P_(this._loader.babylonScene,null,_.specularImageSize);if($.name=_.name||"environment",_._babylonTexture=$,_.intensity!=null&&($.level=_.intensity),_.rotation){let Te=_s.FromArray(_.rotation);this._loader.babylonScene.useRightHandedSystem||(Te=_s.Inverse(Te)),Yt.FromQuaternionToRef(Te,$.getReflectionTextureMatrix())}if(!_.irradianceCoefficients)throw new Error(`${p}: Irradiance coefficients are missing`);const ne=Hu.FromArray(_.irradianceCoefficients);ne.scaleInPlace(_.intensity),ne.convertIrradianceToLambertianRadiance();const xe=Xu.FromHarmonics(ne),ce=(A.length-1)/ri.Log2(_.specularImageSize);return $.updateRGBDAsync(A,xe,ce)})}return _._loaded.then(()=>_._babylonTexture)}}qs.RegisterExtension(O_,_e=>new $L(_e)),Lr.prototype.thinInstanceAdd=function(_e,p=!0){if(!this.getScene().getEngine().getCaps().instancedArrays)return vi.Error("Thin Instances are not supported on this device as Instanced Array extension not supported"),-1;this._thinInstanceUpdateBufferSize("matrix",Array.isArray(_e)?_e.length:1);const _=this._thinInstanceDataStorage.instancesCount;if(Array.isArray(_e))for(let E=0;E<_e.length;++E)this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,_e[E],E===_e.length-1&&p);else this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,_e,p);return _},Lr.prototype.thinInstanceAddSelf=function(_e=!0){return this.thinInstanceAdd(Yt.IdentityReadOnly,_e)},Lr.prototype.thinInstanceRegisterAttribute=function(_e,p){_e===ut.ColorKind&&(_e=ut.ColorInstanceKind),this.removeVerticesData(_e),this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.strides[_e]=p,this._userThinInstanceBuffersStorage.sizes[_e]=p*Math.max(32,this._thinInstanceDataStorage.instancesCount),this._userThinInstanceBuffersStorage.data[_e]=new Float32Array(this._userThinInstanceBuffersStorage.sizes[_e]),this._userThinInstanceBuffersStorage.vertexBuffers[_e]=new ut(this.getEngine(),this._userThinInstanceBuffersStorage.data[_e],_e,!0,!1,p,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[_e])},Lr.prototype.thinInstanceSetMatrixAt=function(_e,p,_=!0){if(!this._thinInstanceDataStorage.matrixData||_e>=this._thinInstanceDataStorage.instancesCount)return!1;const E=this._thinInstanceDataStorage.matrixData;return p.copyToArray(E,_e*16),this._thinInstanceDataStorage.worldMatrices&&(this._thinInstanceDataStorage.worldMatrices[_e]=p),_&&(this.thinInstanceBufferUpdated("matrix"),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)),!0},Lr.prototype.thinInstanceSetAttributeAt=function(_e,p,_,E=!0){return _e===ut.ColorKind&&(_e=ut.ColorInstanceKind),!this._userThinInstanceBuffersStorage||!this._userThinInstanceBuffersStorage.data[_e]||p>=this._thinInstanceDataStorage.instancesCount?!1:(this._thinInstanceUpdateBufferSize(_e,0),this._userThinInstanceBuffersStorage.data[_e].set(_,p*this._userThinInstanceBuffersStorage.strides[_e]),E&&this.thinInstanceBufferUpdated(_e),!0)},Object.defineProperty(Lr.prototype,"thinInstanceCount",{get:function(){return this._thinInstanceDataStorage.instancesCount},set:function(_e){const p=this._thinInstanceDataStorage.matrixData??this.source?._thinInstanceDataStorage.matrixData,_=p?p.length/16:0;_e<=_&&(this._thinInstanceDataStorage.instancesCount=_e)},enumerable:!0,configurable:!0}),Lr.prototype._thinInstanceCreateMatrixBuffer=function(_e,p,_=!0){_e===ut.ColorKind&&(_e=ut.ColorInstanceKind);const E=new vu(this.getEngine(),p,!_,16,!1,!0);for(let A=0;A<4;A++)this.setVerticesBuffer(E.createVertexBuffer(_e+A,A*4,4));return E},Lr.prototype.thinInstanceSetBuffer=function(_e,p,_=0,E=!0){_=_||16,_e==="matrix"?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=null,this._thinInstanceDataStorage.matrixBufferSize=p?p.length:32*_,this._thinInstanceDataStorage.matrixData=p,this._thinInstanceDataStorage.worldMatrices=null,p!==null?(this._thinInstanceDataStorage.instancesCount=p.length/_,this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",p,E),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)):(this._thinInstanceDataStorage.instancesCount=0,this.doNotSyncBoundingInfo||this.refreshBoundingInfo())):_e==="previousMatrix"?(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=null,this._thinInstanceDataStorage.previousMatrixData=p,p!==null&&(this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",p,E))):(_e===ut.ColorKind&&(_e=ut.ColorInstanceKind),p===null?this._userThinInstanceBuffersStorage?.data[_e]&&(this.removeVerticesData(_e),delete this._userThinInstanceBuffersStorage.data[_e],delete this._userThinInstanceBuffersStorage.strides[_e],delete this._userThinInstanceBuffersStorage.sizes[_e],delete this._userThinInstanceBuffersStorage.vertexBuffers[_e]):(this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.data[_e]=p,this._userThinInstanceBuffersStorage.strides[_e]=_,this._userThinInstanceBuffersStorage.sizes[_e]=p.length,this._userThinInstanceBuffersStorage.vertexBuffers[_e]=new ut(this.getEngine(),p,_e,!E,!1,_,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[_e])))},Lr.prototype.thinInstanceBufferUpdated=function(_e){_e==="matrix"?this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData,0,this._thinInstanceDataStorage.instancesCount):_e==="previousMatrix"?this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData,0,this._thinInstanceDataStorage.instancesCount):(_e===ut.ColorKind&&(_e=ut.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[_e]&&this._userThinInstanceBuffersStorage.vertexBuffers[_e].updateDirectly(this._userThinInstanceBuffersStorage.data[_e],0))},Lr.prototype.thinInstancePartialBufferUpdate=function(_e,p,_){_e==="matrix"?this._thinInstanceDataStorage.matrixBuffer&&this._thinInstanceDataStorage.matrixBuffer.updateDirectly(p,_):(_e===ut.ColorKind&&(_e=ut.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[_e]&&this._userThinInstanceBuffersStorage.vertexBuffers[_e].updateDirectly(p,_))},Lr.prototype.thinInstanceGetWorldMatrices=function(){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return[];const _e=this._thinInstanceDataStorage.matrixData;if(!this._thinInstanceDataStorage.worldMatrices){this._thinInstanceDataStorage.worldMatrices=[];for(let p=0;p<this._thinInstanceDataStorage.instancesCount;++p)this._thinInstanceDataStorage.worldMatrices[p]=Yt.FromArray(_e,p*16)}return this._thinInstanceDataStorage.worldMatrices},Lr.prototype.thinInstanceRefreshBoundingInfo=function(_e=!1,p=!1,_=!1){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return;const E=this._thinInstanceDataStorage.boundingVectors;if(_e||!this.rawBoundingInfo){E.length=0,this.refreshBoundingInfo(p,_);const ne=this.getBoundingInfo();this.rawBoundingInfo=new lx(ne.minimum,ne.maximum)}const A=this.getBoundingInfo(),$=this._thinInstanceDataStorage.matrixData;if(E.length===0)for(let ne=0;ne<A.boundingBox.vectors.length;++ne)E.push(A.boundingBox.vectors[ne].clone());pi.Vector3[0].setAll(Number.POSITIVE_INFINITY),pi.Vector3[1].setAll(Number.NEGATIVE_INFINITY);for(let ne=0;ne<this._thinInstanceDataStorage.instancesCount;++ne){Yt.FromArrayToRef($,ne*16,pi.Matrix[0]);for(let xe=0;xe<E.length;++xe)nt.TransformCoordinatesToRef(E[xe],pi.Matrix[0],pi.Vector3[2]),pi.Vector3[0].minimizeInPlace(pi.Vector3[2]),pi.Vector3[1].maximizeInPlace(pi.Vector3[2])}A.reConstruct(pi.Vector3[0],pi.Vector3[1]),this._updateBoundingInfo()},Lr.prototype._thinInstanceUpdateBufferSize=function(_e,p=1){_e===ut.ColorKind&&(_e=ut.ColorInstanceKind);const _=_e==="matrix";if(!_&&(!this._userThinInstanceBuffersStorage||!this._userThinInstanceBuffersStorage.strides[_e]))return;const E=_?16:this._userThinInstanceBuffersStorage.strides[_e],A=_?this._thinInstanceDataStorage.matrixBufferSize:this._userThinInstanceBuffersStorage.sizes[_e];let $=_?this._thinInstanceDataStorage.matrixData:this._userThinInstanceBuffersStorage.data[_e];const ne=(this._thinInstanceDataStorage.instancesCount+p)*E;let xe=A;for(;xe<ne;)xe*=2;if(!$||A!=xe){if(!$)$=new Float32Array(xe);else{const ce=new Float32Array(xe);ce.set($,0),$=ce}_?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",$,!1),this._thinInstanceDataStorage.matrixData=$,this._thinInstanceDataStorage.matrixBufferSize=xe,this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",$,!1))):(this._userThinInstanceBuffersStorage.vertexBuffers[_e]?.dispose(),this._userThinInstanceBuffersStorage.data[_e]=$,this._userThinInstanceBuffersStorage.sizes[_e]=xe,this._userThinInstanceBuffersStorage.vertexBuffers[_e]=new ut(this.getEngine(),$,_e,!0,!1,E,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[_e]))}},Lr.prototype._thinInstanceInitializeUserStorage=function(){this._userThinInstanceBuffersStorage||(this._userThinInstanceBuffersStorage={data:{},sizes:{},vertexBuffers:{},strides:{}})},Lr.prototype._disposeThinInstanceSpecificData=function(){this._thinInstanceDataStorage?.matrixBuffer&&(this._thinInstanceDataStorage.matrixBuffer.dispose(),this._thinInstanceDataStorage.matrixBuffer=null)};const w_="EXT_mesh_gpu_instancing";class rB{constructor(p){this.name=w_,this._loader=p,this.enabled=this._loader.isExtensionUsed(w_)}dispose(){this._loader=null}loadNodeAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{this._loader._disableInstancedMesh++;const ne=this._loader.loadNodeAsync(`/nodes/${_.index}`,_,E);if(this._loader._disableInstancedMesh--,!_._primitiveBabylonMeshes)return ne;const xe=new Array;let ce=0;const Te=Re=>{if($.attributes[Re]==null){xe.push(Promise.resolve(null));return}const ke=Wr.Get(`${A}/attributes/${Re}`,this._loader.gltf.accessors,$.attributes[Re]);if(xe.push(this._loader._loadFloatAccessorAsync(`/accessors/${ke.bufferView}`,ke)),ce===0)ce=ke.count;else if(ce!==ke.count)throw new Error(`${A}/attributes: Instance buffer accessors do not have the same count.`)};return Te("TRANSLATION"),Te("ROTATION"),Te("SCALE"),ne.then(Re=>Promise.all(xe).then(([ke,We,Xe])=>{const xt=new Float32Array(ce*16);pi.Vector3[0].copyFromFloats(0,0,0),pi.Quaternion[0].copyFromFloats(0,0,0,1),pi.Vector3[1].copyFromFloats(1,1,1);for(let qe=0;qe<ce;++qe)ke&&nt.FromArrayToRef(ke,qe*3,pi.Vector3[0]),We&&_s.FromArrayToRef(We,qe*4,pi.Quaternion[0]),Xe&&nt.FromArrayToRef(Xe,qe*3,pi.Vector3[1]),Yt.ComposeToRef(pi.Vector3[1],pi.Quaternion[0],pi.Vector3[0],pi.Matrix[0]),pi.Matrix[0].copyToArray(xt,qe*16);for(const qe of _._primitiveBabylonMeshes)qe.thinInstanceSetBuffer("matrix",xt,16,!0);return Re}))})}}qs.RegisterExtension(w_,_e=>new rB(_e));class ph{static get Default(){return ph._Default||(ph._Default=new ph),ph._Default}constructor(){const p=ph.Configuration.decoder;this._decoderModulePromise=ct.LoadBabylonScriptAsync(p.url).then(()=>MeshoptDecoder.ready)}dispose(){delete this._decoderModulePromise}decodeGltfBufferAsync(p,_,E,A,$){return this._decoderModulePromise.then(()=>{const ne=new Uint8Array(_*E);return MeshoptDecoder.decodeGltfBuffer(ne,_,E,p,A,$),ne})}}ph.Configuration={decoder:{url:`${ct._DefaultCdnUrl}/meshopt_decoder.js`}},ph._Default=null;const D_="EXT_meshopt_compression";class nB{constructor(p){this.name=D_,this.enabled=p.isExtensionUsed(D_),this._loader=p}dispose(){this._loader=null}loadBufferViewAsync(p,_){return qs.LoadExtensionAsync(p,_,this.name,(E,A)=>{const $=_;if($._meshOptData)return $._meshOptData;const ne=Wr.Get(`${p}/buffer`,this._loader.gltf.buffers,A.buffer);return $._meshOptData=this._loader.loadBufferAsync(`/buffers/${ne.index}`,ne,A.byteOffset||0,A.byteLength).then(xe=>ph.Default.decodeGltfBufferAsync(xe,A.count,A.byteStride,A.mode,A.filter)),$._meshOptData})}}qs.RegisterExtension(D_,_e=>new nB(_e));const N_="EXT_texture_webp";class aB{constructor(p){this.name=N_,this._loader=p,this.enabled=p.isExtensionUsed(N_)}dispose(){this._loader=null}_loadTextureAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=_.sampler==null?qs.DefaultSampler:Wr.Get(`${p}/sampler`,this._loader.gltf.samplers,_.sampler),xe=Wr.Get(`${A}/source`,this._loader.gltf.images,$.source);return this._loader._createTextureAsync(p,ne,xe,ce=>{E(ce)},void 0,!_._textureInfo.nonColorData)})}}qs.RegisterExtension(N_,_e=>new aB(_e));class xB{constructor(p){this._pendingActions=new Array,this._workerInfos=p.map(_=>({workerPromise:Promise.resolve(_),idle:!0}))}dispose(){for(const p of this._workerInfos)p.workerPromise.then(_=>{_.terminate()});this._workerInfos.length=0,this._pendingActions.length=0}push(p){this._executeOnIdleWorker(p)||this._pendingActions.push(p)}_executeOnIdleWorker(p){for(const _ of this._workerInfos)if(_.idle)return this._execute(_,p),!0;return!1}_execute(p,_){p.idle=!1,p.workerPromise.then(E=>{_(E,()=>{const A=this._pendingActions.shift();A?this._execute(p,A):p.idle=!0})})}}class zg extends xB{constructor(p,_,E=zg.DefaultOptions){super([]),this._maxWorkers=p,this._createWorkerAsync=_,this._options=E}push(p){if(!this._executeOnIdleWorker(p))if(this._workerInfos.length<this._maxWorkers){const _={workerPromise:this._createWorkerAsync(),idle:!1};this._workerInfos.push(_),this._execute(_,p)}else this._pendingActions.push(p)}_execute(p,_){p.timeoutId&&(clearTimeout(p.timeoutId),delete p.timeoutId),super._execute(p,(E,A)=>{_(E,()=>{A(),p.idle&&(p.timeoutId=setTimeout(()=>{p.workerPromise.then(ne=>{ne.terminate()});const $=this._workerInfos.indexOf(p);$!==-1&&this._workerInfos.splice($,1)},this._options.idleTimeElapsedBeforeRelease))})})}}zg.DefaultOptions={idleTimeElapsedBeforeRelease:1e3};function lB(_e){return new Promise(p=>{DracoDecoderModule({wasmBinary:_e}).then(_=>{p({module:_})})})}function F_(_e,p,_,E,A){let $=null,ne=null,xe=null;try{$=new _e.Decoder,ne=new _e.DecoderBuffer,ne.Init(p,p.byteLength);let ce;const Te=$.GetEncodedGeometryType(ne);switch(Te){case _e.TRIANGULAR_MESH:{const We=new _e.Mesh;if(ce=$.DecodeBufferToMesh(ne,We),!ce.ok()||We.ptr===0)throw new Error(ce.error_msg());const xt=We.num_faces()*3,qe=xt*4,ht=_e._malloc(qe);try{$.GetTrianglesUInt32Array(We,qe,ht);const Nt=new Uint32Array(xt);Nt.set(new Uint32Array(_e.HEAPF32.buffer,ht,xt)),E(Nt)}finally{_e._free(ht)}xe=We;break}case _e.POINT_CLOUD:{const We=new _e.PointCloud;if(ce=$.DecodeBufferToPointCloud(ne,We),!ce.ok()||!We.ptr)throw new Error(ce.error_msg());xe=We;break}default:throw new Error(`Invalid geometry type ${Te}`)}const Re=xe.num_points(),ke=(We,Xe,xt,qe)=>{const ht=qe.data_type(),Nt=qe.num_components(),wt=qe.normalized(),Qt=qe.byte_stride(),Ht=qe.byte_offset(),zt={[_e.DT_FLOAT32]:{typedArrayConstructor:Float32Array,heap:_e.HEAPF32},[_e.DT_INT8]:{typedArrayConstructor:Int8Array,heap:_e.HEAP8},[_e.DT_INT16]:{typedArrayConstructor:Int16Array,heap:_e.HEAP16},[_e.DT_INT32]:{typedArrayConstructor:Int32Array,heap:_e.HEAP32},[_e.DT_UINT8]:{typedArrayConstructor:Uint8Array,heap:_e.HEAPU8},[_e.DT_UINT16]:{typedArrayConstructor:Uint16Array,heap:_e.HEAPU16},[_e.DT_UINT32]:{typedArrayConstructor:Uint32Array,heap:_e.HEAPU32}}[ht];if(!zt)throw new Error(`Invalid data type ${ht}`);const xi=Re*Nt,wi=xi*zt.typedArrayConstructor.BYTES_PER_ELEMENT,vs=_e._malloc(wi);try{We.GetAttributeDataArrayForAllPoints(Xe,qe,ht,wi,vs);const cs=new zt.typedArrayConstructor(zt.heap.buffer,vs,xi);A(xt,cs.slice(),Nt,Ht,Qt,wt)}finally{_e._free(vs)}};if(_)for(const We in _){const Xe=_[We],xt=$.GetAttributeByUniqueId(xe,Xe);ke($,xe,We,xt)}else{const We={position:_e.POSITION,normal:_e.NORMAL,color:_e.COLOR,uv:_e.TEX_COORD};for(const Xe in We){const xt=$.GetAttributeId(xe,We[Xe]);if(xt!==-1){const qe=$.GetAttribute(xe,xt);ke($,xe,Xe,qe)}}}return Re}finally{xe&&_e.destroy(xe),ne&&_e.destroy(ne),$&&_e.destroy($)}}function hB(){let _e;onmessage=p=>{const _=p.data;switch(_.id){case"init":{const E=_.decoder;E.url&&(importScripts(E.url),_e=DracoDecoderModule({wasmBinary:E.wasmBinary})),postMessage({id:"initDone"});break}case"decodeMesh":{if(!_e)throw new Error("Draco decoder module is not available");_e.then(E=>{const A=F_(E,_.dataView,_.attributes,$=>{postMessage({id:"indices",data:$},[$.buffer])},($,ne,xe,ce,Te,Re)=>{postMessage({id:"attribute",kind:$,data:ne,size:xe,byteOffset:ce,byteStride:Te,normalized:Re},[ne.buffer])});postMessage({id:"decodeMeshDone",totalVertices:A})});break}}}}class Lx{static get DecoderAvailable(){const p=Lx.Configuration.decoder;return!!(p.wasmUrl&&p.wasmBinaryUrl&&typeof WebAssembly=="object"||p.fallbackUrl)}static GetDefaultNumWorkers(){return typeof navigator!="object"||!navigator.hardwareConcurrency?1:Math.min(Math.floor(navigator.hardwareConcurrency*.5),4)}static get Default(){return Lx._Default||(Lx._Default=new Lx),Lx._Default}constructor(p=Lx.DefaultNumWorkers){const _=Lx.Configuration.decoder,E=_.wasmUrl&&_.wasmBinaryUrl&&typeof WebAssembly=="object"?{url:ct.GetBabylonScriptURL(_.wasmUrl,!0),wasmBinaryPromise:ct.LoadFileAsync(ct.GetBabylonScriptURL(_.wasmBinaryUrl,!0))}:{url:ct.GetBabylonScriptURL(_.fallbackUrl),wasmBinaryPromise:Promise.resolve(void 0)};p&&typeof Worker=="function"&&typeof URL=="function"?this._workerPoolPromise=E.wasmBinaryPromise.then(A=>{const $=`${F_}(${hB})()`,ne=URL.createObjectURL(new Blob([$],{type:"application/javascript"}));return new zg(p,()=>new Promise((xe,ce)=>{const Te=new Worker(ne),Re=We=>{Te.removeEventListener("error",Re),Te.removeEventListener("message",ke),ce(We)},ke=We=>{We.data.id==="initDone"&&(Te.removeEventListener("error",Re),Te.removeEventListener("message",ke),xe(Te))};Te.addEventListener("error",Re),Te.addEventListener("message",ke),Te.postMessage({id:"init",decoder:{url:E.url,wasmBinary:A}})}))}):this._decoderModulePromise=E.wasmBinaryPromise.then(A=>{if(!E.url)throw new Error("Draco decoder module is not available");return ct.LoadBabylonScriptAsync(E.url).then(()=>lB(A))})}dispose(){this._workerPoolPromise&&this._workerPoolPromise.then(p=>{p.dispose()}),delete this._workerPoolPromise,delete this._decoderModulePromise}whenReadyAsync(){return this._workerPoolPromise?this._workerPoolPromise.then(()=>{}):this._decoderModulePromise?this._decoderModulePromise.then(()=>{}):Promise.resolve()}_decodeMeshAsync(p,_,E){const A=p instanceof ArrayBuffer?new Int8Array(p):new Int8Array(p.buffer,p.byteOffset,p.byteLength),$=(ne,xe)=>E&&E[ne]!==void 0?(xe!==E[ne]&&vi.Warn(`Normalized flag from Draco data (${xe}) does not match normalized flag from glTF accessor (${E[ne]}). Using flag from glTF accessor.`),E[ne]):xe;if(this._workerPoolPromise)return this._workerPoolPromise.then(ne=>new Promise((xe,ce)=>{ne.push((Te,Re)=>{let ke=null;const We=[],Xe=ht=>{Te.removeEventListener("error",Xe),Te.removeEventListener("message",xt),ce(ht),Re()},xt=ht=>{const Nt=ht.data;switch(Nt.id){case"decodeMeshDone":{Te.removeEventListener("error",Xe),Te.removeEventListener("message",xt),xe({indices:ke,attributes:We,totalVertices:Nt.totalVertices}),Re();break}case"indices":{ke=Nt.data;break}case"attribute":{We.push({kind:Nt.kind,data:Nt.data,size:Nt.size,byteOffset:Nt.byteOffset,byteStride:Nt.byteStride,normalized:$(Nt.kind,Nt.normalized)});break}}};Te.addEventListener("error",Xe),Te.addEventListener("message",xt);const qe=A.slice();Te.postMessage({id:"decodeMesh",dataView:qe,attributes:_},[qe.buffer])})}));if(this._decoderModulePromise)return this._decoderModulePromise.then(ne=>{let xe=null;const ce=[],Te=F_(ne.module,A,_,Re=>{xe=Re},(Re,ke,We,Xe,xt,qe)=>{ce.push({kind:Re,data:ke,size:We,byteOffset:Xe,byteStride:xt,normalized:qe})});return{indices:xe,attributes:ce,totalVertices:Te}});throw new Error("Draco decoder module is not available")}decodeMeshToGeometryAsync(p,_,E,A){return this._decodeMeshAsync(E,A).then($=>{const ne=new vo(p,_);$.indices&&ne.setIndices($.indices);for(const xe of $.attributes)ne.setVerticesBuffer(new ut(_.getEngine(),xe.data,xe.kind,!1,void 0,xe.byteStride,void 0,xe.byteOffset,xe.size,void 0,xe.normalized,!0),$.totalVertices);return ne})}_decodeMeshToGeometryForGltfAsync(p,_,E,A,$){return this._decodeMeshAsync(E,A,$).then(ne=>{const xe=new vo(p,_);ne.indices&&xe.setIndices(ne.indices);for(const ce of ne.attributes)xe.setVerticesBuffer(new ut(_.getEngine(),ce.data,ce.kind,!1,void 0,ce.byteStride,void 0,ce.byteOffset,ce.size,void 0,ce.normalized,!0),ne.totalVertices);return xe})}decodeMeshAsync(p,_){return this._decodeMeshAsync(p,_).then(E=>{const A=new Yr;E.indices&&(A.indices=E.indices);for(const $ of E.attributes){const ne=ut.GetFloatData($.data,$.size,ut.GetDataType($.data),$.byteOffset,$.byteStride,$.normalized,E.totalVertices);A.set(ne,$.kind)}return A})}}Lx.Configuration={decoder:{wasmUrl:`${ct._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,wasmBinaryUrl:`${ct._DefaultCdnUrl}/draco_decoder_gltf.wasm`,fallbackUrl:`${ct._DefaultCdnUrl}/draco_decoder_gltf.js`}},Lx.DefaultNumWorkers=Lx.GetDefaultNumWorkers(),Lx._Default=null;const L_="KHR_draco_mesh_compression";class cB{constructor(p){this.name=L_,this.useNormalizedFlagFromAccessor=!0,this._loader=p,this.enabled=Lx.DecoderAvailable&&this._loader.isExtensionUsed(L_)}dispose(){delete this.dracoCompression,this._loader=null}_loadVertexDataAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{if(_.mode!=null&&_.mode!==4&&_.mode!==5)throw new Error(`${p}: Unsupported mode ${_.mode}`);const ne={},xe={},ce=(Re,ke)=>{const We=$.attributes[Re];if(We!=null&&(E._delayInfo=E._delayInfo||[],E._delayInfo.indexOf(ke)===-1&&E._delayInfo.push(ke),ne[ke]=We,this.useNormalizedFlagFromAccessor)){const Xe=Wr.TryGet(this._loader.gltf.accessors,_.attributes[Re]);Xe&&(xe[ke]=Xe.normalized||!1)}};ce("POSITION",ut.PositionKind),ce("NORMAL",ut.NormalKind),ce("TANGENT",ut.TangentKind),ce("TEXCOORD_0",ut.UVKind),ce("TEXCOORD_1",ut.UV2Kind),ce("TEXCOORD_2",ut.UV3Kind),ce("TEXCOORD_3",ut.UV4Kind),ce("TEXCOORD_4",ut.UV5Kind),ce("TEXCOORD_5",ut.UV6Kind),ce("JOINTS_0",ut.MatricesIndicesKind),ce("WEIGHTS_0",ut.MatricesWeightsKind),ce("COLOR_0",ut.ColorKind);const Te=Wr.Get(A,this._loader.gltf.bufferViews,$.bufferView);return Te._dracoBabylonGeometry||(Te._dracoBabylonGeometry=this._loader.loadBufferViewAsync(`/bufferViews/${Te.index}`,Te).then(Re=>(this.dracoCompression||Lx.Default)._decodeMeshToGeometryForGltfAsync(E.name,this._loader.babylonScene,Re,ne,xe).catch(We=>{throw new Error(`${p}: ${We.message}`)}))),Te._dracoBabylonGeometry})}}qs.RegisterExtension(L_,_e=>new cB(_e)),Ka.AddNodeConstructor("Light_Type_0",(_e,p)=>()=>new B_(_e,nt.Zero(),p));class B_ extends rc{get shadowAngle(){return this._shadowAngle}set shadowAngle(p){this._shadowAngle=p,this.forceProjectionMatrixCompute()}get direction(){return this._direction}set direction(p){const _=this.needCube();if(this._direction=p,this.needCube()!==_&&this._shadowGenerators){const E=this._shadowGenerators.values();for(let A=E.next();A.done!==!0;A=E.next())A.value.recreateShadowMap()}}constructor(p,_,E){super(p,E),this._shadowAngle=Math.PI/2,this.position=_}getClassName(){return"PointLight"}getTypeID(){return vn.LIGHTTYPEID_POINTLIGHT}needCube(){return!this.direction}getShadowDirection(p){if(this.direction)return super.getShadowDirection(p);switch(p){case 0:return new nt(1,0,0);case 1:return new nt(-1,0,0);case 2:return new nt(0,-1,0);case 3:return new nt(0,1,0);case 4:return new nt(0,0,1);case 5:return new nt(0,0,-1)}return nt.Zero()}_setDefaultShadowProjectionMatrix(p,_,E){const A=this.getScene().activeCamera;if(!A)return;const $=this.shadowMinZ!==void 0?this.shadowMinZ:A.minZ,ne=this.shadowMaxZ!==void 0?this.shadowMaxZ:A.maxZ,xe=this.getScene().getEngine().useReverseDepthBuffer;Yt.PerspectiveFovLHToRef(this.shadowAngle,1,xe?ne:$,xe?$:ne,p,!0,this._scene.getEngine().isNDCHalfZRange,void 0,xe)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(p,_){return this.computeTransformedInformation()?this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z,0,_):this._uniformBuffer.updateFloat4("vLightData",this.position.x,this.position.y,this.position.z,0,_),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,0,0,_),this}transferToNodeMaterialEffect(p,_){return this.computeTransformedInformation()?p.setFloat3(_,this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z):p.setFloat3(_,this.position.x,this.position.y,this.position.z),this}prepareLightSpecificDefines(p,_){p["POINTLIGHT"+_]=!0}}Mt([Gt()],B_.prototype,"shadowAngle",null),Ka.AddNodeConstructor("Light_Type_2",(_e,p)=>()=>new jx(_e,nt.Zero(),nt.Zero(),0,0,p));class jx extends rc{get angle(){return this._angle}set angle(p){this._angle=p,this._cosHalfAngle=Math.cos(p*.5),this._projectionTextureProjectionLightDirty=!0,this.forceProjectionMatrixCompute(),this._computeAngleValues()}get innerAngle(){return this._innerAngle}set innerAngle(p){this._innerAngle=p,this._computeAngleValues()}get shadowAngleScale(){return this._shadowAngleScale}set shadowAngleScale(p){this._shadowAngleScale=p,this.forceProjectionMatrixCompute()}get projectionTextureMatrix(){return this._projectionTextureMatrix}get projectionTextureLightNear(){return this._projectionTextureLightNear}set projectionTextureLightNear(p){this._projectionTextureLightNear=p,this._projectionTextureProjectionLightDirty=!0}get projectionTextureLightFar(){return this._projectionTextureLightFar}set projectionTextureLightFar(p){this._projectionTextureLightFar=p,this._projectionTextureProjectionLightDirty=!0}get projectionTextureUpDirection(){return this._projectionTextureUpDirection}set projectionTextureUpDirection(p){this._projectionTextureUpDirection=p,this._projectionTextureProjectionLightDirty=!0}get projectionTexture(){return this._projectionTexture}set projectionTexture(p){this._projectionTexture!==p&&(this._projectionTexture=p,this._projectionTextureDirty=!0,this._projectionTexture&&!this._projectionTexture.isReady()&&(jx._IsProceduralTexture(this._projectionTexture)?this._projectionTexture.getEffect().executeWhenCompiled(()=>{this._markMeshesAsLightDirty()}):jx._IsTexture(this._projectionTexture)&&this._projectionTexture.onLoadObservable.addOnce(()=>{this._markMeshesAsLightDirty()})))}static _IsProceduralTexture(p){return p.onGeneratedObservable!==void 0}static _IsTexture(p){return p.onLoadObservable!==void 0}get projectionTextureProjectionLightMatrix(){return this._projectionTextureProjectionLightMatrix}set projectionTextureProjectionLightMatrix(p){this._projectionTextureProjectionLightMatrix=p,this._projectionTextureProjectionLightDirty=!1,this._projectionTextureDirty=!0}constructor(p,_,E,A,$,ne){super(p,ne),this._innerAngle=0,this._projectionTextureMatrix=Yt.Zero(),this._projectionTextureLightNear=1e-6,this._projectionTextureLightFar=1e3,this._projectionTextureUpDirection=nt.Up(),this._projectionTextureViewLightDirty=!0,this._projectionTextureProjectionLightDirty=!0,this._projectionTextureDirty=!0,this._projectionTextureViewTargetVector=nt.Zero(),this._projectionTextureViewLightMatrix=Yt.Zero(),this._projectionTextureProjectionLightMatrix=Yt.Zero(),this._projectionTextureScalingMatrix=Yt.FromValues(.5,0,0,0,0,.5,0,0,0,0,.5,0,.5,.5,.5,1),this.position=_,this.direction=E,this.angle=A,this.exponent=$}getClassName(){return"SpotLight"}getTypeID(){return vn.LIGHTTYPEID_SPOTLIGHT}_setDirection(p){super._setDirection(p),this._projectionTextureViewLightDirty=!0}_setPosition(p){super._setPosition(p),this._projectionTextureViewLightDirty=!0}_setDefaultShadowProjectionMatrix(p,_,E){const A=this.getScene().activeCamera;if(!A)return;this._shadowAngleScale=this._shadowAngleScale||1;const $=this._shadowAngleScale*this._angle,ne=this.shadowMinZ!==void 0?this.shadowMinZ:A.minZ,xe=this.shadowMaxZ!==void 0?this.shadowMaxZ:A.maxZ,ce=this.getScene().getEngine().useReverseDepthBuffer;Yt.PerspectiveFovLHToRef($,1,ce?xe:ne,ce?ne:xe,p,!0,this._scene.getEngine().isNDCHalfZRange,void 0,ce)}_computeProjectionTextureViewLightMatrix(){this._projectionTextureViewLightDirty=!1,this._projectionTextureDirty=!0,this.getAbsolutePosition().addToRef(this.getShadowDirection(),this._projectionTextureViewTargetVector),Yt.LookAtLHToRef(this.getAbsolutePosition(),this._projectionTextureViewTargetVector,this._projectionTextureUpDirection,this._projectionTextureViewLightMatrix)}_computeProjectionTextureProjectionLightMatrix(){this._projectionTextureProjectionLightDirty=!1,this._projectionTextureDirty=!0;const p=this.projectionTextureLightFar,_=this.projectionTextureLightNear,E=p/(p-_),A=-E*_,$=1/Math.tan(this._angle/2),ne=1;Yt.FromValuesToRef($/ne,0,0,0,0,$,0,0,0,0,E,1,0,0,A,0,this._projectionTextureProjectionLightMatrix)}_computeProjectionTextureMatrix(){if(this._projectionTextureDirty=!1,this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix,this._projectionTextureMatrix),this._projectionTexture instanceof Hi){const p=this._projectionTexture.uScale/2,_=this._projectionTexture.vScale/2;Yt.FromValuesToRef(p,0,0,0,0,_,0,0,0,0,.5,0,.5,.5,.5,1,this._projectionTextureScalingMatrix)}this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix,this._projectionTextureMatrix)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightDirection",3),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}_computeAngleValues(){this._lightAngleScale=1/Math.max(.001,Math.cos(this._innerAngle*.5)-this._cosHalfAngle),this._lightAngleOffset=-this._cosHalfAngle*this._lightAngleScale}transferTexturesToEffect(p,_){return this.projectionTexture&&this.projectionTexture.isReady()&&(this._projectionTextureViewLightDirty&&this._computeProjectionTextureViewLightMatrix(),this._projectionTextureProjectionLightDirty&&this._computeProjectionTextureProjectionLightMatrix(),this._projectionTextureDirty&&this._computeProjectionTextureMatrix(),p.setMatrix("textureProjectionMatrix"+_,this._projectionTextureMatrix),p.setTexture("projectionLightSampler"+_,this.projectionTexture)),this}transferToEffect(p,_){let E;return this.computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z,this.exponent,_),E=nt.Normalize(this.transformedDirection)):(this._uniformBuffer.updateFloat4("vLightData",this.position.x,this.position.y,this.position.z,this.exponent,_),E=nt.Normalize(this.direction)),this._uniformBuffer.updateFloat4("vLightDirection",E.x,E.y,E.z,this._cosHalfAngle,_),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,this._lightAngleScale,this._lightAngleOffset,_),this}transferToNodeMaterialEffect(p,_){let E;return this.computeTransformedInformation()?E=nt.Normalize(this.transformedDirection):E=nt.Normalize(this.direction),this.getScene().useRightHandedSystem?p.setFloat3(_,-E.x,-E.y,-E.z):p.setFloat3(_,E.x,E.y,E.z),this}dispose(){super.dispose(),this._projectionTexture&&this._projectionTexture.dispose()}getDepthMinZ(p){const _=this._scene.getEngine(),E=this.shadowMinZ!==void 0?this.shadowMinZ:p.minZ;return _.useReverseDepthBuffer&&_.isNDCHalfZRange?E:this._scene.getEngine().isNDCHalfZRange?0:E}getDepthMaxZ(p){const _=this._scene.getEngine(),E=this.shadowMaxZ!==void 0?this.shadowMaxZ:p.maxZ;return _.useReverseDepthBuffer&&_.isNDCHalfZRange?0:E}prepareLightSpecificDefines(p,_){p["SPOTLIGHT"+_]=!0,p["PROJECTEDLIGHTTEXTURE"+_]=!!(this.projectionTexture&&this.projectionTexture.isReady())}}Mt([Gt()],jx.prototype,"angle",null),Mt([Gt()],jx.prototype,"innerAngle",null),Mt([Gt()],jx.prototype,"shadowAngleScale",null),Mt([Gt()],jx.prototype,"exponent",void 0),Mt([Gt()],jx.prototype,"projectionTextureLightNear",null),Mt([Gt()],jx.prototype,"projectionTextureLightFar",null),Mt([Gt()],jx.prototype,"projectionTextureUpDirection",null),Mt([Kn("projectedLightTexture")],jx.prototype,"_projectionTexture",void 0);const k_="KHR_lights_punctual";class uB{constructor(p){this.name=k_,this._loader=p,this.enabled=this._loader.isExtensionUsed(k_)}dispose(){this._loader=null,delete this._lights}onLoading(){const p=this._loader.gltf.extensions;if(p&&p[this.name]){const _=p[this.name];this._lights=_.lights,Wr.Assign(this._lights)}}loadNodeAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>(this._loader._allMaterialsDirtyRequired=!0,this._loader.loadNodeAsync(p,_,ne=>{let xe;const ce=Wr.Get(A,this._lights,$.light),Te=ce.name||ne.name;switch(this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer,ce.type){case"directional":{const Re=new Kl(Te,nt.Backward(),this._loader.babylonScene);Re.position.setAll(0),xe=Re;break}case"point":{xe=new B_(Te,nt.Zero(),this._loader.babylonScene);break}case"spot":{const Re=new jx(Te,nt.Zero(),nt.Backward(),0,1,this._loader.babylonScene);Re.angle=(ce.spot&&ce.spot.outerConeAngle||Math.PI/4)*2,Re.innerAngle=(ce.spot&&ce.spot.innerConeAngle||0)*2,xe=Re;break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${A}: Invalid light type (${ce.type})`)}xe._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,ce._babylonLight=xe,xe.falloffType=vn.FALLOFF_GLTF,xe.diffuse=ce.color?ws.FromArray(ce.color):ws.White(),xe.intensity=ce.intensity==null?1:ce.intensity,xe.range=ce.range==null?Number.MAX_VALUE:ce.range,xe.parent=ne,this._loader._babylonLights.push(xe),qs.AddPointerMetadata(xe,A),E(ne)})))}}qs.RegisterExtension(k_,_e=>new uB(_e));const U_="KHR_materials_pbrSpecularGlossiness";class pB{constructor(p){this.name=U_,this.order=200,this._loader=p,this.enabled=this._loader.isExtensionUsed(U_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),ne.push(this._loadSpecularGlossinessPropertiesAsync(A,$,E)),this._loader.loadMaterialAlphaProperties(p,_,E),Promise.all(ne).then(()=>{})})}_loadSpecularGlossinessPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const A=new Array;return E.metallic=null,E.roughness=null,_.diffuseFactor?(E.albedoColor=ws.FromArray(_.diffuseFactor),E.alpha=_.diffuseFactor[3]):E.albedoColor=ws.White(),E.reflectivityColor=_.specularFactor?ws.FromArray(_.specularFactor):ws.White(),E.microSurface=_.glossinessFactor==null?1:_.glossinessFactor,_.diffuseTexture&&A.push(this._loader.loadTextureInfoAsync(`${p}/diffuseTexture`,_.diffuseTexture,$=>{$.name=`${E.name} (Diffuse)`,E.albedoTexture=$})),_.specularGlossinessTexture&&(A.push(this._loader.loadTextureInfoAsync(`${p}/specularGlossinessTexture`,_.specularGlossinessTexture,$=>{$.name=`${E.name} (Specular Glossiness)`,E.reflectivityTexture=$,E.reflectivityTexture.hasAlpha=!0})),E.useMicroSurfaceFromReflectivityMapAlpha=!0),Promise.all(A).then(()=>{})}}qs.RegisterExtension(U_,_e=>new pB(_e));const V_="KHR_materials_unlit";class _B{constructor(p){this.name=V_,this.order=210,this._loader=p,this.enabled=this._loader.isExtensionUsed(V_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,()=>this._loadUnlitPropertiesAsync(p,_,E))}_loadUnlitPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const A=new Array;E.unlit=!0;const $=_.pbrMetallicRoughness;return $&&($.baseColorFactor?(E.albedoColor=ws.FromArray($.baseColorFactor),E.alpha=$.baseColorFactor[3]):E.albedoColor=ws.White(),$.baseColorTexture&&A.push(this._loader.loadTextureInfoAsync(`${p}/baseColorTexture`,$.baseColorTexture,ne=>{ne.name=`${E.name} (Base Color)`,E.albedoTexture=ne}))),_.doubleSided&&(E.backFaceCulling=!1,E.twoSidedLighting=!0),this._loader.loadMaterialAlphaProperties(p,_,E),Promise.all(A).then(()=>{})}}qs.RegisterExtension(V_,_e=>new _B(_e));const G_="KHR_materials_clearcoat";class TB{constructor(p){this.name=G_,this.order=190,this._loader=p,this.enabled=this._loader.isExtensionUsed(G_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadClearCoatPropertiesAsync(A,$,E)),Promise.all(ne).then(()=>{})})}_loadClearCoatPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const A=new Array;return E.clearCoat.isEnabled=!0,E.clearCoat.useRoughnessFromMainTexture=!1,E.clearCoat.remapF0OnInterfaceChange=!1,_.clearcoatFactor!=null?E.clearCoat.intensity=_.clearcoatFactor:E.clearCoat.intensity=0,_.clearcoatTexture&&A.push(this._loader.loadTextureInfoAsync(`${p}/clearcoatTexture`,_.clearcoatTexture,$=>{$.name=`${E.name} (ClearCoat Intensity)`,E.clearCoat.texture=$})),_.clearcoatRoughnessFactor!=null?E.clearCoat.roughness=_.clearcoatRoughnessFactor:E.clearCoat.roughness=0,_.clearcoatRoughnessTexture&&(_.clearcoatRoughnessTexture.nonColorData=!0,A.push(this._loader.loadTextureInfoAsync(`${p}/clearcoatRoughnessTexture`,_.clearcoatRoughnessTexture,$=>{$.name=`${E.name} (ClearCoat Roughness)`,E.clearCoat.textureRoughness=$}))),_.clearcoatNormalTexture&&(_.clearcoatNormalTexture.nonColorData=!0,A.push(this._loader.loadTextureInfoAsync(`${p}/clearcoatNormalTexture`,_.clearcoatNormalTexture,$=>{$.name=`${E.name} (ClearCoat Normal)`,E.clearCoat.bumpTexture=$})),E.invertNormalMapX=!E.getScene().useRightHandedSystem,E.invertNormalMapY=E.getScene().useRightHandedSystem,_.clearcoatNormalTexture.scale!=null&&(E.clearCoat.bumpTexture.level=_.clearcoatNormalTexture.scale)),Promise.all(A).then(()=>{})}}qs.RegisterExtension(G_,_e=>new TB(_e));const z_="KHR_materials_iridescence";class vB{constructor(p){this.name=z_,this.order=195,this._loader=p,this.enabled=this._loader.isExtensionUsed(z_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadIridescencePropertiesAsync(A,$,E)),Promise.all(ne).then(()=>{})})}_loadIridescencePropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const A=new Array;return E.iridescence.isEnabled=!0,E.iridescence.intensity=_.iridescenceFactor??0,E.iridescence.indexOfRefraction=_.iridescenceIor??_.iridescenceIOR??1.3,E.iridescence.minimumThickness=_.iridescenceThicknessMinimum??100,E.iridescence.maximumThickness=_.iridescenceThicknessMaximum??400,_.iridescenceTexture&&A.push(this._loader.loadTextureInfoAsync(`${p}/iridescenceTexture`,_.iridescenceTexture,$=>{$.name=`${E.name} (Iridescence Intensity)`,E.iridescence.texture=$})),_.iridescenceThicknessTexture&&A.push(this._loader.loadTextureInfoAsync(`${p}/iridescenceThicknessTexture`,_.iridescenceThicknessTexture,$=>{$.name=`${E.name} (Iridescence Thickness)`,E.iridescence.thicknessTexture=$})),Promise.all(A).then(()=>{})}}qs.RegisterExtension(z_,_e=>new vB(_e));const W_="KHR_materials_anisotropy";class RB{constructor(p){this.name=W_,this.order=195,this._loader=p,this.enabled=this._loader.isExtensionUsed(W_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadIridescencePropertiesAsync(A,$,E)),Promise.all(ne).then(()=>{})})}_loadIridescencePropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const A=new Array;return E.anisotropy.isEnabled=!0,E.anisotropy.intensity=_.anisotropyStrength??0,E.anisotropy.angle=_.anisotropyRotation??0,_.anisotropyTexture&&A.push(this._loader.loadTextureInfoAsync(`${p}/anisotropyTexture`,_.anisotropyTexture,$=>{$.name=`${E.name} (Anisotropy Intensity)`,E.anisotropy.texture=$})),Promise.all(A).then(()=>{})}}qs.RegisterExtension(W_,_e=>new RB(_e));const H_="KHR_materials_emissive_strength";class MB{constructor(p){this.name=H_,this.order=170,this._loader=p,this.enabled=this._loader.isExtensionUsed(H_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>this._loader.loadMaterialPropertiesAsync(p,_,E).then(()=>{this._loadEmissiveProperties(A,$,E)}))}_loadEmissiveProperties(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);_.emissiveStrength!==void 0&&E.emissiveColor.scaleToRef(_.emissiveStrength,E.emissiveColor)}}qs.RegisterExtension(H_,_e=>new MB(_e));const X_="KHR_materials_sheen";class wB{constructor(p){this.name=X_,this.order=190,this._loader=p,this.enabled=this._loader.isExtensionUsed(X_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadSheenPropertiesAsync(A,$,E)),Promise.all(ne).then(()=>{})})}_loadSheenPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const A=new Array;return E.sheen.isEnabled=!0,E.sheen.intensity=1,_.sheenColorFactor!=null?E.sheen.color=ws.FromArray(_.sheenColorFactor):E.sheen.color=ws.Black(),_.sheenColorTexture&&A.push(this._loader.loadTextureInfoAsync(`${p}/sheenColorTexture`,_.sheenColorTexture,$=>{$.name=`${E.name} (Sheen Color)`,E.sheen.texture=$})),_.sheenRoughnessFactor!==void 0?E.sheen.roughness=_.sheenRoughnessFactor:E.sheen.roughness=0,_.sheenRoughnessTexture&&(_.sheenRoughnessTexture.nonColorData=!0,A.push(this._loader.loadTextureInfoAsync(`${p}/sheenRoughnessTexture`,_.sheenRoughnessTexture,$=>{$.name=`${E.name} (Sheen Roughness)`,E.sheen.textureRoughness=$}))),E.sheen.albedoScaling=!0,E.sheen.useRoughnessFromMainTexture=!1,Promise.all(A).then(()=>{})}}qs.RegisterExtension(X_,_e=>new wB(_e));const K_="KHR_materials_specular";class LB{constructor(p){this.name=K_,this.order=190,this._loader=p,this.enabled=this._loader.isExtensionUsed(K_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadSpecularPropertiesAsync(A,$,E)),Promise.all(ne).then(()=>{})})}_loadSpecularPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const A=new Array;return _.specularFactor!==void 0&&(E.metallicF0Factor=_.specularFactor),_.specularColorFactor!==void 0&&(E.metallicReflectanceColor=ws.FromArray(_.specularColorFactor)),_.specularTexture&&(_.specularTexture.nonColorData=!0,A.push(this._loader.loadTextureInfoAsync(`${p}/specularTexture`,_.specularTexture,$=>{$.name=`${E.name} (Specular F0 Strength)`,E.metallicReflectanceTexture=$,E.useOnlyMetallicFromMetallicReflectanceTexture=!0}))),_.specularColorTexture&&A.push(this._loader.loadTextureInfoAsync(`${p}/specularColorTexture`,_.specularColorTexture,$=>{$.name=`${E.name} (Specular F0 Color)`,E.reflectanceTexture=$})),Promise.all(A).then(()=>{})}}qs.RegisterExtension(K_,_e=>new LB(_e));const Y_="KHR_materials_ior";class Wg{constructor(p){this.name=Y_,this.order=180,this._loader=p,this.enabled=this._loader.isExtensionUsed(Y_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadIorPropertiesAsync(A,$,E)),Promise.all(ne).then(()=>{})})}_loadIorPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);return _.ior!==void 0?E.indexOfRefraction=_.ior:E.indexOfRefraction=Wg._DEFAULT_IOR,Promise.resolve()}}Wg._DEFAULT_IOR=1.5,qs.RegisterExtension(Y_,_e=>new Wg(_e));const cx="KHR_materials_variants";class uc{constructor(p){this.name=cx,this._loader=p,this.enabled=this._loader.isExtensionUsed(cx)}dispose(){this._loader=null}static GetAvailableVariants(p){const _=this._GetExtensionMetadata(p);return _?Object.keys(_.variants):[]}getAvailableVariants(p){return uc.GetAvailableVariants(p)}static SelectVariant(p,_){const E=this._GetExtensionMetadata(p);if(!E)throw new Error(`Cannot select variant on a glTF mesh that does not have the ${cx} extension`);const A=$=>{const ne=E.variants[$];if(ne)for(const xe of ne)xe.mesh.material=xe.material};if(_ instanceof Array)for(const $ of _)A($);else A(_);E.lastSelected=_}selectVariant(p,_){uc.SelectVariant(p,_)}static Reset(p){const _=this._GetExtensionMetadata(p);if(!_)throw new Error(`Cannot reset on a glTF mesh that does not have the ${cx} extension`);for(const E of _.original)E.mesh.material=E.material;_.lastSelected=null}reset(p){uc.Reset(p)}static GetLastSelectedVariant(p){const _=this._GetExtensionMetadata(p);if(!_)throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${cx} extension`);return _.lastSelected}getLastSelectedVariant(p){return uc.GetLastSelectedVariant(p)}static _GetExtensionMetadata(p){return p?._internalMetadata?.gltf?.[cx]||null}onLoading(){const p=this._loader.gltf.extensions;if(p&&p[this.name]){const _=p[this.name];this._variants=_.variants}}_loadMeshPrimitiveAsync(p,_,E,A,$,ne){return qs.LoadExtensionAsync(p,$,this.name,(xe,ce)=>{const Te=new Array;return Te.push(this._loader._loadMeshPrimitiveAsync(p,_,E,A,$,Re=>{if(ne(Re),Re instanceof Lr){const ke=qs._GetDrawMode(p,$.mode),We=this._loader.rootBabylonMesh,Xe=We?We._internalMetadata=We._internalMetadata||{}:{},xt=Xe.gltf=Xe.gltf||{},qe=xt[cx]=xt[cx]||{lastSelected:null,original:[],variants:{}};qe.original.push({mesh:Re,material:Re.material});for(let ht=0;ht<ce.mappings.length;++ht){const Nt=ce.mappings[ht],wt=Wr.Get(`${xe}/mappings/${ht}/material`,this._loader.gltf.materials,Nt.material);Te.push(this._loader._loadMaterialAsync(`#/materials/${Nt.material}`,wt,Re,ke,Qt=>{for(let Ht=0;Ht<Nt.variants.length;++Ht){const Wt=Nt.variants[Ht],zt=Wr.Get(`/extensions/${cx}/variants/${Wt}`,this._variants,Wt);qe.variants[zt.name]=qe.variants[zt.name]||[],qe.variants[zt.name].push({mesh:Re,material:Qt}),Re.onClonedObservable.add(xi=>{const wi=xi;let vs=null,cs=wi;do{if(cs=cs.parent,!cs)return;vs=uc._GetExtensionMetadata(cs)}while(vs===null);if(We&&vs===uc._GetExtensionMetadata(We)){cs._internalMetadata={};for(const Mr in We._internalMetadata)cs._internalMetadata[Mr]=We._internalMetadata[Mr];cs._internalMetadata.gltf=[];for(const Mr in We._internalMetadata.gltf)cs._internalMetadata.gltf[Mr]=We._internalMetadata.gltf[Mr];cs._internalMetadata.gltf[cx]={lastSelected:null,original:[],variants:{}};for(const Mr of vs.original)cs._internalMetadata.gltf[cx].original.push({mesh:Mr.mesh,material:Mr.material});for(const Mr in vs.variants)if(Object.prototype.hasOwnProperty.call(vs.variants,Mr)){cs._internalMetadata.gltf[cx].variants[Mr]=[];for(const xn of vs.variants[Mr])cs._internalMetadata.gltf[cx].variants[Mr].push({mesh:xn.mesh,material:xn.material})}vs=cs._internalMetadata.gltf[cx]}for(const Mr of vs.original)Mr.mesh===Re&&(Mr.mesh=wi);for(const Mr of vs.variants[zt.name])Mr.mesh===Re&&(Mr.mesh=wi)})}}))}}})),Promise.all(Te).then(([Re])=>Re)})}}qs.RegisterExtension(cx,_e=>new uc(_e));class $t{}$t.ALPHA_DISABLE=0,$t.ALPHA_ADD=1,$t.ALPHA_COMBINE=2,$t.ALPHA_SUBTRACT=3,$t.ALPHA_MULTIPLY=4,$t.ALPHA_MAXIMIZED=5,$t.ALPHA_ONEONE=6,$t.ALPHA_PREMULTIPLIED=7,$t.ALPHA_PREMULTIPLIED_PORTERDUFF=8,$t.ALPHA_INTERPOLATE=9,$t.ALPHA_SCREENMODE=10,$t.ALPHA_ONEONE_ONEONE=11,$t.ALPHA_ALPHATOCOLOR=12,$t.ALPHA_REVERSEONEMINUS=13,$t.ALPHA_SRC_DSTONEMINUSSRCALPHA=14,$t.ALPHA_ONEONE_ONEZERO=15,$t.ALPHA_EXCLUSION=16,$t.ALPHA_LAYER_ACCUMULATE=17,$t.ALPHA_EQUATION_ADD=0,$t.ALPHA_EQUATION_SUBSTRACT=1,$t.ALPHA_EQUATION_REVERSE_SUBTRACT=2,$t.ALPHA_EQUATION_MAX=3,$t.ALPHA_EQUATION_MIN=4,$t.ALPHA_EQUATION_DARKEN=5,$t.DELAYLOADSTATE_NONE=0,$t.DELAYLOADSTATE_LOADED=1,$t.DELAYLOADSTATE_LOADING=2,$t.DELAYLOADSTATE_NOTLOADED=4,$t.NEVER=512,$t.ALWAYS=519,$t.LESS=513,$t.EQUAL=514,$t.LEQUAL=515,$t.GREATER=516,$t.GEQUAL=518,$t.NOTEQUAL=517,$t.KEEP=7680,$t.ZERO=0,$t.REPLACE=7681,$t.INCR=7682,$t.DECR=7683,$t.INVERT=5386,$t.INCR_WRAP=34055,$t.DECR_WRAP=34056,$t.TEXTURE_CLAMP_ADDRESSMODE=0,$t.TEXTURE_WRAP_ADDRESSMODE=1,$t.TEXTURE_MIRROR_ADDRESSMODE=2,$t.TEXTURE_CREATIONFLAG_STORAGE=1,$t.TEXTUREFORMAT_ALPHA=0,$t.TEXTUREFORMAT_LUMINANCE=1,$t.TEXTUREFORMAT_LUMINANCE_ALPHA=2,$t.TEXTUREFORMAT_RGB=4,$t.TEXTUREFORMAT_RGBA=5,$t.TEXTUREFORMAT_RED=6,$t.TEXTUREFORMAT_R=6,$t.TEXTUREFORMAT_RG=7,$t.TEXTUREFORMAT_RED_INTEGER=8,$t.TEXTUREFORMAT_R_INTEGER=8,$t.TEXTUREFORMAT_RG_INTEGER=9,$t.TEXTUREFORMAT_RGB_INTEGER=10,$t.TEXTUREFORMAT_RGBA_INTEGER=11,$t.TEXTUREFORMAT_BGRA=12,$t.TEXTUREFORMAT_DEPTH24_STENCIL8=13,$t.TEXTUREFORMAT_DEPTH32_FLOAT=14,$t.TEXTUREFORMAT_DEPTH16=15,$t.TEXTUREFORMAT_DEPTH24=16,$t.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8=17,$t.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8=18,$t.TEXTUREFORMAT_STENCIL8=19,$t.TEXTUREFORMAT_UNDEFINED=4294967295,$t.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM=36492,$t.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM=36493,$t.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT=36495,$t.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT=36494,$t.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5=33779,$t.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=35919,$t.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3=33778,$t.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT=35918,$t.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1=33777,$t.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1=33776,$t.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=35917,$t.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT=35916,$t.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4=37808,$t.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=37840,$t.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL=36196,$t.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2=37492,$t.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2=37493,$t.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2=37494,$t.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2=37495,$t.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC=37496,$t.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=37497,$t.TEXTURETYPE_UNSIGNED_BYTE=0,$t.TEXTURETYPE_UNSIGNED_INT=0,$t.TEXTURETYPE_FLOAT=1,$t.TEXTURETYPE_HALF_FLOAT=2,$t.TEXTURETYPE_BYTE=3,$t.TEXTURETYPE_SHORT=4,$t.TEXTURETYPE_UNSIGNED_SHORT=5,$t.TEXTURETYPE_INT=6,$t.TEXTURETYPE_UNSIGNED_INTEGER=7,$t.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4=8,$t.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1=9,$t.TEXTURETYPE_UNSIGNED_SHORT_5_6_5=10,$t.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV=11,$t.TEXTURETYPE_UNSIGNED_INT_24_8=12,$t.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV=13,$t.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV=14,$t.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV=15,$t.TEXTURETYPE_UNDEFINED=16,$t.TEXTURE_2D=3553,$t.TEXTURE_2D_ARRAY=35866,$t.TEXTURE_CUBE_MAP=34067,$t.TEXTURE_CUBE_MAP_ARRAY=3735928559,$t.TEXTURE_3D=32879,$t.TEXTURE_NEAREST_SAMPLINGMODE=1,$t.TEXTURE_NEAREST_NEAREST=1,$t.TEXTURE_BILINEAR_SAMPLINGMODE=2,$t.TEXTURE_LINEAR_LINEAR=2,$t.TEXTURE_TRILINEAR_SAMPLINGMODE=3,$t.TEXTURE_LINEAR_LINEAR_MIPLINEAR=3,$t.TEXTURE_NEAREST_NEAREST_MIPNEAREST=4,$t.TEXTURE_NEAREST_LINEAR_MIPNEAREST=5,$t.TEXTURE_NEAREST_LINEAR_MIPLINEAR=6,$t.TEXTURE_NEAREST_LINEAR=7,$t.TEXTURE_NEAREST_NEAREST_MIPLINEAR=8,$t.TEXTURE_LINEAR_NEAREST_MIPNEAREST=9,$t.TEXTURE_LINEAR_NEAREST_MIPLINEAR=10,$t.TEXTURE_LINEAR_LINEAR_MIPNEAREST=11,$t.TEXTURE_LINEAR_NEAREST=12,$t.TEXTURE_EXPLICIT_MODE=0,$t.TEXTURE_SPHERICAL_MODE=1,$t.TEXTURE_PLANAR_MODE=2,$t.TEXTURE_CUBIC_MODE=3,$t.TEXTURE_PROJECTION_MODE=4,$t.TEXTURE_SKYBOX_MODE=5,$t.TEXTURE_INVCUBIC_MODE=6,$t.TEXTURE_EQUIRECTANGULAR_MODE=7,$t.TEXTURE_FIXED_EQUIRECTANGULAR_MODE=8,$t.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,$t.TEXTURE_FILTERING_QUALITY_OFFLINE=4096,$t.TEXTURE_FILTERING_QUALITY_HIGH=64,$t.TEXTURE_FILTERING_QUALITY_MEDIUM=16,$t.TEXTURE_FILTERING_QUALITY_LOW=8,$t.SCALEMODE_FLOOR=1,$t.SCALEMODE_NEAREST=2,$t.SCALEMODE_CEILING=3,$t.MATERIAL_TextureDirtyFlag=1,$t.MATERIAL_LightDirtyFlag=2,$t.MATERIAL_FresnelDirtyFlag=4,$t.MATERIAL_AttributesDirtyFlag=8,$t.MATERIAL_MiscDirtyFlag=16,$t.MATERIAL_PrePassDirtyFlag=32,$t.MATERIAL_AllDirtyFlag=63,$t.MATERIAL_TriangleFillMode=0,$t.MATERIAL_WireFrameFillMode=1,$t.MATERIAL_PointFillMode=2,$t.MATERIAL_PointListDrawMode=3,$t.MATERIAL_LineListDrawMode=4,$t.MATERIAL_LineLoopDrawMode=5,$t.MATERIAL_LineStripDrawMode=6,$t.MATERIAL_TriangleStripDrawMode=7,$t.MATERIAL_TriangleFanDrawMode=8,$t.MATERIAL_ClockWiseSideOrientation=0,$t.MATERIAL_CounterClockWiseSideOrientation=1,$t.ACTION_NothingTrigger=0,$t.ACTION_OnPickTrigger=1,$t.ACTION_OnLeftPickTrigger=2,$t.ACTION_OnRightPickTrigger=3,$t.ACTION_OnCenterPickTrigger=4,$t.ACTION_OnPickDownTrigger=5,$t.ACTION_OnDoublePickTrigger=6,$t.ACTION_OnPickUpTrigger=7,$t.ACTION_OnPickOutTrigger=16,$t.ACTION_OnLongPressTrigger=8,$t.ACTION_OnPointerOverTrigger=9,$t.ACTION_OnPointerOutTrigger=10,$t.ACTION_OnEveryFrameTrigger=11,$t.ACTION_OnIntersectionEnterTrigger=12,$t.ACTION_OnIntersectionExitTrigger=13,$t.ACTION_OnKeyDownTrigger=14,$t.ACTION_OnKeyUpTrigger=15,$t.PARTICLES_BILLBOARDMODE_Y=2,$t.PARTICLES_BILLBOARDMODE_ALL=7,$t.PARTICLES_BILLBOARDMODE_STRETCHED=8,$t.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL=9,$t.MESHES_CULLINGSTRATEGY_STANDARD=0,$t.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY=1,$t.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION=2,$t.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY=3,$t.SCENELOADER_NO_LOGGING=0,$t.SCENELOADER_MINIMAL_LOGGING=1,$t.SCENELOADER_SUMMARY_LOGGING=2,$t.SCENELOADER_DETAILED_LOGGING=3,$t.PREPASS_IRRADIANCE_TEXTURE_TYPE=0,$t.PREPASS_POSITION_TEXTURE_TYPE=1,$t.PREPASS_VELOCITY_TEXTURE_TYPE=2,$t.PREPASS_REFLECTIVITY_TEXTURE_TYPE=3,$t.PREPASS_COLOR_TEXTURE_TYPE=4,$t.PREPASS_DEPTH_TEXTURE_TYPE=5,$t.PREPASS_NORMAL_TEXTURE_TYPE=6,$t.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE=7,$t.BUFFER_CREATIONFLAG_READ=1,$t.BUFFER_CREATIONFLAG_WRITE=2,$t.BUFFER_CREATIONFLAG_READWRITE=3,$t.BUFFER_CREATIONFLAG_UNIFORM=4,$t.BUFFER_CREATIONFLAG_VERTEX=8,$t.BUFFER_CREATIONFLAG_INDEX=16,$t.BUFFER_CREATIONFLAG_STORAGE=32,$t.RENDERPASS_MAIN=0,$t.INPUT_ALT_KEY=18,$t.INPUT_CTRL_KEY=17,$t.INPUT_META_KEY1=91,$t.INPUT_META_KEY2=92,$t.INPUT_META_KEY3=93,$t.INPUT_SHIFT_KEY=16,$t.SNAPSHOTRENDERING_STANDARD=0,$t.SNAPSHOTRENDERING_FAST=1,$t.PERSPECTIVE_CAMERA=0,$t.ORTHOGRAPHIC_CAMERA=1,$t.FOVMODE_VERTICAL_FIXED=0,$t.FOVMODE_HORIZONTAL_FIXED=1,$t.RIG_MODE_NONE=0,$t.RIG_MODE_STEREOSCOPIC_ANAGLYPH=10,$t.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL=11,$t.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED=12,$t.RIG_MODE_STEREOSCOPIC_OVERUNDER=13,$t.RIG_MODE_STEREOSCOPIC_INTERLACED=14,$t.RIG_MODE_VR=20,$t.RIG_MODE_CUSTOM=22,$t.MAX_SUPPORTED_UV_SETS=6,$t.GL_ALPHA_EQUATION_ADD=32774,$t.GL_ALPHA_EQUATION_MIN=32775,$t.GL_ALPHA_EQUATION_MAX=32776,$t.GL_ALPHA_EQUATION_SUBTRACT=32778,$t.GL_ALPHA_EQUATION_REVERSE_SUBTRACT=32779,$t.GL_ALPHA_FUNCTION_SRC=768,$t.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR=769,$t.GL_ALPHA_FUNCTION_SRC_ALPHA=770,$t.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA=771,$t.GL_ALPHA_FUNCTION_DST_ALPHA=772,$t.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA=773,$t.GL_ALPHA_FUNCTION_DST_COLOR=774,$t.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR=775,$t.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED=776,$t.GL_ALPHA_FUNCTION_CONSTANT_COLOR=32769,$t.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR=32770,$t.GL_ALPHA_FUNCTION_CONSTANT_ALPHA=32771,$t.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA=32772,$t.SnippetUrl="https://snippet.babylonjs.com";class j_{static _GetDefaultOptions(){return{renderSize:1024,samples:4,lodGenerationScale:1,lodGenerationOffset:-4,renderTargetTextureType:$t.TEXTURETYPE_HALF_FLOAT,generateMipmaps:!0}}constructor(p,_){this._opaqueRenderTarget=null,this._opaqueMeshesCache=[],this._transparentMeshesCache=[],this._materialObservers={},this._options={...j_._GetDefaultOptions(),...p},this._scene=_,this._scene._transmissionHelper=this,this.onErrorObservable=new Mi,this._scene.onDisposeObservable.addOnce(()=>{this.dispose()}),this._parseScene(),this._setupRenderTargets()}updateOptions(p){if(!Object.keys(p).filter($=>this._options[$]!==p[$]).length)return;const E={...this._options,...p},A=this._options;this._options=E,E.renderSize!==A.renderSize||E.renderTargetTextureType!==A.renderTargetTextureType||E.generateMipmaps!==A.generateMipmaps||!this._opaqueRenderTarget?this._setupRenderTargets():(this._opaqueRenderTarget.samples=E.samples,this._opaqueRenderTarget.lodGenerationScale=E.lodGenerationScale,this._opaqueRenderTarget.lodGenerationOffset=E.lodGenerationOffset)}getOpaqueTarget(){return this._opaqueRenderTarget}_shouldRenderAsTransmission(p){return p?!!(p instanceof Ys&&p.subSurface.isRefractionEnabled):!1}_addMesh(p){this._materialObservers[p.uniqueId]=p.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this)),ct.SetImmediate(()=>{this._shouldRenderAsTransmission(p.material)?(p.material.refractionTexture=this._opaqueRenderTarget,this._transparentMeshesCache.indexOf(p)===-1&&this._transparentMeshesCache.push(p)):this._opaqueMeshesCache.indexOf(p)===-1&&this._opaqueMeshesCache.push(p)})}_removeMesh(p){p.onMaterialChangedObservable.remove(this._materialObservers[p.uniqueId]),delete this._materialObservers[p.uniqueId];let _=this._transparentMeshesCache.indexOf(p);_!==-1&&this._transparentMeshesCache.splice(_,1),_=this._opaqueMeshesCache.indexOf(p),_!==-1&&this._opaqueMeshesCache.splice(_,1)}_parseScene(){this._scene.meshes.forEach(this._addMesh.bind(this)),this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this)),this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this))}_onMeshMaterialChanged(p){const _=this._transparentMeshesCache.indexOf(p),E=this._opaqueMeshesCache.indexOf(p);this._shouldRenderAsTransmission(p.material)?(p.material instanceof Ys&&(p.material.subSurface.refractionTexture=this._opaqueRenderTarget),E!==-1?(this._opaqueMeshesCache.splice(E,1),this._transparentMeshesCache.push(p)):_===-1&&this._transparentMeshesCache.push(p)):_!==-1?(this._transparentMeshesCache.splice(_,1),this._opaqueMeshesCache.push(p)):E===-1&&this._opaqueMeshesCache.push(p)}_isRenderTargetValid(){return this._opaqueRenderTarget?.getInternalTexture()!==null}_setupRenderTargets(){this._opaqueRenderTarget&&this._opaqueRenderTarget.dispose(),this._opaqueRenderTarget=new $o("opaqueSceneTexture",this._options.renderSize,this._scene,this._options.generateMipmaps,void 0,this._options.renderTargetTextureType),this._opaqueRenderTarget.ignoreCameraViewport=!0,this._opaqueRenderTarget.renderList=this._opaqueMeshesCache,this._opaqueRenderTarget.clearColor=this._options.clearColor?.clone()??this._scene.clearColor.clone(),this._opaqueRenderTarget.gammaSpace=!1,this._opaqueRenderTarget.lodGenerationScale=this._options.lodGenerationScale,this._opaqueRenderTarget.lodGenerationOffset=this._options.lodGenerationOffset,this._opaqueRenderTarget.samples=this._options.samples,this._opaqueRenderTarget.renderSprites=!0,this._opaqueRenderTarget.renderParticles=!0;let p,_;this._opaqueRenderTarget.onBeforeBindObservable.add(E=>{_=this._scene.environmentIntensity,this._scene.environmentIntensity=1,p=this._scene.imageProcessingConfiguration.applyByPostProcess,this._options.clearColor?E.clearColor.copyFrom(this._options.clearColor):this._scene.clearColor.toLinearSpaceToRef(E.clearColor,this._scene.getEngine().useExactSrgbConversions),this._scene.imageProcessingConfiguration._applyByPostProcess=!0}),this._opaqueRenderTarget.onAfterUnbindObservable.add(()=>{this._scene.environmentIntensity=_,this._scene.imageProcessingConfiguration._applyByPostProcess=p}),this._transparentMeshesCache.forEach(E=>{this._shouldRenderAsTransmission(E.material)&&(E.material.refractionTexture=this._opaqueRenderTarget)})}dispose(){this._scene._transmissionHelper=void 0,this._opaqueRenderTarget&&(this._opaqueRenderTarget.dispose(),this._opaqueRenderTarget=null),this._transparentMeshesCache=[],this._opaqueMeshesCache=[]}}const q_="KHR_materials_transmission";class kB{constructor(p){this.name=q_,this.order=175,this._loader=p,this.enabled=this._loader.isExtensionUsed(q_),this.enabled&&(p.parent.transparencyAsCoverage=!0)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadTransparentPropertiesAsync(A,_,E,$)),Promise.all(ne).then(()=>{})})}_loadTransparentPropertiesAsync(p,_,E,A){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const $=E;if($.subSurface.isRefractionEnabled=!0,$.subSurface.volumeIndexOfRefraction=1,$.subSurface.useAlbedoToTintRefraction=!0,A.transmissionFactor!==void 0){$.subSurface.refractionIntensity=A.transmissionFactor;const ne=$.getScene();$.subSurface.refractionIntensity&&!ne._transmissionHelper?new j_({},$.getScene()):$.subSurface.refractionIntensity&&!ne._transmissionHelper?._isRenderTargetValid()&&ne._transmissionHelper?._setupRenderTargets()}else return $.subSurface.refractionIntensity=0,$.subSurface.isRefractionEnabled=!1,Promise.resolve();return $.subSurface.minimumThickness=0,$.subSurface.maximumThickness=0,A.transmissionTexture?(A.transmissionTexture.nonColorData=!0,this._loader.loadTextureInfoAsync(`${p}/transmissionTexture`,A.transmissionTexture,void 0).then(ne=>{$.subSurface.refractionIntensityTexture=ne,$.subSurface.useGltfStyleTextures=!0})):Promise.resolve()}}qs.RegisterExtension(q_,_e=>new kB(_e));const Z_="KHR_materials_translucency";class UB{constructor(p){this.name=Z_,this.order=174,this._loader=p,this.enabled=this._loader.isExtensionUsed(Z_),this.enabled&&(p.parent.transparencyAsCoverage=!0)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadTranslucentPropertiesAsync(A,_,E,$)),Promise.all(ne).then(()=>{})})}_loadTranslucentPropertiesAsync(p,_,E,A){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const $=E;if($.subSurface.isTranslucencyEnabled=!0,$.subSurface.volumeIndexOfRefraction=1,$.subSurface.minimumThickness=0,$.subSurface.maximumThickness=0,$.subSurface.useAlbedoToTintTranslucency=!0,A.translucencyFactor!==void 0)$.subSurface.translucencyIntensity=A.translucencyFactor;else return $.subSurface.translucencyIntensity=0,$.subSurface.isTranslucencyEnabled=!1,Promise.resolve();return A.translucencyTexture?(A.translucencyTexture.nonColorData=!0,this._loader.loadTextureInfoAsync(`${p}/translucencyTexture`,A.translucencyTexture).then(ne=>{$.subSurface.translucencyIntensityTexture=ne})):Promise.resolve()}}qs.RegisterExtension(Z_,_e=>new UB(_e));const Q_="KHR_materials_volume";class GB{constructor(p){this.name=Q_,this.order=173,this._loader=p,this.enabled=this._loader.isExtensionUsed(Q_),this.enabled&&this._loader._disableInstancedMesh++}dispose(){this.enabled&&this._loader._disableInstancedMesh--,this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadVolumePropertiesAsync(A,_,E,$)),Promise.all(ne).then(()=>{})})}_loadVolumePropertiesAsync(p,_,E,A){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);if(!E.subSurface.isRefractionEnabled&&!E.subSurface.isTranslucencyEnabled||!A.thicknessFactor)return Promise.resolve();E.subSurface.volumeIndexOfRefraction=E.indexOfRefraction;const $=A.attenuationDistance!==void 0?A.attenuationDistance:Number.MAX_VALUE;return E.subSurface.tintColorAtDistance=$,A.attenuationColor!==void 0&&A.attenuationColor.length==3&&E.subSurface.tintColor.copyFromFloats(A.attenuationColor[0],A.attenuationColor[1],A.attenuationColor[2]),E.subSurface.minimumThickness=0,E.subSurface.maximumThickness=A.thicknessFactor,E.subSurface.useThicknessAsDepth=!0,A.thicknessTexture?(A.thicknessTexture.nonColorData=!0,this._loader.loadTextureInfoAsync(`${p}/thicknessTexture`,A.thicknessTexture).then(ne=>{E.subSurface.thicknessTexture=ne,E.subSurface.useGltfStyleTextures=!0})):Promise.resolve()}}qs.RegisterExtension(Q_,_e=>new GB(_e));const J_="KHR_materials_dispersion";class zB{constructor(p){this.name=J_,this.order=174,this._loader=p,this.enabled=this._loader.isExtensionUsed(J_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return ne.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),ne.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),ne.push(this._loadDispersionPropertiesAsync(A,_,E,$)),Promise.all(ne).then(()=>{})})}_loadDispersionPropertiesAsync(p,_,E,A){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);return!E.subSurface.isRefractionEnabled||!A.dispersion||(E.subSurface.isDispersionEnabled=!0,E.subSurface.dispersion=A.dispersion),Promise.resolve()}}qs.RegisterExtension(J_,_e=>new zB(_e));const $_="KHR_mesh_quantization";class WB{constructor(p){this.name=$_,this.enabled=p.isExtensionUsed($_)}dispose(){}}qs.RegisterExtension($_,_e=>new WB(_e));const ry="KHR_texture_basisu";class HB{constructor(p){this.name=ry,this._loader=p,this.enabled=p.isExtensionUsed(ry)}dispose(){this._loader=null}_loadTextureAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=_.sampler==null?qs.DefaultSampler:Wr.Get(`${p}/sampler`,this._loader.gltf.samplers,_.sampler),xe=Wr.Get(`${A}/source`,this._loader.gltf.images,$.source);return this._loader._createTextureAsync(p,ne,xe,ce=>{E(ce)},_._textureInfo.nonColorData?{useRGBAIfASTCBC7NotAvailableWhenUASTC:!0}:void 0,!_._textureInfo.nonColorData)})}}qs.RegisterExtension(ry,_e=>new HB(_e));const ny="KHR_texture_transform";class XB{constructor(p){this.name=ny,this._loader=p,this.enabled=this._loader.isExtensionUsed(ny)}dispose(){this._loader=null}loadTextureInfoAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>this._loader.loadTextureInfoAsync(p,_,ne=>{if(!(ne instanceof Hi))throw new Error(`${A}: Texture type not supported`);$.offset&&(ne.uOffset=$.offset[0],ne.vOffset=$.offset[1]),ne.uRotationCenter=0,ne.vRotationCenter=0,$.rotation&&(ne.wAng=-$.rotation),$.scale&&(ne.uScale=$.scale[0],ne.vScale=$.scale[1]),$.texCoord!=null&&(ne.coordinatesIndex=$.texCoord),E(ne)}))}}qs.RegisterExtension(ny,_e=>new XB(_e));const ay="KHR_xmp_json_ld";class KB{constructor(p){this.name=ay,this.order=100,this._loader=p,this.enabled=this._loader.isExtensionUsed(ay)}dispose(){this._loader=null}onLoading(){if(this._loader.rootBabylonMesh===null)return;const p=this._loader.gltf.extensions?.KHR_xmp_json_ld,_=this._loader.gltf.asset?.extensions?.KHR_xmp_json_ld;if(p&&_){const E=+_.packet;p.packets&&E<p.packets.length&&(this._loader.rootBabylonMesh.metadata=this._loader.rootBabylonMesh.metadata||{},this._loader.rootBabylonMesh.metadata.xmp=p.packets[E])}}}qs.RegisterExtension(ay,_e=>new KB(_e));function nd(_e,p,_,E){return ws.FromArray(p,_).scale(E)}function YB(_e,p,_,E){return p[_+3]*E}function Ga(_e,p,_,E){return p[_]*E}function xy(_e,p,_,E){return-p[_]*E}function Hg(_e,p,_,E){return p[_+1]*E}function pO(_e,p,_,E){return p[_]*E*2}function ly(_e){return{scale:[new Ta(Ui.ANIMATIONTYPE_FLOAT,`${_e}.uScale`,Ga,()=>2),new Ta(Ui.ANIMATIONTYPE_FLOAT,`${_e}.vScale`,Hg,()=>2)],offset:[new Ta(Ui.ANIMATIONTYPE_FLOAT,`${_e}.uOffset`,Ga,()=>2),new Ta(Ui.ANIMATIONTYPE_FLOAT,`${_e}.vOffset`,Hg,()=>2)],rotation:[new Ta(Ui.ANIMATIONTYPE_FLOAT,`${_e}.wAng`,xy,()=>1)]}}class _h extends Tm{buildAnimations(p,_,E,A,$){$(p._babylonCamera,this._buildAnimation(_,E,A))}}class Ta extends Tm{buildAnimations(p,_,E,A,$){for(const ne in p._data)$(p._data[ne].babylonMaterial,this._buildAnimation(_,E,A))}}class Rm extends Tm{buildAnimations(p,_,E,A,$){$(p._babylonLight,this._buildAnimation(_,E,A))}}const jB={__array__:{__target__:!0,...vm}},qB={__array__:{__target__:!0,orthographic:{xmag:[new _h(Ui.ANIMATIONTYPE_FLOAT,"orthoLeft",xy,()=>1),new _h(Ui.ANIMATIONTYPE_FLOAT,"orthoRight",Hg,()=>1)],ymag:[new _h(Ui.ANIMATIONTYPE_FLOAT,"orthoBottom",xy,()=>1),new _h(Ui.ANIMATIONTYPE_FLOAT,"orthoTop",Hg,()=>1)],zfar:[new _h(Ui.ANIMATIONTYPE_FLOAT,"maxZ",Ga,()=>1)],znear:[new _h(Ui.ANIMATIONTYPE_FLOAT,"minZ",Ga,()=>1)]},perspective:{yfov:[new _h(Ui.ANIMATIONTYPE_FLOAT,"fov",Ga,()=>1)],zfar:[new _h(Ui.ANIMATIONTYPE_FLOAT,"maxZ",Ga,()=>1)],znear:[new _h(Ui.ANIMATIONTYPE_FLOAT,"minZ",Ga,()=>1)]}}},$B={__array__:{__target__:!0,pbrMetallicRoughness:{baseColorFactor:[new Ta(Ui.ANIMATIONTYPE_COLOR3,"albedoColor",nd,()=>4),new Ta(Ui.ANIMATIONTYPE_FLOAT,"alpha",YB,()=>4)],metallicFactor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"metallic",Ga,()=>1)],roughnessFactor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"roughness",Ga,()=>1)],baseColorTexture:{extensions:{KHR_texture_transform:ly("albedoTexture")}}},emissiveFactor:[new Ta(Ui.ANIMATIONTYPE_COLOR3,"emissiveColor",nd,()=>3)],normalTexture:{scale:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"bumpTexture.level",Ga,()=>1)]},occlusionTexture:{strength:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"ambientTextureStrength",Ga,()=>1)],extensions:{KHR_texture_transform:ly("ambientTexture")}},emissiveTexture:{extensions:{KHR_texture_transform:ly("emissiveTexture")}},extensions:{KHR_materials_ior:{ior:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"indexOfRefraction",Ga,()=>1)]},KHR_materials_clearcoat:{clearcoatFactor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"clearCoat.intensity",Ga,()=>1)],clearcoatRoughnessFactor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"clearCoat.roughness",Ga,()=>1)]},KHR_materials_sheen:{sheenColorFactor:[new Ta(Ui.ANIMATIONTYPE_COLOR3,"sheen.color",nd,()=>3)],sheenRoughnessFactor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"sheen.roughness",Ga,()=>1)]},KHR_materials_specular:{specularFactor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"metallicF0Factor",Ga,()=>1)],specularColorFactor:[new Ta(Ui.ANIMATIONTYPE_COLOR3,"metallicReflectanceColor",nd,()=>3)]},KHR_materials_emissive_strength:{emissiveStrength:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"emissiveIntensity",Ga,()=>1)]},KHR_materials_transmission:{transmissionFactor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"subSurface.refractionIntensity",Ga,()=>1)]},KHR_materials_volume:{attenuationColor:[new Ta(Ui.ANIMATIONTYPE_COLOR3,"subSurface.tintColor",nd,()=>3)],attenuationDistance:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"subSurface.tintColorAtDistance",Ga,()=>1)],thicknessFactor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"subSurface.maximumThickness",Ga,()=>1)]},KHR_materials_dispersion:{dispersion:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"subSurface.dispersion",Ga,()=>1)]},KHR_materials_iridescence:{iridescenceFactor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"iridescence.intensity",Ga,()=>1)],iridescenceIor:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"iridescence.indexOfRefraction",Ga,()=>1)],iridescenceThicknessMinimum:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"iridescence.minimumThickness",Ga,()=>1)],iridescenceThicknessMaximum:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"iridescence.maximumThickness",Ga,()=>1)]},KHR_materials_anisotropy:{anisotropyStrength:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"anisotropy.intensity",Ga,()=>1)],anisotropyRotation:[new Ta(Ui.ANIMATIONTYPE_FLOAT,"anisotropy.angle",Ga,()=>1)]}}}},r3={KHR_lights_punctual:{lights:{__array__:{__target__:!0,color:[new Rm(Ui.ANIMATIONTYPE_COLOR3,"diffuse",nd,()=>3)],intensity:[new Rm(Ui.ANIMATIONTYPE_FLOAT,"intensity",Ga,()=>1)],range:[new Rm(Ui.ANIMATIONTYPE_FLOAT,"range",Ga,()=>1)],spot:{innerConeAngle:[new Rm(Ui.ANIMATIONTYPE_FLOAT,"innerAngle",pO,()=>1)],outerConeAngle:[new Rm(Ui.ANIMATIONTYPE_FLOAT,"angle",pO,()=>1)]}}}}},n3={nodes:jB,materials:$B,cameras:qB,extensions:r3};class _O{constructor(p,_){this._gltf=p,this._infoTree=_}convert(p){let _=this._gltf,E=this._infoTree,A;if(!p.startsWith("/"))throw new Error("Path must start with a /");const $=p.split("/");$.shift();for(const ne of $){if(E.__array__)E=E.__array__;else if(E=E[ne],!E)throw new Error(`Path ${p} is invalid`);if(_===void 0)throw new Error(`Path ${p} is invalid`);_=_[ne],E.__target__&&(A=_)}return{object:A,info:E}}}const hy="KHR_animation_pointer";class a3 extends _O{constructor(p){super(p,n3)}}class x3{constructor(p){this.name=hy,this._loader=p,this._pathToObjectConverter=new a3(this._loader.gltf)}get enabled(){return this._loader.isExtensionUsed(hy)}dispose(){this._loader=null,delete this._pathToObjectConverter}_loadAnimationChannelAsync(p,_,E,A,$){const ne=A.target.extensions?.KHR_animation_pointer;if(!ne||!this._pathToObjectConverter)return null;A.target.path!=="pointer"&&vi.Warn(`${p}/target/path: Value (${A.target.path}) must be (pointer) when using the ${this.name} extension`),A.target.node!=null&&vi.Warn(`${p}/target/node: Value (${A.target.node}) must not be present when using the ${this.name} extension`);const xe=`${p}/extensions/${this.name}`,ce=ne.pointer;if(!ce)throw new Error(`${xe}: Pointer is missing`);try{const Te=this._pathToObjectConverter.convert(ce);return this._loader._loadAnimationChannelFromTargetInfoAsync(p,_,E,A,Te,$)}catch{return vi.Warn(`${xe}/pointer: Invalid pointer (${ce}) skipped`),null}}}qs.RegisterExtension(hy,_e=>new x3(_e));class cy{constructor(p,_,E){this.frame=p,this.action=_,this.onlyOnce=E,this.isDone=!1}_clone(){return new cy(this.frame,this.action,this.onlyOnce)}}class hu{get loop(){return this._loop}set loop(p){p!==this._loop&&(this._loop=p,this.updateOptions({loop:p}))}get currentTime(){if(this._htmlAudioElement)return this._htmlAudioElement.currentTime;if(ui.audioEngine?.audioContext&&(this.isPlaying||this.isPaused)){const p=this.isPaused?0:ui.audioEngine.audioContext.currentTime-this._startTime;return this._currentTime+p}return 0}get spatialSound(){return this._spatialSound}set spatialSound(p){if(p==this._spatialSound)return;const _=this.isPlaying;this.pause(),p?(this._spatialSound=p,this._updateSpatialParameters()):this._disableSpatialSound(),_&&this.play()}constructor(p,_,E,A=null,$){if(this.autoplay=!1,this._loop=!1,this.useCustomAttenuation=!1,this.isPlaying=!1,this.isPaused=!1,this.refDistance=1,this.rolloffFactor=1,this.maxDistance=100,this.distanceModel="linear",this.metadata=null,this.onEndedObservable=new Mi,this._spatialSound=!1,this._panningModel="equalpower",this._playbackRate=1,this._streaming=!1,this._startTime=0,this._currentTime=0,this._position=nt.Zero(),this._localDirection=new nt(1,0,0),this._volume=1,this._isReadyToPlay=!1,this._isDirectional=!1,this._coneInnerAngle=360,this._coneOuterAngle=360,this._coneOuterGain=0,this._isOutputConnected=!1,this._urlType="Unknown",this.name=p,E=E||wr.LastCreatedScene,!!E)if(this._scene=E,hu._SceneComponentInitialization(E),this._readyToPlayCallback=A,this._customAttenuationFunction=(ne,xe,ce,Te,Re)=>xe<ce?ne*(1-xe/ce):0,$&&(this.autoplay=$.autoplay||!1,this._loop=$.loop||!1,$.volume!==void 0&&(this._volume=$.volume),this._spatialSound=$.spatialSound??!1,this.maxDistance=$.maxDistance??100,this.useCustomAttenuation=$.useCustomAttenuation??!1,this.rolloffFactor=$.rolloffFactor||1,this.refDistance=$.refDistance||1,this.distanceModel=$.distanceModel||"linear",this._playbackRate=$.playbackRate||1,this._streaming=$.streaming??!1,this._length=$.length,this._offset=$.offset),ui.audioEngine?.canUseWebAudio&&ui.audioEngine.audioContext){this._soundGain=ui.audioEngine.audioContext.createGain(),this._soundGain.gain.value=this._volume,this._inputAudioNode=this._soundGain,this._outputAudioNode=this._soundGain,this._spatialSound&&this._createSpatialParameters(),this._scene.mainSoundTrack.addSound(this);let ne=!0;if(_)try{typeof _=="string"?(this._urlType="String",this._url=_):_ instanceof ArrayBuffer?this._urlType="ArrayBuffer":_ instanceof HTMLMediaElement?this._urlType="MediaElement":_ instanceof MediaStream?this._urlType="MediaStream":_ instanceof AudioBuffer?this._urlType="AudioBuffer":Array.isArray(_)&&(this._urlType="Array");let xe=[],ce=!1;switch(this._urlType){case"MediaElement":this._streaming=!0,this._isReadyToPlay=!0,this._streamingSource=ui.audioEngine.audioContext.createMediaElementSource(_),this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback();break;case"MediaStream":this._streaming=!0,this._isReadyToPlay=!0,this._streamingSource=ui.audioEngine.audioContext.createMediaStreamSource(_),this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback();break;case"ArrayBuffer":_.byteLength>0&&(ce=!0,this._soundLoaded(_));break;case"AudioBuffer":this._audioBufferLoaded(_);break;case"String":xe.push(_);case"Array":xe.length===0&&(xe=_);for(let Te=0;Te<xe.length;Te++){const Re=xe[Te];if(ce=$&&$.skipCodecCheck||Re.indexOf(".mp3",Re.length-4)!==-1&&ui.audioEngine.isMP3supported||Re.indexOf(".ogg",Re.length-4)!==-1&&ui.audioEngine.isOGGsupported||Re.indexOf(".wav",Re.length-4)!==-1||Re.indexOf(".m4a",Re.length-4)!==-1||Re.indexOf(".mp4",Re.length-4)!==-1||Re.indexOf("blob:")!==-1,ce){this._streaming?(this._htmlAudioElement=new Audio(Re),this._htmlAudioElement.controls=!1,this._htmlAudioElement.loop=this.loop,ct.SetCorsBehavior(Re,this._htmlAudioElement),this._htmlAudioElement.preload="auto",this._htmlAudioElement.addEventListener("canplaythrough",()=>{this._isReadyToPlay=!0,this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback()}),document.body.appendChild(this._htmlAudioElement),this._htmlAudioElement.load()):this._scene._loadFile(Re,ke=>{this._soundLoaded(ke)},void 0,!0,!0,ke=>{ke&&vi.Error("XHR "+ke.status+" error on: "+Re+"."),vi.Error("Sound creation aborted."),this._scene.mainSoundTrack.removeSound(this)});break}}break;default:ne=!1;break}ne?ce||(this._isReadyToPlay=!0,this._readyToPlayCallback&&setTimeout(()=>{this._readyToPlayCallback&&this._readyToPlayCallback()},1e3)):vi.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.")}catch{vi.Error("Unexpected error. Sound creation aborted."),this._scene.mainSoundTrack.removeSound(this)}}else this._scene.mainSoundTrack.addSound(this),ui.audioEngine&&!ui.audioEngine.WarnedWebAudioUnsupported&&(vi.Error("Web Audio is not supported by your browser."),ui.audioEngine.WarnedWebAudioUnsupported=!0),this._readyToPlayCallback&&setTimeout(()=>{this._readyToPlayCallback&&this._readyToPlayCallback()},1e3)}dispose(){ui.audioEngine?.canUseWebAudio&&(this.isPlaying&&this.stop(),this._isReadyToPlay=!1,this.soundTrackId===-1?this._scene.mainSoundTrack.removeSound(this):this._scene.soundTracks&&this._scene.soundTracks[this.soundTrackId].removeSound(this),this._soundGain&&(this._soundGain.disconnect(),this._soundGain=null),this._soundPanner&&(this._soundPanner.disconnect(),this._soundPanner=null),this._soundSource&&(this._soundSource.disconnect(),this._soundSource=null),this._audioBuffer=null,this._htmlAudioElement&&(this._htmlAudioElement.pause(),this._htmlAudioElement.src="",document.body.removeChild(this._htmlAudioElement)),this._streamingSource&&this._streamingSource.disconnect(),this._connectedTransformNode&&this._registerFunc&&(this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc),this._connectedTransformNode=null),this._clearTimeoutsAndObservers())}isReady(){return this._isReadyToPlay}getClassName(){return"Sound"}_audioBufferLoaded(p){ui.audioEngine?.audioContext&&(this._audioBuffer=p,this._isReadyToPlay=!0,this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback())}_soundLoaded(p){ui.audioEngine?.audioContext&&ui.audioEngine.audioContext.decodeAudioData(p,_=>{this._audioBufferLoaded(_)},_=>{vi.Error("Error while decoding audio data for: "+this.name+" / Error: "+_)})}setAudioBuffer(p){ui.audioEngine?.canUseWebAudio&&(this._audioBuffer=p,this._isReadyToPlay=!0)}updateOptions(p){p&&(this.loop=p.loop??this.loop,this.maxDistance=p.maxDistance??this.maxDistance,this.useCustomAttenuation=p.useCustomAttenuation??this.useCustomAttenuation,this.rolloffFactor=p.rolloffFactor??this.rolloffFactor,this.refDistance=p.refDistance??this.refDistance,this.distanceModel=p.distanceModel??this.distanceModel,this._playbackRate=p.playbackRate??this._playbackRate,this._length=p.length??void 0,this.spatialSound=p.spatialSound??this._spatialSound,this._setOffset(p.offset??void 0),this.setVolume(p.volume??this._volume),this._updateSpatialParameters(),this.isPlaying&&(this._streaming&&this._htmlAudioElement?(this._htmlAudioElement.playbackRate=this._playbackRate,this._htmlAudioElement.loop!==this.loop&&(this._htmlAudioElement.loop=this.loop)):this._soundSource&&(this._soundSource.playbackRate.value=this._playbackRate,this._soundSource.loop!==this.loop&&(this._soundSource.loop=this.loop),this._offset!==void 0&&this._soundSource.loopStart!==this._offset&&(this._soundSource.loopStart=this._offset),this._length!==void 0&&this._length!==this._soundSource.loopEnd&&(this._soundSource.loopEnd=(this._offset|0)+this._length))))}_createSpatialParameters(){ui.audioEngine?.canUseWebAudio&&ui.audioEngine.audioContext&&(this._scene.headphone&&(this._panningModel="HRTF"),this._soundPanner=this._soundPanner??ui.audioEngine.audioContext.createPanner(),this._soundPanner&&this._outputAudioNode&&(this._updateSpatialParameters(),this._soundPanner.connect(this._outputAudioNode),this._inputAudioNode=this._soundPanner))}_disableSpatialSound(){this._spatialSound&&(this._inputAudioNode=this._soundGain,this._soundPanner?.disconnect(),this._soundPanner=null,this._spatialSound=!1)}_updateSpatialParameters(){this._spatialSound&&(this._soundPanner?this.useCustomAttenuation?(this._soundPanner.distanceModel="linear",this._soundPanner.maxDistance=Number.MAX_VALUE,this._soundPanner.refDistance=1,this._soundPanner.rolloffFactor=1,this._soundPanner.panningModel=this._panningModel):(this._soundPanner.distanceModel=this.distanceModel,this._soundPanner.maxDistance=this.maxDistance,this._soundPanner.refDistance=this.refDistance,this._soundPanner.rolloffFactor=this.rolloffFactor,this._soundPanner.panningModel=this._panningModel):this._createSpatialParameters())}switchPanningModelToHRTF(){this._panningModel="HRTF",this._switchPanningModel()}switchPanningModelToEqualPower(){this._panningModel="equalpower",this._switchPanningModel()}_switchPanningModel(){ui.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&(this._soundPanner.panningModel=this._panningModel)}connectToSoundTrackAudioNode(p){ui.audioEngine?.canUseWebAudio&&this._outputAudioNode&&(this._isOutputConnected&&this._outputAudioNode.disconnect(),this._outputAudioNode.connect(p),this._isOutputConnected=!0)}setDirectionalCone(p,_,E){if(_<p){vi.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=p,this._coneOuterAngle=_,this._coneOuterGain=E,this._isDirectional=!0,this.isPlaying&&this.loop&&(this.stop(),this.play(0,this._offset,this._length))}get directionalConeInnerAngle(){return this._coneInnerAngle}set directionalConeInnerAngle(p){if(p!=this._coneInnerAngle){if(this._coneOuterAngle<p){vi.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=p,ui.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&(this._soundPanner.coneInnerAngle=this._coneInnerAngle)}}get directionalConeOuterAngle(){return this._coneOuterAngle}set directionalConeOuterAngle(p){if(p!=this._coneOuterAngle){if(p<this._coneInnerAngle){vi.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneOuterAngle=p,ui.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&(this._soundPanner.coneOuterAngle=this._coneOuterAngle)}}setPosition(p){p.equals(this._position)||(this._position.copyFrom(p),ui.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&!isNaN(this._position.x)&&!isNaN(this._position.y)&&!isNaN(this._position.z)&&(this._soundPanner.positionX.value=this._position.x,this._soundPanner.positionY.value=this._position.y,this._soundPanner.positionZ.value=this._position.z))}setLocalDirectionToMesh(p){this._localDirection=p,ui.audioEngine?.canUseWebAudio&&this._connectedTransformNode&&this.isPlaying&&this._updateDirection()}_updateDirection(){if(!this._connectedTransformNode||!this._soundPanner)return;const p=this._connectedTransformNode.getWorldMatrix(),_=nt.TransformNormal(this._localDirection,p);_.normalize(),this._soundPanner.orientationX.value=_.x,this._soundPanner.orientationY.value=_.y,this._soundPanner.orientationZ.value=_.z}updateDistanceFromListener(){if(ui.audioEngine?.canUseWebAudio&&this._connectedTransformNode&&this.useCustomAttenuation&&this._soundGain&&this._scene.activeCamera){const p=this._scene.audioListenerPositionProvider?this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length():this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);this._soundGain.gain.value=this._customAttenuationFunction(this._volume,p,this.maxDistance,this.refDistance,this.rolloffFactor)}}setAttenuationFunction(p){this._customAttenuationFunction=p}play(p,_,E){if(this._isReadyToPlay&&this._scene.audioEnabled&&ui.audioEngine?.audioContext)try{this._clearTimeoutsAndObservers();let A=p?ui.audioEngine?.audioContext.currentTime+p:ui.audioEngine?.audioContext.currentTime;if((!this._soundSource||!this._streamingSource)&&this._spatialSound&&this._soundPanner&&(!isNaN(this._position.x)&&!isNaN(this._position.y)&&!isNaN(this._position.z)&&(this._soundPanner.positionX.value=this._position.x,this._soundPanner.positionY.value=this._position.y,this._soundPanner.positionZ.value=this._position.z),this._isDirectional&&(this._soundPanner.coneInnerAngle=this._coneInnerAngle,this._soundPanner.coneOuterAngle=this._coneOuterAngle,this._soundPanner.coneOuterGain=this._coneOuterGain,this._connectedTransformNode?this._updateDirection():this._soundPanner.setOrientation(this._localDirection.x,this._localDirection.y,this._localDirection.z))),this._streaming){if(this._streamingSource||(this._streamingSource=ui.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement),this._htmlAudioElement.onended=()=>{this._onended()},this._htmlAudioElement.playbackRate=this._playbackRate),this._streamingSource.disconnect(),this._inputAudioNode&&this._streamingSource.connect(this._inputAudioNode),this._htmlAudioElement){const $=()=>{if(ui.audioEngine?.unlocked){const ne=this._htmlAudioElement.play();ne!==void 0&&ne.catch(()=>{ui.audioEngine?.lock(),(this.loop||this.autoplay)&&(this._audioUnlockedObserver=ui.audioEngine?.onAudioUnlockedObservable.addOnce(()=>{$()}))})}else(this.loop||this.autoplay)&&(this._audioUnlockedObserver=ui.audioEngine?.onAudioUnlockedObservable.addOnce(()=>{$()}))};$()}}else{const $=()=>{if(ui.audioEngine?.audioContext){if(E=E||this._length,_!==void 0&&this._setOffset(_),this._soundSource){const ne=this._soundSource;ne.onended=()=>{ne.disconnect()}}if(this._soundSource=ui.audioEngine?.audioContext.createBufferSource(),this._soundSource&&this._inputAudioNode){this._soundSource.buffer=this._audioBuffer,this._soundSource.connect(this._inputAudioNode),this._soundSource.loop=this.loop,_!==void 0&&(this._soundSource.loopStart=_),E!==void 0&&(this._soundSource.loopEnd=(_|0)+E),this._soundSource.playbackRate.value=this._playbackRate,this._soundSource.onended=()=>{this._onended()},A=p?ui.audioEngine?.audioContext.currentTime+p:ui.audioEngine.audioContext.currentTime;const ne=((this.isPaused?this.currentTime:0)+(this._offset??0))%this._soundSource.buffer.duration;this._soundSource.start(A,ne,this.loop?void 0:E)}}};ui.audioEngine?.audioContext.state==="suspended"?this._tryToPlayTimeout=setTimeout(()=>{ui.audioEngine?.audioContext.state==="suspended"?(ui.audioEngine.lock(),(this.loop||this.autoplay)&&(this._audioUnlockedObserver=ui.audioEngine.onAudioUnlockedObservable.addOnce(()=>{$()}))):$()},500):$()}this._startTime=A,this.isPlaying=!0,this.isPaused=!1}catch(A){vi.Error("Error while trying to play audio: "+this.name+", "+A.message)}}_onended(){this.isPlaying=!1,this._startTime=0,this._currentTime=0,this.onended&&this.onended(),this.onEndedObservable.notifyObservers(this)}stop(p){if(this.isPlaying)if(this._clearTimeoutsAndObservers(),this._streaming)this._htmlAudioElement?(this._htmlAudioElement.pause(),this._htmlAudioElement.currentTime>0&&(this._htmlAudioElement.currentTime=0)):this._streamingSource.disconnect(),this.isPlaying=!1;else if(ui.audioEngine?.audioContext&&this._soundSource){const _=p?ui.audioEngine.audioContext.currentTime+p:void 0;this._soundSource.onended=()=>{this.isPlaying=!1,this.isPaused=!1,this._startTime=0,this._currentTime=0,this._soundSource&&(this._soundSource.onended=()=>{}),this._onended()},this._soundSource.stop(_)}else this.isPlaying=!1;else this.isPaused&&(this.isPaused=!1,this._startTime=0,this._currentTime=0)}pause(){this.isPlaying&&(this._clearTimeoutsAndObservers(),this._streaming?(this._htmlAudioElement?this._htmlAudioElement.pause():this._streamingSource.disconnect(),this.isPlaying=!1,this.isPaused=!0):ui.audioEngine?.audioContext&&this._soundSource&&(this._soundSource.onended=()=>{},this._soundSource.stop(),this.isPlaying=!1,this.isPaused=!0,this._currentTime+=ui.audioEngine.audioContext.currentTime-this._startTime))}setVolume(p,_){ui.audioEngine?.canUseWebAudio&&this._soundGain&&(_&&ui.audioEngine.audioContext?(this._soundGain.gain.cancelScheduledValues(ui.audioEngine.audioContext.currentTime),this._soundGain.gain.setValueAtTime(this._soundGain.gain.value,ui.audioEngine.audioContext.currentTime),this._soundGain.gain.linearRampToValueAtTime(p,ui.audioEngine.audioContext.currentTime+_)):this._soundGain.gain.value=p),this._volume=p}setPlaybackRate(p){this._playbackRate=p,this.isPlaying&&(this._streaming&&this._htmlAudioElement?this._htmlAudioElement.playbackRate=this._playbackRate:this._soundSource&&(this._soundSource.playbackRate.value=this._playbackRate))}getPlaybackRate(){return this._playbackRate}getVolume(){return this._volume}attachToMesh(p){this._connectedTransformNode&&this._registerFunc&&(this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc),this._registerFunc=null),this._connectedTransformNode=p,this._spatialSound||(this._spatialSound=!0,this._createSpatialParameters(),this.isPlaying&&this.loop&&(this.stop(),this.play(0,this._offset,this._length))),this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode),this._registerFunc=_=>this._onRegisterAfterWorldMatrixUpdate(_),this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc)}detachFromMesh(){this._connectedTransformNode&&this._registerFunc&&(this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc),this._registerFunc=null,this._connectedTransformNode=null)}_onRegisterAfterWorldMatrixUpdate(p){if(!p.getBoundingInfo)this.setPosition(p.absolutePosition);else{const E=p.getBoundingInfo();this.setPosition(E.boundingSphere.centerWorld)}ui.audioEngine?.canUseWebAudio&&this._isDirectional&&this.isPlaying&&this._updateDirection()}clone(){if(this._streaming)return null;{const p=()=>{this._isReadyToPlay?(E._audioBuffer=this.getAudioBuffer(),E._isReadyToPlay=!0,E.autoplay&&E.play(0,this._offset,this._length)):setTimeout(p,300)},_={autoplay:this.autoplay,loop:this.loop,volume:this._volume,spatialSound:this._spatialSound,maxDistance:this.maxDistance,useCustomAttenuation:this.useCustomAttenuation,rolloffFactor:this.rolloffFactor,refDistance:this.refDistance,distanceModel:this.distanceModel},E=new hu(this.name+"_cloned",new ArrayBuffer(0),this._scene,null,_);return this.useCustomAttenuation&&E.setAttenuationFunction(this._customAttenuationFunction),E.setPosition(this._position),E.setPlaybackRate(this._playbackRate),p(),E}}getAudioBuffer(){return this._audioBuffer}getSoundSource(){return this._soundSource}getSoundGain(){return this._soundGain}serialize(){const p={name:this.name,url:this._url,autoplay:this.autoplay,loop:this.loop,volume:this._volume,spatialSound:this._spatialSound,maxDistance:this.maxDistance,rolloffFactor:this.rolloffFactor,refDistance:this.refDistance,distanceModel:this.distanceModel,playbackRate:this._playbackRate,panningModel:this._panningModel,soundTrackId:this.soundTrackId,metadata:this.metadata};return this._spatialSound&&(this._connectedTransformNode&&(p.connectedMeshId=this._connectedTransformNode.id),p.position=this._position.asArray(),p.refDistance=this.refDistance,p.distanceModel=this.distanceModel,p.isDirectional=this._isDirectional,p.localDirectionToMesh=this._localDirection.asArray(),p.coneInnerAngle=this._coneInnerAngle,p.coneOuterAngle=this._coneOuterAngle,p.coneOuterGain=this._coneOuterGain),p}static Parse(p,_,E,A){const $=p.name;let ne;p.url?ne=E+p.url:ne=E+$;const xe={autoplay:p.autoplay,loop:p.loop,volume:p.volume,spatialSound:p.spatialSound,maxDistance:p.maxDistance,rolloffFactor:p.rolloffFactor,refDistance:p.refDistance,distanceModel:p.distanceModel,playbackRate:p.playbackRate};let ce;if(!A)ce=new hu($,ne,_,()=>{_.removePendingData(ce)},xe),_.addPendingData(ce);else{const Te=()=>{A._isReadyToPlay?(ce._audioBuffer=A.getAudioBuffer(),ce._isReadyToPlay=!0,ce.autoplay&&ce.play(0,ce._offset,ce._length)):setTimeout(Te,300)};ce=new hu($,new ArrayBuffer(0),_,null,xe),Te()}if(p.position){const Te=nt.FromArray(p.position);ce.setPosition(Te)}if(p.isDirectional&&(ce.setDirectionalCone(p.coneInnerAngle||360,p.coneOuterAngle||360,p.coneOuterGain||0),p.localDirectionToMesh)){const Te=nt.FromArray(p.localDirectionToMesh);ce.setLocalDirectionToMesh(Te)}if(p.connectedMeshId){const Te=_.getMeshById(p.connectedMeshId);Te&&ce.attachToMesh(Te)}return p.metadata&&(ce.metadata=p.metadata),ce}_setOffset(p){this._offset!==p&&(this.isPaused&&(this.stop(),this.isPaused=!1),this._offset=p)}_clearTimeoutsAndObservers(){this._tryToPlayTimeout&&(clearTimeout(this._tryToPlayTimeout),this._tryToPlayTimeout=null),this._audioUnlockedObserver&&(ui.audioEngine?.onAudioUnlockedObservable.remove(this._audioUnlockedObserver),this._audioUnlockedObserver=null)}}hu._SceneComponentInitialization=_e=>{throw Tr("AudioSceneComponent")};class l3{constructor(p,_,E){if(this.loop=!1,this._coneInnerAngle=360,this._coneOuterAngle=360,this._volume=1,this.isPlaying=!1,this.isPaused=!1,this._sounds=[],this._weights=[],_.length!==E.length)throw new Error("Sounds length does not equal weights length");this.loop=p,this._weights=E;let A=0;for(const ne of E)A+=ne;const $=A>0?1/A:0;for(let ne=0;ne<this._weights.length;ne++)this._weights[ne]*=$;this._sounds=_;for(const ne of this._sounds)ne.onEndedObservable.add(()=>{this._onended()})}get directionalConeInnerAngle(){return this._coneInnerAngle}set directionalConeInnerAngle(p){if(p!==this._coneInnerAngle){if(this._coneOuterAngle<p){vi.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=p;for(const _ of this._sounds)_.directionalConeInnerAngle=p}}get directionalConeOuterAngle(){return this._coneOuterAngle}set directionalConeOuterAngle(p){if(p!==this._coneOuterAngle){if(p<this._coneInnerAngle){vi.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneOuterAngle=p;for(const _ of this._sounds)_.directionalConeOuterAngle=p}}get volume(){return this._volume}set volume(p){if(p!==this._volume)for(const _ of this._sounds)_.setVolume(p)}_onended(){this._currentIndex!==void 0&&(this._sounds[this._currentIndex].autoplay=!1),this.loop&&this.isPlaying?this.play():this.isPlaying=!1}pause(){this.isPaused=!0,this._currentIndex!==void 0&&this._sounds[this._currentIndex].pause()}stop(){this.isPlaying=!1,this._currentIndex!==void 0&&this._sounds[this._currentIndex].stop()}play(p){if(!this.isPaused){this.stop();const E=Math.random();let A=0;for(let $=0;$<this._weights.length;$++)if(A+=this._weights[$],E<=A){this._currentIndex=$;break}}const _=this._sounds[this._currentIndex];_.isReady()?_.play(0,this.isPaused?void 0:p):_.autoplay=!0,this.isPlaying=!0,this.isPaused=!1}}const uy="MSFT_audio_emitter";class h3{constructor(p){this.name=uy,this._loader=p,this.enabled=this._loader.isExtensionUsed(uy)}dispose(){this._loader=null,this._clips=null,this._emitters=null}onLoading(){const p=this._loader.gltf.extensions;if(p&&p[this.name]){const _=p[this.name];this._clips=_.clips,this._emitters=_.emitters,Wr.Assign(this._clips),Wr.Assign(this._emitters)}}loadSceneAsync(p,_){return qs.LoadExtensionAsync(p,_,this.name,(E,A)=>{const $=new Array;$.push(this._loader.loadSceneAsync(p,_));for(const ne of A.emitters){const xe=Wr.Get(`${E}/emitters`,this._emitters,ne);if(xe.refDistance!=null||xe.maxDistance!=null||xe.rolloffFactor!=null||xe.distanceModel!=null||xe.innerAngle!=null||xe.outerAngle!=null)throw new Error(`${E}: Direction or Distance properties are not allowed on emitters attached to a scene`);$.push(this._loadEmitterAsync(`${E}/emitters/${xe.index}`,xe))}return Promise.all($).then(()=>{})})}loadNodeAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{const ne=new Array;return this._loader.loadNodeAsync(A,_,xe=>{for(const ce of $.emitters){const Te=Wr.Get(`${A}/emitters`,this._emitters,ce);ne.push(this._loadEmitterAsync(`${A}/emitters/${Te.index}`,Te).then(()=>{for(const Re of Te._babylonSounds)Re.attachToMesh(xe),(Te.innerAngle!=null||Te.outerAngle!=null)&&(Re.setLocalDirectionToMesh(nt.Forward()),Re.setDirectionalCone(2*ct.ToDegrees(Te.innerAngle==null?Math.PI:Te.innerAngle),2*ct.ToDegrees(Te.outerAngle==null?Math.PI:Te.outerAngle),0))}))}E(xe)}).then(xe=>Promise.all(ne).then(()=>xe))})}loadAnimationAsync(p,_){return qs.LoadExtensionAsync(p,_,this.name,(E,A)=>this._loader.loadAnimationAsync(p,_).then($=>{const ne=new Array;Wr.Assign(A.events);for(const xe of A.events)ne.push(this._loadAnimationEventAsync(`${E}/events/${xe.index}`,p,_,xe,$));return Promise.all(ne).then(()=>$)}))}_loadClipAsync(p,_){if(_._objectURL)return _._objectURL;let E;if(_.uri)E=this._loader.loadUriAsync(p,_,_.uri);else{const A=Wr.Get(`${p}/bufferView`,this._loader.gltf.bufferViews,_.bufferView);E=this._loader.loadBufferViewAsync(`/bufferViews/${A.index}`,A)}return _._objectURL=E.then(A=>URL.createObjectURL(new Blob([A],{type:_.mimeType}))),_._objectURL}_loadEmitterAsync(p,_){if(_._babylonSounds=_._babylonSounds||[],!_._babylonData){const E=new Array,A=_.name||`emitter${_.index}`,$={loop:!1,autoplay:!1,volume:_.volume==null?1:_.volume};for(let xe=0;xe<_.clips.length;xe++){const ce=`/extensions/${this.name}/clips`,Te=Wr.Get(ce,this._clips,_.clips[xe].clip);E.push(this._loadClipAsync(`${ce}/${_.clips[xe].clip}`,Te).then(Re=>{const ke=_._babylonSounds[xe]=new hu(A,Re,this._loader.babylonScene,null,$);ke.refDistance=_.refDistance||1,ke.maxDistance=_.maxDistance||256,ke.rolloffFactor=_.rolloffFactor||1,ke.distanceModel=_.distanceModel||"exponential"}))}const ne=Promise.all(E).then(()=>{const xe=_.clips.map(Te=>Te.weight||1),ce=new l3(_.loop||!1,_._babylonSounds,xe);_.innerAngle&&(ce.directionalConeInnerAngle=2*ct.ToDegrees(_.innerAngle)),_.outerAngle&&(ce.directionalConeOuterAngle=2*ct.ToDegrees(_.outerAngle)),_.volume&&(ce.volume=_.volume),_._babylonData.sound=ce});_._babylonData={loaded:ne}}return _._babylonData.loaded}_getEventAction(p,_,E,A,$){switch(E){case"play":return ne=>{const xe=($||0)+(ne-A);_.play(xe)};case"stop":return()=>{_.stop()};case"pause":return()=>{_.pause()};default:throw new Error(`${p}: Unsupported action ${E}`)}}_loadAnimationEventAsync(p,_,E,A,$){if($.targetedAnimations.length==0)return Promise.resolve();const ne=$.targetedAnimations[0],xe=A.emitter,ce=Wr.Get(`/extensions/${this.name}/emitters`,this._emitters,xe);return this._loadEmitterAsync(p,ce).then(()=>{const Te=ce._babylonData.sound;if(Te){const Re=new cy(A.time,this._getEventAction(p,Te,A.action,A.time,A.startOffset));ne.animation.addEvent(Re),$.onAnimationGroupEndObservable.add(()=>{Te.stop()}),$.onAnimationGroupPauseObservable.add(()=>{Te.pause()})}})}}qs.RegisterExtension(uy,_e=>new h3(_e));const py="MSFT_lod";class c3{constructor(p){this.name=py,this.order=100,this.maxLODsToLoad=10,this.onNodeLODsLoadedObservable=new Mi,this.onMaterialLODsLoadedObservable=new Mi,this._bufferLODs=new Array,this._nodeIndexLOD=null,this._nodeSignalLODs=new Array,this._nodePromiseLODs=new Array,this._nodeBufferLODs=new Array,this._materialIndexLOD=null,this._materialSignalLODs=new Array,this._materialPromiseLODs=new Array,this._materialBufferLODs=new Array,this._loader=p,this.enabled=this._loader.isExtensionUsed(py)}dispose(){this._loader=null,this._nodeIndexLOD=null,this._nodeSignalLODs.length=0,this._nodePromiseLODs.length=0,this._nodeBufferLODs.length=0,this._materialIndexLOD=null,this._materialSignalLODs.length=0,this._materialPromiseLODs.length=0,this._materialBufferLODs.length=0,this.onMaterialLODsLoadedObservable.clear(),this.onNodeLODsLoadedObservable.clear()}onReady(){for(let p=0;p<this._nodePromiseLODs.length;p++){const _=Promise.all(this._nodePromiseLODs[p]).then(()=>{p!==0&&(this._loader.endPerformanceCounter(`Node LOD ${p}`),this._loader.log(`Loaded node LOD ${p}`)),this.onNodeLODsLoadedObservable.notifyObservers(p),p!==this._nodePromiseLODs.length-1&&(this._loader.startPerformanceCounter(`Node LOD ${p+1}`),this._loadBufferLOD(this._nodeBufferLODs,p+1),this._nodeSignalLODs[p]&&this._nodeSignalLODs[p].resolve())});this._loader._completePromises.push(_)}for(let p=0;p<this._materialPromiseLODs.length;p++){const _=Promise.all(this._materialPromiseLODs[p]).then(()=>{p!==0&&(this._loader.endPerformanceCounter(`Material LOD ${p}`),this._loader.log(`Loaded material LOD ${p}`)),this.onMaterialLODsLoadedObservable.notifyObservers(p),p!==this._materialPromiseLODs.length-1&&(this._loader.startPerformanceCounter(`Material LOD ${p+1}`),this._loadBufferLOD(this._materialBufferLODs,p+1),this._materialSignalLODs[p]&&this._materialSignalLODs[p].resolve())});this._loader._completePromises.push(_)}}loadSceneAsync(p,_){const E=this._loader.loadSceneAsync(p,_);return this._loadBufferLOD(this._bufferLODs,0),E}loadNodeAsync(p,_,E){return qs.LoadExtensionAsync(p,_,this.name,(A,$)=>{let ne;const xe=this._getLODs(A,_,this._loader.gltf.nodes,$.ids);this._loader.logOpen(`${A}`);for(let ce=0;ce<xe.length;ce++){const Te=xe[ce];ce!==0&&(this._nodeIndexLOD=ce,this._nodeSignalLODs[ce]=this._nodeSignalLODs[ce]||new um);const Re=We=>{E(We),We.setEnabled(!1)},ke=this._loader.loadNodeAsync(`/nodes/${Te.index}`,Te,Re).then(We=>{if(ce!==0){const Xe=xe[ce-1];Xe._babylonTransformNode&&(this._disposeTransformNode(Xe._babylonTransformNode),delete Xe._babylonTransformNode)}return We.setEnabled(!0),We});this._nodePromiseLODs[ce]=this._nodePromiseLODs[ce]||[],ce===0?ne=ke:(this._nodeIndexLOD=null,this._nodePromiseLODs[ce].push(ke))}return this._loader.logClose(),ne})}_loadMaterialAsync(p,_,E,A,$){return this._nodeIndexLOD?null:qs.LoadExtensionAsync(p,_,this.name,(ne,xe)=>{let ce;const Te=this._getLODs(ne,_,this._loader.gltf.materials,xe.ids);this._loader.logOpen(`${ne}`);for(let Re=0;Re<Te.length;Re++){const ke=Te[Re];Re!==0&&(this._materialIndexLOD=Re);const We=this._loader._loadMaterialAsync(`/materials/${ke.index}`,ke,E,A,Xe=>{Re===0&&$(Xe)}).then(Xe=>{if(Re!==0){$(Xe);const xt=Te[Re-1]._data;xt[A]&&(this._disposeMaterials([xt[A].babylonMaterial]),delete xt[A])}return Xe});this._materialPromiseLODs[Re]=this._materialPromiseLODs[Re]||[],Re===0?ce=We:(this._materialIndexLOD=null,this._materialPromiseLODs[Re].push(We))}return this._loader.logClose(),ce})}_loadUriAsync(p,_,E){if(this._nodeIndexLOD!==null){this._loader.log("deferred");const A=this._nodeIndexLOD-1;return this._nodeSignalLODs[A]=this._nodeSignalLODs[A]||new um,this._nodeSignalLODs[this._nodeIndexLOD-1].promise.then(()=>this._loader.loadUriAsync(p,_,E))}else if(this._materialIndexLOD!==null){this._loader.log("deferred");const A=this._materialIndexLOD-1;return this._materialSignalLODs[A]=this._materialSignalLODs[A]||new um,this._materialSignalLODs[A].promise.then(()=>this._loader.loadUriAsync(p,_,E))}return null}loadBufferAsync(p,_,E,A){if(this._loader.parent.useRangeRequests&&!_.uri){if(!this._loader.bin)throw new Error(`${p}: Uri is missing or the binary glTF is missing its binary chunk`);const $=(ne,xe)=>{const ce=E,Te=ce+A-1;let Re=ne[xe];return Re?(Re.start=Math.min(Re.start,ce),Re.end=Math.max(Re.end,Te)):(Re={start:ce,end:Te,loaded:new um},ne[xe]=Re),Re.loaded.promise.then(ke=>new Uint8Array(ke.buffer,ke.byteOffset+E-Re.start,A))};return this._loader.log("deferred"),this._nodeIndexLOD!==null?$(this._nodeBufferLODs,this._nodeIndexLOD):this._materialIndexLOD!==null?$(this._materialBufferLODs,this._materialIndexLOD):$(this._bufferLODs,0)}return null}_loadBufferLOD(p,_){const E=p[_];E&&(this._loader.log(`Loading buffer range [${E.start}-${E.end}]`),this._loader.bin.readAsync(E.start,E.end-E.start+1).then(A=>{E.loaded.resolve(A)},A=>{E.loaded.reject(A)}))}_getLODs(p,_,E,A){if(this.maxLODsToLoad<=0)throw new Error("maxLODsToLoad must be greater than zero");const $=[];for(let ne=A.length-1;ne>=0;ne--)if($.push(Wr.Get(`${p}/ids/${A[ne]}`,E,A[ne])),$.length===this.maxLODsToLoad)return $;return $.push(_),$}_disposeTransformNode(p){const _=[],E=p.material;E&&_.push(E);for(const $ of p.getChildMeshes())$.material&&_.push($.material);p.dispose();const A=_.filter($=>this._loader.babylonScene.meshes.every(ne=>ne.material!=$));this._disposeMaterials(A)}_disposeMaterials(p){const _={};for(const E of p){for(const A of E.getActiveTextures())_[A.uniqueId]=A;E.dispose()}for(const E in _)for(const A of this._loader.babylonScene.materials)A.hasTexture(_[E])&&delete _[E];for(const E in _)_[E].dispose()}}qs.RegisterExtension(py,_e=>new c3(_e));const _y="MSFT_minecraftMesh";class u3{constructor(p){this.name=_y,this._loader=p,this.enabled=this._loader.isExtensionUsed(_y)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtraAsync(p,_,this.name,(A,$)=>{if($){if(!(E instanceof Ys))throw new Error(`${A}: Material type not supported`);const ne=this._loader.loadMaterialPropertiesAsync(p,_,E);return E.needAlphaBlending()&&(E.forceDepthWrite=!0,E.separateCullingPass=!0),E.backFaceCulling=E.forceDepthWrite,E.twoSidedLighting=!0,ne}return null})}}qs.RegisterExtension(_y,_e=>new u3(_e));const Ty="MSFT_sRGBFactors";class p3{constructor(p){this.name=Ty,this._loader=p,this.enabled=this._loader.isExtensionUsed(Ty)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return qs.LoadExtraAsync(p,_,this.name,(A,$)=>{if($){if(!(E instanceof Ys))throw new Error(`${A}: Material type not supported`);const ne=this._loader.loadMaterialPropertiesAsync(p,_,E),xe=E.getScene().getEngine().useExactSrgbConversions;return E.albedoTexture||E.albedoColor.toLinearSpaceToRef(E.albedoColor,xe),E.reflectivityTexture||E.reflectivityColor.toLinearSpaceToRef(E.reflectivityColor,xe),ne}return null})}}qs.RegisterExtension(Ty,_e=>new p3(_e));var kx;(function(_e){_e[_e.Input=0]="Input",_e[_e.Output=1]="Output"})(kx||(kx={}));class vy{constructor(p,_,E){this._ownerBlock=E,this._connectedPoint=[],this.uniqueId=q0(),this.connectedPointIds=[],this.name=p,this._connectionType=_}get connectionType(){return this._connectionType}_isSingularConnection(){return!0}isConnected(){return this._connectedPoint.length>0}connectTo(p){if(this._connectionType===p._connectionType)throw new Error(`Cannot connect two points of type ${this.connectionType}`);if(this._isSingularConnection()&&this._connectedPoint.length>0||p._isSingularConnection()&&p._connectedPoint.length>0)throw new Error("Max number of connections for point reached");this._connectedPoint.push(p),p._connectedPoint.push(this)}serialize(p={}){p.uniqueId=this.uniqueId,p.name=this.name,p._connectionType=this._connectionType,p.connectedPointIds=[],p.className=this.getClassName();for(const _ of this._connectedPoint)p.connectedPointIds.push(_.uniqueId)}getClassName(){return"FGConnection"}deserialize(p){this.uniqueId=p.uniqueId,this.name=p.name,this._connectionType=p._connectionType,this.connectedPointIds=p.connectedPointIds}static Parse(p={},_){const E=ct.Instantiate(p.className),A=new E(p.name,p._connectionType,_);return A.deserialize(p),A}}class r0{constructor(p){this.value=this._toInt(p)}_toInt(p){return p|0}add(p){return new r0(this.value+p.value)}subtract(p){return new r0(this.value-p.value)}multiply(p){return new r0(Math.imul(this.value,p.value))}divide(p){return new r0(this.value/p.value)}getClassName(){return r0.ClassName}equals(p){return this.value===p.value}static Parse(p){return new r0(p.value)}}r0.ClassName="FlowGraphInteger",zs("FlowGraphInteger",r0);class ux{constructor(p,_){this.typeName=p,this.defaultValue=_}serialize(p){p.typeName=this.typeName,p.defaultValue=this.defaultValue}static Parse(p){return new ux(p.typeName,p.defaultValue)}}const Ws=new ux("any",void 0),_3=new ux("string",""),L0=new ux("number",0),Th=new ux("boolean",!1),Ry=new ux("Vector2",xr.Zero()),cu=new ux("Vector3",nt.Zero()),T3=new ux("Vector4",Gr.Zero()),pc=new ux("Matrix",Yt.Identity()),v3=new ux("Color3",ws.Black()),R3=new ux("Color4",new vr(0,0,0,0)),M3=new ux("Quaternion",_s.Identity()),Ya=new ux("FlowGraphInteger",new r0(0));function k8(_e){switch(typeof _e){case"string":return _3;case"number":return L0;case"boolean":return Th;case"object":return _e instanceof Vector2?Ry:_e instanceof Vector3?cu:_e instanceof Vector4?T3:_e instanceof Color3?v3:_e instanceof Color4?R3:_e instanceof Quaternion?M3:_e instanceof FlowGraphInteger?Ya:Ws;default:return Ws}}class My extends vy{constructor(p,_,E,A){super(p,_,E),this.richType=A}_isSingularConnection(){return this.connectionType===kx.Input}setValue(p,_){_._setConnectionValue(this,p)}connectTo(p){super.connectTo(p)}_getValueOrDefault(p){return p._hasConnectionValue(this)?p._getConnectionValue(this):this.richType.defaultValue}getValue(p){return this.connectionType===kx.Output?(p._notifyExecuteNode(this._ownerBlock),this._ownerBlock._updateOutputs(p),this._getValueOrDefault(p)):this.isConnected()?this._connectedPoint[0].getValue(p):this._getValueOrDefault(p)}getClassName(){return"FGDataConnection"}serialize(p={}){super.serialize(p),p.richType={},this.richType.serialize(p.richType)}static Parse(p,_){const E=vy.Parse(p,_);return E.richType=ux.Parse(p.richType),E}}zs("FGDataConnection",My);function TO(_e){return _e==="Mesh"||_e==="AbstractMesh"||_e==="GroundMesh"||_e==="InstanceMesh"||_e==="LinesMesh"||_e==="GoldbergMesh"||_e==="GreasedLineMesh"||_e==="TrailMesh"}function vO(_e){return _e==="Vector2"||_e==="Vector3"||_e==="Vector4"||_e==="Quaternion"||_e==="Color3"||_e==="Color4"}function w3(_e,p){if(_e==="Vector2")return xr.FromArray(p);if(_e==="Vector3")return nt.FromArray(p);if(_e==="Vector4")return Gr.FromArray(p);if(_e==="Quaternion")return _s.FromArray(p);if(_e==="Color3")return new ws(p[0],p[1],p[2]);if(_e==="Color4")return new vr(p[0],p[1],p[2],p[3]);throw new Error(`Unknown vector class name ${_e}`)}function RO(_e,p,_){const E=p?.getClassName?.()??"";TO(E)?_[_e]={name:p.name,className:E}:vO(E)?_[_e]={value:p.asArray(),className:E}:_[_e]=p}function Xg(_e,p,_){const E=p[_e];let A;const $=E?.className;return TO($)?A=_.getMeshByName(E.name):vO($)?A=w3($,E.value):$==="Matrix"?A=Yt.FromArray(E.value):$===r0.ClassName?A=r0.Parse(E):E&&E.value!==void 0?A=E.value:A=E,A}function L3(_e){return _e==="FGSetPropertyBlock"||_e==="FGGetPropertyBlock"||_e==="FGPlayAnimationBlock"||_e==="FGMeshPickEventBlock"}class Mm{constructor(p){this.config=p,this.uniqueId=q0(),this.name=this.config?.name??this.getClassName(),this.dataInputs=[],this.dataOutputs=[]}_updateOutputs(p){}registerDataInput(p,_){const E=new My(p,kx.Input,this,_);return this.dataInputs.push(E),E}registerDataOutput(p,_){const E=new My(p,kx.Output,this,_);return this.dataOutputs.push(E),E}getDataInput(p){return this.dataInputs.find(_=>_.name===p)}getDataOutput(p){return this.dataOutputs.find(_=>_.name===p)}serialize(p={},_=RO){p.uniqueId=this.uniqueId,p.config={},this.config&&(p.config.name=this.config.name),p.dataInputs=[],p.dataOutputs=[],p.className=this.getClassName();for(const E of this.dataInputs){const A={};E.serialize(A),p.dataInputs.push(A)}for(const E of this.dataOutputs){const A={};E.serialize(A),p.dataOutputs.push(A)}}getClassName(){return"FGBlock"}static Parse(p,_){const E=ct.Instantiate(p.className),A={},$=_.valueParseFunction??Xg;if(p.config)for(const xe in p.config)A[xe]=$(xe,p.config,_.scene);L3(p.className)&&(A.pathConverter=_.pathConverter);const ne=new E(A);ne.uniqueId=p.uniqueId;for(let xe=0;xe<p.dataInputs.length;xe++){const ce=ne.getDataInput(p.dataInputs[xe].name);if(ce)ce.deserialize(p.dataInputs[xe]);else throw new Error("Could not find data input with name "+p.dataInputs[xe].name+" in block "+p.className)}for(let xe=0;xe<p.dataOutputs.length;xe++){const ce=ne.getDataOutput(p.dataOutputs[xe].name);if(ce)ce.deserialize(p.dataOutputs[xe]);else throw new Error("Could not find data output with name "+p.dataOutputs[xe].name+" in block "+p.className)}return ne.metadata=p.metadata,ne.deserialize&&ne.deserialize(p),ne}}class wy extends vy{_isSingularConnection(){return this.connectionType===kx.Output}_activateSignal(p){this.connectionType===kx.Input?(p._notifyExecuteNode(this._ownerBlock),this._ownerBlock._execute(p,this),p._increaseExecutionId()):this._connectedPoint[0]?._activateSignal(p)}}zs("FlowGraphSignalConnection",wy);class ad extends Mm{constructor(p){super(p),this.signalInputs=[],this.signalOutputs=[],this.in=this._registerSignalInput("in")}_registerSignalInput(p){const _=new wy(p,kx.Input,this);return this.signalInputs.push(_),_}_registerSignalOutput(p){const _=new wy(p,kx.Output,this);return this.signalOutputs.push(_),_}getSignalInput(p){return this.signalInputs.find(_=>_.name===p)}getSignalOutput(p){return this.signalOutputs.find(_=>_.name===p)}serialize(p={}){super.serialize(p),p.signalInputs=[],p.signalOutputs=[];for(const _ of this.signalInputs){const E={};_.serialize(E),p.signalInputs.push(E)}for(const _ of this.signalOutputs){const E={};_.serialize(E),p.signalOutputs.push(E)}}deserialize(p){for(let _=0;_<p.signalInputs.length;_++){const E=this.getSignalInput(p.signalInputs[_].name);if(E)E.deserialize(p.signalInputs[_]);else throw new Error("Could not find signal input with name "+p.signalInputs[_].name+" in block "+p.className)}for(let _=0;_<p.signalOutputs.length;_++){const E=this.getSignalOutput(p.signalOutputs[_].name);if(E)E.deserialize(p.signalOutputs[_]);else throw new Error("Could not find signal output with name "+p.signalOutputs[_].name+" in block "+p.className)}}getClassName(){return"FGExecutionBlock"}}class MO extends ad{constructor(p){super(p),this.out=this._registerSignalOutput("out"),this.done=this._registerSignalOutput("done")}_startPendingTasks(p){this._preparePendingTasks(p),p._addPendingBlock(this)}}class wm extends MO{_execute(p){p._notifyExecuteNode(this),this.out._activateSignal(p)}}class Ly{constructor(p){this.uniqueId=q0(),this._userVariables={},this._executionVariables={},this._connectionValues={},this._pendingBlocks=[],this._executionId=0,this.onNodeExecutedObservable=new Mi,this._configuration=p}hasVariable(p){return p in this._userVariables}setVariable(p,_){this._userVariables[p]=_}getVariable(p){return this._userVariables[p]}get userVariables(){return this._userVariables}_getUniqueIdPrefixedName(p,_){return`${p.uniqueId}_${_}`}_setExecutionVariable(p,_,E){this._executionVariables[this._getUniqueIdPrefixedName(p,_)]=E}_getExecutionVariable(p,_,E){return this._hasExecutionVariable(p,_)?this._executionVariables[this._getUniqueIdPrefixedName(p,_)]:E}_deleteExecutionVariable(p,_){delete this._executionVariables[this._getUniqueIdPrefixedName(p,_)]}_hasExecutionVariable(p,_){return this._getUniqueIdPrefixedName(p,_)in this._executionVariables}_hasConnectionValue(p){return p.uniqueId in this._connectionValues}_setConnectionValue(p,_){this._connectionValues[p.uniqueId]=_}_getConnectionValue(p){return this._connectionValues[p.uniqueId]}get configuration(){return this._configuration}_addPendingBlock(p){this._pendingBlocks.push(p)}_removePendingBlock(p){const _=this._pendingBlocks.indexOf(p);_!==-1&&this._pendingBlocks.splice(_,1)}_clearPendingBlocks(){for(const p of this._pendingBlocks)p._cancelPendingTasks(this);this._pendingBlocks.length=0}_notifyExecuteNode(p){this.onNodeExecutedObservable.notifyObservers(p)}_increaseExecutionId(){this._executionId++}get executionId(){return this._executionId}serialize(p={},_=RO){p.uniqueId=this.uniqueId,p._userVariables={};for(const E in this._userVariables)_(E,this._userVariables[E],p._userVariables);p._connectionValues={};for(const E in this._connectionValues)_(E,this._connectionValues[E],p._connectionValues)}getClassName(){return"FGContext"}static Parse(p,_){const E=_.graph.createContext(),A=_.valueParseFunction??Xg;E.uniqueId=p.uniqueId;for(const $ in p._userVariables){const ne=A($,p._userVariables,E._configuration.scene);E._userVariables[$]=ne}for(const $ in p._connectionValues){const ne=A($,p._connectionValues,E._configuration.scene);E._connectionValues[$]=ne}return E}}Mt([Gt()],Ly.prototype,"uniqueId",void 0);function ky(_e,p){return!!(_e.parent&&(_e.parent===p||ky(_e.parent,p)))}class xd extends wm{constructor(p){super(p),this.config=p}_getReferencedMesh(){const p=this.config.pathConverter.convert(this.config.path),_=p.info.getObject(p.object);if(!_||!(_ instanceof zo))throw new Error("Mesh pick event block requires a valid mesh");return _}_preparePendingTasks(p){let _=p._getExecutionVariable(this,"meshPickObserver");if(!_){const E=this._getReferencedMesh();p._setExecutionVariable(this,"mesh",E),_=E.getScene().onPointerObservable.add($=>{$.type===Kr.POINTERPICK&&$.pickInfo?.pickedMesh&&($.pickInfo?.pickedMesh===E||ky($.pickInfo?.pickedMesh,E))&&this._execute(p)});const A=E.onDisposeObservable.add(()=>this._onDispose);p._setExecutionVariable(this,"meshPickObserver",_),p._setExecutionVariable(this,"meshDisposeObserver",A)}}_onDispose(p){this._cancelPendingTasks(p),p._removePendingBlock(this)}_cancelPendingTasks(p){const _=p._getExecutionVariable(this,"mesh"),E=p._getExecutionVariable(this,"meshPickObserver"),A=p._getExecutionVariable(this,"meshDisposeObserver");_.getScene().onPointerObservable.remove(E),_.onDisposeObservable.remove(A),p._deleteExecutionVariable(this,"mesh"),p._deleteExecutionVariable(this,"meshPickObserver"),p._deleteExecutionVariable(this,"meshDisposeObserver")}getClassName(){return xd.ClassName}serialize(p){super.serialize(p),p.config.path=this.config.path}}xd.ClassName="FGMeshPickEventBlock",zs(xd.ClassName,xd);var uu;(function(_e){_e[_e.Stopped=0]="Stopped",_e[_e.Started=1]="Started"})(uu||(uu={}));class ld{constructor(p){this._eventBlocks=[],this._executionContexts=[],this.state=uu.Stopped,this._scene=p.scene,this._coordinator=p.coordinator,this._sceneDisposeObserver=this._scene.onDisposeObservable.add(()=>this.dispose())}createContext(){const p=new Ly({scene:this._scene,coordinator:this._coordinator});return this._executionContexts.push(p),p}getContext(p){return this._executionContexts[p]}addEventBlock(p){this._eventBlocks.push(p)}start(){if(this.state!==uu.Started){this.state=uu.Started,this._executionContexts.length===0&&this.createContext();for(const p of this._executionContexts){const _=this._getContextualOrder();for(const E of _)E._startPendingTasks(p)}}}_getContextualOrder(){const p=[];for(const _ of this._eventBlocks)if(_.getClassName()===xd.ClassName){const E=_._getReferencedMesh();let A=0;for(;A<p.length;A++){const ne=p[A]._getReferencedMesh();if(E&&ne&&ky(E,ne))break}p.splice(A,0,_)}else p.push(_);return p}dispose(){if(this.state!==uu.Stopped){this.state=uu.Stopped;for(const p of this._executionContexts)p._clearPendingBlocks();this._executionContexts.length=0,this._eventBlocks.length=0,this._scene.onDisposeObservable.remove(this._sceneDisposeObserver),this._sceneDisposeObserver=null}}visitAllBlocks(p){const _=[],E=new Set;for(const A of this._eventBlocks)_.push(A),E.add(A.uniqueId);for(;_.length>0;){const A=_.pop();p(A);for(const $ of A.dataInputs)for(const ne of $._connectedPoint)E.has(ne._ownerBlock.uniqueId)||(_.push(ne._ownerBlock),E.add(ne._ownerBlock.uniqueId));if(A instanceof ad)for(const $ of A.signalOutputs)for(const ne of $._connectedPoint)E.has(ne._ownerBlock.uniqueId)||(_.push(ne._ownerBlock),E.add(ne._ownerBlock.uniqueId))}}serialize(p={},_){p.allBlocks=[],this.visitAllBlocks(E=>{const A={};E.serialize(A),p.allBlocks.push(A)}),p.executionContexts=[];for(const E of this._executionContexts){const A={};E.serialize(A,_),p.executionContexts.push(A)}}static GetDataOutConnectionByUniqueId(p,_){for(const E of p)for(const A of E.dataOutputs)if(A.uniqueId===_)return A;throw new Error("Could not find data out connection with unique id "+_)}static GetSignalInConnectionByUniqueId(p,_){for(const E of p)if(E instanceof ad){for(const A of E.signalInputs)if(A.uniqueId===_)return A}throw new Error("Could not find signal in connection with unique id "+_)}static Parse(p,_){const E=_.coordinator.createGraph(),A=[],$=_.valueParseFunction??Xg;for(const ne of p.allBlocks){const xe=Mm.Parse(ne,{scene:_.coordinator.config.scene,pathConverter:_.pathConverter,valueParseFunction:$});A.push(xe),xe instanceof wm&&E.addEventBlock(xe)}for(const ne of A){for(const xe of ne.dataInputs)for(const ce of xe.connectedPointIds){const Te=ld.GetDataOutConnectionByUniqueId(A,ce);xe.connectTo(Te)}if(ne instanceof ad)for(const xe of ne.signalOutputs)for(const ce of xe.connectedPointIds){const Te=ld.GetSignalInConnectionByUniqueId(A,ce);xe.connectTo(Te)}}for(const ne of p.executionContexts)Ly.Parse(ne,{graph:E,valueParseFunction:$});return E}}class hd{constructor(p){this.config=p,this._flowGraphs=[],this._customEventsMap=new Map,this.config.scene.onDisposeObservable.add(()=>{this.dispose()}),(hd.SceneCoordinators.get(this.config.scene)??[]).push(this)}createGraph(){const p=new ld({scene:this.config.scene,coordinator:this});return this._flowGraphs.push(p),p}removeGraph(p){const _=this._flowGraphs.indexOf(p);_!==-1&&(p.dispose(),this._flowGraphs.splice(_,1))}start(){this._flowGraphs.forEach(p=>p.start())}dispose(){this._flowGraphs.forEach(E=>E.dispose()),this._flowGraphs.length=0;const p=hd.SceneCoordinators.get(this.config.scene)??[],_=p.indexOf(this);_!==-1&&p.splice(_,1)}serialize(p,_){p._flowGraphs=[],this._flowGraphs.forEach(E=>{const A={};E.serialize(A,_),p._flowGraphs.push(A)})}static Parse(p,_){const E=_.valueParseFunction??Xg,A=new hd({scene:_.scene});return p._flowGraphs?.forEach($=>{ld.Parse($,{coordinator:A,valueParseFunction:E,pathConverter:_.pathConverter})}),A}get flowGraphs(){return this._flowGraphs}getCustomEventObservable(p){let _=this._customEventsMap.get(p);return _||(_=new Mi,this._customEventsMap.set(p,_)),_}notifyCustomEvent(p,_){const E=this._customEventsMap.get(p);E&&E.notifyObservers(_)}}hd.SceneCoordinators=new Map;class Lm extends wm{_preparePendingTasks(p){if(!p._getExecutionVariable(this,"sceneReadyObserver")){const E=p.configuration.scene.onReadyObservable.add(()=>{this._execute(p)});p._setExecutionVariable(this,"sceneReadyObserver",E)}}_cancelPendingTasks(p){const _=p._getExecutionVariable(this,"sceneReadyObserver");p.configuration.scene.onReadyObservable.remove(_),p._deleteExecutionVariable(this,"sceneReadyObserver")}getClassName(){return Lm.ClassName}}Lm.ClassName="FGSceneReadyEventBlock",zs("FGSceneReadyEventBlock",Lm);class cd extends wm{_preparePendingTasks(p){if(!p._getExecutionVariable(this,"sceneBeforeRender")){const E=p.configuration.scene.onBeforeRenderObservable.add(()=>{this._execute(p)});p._setExecutionVariable(this,"sceneBeforeRender",E)}}_cancelPendingTasks(p){const _=p._getExecutionVariable(this,"sceneBeforeRender");p.configuration.scene.onBeforeRenderObservable.remove(_),p._deleteExecutionVariable(this,"sceneBeforeRender")}getClassName(){return cd.ClassName}}cd.ClassName="FGSceneTickEventBlock",zs(cd.ClassName,cd);class ud extends ad{constructor(p){super(p),this.out=this._registerSignalOutput("out")}}class pd extends ud{constructor(p){super(p),this.message=this.registerDataInput("message",Ws)}_execute(p){const _=this.message.getValue(p);vi.Log(_),this.out._activateSignal(p)}getClassName(){return pd.ClassName}}pd.ClassName="FGConsoleLogBlock",zs(pd.ClassName,pd);var pu;(function(_e){_e[_e.INIT=0]="INIT",_e[_e.STARTED=1]="STARTED",_e[_e.ENDED=2]="ENDED"})(pu||(pu={}));function U8(_e){let p=0;const _=Date.now();_e.observableParameters=_e.observableParameters??{};const E=_e.contextObservable.add(A=>{const $=Date.now();p=$-_;const ne={startTime:_,currentTime:$,deltaTime:p,completeRate:p/_e.timeout,payload:A};_e.onTick&&_e.onTick(ne),_e.breakCondition&&_e.breakCondition()&&(_e.contextObservable.remove(E),_e.onAborted&&_e.onAborted(ne)),p>=_e.timeout&&(_e.contextObservable.remove(E),_e.onEnded&&_e.onEnded(ne))},_e.observableParameters.mask,_e.observableParameters.insertFirst,_e.observableParameters.scope);return E}class k3{constructor(p){this.onEachCountObservable=new Mi,this.onTimerAbortedObservable=new Mi,this.onTimerEndedObservable=new Mi,this.onStateChangedObservable=new Mi,this._observer=null,this._breakOnNextTick=!1,this._tick=_=>{const E=Date.now();this._timer=E-this._startTime;const A={startTime:this._startTime,currentTime:E,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:_},$=this._breakOnNextTick||this._breakCondition(A);$||this._timer>=this._timeToEnd?this._stop(A,$):this.onEachCountObservable.notifyObservers(A)},this._setState(pu.INIT),this._contextObservable=p.contextObservable,this._observableParameters=p.observableParameters??{},this._breakCondition=p.breakCondition??(()=>!1),this._timeToEnd=p.timeout,p.onEnded&&this.onTimerEndedObservable.add(p.onEnded),p.onTick&&this.onEachCountObservable.add(p.onTick),p.onAborted&&this.onTimerAbortedObservable.add(p.onAborted)}set breakCondition(p){this._breakCondition=p}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(p=this._timeToEnd){if(this._state===pu.STARTED)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=p,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(pu.STARTED)}stop(){this._state===pu.STARTED&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(p){this._state=p,this.onStateChangedObservable.notifyObservers(this._state)}_stop(p,_=!1){this._contextObservable.remove(this._observer),this._setState(pu.ENDED),_?this.onTimerAbortedObservable.notifyObservers(p):this.onTimerEndedObservable.notifyObservers(p)}}class km extends MO{constructor(p){super(p),this.timeout=this.registerDataInput("timeout",L0)}_preparePendingTasks(p){const _=this.timeout.getValue(p);if(_!==void 0&&_>=0){const E=p._getExecutionVariable(this,"runningTimers")||[],A=p.configuration.scene,$=new k3({timeout:_,contextObservable:A.onBeforeRenderObservable,onEnded:()=>this._onEnded($,p)});$.start(),E.push($),p._setExecutionVariable(this,"runningTimers",E)}}_execute(p){this._startPendingTasks(p),this.out._activateSignal(p)}_onEnded(p,_){const E=_._getExecutionVariable(this,"runningTimers")||[],A=E.indexOf(p);A!==-1?E.splice(A,1):ct.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),_._removePendingBlock(this),this.done._activateSignal(_)}_cancelPendingTasks(p){const _=p._getExecutionVariable(this,"runningTimers")||[];for(const E of _)E.dispose();p._deleteExecutionVariable(this,"runningTimers")}getClassName(){return km.ClassName}}km.ClassName="FGTimerBlock",zs("FGTimerBlock",km);class Um extends ud{constructor(p){super(p),this.config=p;for(let _=0;_<this.config.eventData.length;_++){const E=this.config.eventData[_];this.registerDataInput(E,Ws)}}_execute(p){const _=this.config.eventId,E=this.dataInputs.map(A=>A.getValue(p));p.configuration.coordinator.notifyCustomEvent(_,E),this.out._activateSignal(p)}getClassName(){return Um.ClassName}}Um.ClassName="FGSendCustomEventBlock",zs("FGSendCustomEventBlock",Um);class _d extends wm{constructor(p){super(p),this.config=p;for(let _=0;_<this.config.eventData.length;_++){const E=this.config.eventData[_];this.registerDataOutput(E,Ws)}}_preparePendingTasks(p){const _=p.configuration.coordinator.getCustomEventObservable(this.config.eventId);this._eventObserver=_.add(E=>{for(let A=0;A<E.length;A++)this.dataOutputs[A].setValue(E[A],p);this._execute(p)})}_cancelPendingTasks(p){const _=p.configuration.coordinator.getCustomEventObservable(this.config.eventId);_?_.remove(this._eventObserver):ct.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)}getClassName(){return _d.ClassName}serialize(p){super.serialize(p),p.eventId=this.config.eventId,p.eventData=this.config.eventData}}_d.ClassName="FGReceiveCustomEventBlock",zs(_d.ClassName,_d);class Td extends ad{constructor(p){super(p),this.config=p,this.outFlows=[];for(let _=0;_<this.config.numberOutputFlows;_++)this.outFlows.push(this._registerSignalOutput(`${_}`))}_execute(p){for(let _=0;_<this.config.numberOutputFlows;_++)this.outFlows[_]._activateSignal(p)}getClassName(){return Td.ClassName}}Td.ClassName="FGSequenceBlock",zs(Td.ClassName,Td);const wO=new RegExp(/\{(\w+)\}/g);class LO{constructor(p,_){this.path=p,this.ownerBlock=_,this.templatedInputs=[];let E=wO.exec(p);for(;E;){const[,A]=E;this.templatedInputs.push(_.registerDataInput(A,Ya)),E=wO.exec(p)}}getAccessor(p,_){let E=this.path;for(const A of this.templatedInputs){const $=A.getValue(_).value;E=E.replace(`{${A.name}}`,$.toString())}return p.convert(E)}}class vd extends Mm{constructor(p){super(p),this.config=p,this.value=this.registerDataOutput("value",Ws),this.templateComponent=new LO(p.path,this)}_updateOutputs(p){const _=this.templateComponent.getAccessor(this.config.pathConverter,p),E=_.info.get(_.object);this.value.setValue(E,p)}getClassName(){return vd.ClassName}serialize(p={}){super.serialize(p),p.config.path=this.config.path}}vd.ClassName="FGGetPropertyBlock",zs(vd.ClassName,vd);class Gm extends ud{constructor(p){super(p),this.config=p,this.a=this.registerDataInput("a",Ws),this.templateComponent=new LO(p.path,this)}_execute(p){const _=this.a.getValue(p),E=this.templateComponent.getAccessor(this.config.pathConverter,p);E.info.set(_,E.object),this.out._activateSignal(p)}serialize(p={}){super.serialize(p),p.config.path=this.config.path}getClassName(){return Gm.ClassName}}Gm.ClassName="FGSetPropertyBlock",zs("FGSetPropertyBlock",Gm);const kO="cachedOperationValue",UO="cachedExecutionId";class Kg extends Mm{constructor(p,_){super(_),this.value=this.registerDataOutput("value",p)}_updateOutputs(p){const _=p._getExecutionVariable(this,UO),E=p._getExecutionVariable(this,kO);if(E!==void 0&&_===p.executionId)this.value.setValue(E,p);else{const A=this._doOperation(p);p._setExecutionVariable(this,kO,A),p._setExecutionVariable(this,UO,p.executionId),this.value.setValue(A,p)}}}class k0 extends Kg{constructor(p,_,E,A,$,ne){super(E,ne),this._operation=A,this._className=$,this.a=this.registerDataInput("a",p),this.b=this.registerDataInput("b",_)}_doOperation(p){return this._operation(this.a.getValue(p),this.b.getValue(p))}getClassName(){return this._className}}class zm extends Kg{constructor(p,_,E,A){super(p,A),this._operation=_,this._className=E}_doOperation(p){return this._operation()}getClassName(){return this._className}}class Yn extends Kg{constructor(p,_,E,A,$){super(_,$),this._operation=E,this._className=A,this.a=this.registerDataInput("a",p)}_doOperation(p){return this._operation(this.a.getValue(p))}getClassName(){return this._className}}class Uy extends Kg{constructor(p,_,E,A,$,ne,xe){super(A,xe),this._operation=$,this._className=ne,this.a=this.registerDataInput("a",p),this.b=this.registerDataInput("b",_),this.c=this.registerDataInput("c",E)}_doOperation(p){return this._operation(this.a.getValue(p),this.b.getValue(p),this.c.getValue(p))}getClassName(){return this._className}}function co(_e){return _e.getClassName?_e.getClassName():""}function Wm(_e,p){return _e==="Vector2"&&p==="Vector2"||_e==="Vector3"&&p==="Vector3"||_e==="Vector4"&&p==="Vector4"}function Hm(_e,p){return _e==="Matrix"&&p==="Matrix"}function Xm(_e,p){return _e==="FlowGraphInteger"&&p==="FlowGraphInteger"}class Rd extends k0{constructor(p){super(Ws,Ws,Ws,(_,E)=>this._polymorphicAdd(_,E),Rd.ClassName,p)}_polymorphicAdd(p,_){const E=co(p),A=co(_);return Wm(E,A)||Hm(E,A)||Xm(E,A)?p.add(_):p+_}}Rd.ClassName="FGAddBlock",zs(Rd.ClassName,Rd);class Md extends k0{constructor(p){super(Ws,Ws,Ws,(_,E)=>this._polymorphicAdd(_,E),Md.ClassName,p)}_polymorphicAdd(p,_){const E=co(p),A=co(_);return Wm(E,A)||Xm(E,A)?p.subtract(_):Hm(E,A)?p.add(_.scale(-1)):p-_}}Md.ClassName="FGSubBlock",zs(Md.ClassName,Md);class wd extends k0{constructor(p){super(Ws,Ws,Ws,(_,E)=>this._polymorphicMultiply(_,E),wd.ClassName,p)}_polymorphicMultiply(p,_){const E=co(p),A=co(_);return Wm(E,A)||Xm(E,A)?p.multiply(_):Hm(E,A)?Yt.FromValues(p.m[0]*_.m[0],p.m[4]*_.m[4],p.m[8]*_.m[8],p.m[12]*_.m[12],p.m[1]*_.m[1],p.m[5]*_.m[5],p.m[9]*_.m[9],p.m[13]*_.m[13],p.m[2]*_.m[2],p.m[6]*_.m[6],p.m[10]*_.m[10],p.m[14]*_.m[14],p.m[3]*_.m[3],p.m[7]*_.m[7],p.m[11]*_.m[11],p.m[15]*_.m[15]):p*_}}wd.ClassName="FGMultiplyBlock",zs(wd.ClassName,wd);class Ld extends k0{constructor(p){super(Ws,Ws,Ws,(_,E)=>this._polymorphicDivide(_,E),Ld.ClassName,p)}_polymorphicDivide(p,_){const E=co(p),A=co(_);return Wm(E,A)||Xm(E,A)?p.divide(_):Hm(E,A)?Yt.FromValues(p.m[0]/_.m[0],p.m[4]/_.m[4],p.m[8]/_.m[8],p.m[12]/_.m[12],p.m[1]/_.m[1],p.m[5]/_.m[5],p.m[9]/_.m[9],p.m[13]/_.m[13],p.m[2]/_.m[2],p.m[6]/_.m[6],p.m[10]/_.m[10],p.m[14]/_.m[14],p.m[3]/_.m[3],p.m[7]/_.m[7],p.m[11]/_.m[11],p.m[15]/_.m[15]):p/_}}Ld.ClassName="FGDivideBlock",zs(Ld.ClassName,Ld);class kd extends zm{constructor(p){super(L0,()=>Math.random(),kd.ClassName,p)}}kd.ClassName="FGRandomBlock",zs(kd.ClassName,kd);class Ud extends k0{constructor(p){super(Ws,Ws,L0,(_,E)=>this._polymorphicDot(_,E),Ud.ClassName,p)}_polymorphicDot(p,_){switch(co(p)){case"Vector2":return xr.Dot(p,_);case"Vector3":return nt.Dot(p,_);case"Vector4":return Gr.Dot(p,_);default:throw new Error(`Cannot get dot product of ${p} and ${_}`)}}}Ud.ClassName="FGDotBlock",zs(Ud.ClassName,Ud);class Gd extends zm{constructor(p){super(L0,()=>Math.E,Gd.ClassName,p)}}Gd.ClassName="FGEBlock",zs(Gd.ClassName,Gd);class zd extends zm{constructor(p){super(L0,()=>Math.PI,zd.ClassName,p)}}zd.ClassName="FGPIBlock",zs(zd.ClassName,zd);class Wd extends zm{constructor(p){super(L0,()=>Number.POSITIVE_INFINITY,Wd.ClassName,p)}}Wd.ClassName="FGInfBlock",zs(Wd.ClassName,Wd);class Hd extends zm{constructor(p){super(L0,()=>Number.NaN,Hd.ClassName,p)}}Hd.ClassName="FGNaNBlock",zs(Hd.ClassName,Hd);function Ha(_e,p){switch(co(_e)){case"FlowGraphInteger":return new r0(p(_e.value));case"Vector2":return new xr(p(_e.x),p(_e.y));case"Vector3":return new nt(p(_e.x),p(_e.y),p(_e.z));case"Vector4":return new Gr(p(_e.x),p(_e.y),p(_e.z),p(_e.w));case"Matrix":return Yt.FromValues(p(_e.m[0]),p(_e.m[4]),p(_e.m[8]),p(_e.m[12]),p(_e.m[1]),p(_e.m[5]),p(_e.m[9]),p(_e.m[13]),p(_e.m[2]),p(_e.m[6]),p(_e.m[10]),p(_e.m[14]),p(_e.m[3]),p(_e.m[7]),p(_e.m[11]),p(_e.m[15]));default:return p(_e)}}class Xd extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicAbs(_),Xd.ClassName,p)}_polymorphicAbs(p){return Ha(p,Math.abs)}}Xd.ClassName="FGAbsBlock",zs(Xd.ClassName,Xd);class Kd extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicSign(_),Kd.ClassName,p)}_polymorphicSign(p){return Ha(p,Math.sign)}}Kd.ClassName="FGSignBlock",zs(Kd.ClassName,Kd);class Yd extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicTrunc(_),Yd.ClassName,p)}_polymorphicTrunc(p){return Ha(p,Math.trunc)}}Yd.ClassName="FGTruncBlock",zs(Yd.ClassName,Yd);class jd extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicFloor(_),jd.ClassName,p)}_polymorphicFloor(p){return Ha(p,Math.floor)}}jd.ClassName="FGFloorBlock",zs(jd.ClassName,jd);class qd extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicCeiling(_),qd.ClassName,p)}_polymorphicCeiling(p){return Ha(p,Math.ceil)}}qd.ClassName="FGCeilBlock",zs(qd.ClassName,qd);class $d extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicFract(_),$d.ClassName,p)}_polymorphicFract(p){return Ha(p,_=>_-Math.floor(_))}}$d.ClassName="FGFractBlock",zs($d.ClassName,$d);class rf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicNeg(_),rf.ClassName,p)}_polymorphicNeg(p){return Ha(p,_=>-_)}}rf.ClassName="FGNegBlock",zs(rf.ClassName,rf);function Km(_e,p,_){switch(co(_e)){case"FlowGraphInteger":return new r0(_(_e.value,p.value));case"Vector2":return new xr(_(_e.x,p.x),_(_e.y,p.y));case"Vector3":return new nt(_(_e.x,p.x),_(_e.y,p.y),_(_e.z,p.z));case"Vector4":return new Gr(_(_e.x,p.x),_(_e.y,p.y),_(_e.z,p.z),_(_e.w,p.w));case"Matrix":return Yt.FromValues(_(_e.m[0],p.m[0]),_(_e.m[4],p.m[4]),_(_e.m[8],p.m[8]),_(_e.m[12],p.m[12]),_(_e.m[1],p.m[1]),_(_e.m[5],p.m[5]),_(_e.m[9],p.m[9]),_(_e.m[13],p.m[13]),_(_e.m[2],p.m[2]),_(_e.m[6],p.m[6]),_(_e.m[10],p.m[10]),_(_e.m[14],p.m[14]),_(_e.m[3],p.m[3]),_(_e.m[7],p.m[7]),_(_e.m[11],p.m[11]),_(_e.m[15],p.m[15]));default:return _(_e,p)}}class nf extends k0{constructor(p){super(Ws,Ws,Ws,(_,E)=>this._polymorphicRemainder(_,E),nf.ClassName,p)}_polymorphicRemainder(p,_){return Km(p,_,(E,A)=>E%A)}}nf.ClassName="FGRemainderBlock",zs(nf.ClassName,nf);class af extends k0{constructor(p){super(Ws,Ws,Ws,(_,E)=>this._polymorphicMin(_,E),af.ClassName,p)}_polymorphicMin(p,_){return Km(p,_,Math.min)}}af.ClassName="FGMinBlock",zs(af.ClassName,af);class xf extends k0{constructor(p){super(Ws,Ws,Ws,(_,E)=>this._polymorphicMax(_,E),xf.ClassName,p)}_polymorphicMax(p,_){return Km(p,_,Math.max)}}xf.ClassName="FGMaxBlock",zs(xf.ClassName,xf);function U3(_e,p,_){return Math.min(Math.max(_e,Math.min(p,_)),Math.max(p,_))}function GO(_e,p,_,E){switch(co(_e)){case"FlowGraphInteger":return new r0(E(_e.value,p.value,_.value));case"Vector2":return new xr(E(_e.x,p.x,_.x),E(_e.y,p.y,_.y));case"Vector3":return new nt(E(_e.x,p.x,_.x),E(_e.y,p.y,_.y),E(_e.z,p.z,_.z));case"Vector4":return new Gr(E(_e.x,p.x,_.x),E(_e.y,p.y,_.y),E(_e.z,p.z,_.z),E(_e.w,p.w,_.w));case"Matrix":return Yt.FromValues(E(_e.m[0],p.m[0],_.m[0]),E(_e.m[4],p.m[4],_.m[4]),E(_e.m[8],p.m[8],_.m[8]),E(_e.m[12],p.m[12],_.m[12]),E(_e.m[1],p.m[1],_.m[1]),E(_e.m[5],p.m[5],_.m[5]),E(_e.m[9],p.m[9],_.m[9]),E(_e.m[13],p.m[13],_.m[13]),E(_e.m[2],p.m[2],_.m[2]),E(_e.m[6],p.m[6],_.m[6]),E(_e.m[10],p.m[10],_.m[10]),E(_e.m[14],p.m[14],_.m[14]),E(_e.m[3],p.m[3],_.m[3]),E(_e.m[7],p.m[7],_.m[7]),E(_e.m[11],p.m[11],_.m[11]),E(_e.m[15],p.m[15],_.m[15]));default:return E(_e,p,_)}}class lf extends Uy{constructor(p){super(Ws,Ws,Ws,Ws,(_,E,A)=>this._polymorphicClamp(_,E,A),lf.ClassName,p)}_polymorphicClamp(p,_,E){return GO(p,_,E,U3)}}lf.ClassName="FGClampBlock",zs(lf.ClassName,lf);function G3(_e){return Math.min(Math.max(_e,0),1)}class hf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicSaturate(_),hf.ClassName,p)}_polymorphicSaturate(p){return Ha(p,G3)}}hf.ClassName="FGSaturateBlock",zs(hf.ClassName,hf);class cf extends Uy{constructor(p){super(Ws,Ws,Ws,Ws,(_,E,A)=>this._polymorphicInterpolate(_,E,A),cf.ClassName,p)}_interpolate(p,_,E){return(1-E)*p+E*_}_polymorphicInterpolate(p,_,E){return GO(p,_,E,this._interpolate)}}cf.ClassName="FGInterpolateBlock",zs(cf.ClassName,cf);class uf extends k0{constructor(p){super(Ws,Ws,Th,(_,E)=>this._polymorphicEq(_,E),uf.ClassName,p)}_polymorphicEq(p,_){const E=co(p),A=co(_);return Wm(E,A)||Hm(E,A)||Xm(E,A)?p.equals(_):p===_}}uf.ClassName="FGEqBlock",zs(uf.ClassName,uf);function Yg(_e,p,_){const E=co(_e),A=co(p);if(E===A){if(E==="")return _(_e,p);if(E==="FlowGraphInteger")return _(_e.value,p.value);throw new Error(`Cannot compare ${_e} and ${p}`)}throw new Error(`${_e} and ${p} are of different types.`)}class pf extends k0{constructor(p){super(Ws,Ws,Th,(_,E)=>this._polymorphicLessThan(_,E),pf.ClassName,p)}_polymorphicLessThan(p,_){return Yg(p,_,(E,A)=>E<A)}}pf.ClassName="FGLessThanBlock",zs(pf.ClassName,pf);class jg extends k0{constructor(p){super(Ws,Ws,Th,(_,E)=>this._polymorphicLessThanOrEqual(_,E),jg.ClassName,p)}_polymorphicLessThanOrEqual(p,_){return Yg(p,_,(E,A)=>E<=A)}}jg.ClassName="FGLessThanOrEqualBlock";class _f extends k0{constructor(p){super(Ws,Ws,Th,(_,E)=>this._polymorphicGreaterThan(_,E),_f.ClassName,p)}_polymorphicGreaterThan(p,_){return Yg(p,_,(E,A)=>E>A)}}_f.ClassName="FGGreaterThanBlock",zs(_f.ClassName,_f);class Tf extends k0{constructor(p){super(Ws,Ws,Th,(_,E)=>this._polymorphicGreaterThanOrEqual(_,E),Tf.ClassName,p)}_polymorphicGreaterThanOrEqual(p,_){return Yg(p,_,(E,A)=>E>=A)}}Tf.ClassName="FGGreaterThanOrEqualBlock",zs(Tf.ClassName,Tf);class vf extends Yn{constructor(p){super(Ws,Th,_=>this._polymorphicIsNan(_),vf.ClassName,p)}_polymorphicIsNan(p){const _=co(p);if(_==="")return isNaN(p);if(_==="FlowGraphInteger")return isNaN(p.value);throw new Error(`Cannot get NaN of ${p}`)}}vf.ClassName="FGIsNanBlock",zs(vf.ClassName,vf);class qg extends Yn{constructor(p){super(Ws,Th,_=>this._polymorphicIsInf(_),qg.ClassName,p)}_polymorphicIsInf(p){const _=co(p);if(_==="")return!isFinite(p);if(_==="FlowGraphInteger")return!isFinite(p.value);throw new Error(`Cannot get isInf of ${p}`)}}qg.ClassName="FGIsInfBlock";class Rf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicDegToRad(_),Rf.ClassName,p)}_degToRad(p){return p*Math.PI/180}_polymorphicDegToRad(p){return Ha(p,this._degToRad)}}Rf.ClassName="FGDegToRadBlock",zs(Rf.ClassName,Rf);class Mf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicRadToDeg(_),Mf.ClassName,p)}_radToDeg(p){return p*180/Math.PI}_polymorphicRadToDeg(p){return Ha(p,this._radToDeg)}}Mf.ClassName="FGRadToDegBlock",zs(Mf.ClassName,Mf);class wf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicSin(_),wf.ClassName,p)}_polymorphicSin(p){return Ha(p,Math.sin)}}wf.ClassName="FGSinBlock",zs(wf.ClassName,wf);class Lf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicCos(_),Lf.ClassName,p)}_polymorphicCos(p){return Ha(p,Math.cos)}}Lf.ClassName="FGCosBlock",zs(Lf.ClassName,Lf);class kf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicTan(_),kf.ClassName,p)}_polymorphicTan(p){return Ha(p,Math.tan)}}kf.ClassName="FGTanBlock",zs(kf.ClassName,kf);class Uf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicAsin(_),Uf.ClassName,p)}_polymorphicAsin(p){return Ha(p,Math.asin)}}Uf.ClassName="FGAsinBlock",zs(Uf.ClassName,Uf);class Gf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicAcos(_),Gf.ClassName,p)}_polymorphicAcos(p){return Ha(p,Math.acos)}}Gf.ClassName="FGAcosBlock",zs(Gf.ClassName,Gf);class zf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicAtan(_),zf.ClassName,p)}_polymorphicAtan(p){return Ha(p,Math.atan)}}zf.ClassName="FGAtanBlock",zs(zf.ClassName,zf);class Wf extends k0{constructor(p){super(Ws,Ws,Ws,(_,E)=>this._polymorphicAtan2(_,E),Wf.ClassName,p)}_polymorphicAtan2(p,_){return Km(p,_,Math.atan2)}}Wf.ClassName="FGAtan2Block",zs(Wf.ClassName,Wf);class Hf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicSinh(_),Hf.ClassName,p)}_polymorphicSinh(p){return Ha(p,Math.sinh)}}Hf.ClassName="FGSinhBlock",zs(Hf.ClassName,Hf);class Xf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicCosh(_),Xf.ClassName,p)}_polymorphicCosh(p){return Ha(p,Math.cosh)}}Xf.ClassName="FGCoshBlock",zs(Xf.ClassName,Xf);class Kf extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicTanh(_),Kf.ClassName,p)}_polymorphicTanh(p){return Ha(p,Math.tanh)}}Kf.ClassName="FGTanhBlock",zs(Kf.ClassName,Kf);class Yf extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicAsinh(_),Yf.ClassName,p)}_polymorphicAsinh(p){return Ha(p,Math.asinh)}}Yf.ClassName="FGAsinhBlock",zs(Yf.ClassName,Yf);class jf extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicAcosh(_),jf.ClassName,p)}_polymorphicAcosh(p){return Ha(p,Math.acosh)}}jf.ClassName="FGAcoshBlock",zs(jf.ClassName,jf);class qf extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicAtanh(_),qf.ClassName,p)}_polymorphicAtanh(p){return Ha(p,Math.atanh)}}qf.ClassName="FGAtanhBlock",zs(qf.ClassName,qf);class $f extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicExp(_),$f.ClassName,p)}_polymorphicExp(p){return Ha(p,Math.exp)}}$f.ClassName="FGExpBlock",zs($f.ClassName,$f);class rp extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicLog(_),rp.ClassName,p)}_polymorphicLog(p){return Ha(p,Math.log)}}rp.ClassName="FGLogBlock",zs(rp.ClassName,rp);class np extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicLog2(_),np.ClassName,p)}_polymorphicLog2(p){return Ha(p,Math.log2)}}np.ClassName="FGLog2Block",zs(np.ClassName,np);class ap extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicLog10(_),ap.ClassName,p)}_polymorphicLog10(p){return Ha(p,Math.log10)}}ap.ClassName="FGLog10Block",zs(ap.ClassName,ap);class op extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicSqrt(_),op.ClassName,p)}_polymorphicSqrt(p){return Ha(p,Math.sqrt)}}op.ClassName="FGSqrtBlock",zs(op.ClassName,op);class xp extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicCubeRoot(_),xp.ClassName,p)}_polymorphicCubeRoot(p){return Ha(p,Math.cbrt)}}xp.ClassName="FGCubeRootBlock",zs(xp.ClassName,xp);class lp extends k0{constructor(p){super(Ws,L0,L0,(_,E)=>this._polymorphicPow(_,E),lp.ClassName,p)}_polymorphicPow(p,_){return Km(p,_,Math.pow)}}lp.ClassName="FGPowBlock",zs(lp.ClassName,lp);class hp extends Yn{constructor(p){super(Ws,L0,_=>this._polymorphicLength(_),hp.ClassName,p)}_polymorphicLength(p){switch(co(p)){case"Vector2":case"Vector3":case"Vector4":return p.length();default:throw new Error(`Cannot compute length of value ${p}`)}}}hp.ClassName="FGLengthBlock",zs(hp.ClassName,hp);class cp extends Yn{constructor(p){super(Ws,Ws,_=>this._polymorphicNormalize(_),cp.ClassName,p)}_polymorphicNormalize(p){switch(co(p)){case"Vector2":case"Vector3":case"Vector4":return p.normalize();default:throw new Error(`Cannot normalize value ${p}`)}}}cp.ClassName="FGNormalizeBlock",zs(cp.ClassName,cp);class up extends k0{constructor(p){super(cu,cu,cu,(_,E)=>nt.Cross(_,E),up.ClassName,p)}}up.ClassName="FGCrossBlock",zs(up.ClassName,up);class pp extends k0{constructor(p){super(Ry,L0,Ry,(_,E)=>xr.Transform(_,Yt.RotationZ(E)),pp.ClassName,p)}}pp.ClassName="FGRotate2DBlock",zs(pp.ClassName,pp);class _p extends Uy{constructor(p){super(cu,cu,L0,cu,(_,E,A)=>nt.TransformCoordinates(_,Yt.RotationAxis(E,A)),_p.ClassName,p)}}_p.ClassName="FGRotate3DBlock",zs(_p.ClassName,_p);class Tp extends Yn{constructor(p){super(pc,pc,_=>Yt.Transpose(_),Tp.ClassName,p)}}Tp.ClassName="FGTransposeBlock",zs(Tp.ClassName,Tp);class vp extends Yn{constructor(p){super(pc,L0,_=>_.determinant(),vp.ClassName,p)}}vp.ClassName="FGDeterminantBlock",zs(vp.ClassName,vp);class Rp extends Yn{constructor(p){super(pc,pc,_=>Yt.Invert(_),Rp.ClassName,p)}}Rp.ClassName="FGInvertMatrixBlock",zs(Rp.ClassName,Rp);class Mp extends k0{constructor(p){super(pc,pc,pc,(_,E)=>E.multiply(_),Mp.ClassName,p)}}Mp.ClassName="FGMatMulBlock",zs(Mp.ClassName,Mp);class wp extends Yn{constructor(p){super(Ya,Ya,_=>new r0(~_.value),wp.ClassName,p)}}wp.ClassName="FGBitwiseNotBlock",zs(wp.ClassName,wp);class Lp extends k0{constructor(p){super(Ya,Ya,Ya,(_,E)=>new r0(_.value&E.value),Lp.ClassName,p)}}Lp.ClassName="FGBitwiseAndBlock",zs(Lp.ClassName,Lp);class kp extends k0{constructor(p){super(Ya,Ya,Ya,(_,E)=>new r0(_.value|E.value),kp.ClassName,p)}}kp.ClassName="FGBitwiseOrBlock",zs(kp.ClassName,kp);class Up extends k0{constructor(p){super(Ya,Ya,Ya,(_,E)=>new r0(_.value^E.value),Up.ClassName,p)}}Up.ClassName="FGBitwiseXorBlock",zs(Up.ClassName,Up);class Gp extends k0{constructor(p){super(Ya,Ya,Ya,(_,E)=>new r0(_.value<<E.value),Gp.ClassName,p)}}Gp.ClassName="FGBitwiseLeftShiftBlock",zs(Gp.ClassName,Gp);class zp extends k0{constructor(p){super(Ya,Ya,Ya,(_,E)=>new r0(_.value>>E.value),zp.ClassName,p)}}zp.ClassName="FGBitwiseRightShiftBlock",zs(zp.ClassName,zp);class Wp extends Yn{constructor(p){super(Ya,Ya,_=>new r0(Math.clz32(_.value)),Wp.ClassName,p)}}Wp.ClassName="FGCountLeadingZerosBlock",zs(Wp.ClassName,Wp);class Hp extends Yn{constructor(p){super(Ya,Ya,_=>new r0(_.value?31-Math.clz32(_.value&-_.value):32),Hp.ClassName,p)}}Hp.ClassName="FGCountTrailingZerosBlock",zs(Hp.ClassName,Hp);function z3(_e){let p=0;for(;_e;)p+=_e&1,_e>>=1;return p}class Xp extends Yn{constructor(p){super(Ya,Ya,_=>new r0(z3(_.value)),Xp.ClassName,p)}}Xp.ClassName="FGCountOneBitsBlock",zs(Xp.ClassName,Xp);class Kp extends ud{constructor(p={startIndex:new r0(0)}){super(p),this.config=p,this.reset=this._registerSignalInput("reset"),this.n=this.registerDataInput("n",Ya),this.value=this.registerDataOutput("value",Ya)}_execute(p,_){if(_===this.reset)this.value.setValue(this.config.startIndex,p);else{const E=this.value.getValue(p);E.value<this.n.getValue(p).value&&(this.value.setValue(new r0(E.value+1),p),this.out._activateSignal(p))}}getClassName(){return Kp.ClassName}}Kp.ClassName="FGDoNBlock",zs(Kp.ClassName,Kp);class Yp extends Mm{constructor(p){super(p),this.config=p,this.output=this.registerDataOutput(p.variableName,Ws)}_updateOutputs(p){const _=this.config.variableName;p.hasVariable(_)&&this.output.setValue(p.getVariable(_),p)}getClassName(){return Yp.ClassName}serialize(p){super.serialize(p),p.config.variableName=this.config.variableName}}Yp.ClassName="FGGetVariableBlock",zs(Yp.ClassName,Yp);class jp extends ud{constructor(p){super(p),this.config=p,this.input=this.registerDataInput(p.variableName,Ws)}_execute(p){const _=this.config.variableName,E=this.input.getValue(p);p.setVariable(_,E),this.out._activateSignal(p)}getClassName(){return jp.ClassName}}jp.ClassName="FGSetVariableBlock",zs(jp.ClassName,jp);class qp extends ud{constructor(p){super(p),this.config=p,this.condition=this.registerDataInput("condition",Th),this.loopBody=this._registerSignalOutput("loopBody")}_execute(p,_){let E=this.condition.getValue(p);for(this.config?.isDo&&!E&&this.loopBody._activateSignal(p);E;)this.loopBody._activateSignal(p),E=this.condition.getValue(p);this.out._activateSignal(p)}getClassName(){return qp.ClassName}serialize(p){super.serialize(p),p.isDo=this.config?.isDo}}qp.ClassName="FGWhileLoopBlock",zs(qp.ClassName,qp);const W3={"lifecycle/onStart":Lm.ClassName,"lifecycle/onTick":cd.ClassName,log:pd.ClassName,"flow/delay":km.ClassName,"customEvent/send":Um.ClassName,"customEvent/receive":_d.ClassName,"flow/sequence":Td.ClassName,"world/get":vd.ClassName,"world/set":Gm.ClassName,"flow/doN":Kp.ClassName,"variable/get":Yp.ClassName,"variable/set":jp.ClassName,"flow/whileLoop":qp.ClassName,"math/random":kd.ClassName,"math/e":Gd.ClassName,"math/pi":zd.ClassName,"math/inf":Wd.ClassName,"math/nan":Hd.ClassName,"math/abs":Xd.ClassName,"math/sign":Kd.ClassName,"math/trunc":Yd.ClassName,"math/floor":jd.ClassName,"math/ceil":qd.ClassName,"math/fract":$d.ClassName,"math/neg":rf.ClassName,"math/add":Rd.ClassName,"math/sub":Md.ClassName,"math/mul":wd.ClassName,"math/div":Ld.ClassName,"math/rem":nf.ClassName,"math/min":af.ClassName,"math/max":xf.ClassName,"math/clamp":lf.ClassName,"math/saturate":hf.ClassName,"math/mix":cf.ClassName,"math/eq":uf.ClassName,"math/lt":pf.ClassName,"math/le":jg.ClassName,"math/gt":_f.ClassName,"math/ge":Tf.ClassName,"math/isnan":vf.ClassName,"math/isinf":qg.ClassName,"math/rad":Rf.ClassName,"math/deg":Mf.ClassName,"math/sin":wf.ClassName,"math/cos":Lf.ClassName,"math/tan":kf.ClassName,"math/asin":Uf.ClassName,"math/acos":Gf.ClassName,"math/atan":zf.ClassName,"math/atan2":Wf.ClassName,"math/sinh":Hf.ClassName,"math/cosh":Xf.ClassName,"math/tanh":Kf.ClassName,"math/asinh":Yf.ClassName,"math/acosh":jf.ClassName,"math/atanh":qf.ClassName,"math/exp":$f.ClassName,"math/log":rp.ClassName,"math/log2":np.ClassName,"math/log10":ap.ClassName,"math/sqrt":op.ClassName,"math/cbrt":xp.ClassName,"math/pow":lp.ClassName,"math/length":hp.ClassName,"math/normalize":cp.ClassName,"math/dot":Ud.ClassName,"math/cross":up.ClassName,"math/rotate2d":pp.ClassName,"math/rotate3d":_p.ClassName,"math/transpose":Tp.ClassName,"math/determinant":vp.ClassName,"math/inverse":Rp.ClassName,"math/matmul":Mp.ClassName,"math/not":wp.ClassName,"math/and":Lp.ClassName,"math/or":kp.ClassName,"math/xor":Up.ClassName,"math/asr":zp.ClassName,"math/lsl":Gp.ClassName,"math/clz":Wp.ClassName,"math/ctz":Hp.ClassName,"math/popcnt":Xp.ClassName},X3={float2:"Vector2",float3:"Vector3",float4:"Vector4",float4x4:"Matrix",int:"FlowGraphInteger"};function Gy(_e,p,_){if(_e.type!==void 0){const E=p.types&&p.types[_e.type];if(!E)throw new Error(`${_}: Unknown type: ${_e.type}`);const A=E.signature;if(!A)throw new Error(`${_}: Type ${_e.type} has no signature`);const $=X3[A];return{value:_e.value,className:$}}else return _e.value}function K3(_e,p,_){const E={},A=_e.configuration??[];for(const $ of A)if($.id==="customEvent"){const ne=p.customEvents&&p.customEvents[$.value];if(!ne)throw new Error(`/extensions/KHR_interactivity/nodes/${_}: Unknown custom event: ${$.value}`);E.eventId=ne.id,E.eventData=ne.values.map(xe=>xe.id)}else if($.id==="variable"){const ne=p.variables&&p.variables[$.value];if(!ne)throw new Error(`/extensions/KHR_interactivity/nodes/${_}: Unknown variable: ${$.value}`);E.variableName=ne.id}else if($.id==="path"){const ne=$.value;E.path=ne}else E[$.id]=Gy($,p,`/extensions/KHR_interactivity/nodes/${_}`);return E}function Y3(_e,p,_){const E=W3[p.type];if(!E)throw new Error(`/extensions/KHR_interactivity/nodes/${_e}: Unknown block type: ${p.type}`);const A=_e.toString(),$=K3(p,_,A),ne=p.metadata;return{className:E,config:$,uniqueId:A,metadata:ne,dataInputs:[],dataOutputs:[],signalInputs:[],signalOutputs:[]}}function j3(_e){const p={uniqueId:q0(),_userVariables:{},_connectionValues:{}},_=[p],E=[];for(let $=0;$<_e.nodes.length;$++){const ne=_e.nodes[$],xe=Y3($,ne,_e);E.push(xe)}for(let $=0;$<_e.nodes.length;$++){const ne=_e.nodes[$],xe=E[$],ce=ne.flows??[];for(const Re of ce){const ke=Re.id,We={uniqueId:q0(),name:ke,_connectionType:kx.Output,connectedPointIds:[]};xe.signalOutputs.push(We);const Xe=Re.node,xt=Re.socket,qe=E[Xe];if(!qe)throw new Error(`/extensions/KHR_interactivity/nodes/${$}: Could not find node with id ${Xe} that connects its input with with node ${$}'s output ${ke}`);let ht=qe.signalInputs.find(Nt=>Nt.name===xt);ht||(ht={uniqueId:q0(),name:xt,_connectionType:kx.Input,connectedPointIds:[]},qe.signalInputs.push(ht)),ht.connectedPointIds.push(We.uniqueId),We.connectedPointIds.push(ht.uniqueId)}const Te=ne.values??[];for(const Re of Te){const ke=Re.id,We={uniqueId:q0(),name:ke,_connectionType:kx.Input,connectedPointIds:[]};if(xe.dataInputs.push(We),Re.value!==void 0){const Xe=Gy(Re,_e,`/extensions/KHR_interactivity/nodes/${$}`);p._connectionValues[We.uniqueId]=Xe}else if(Re.node!==void 0&&Re.socket!==void 0){const Xe=Re.node,xt=Re.socket,qe=E[Xe];if(!qe)throw new Error(`/extensions/KHR_interactivity/nodes/${$}: Could not find node with id ${Xe} that connects its output with node${$}'s input ${ke}`);let ht=qe.dataOutputs.find(Nt=>Nt.name===xt);ht||(ht={uniqueId:q0(),name:xt,_connectionType:kx.Output,connectedPointIds:[]},qe.dataOutputs.push(ht)),We.connectedPointIds.push(ht.uniqueId),ht.connectedPointIds.push(We.uniqueId)}else throw new Error(`/extensions/KHR_interactivity/nodes/${$}: Invalid socket ${ke} in node ${$}`)}}const A=_e.variables??[];for(let $=0;$<A.length;$++){const ne=A[$],xe=ne.id;p._userVariables[xe]=Gy(ne,_e,`/extensions/KHR_interactivity/variables/${$}`)}return{allBlocks:E,executionContexts:_}}class q3 extends _O{constructor(p){super(p,$3)}}const $3={nodes:{__array__:{__target__:!0,translation:{type:"Vector3",get:_e=>_e._babylonTransformNode.position,set:(_e,p)=>{const _=p._babylonTransformNode;_.position=_e},getObject(_e){return _e._babylonTransformNode}}}}},zy="KHR_interactivity";class rk{constructor(p){this._loader=p,this.name=zy,this.enabled=this._loader.isExtensionUsed(zy),this._pathConverter=new q3(this._loader.gltf)}dispose(){this._loader=null,delete this._pathConverter}onReady(){if(!this._loader.babylonScene||!this._pathConverter)return;const p=this._loader.babylonScene,_=this._loader.gltf.extensions?.KHR_interactivity,E=j3(_),A=new hd({scene:p});ld.Parse(E,{coordinator:A,pathConverter:this._pathConverter}),A.start()}}qs.RegisterExtension(zy,_e=>new rk(_e));const zO="ExtrasAsMetadata";class nk{_assignExtras(p,_){if(_.extras&&Object.keys(_.extras).length>0){const E=p.metadata=p.metadata||{},A=E.gltf=E.gltf||{};A.extras=_.extras}}constructor(p){this.name=zO,this.enabled=!0,this._loader=p}dispose(){this._loader=null}loadNodeAsync(p,_,E){return this._loader.loadNodeAsync(p,_,A=>{this._assignExtras(A,_),E(A)})}loadCameraAsync(p,_,E){return this._loader.loadCameraAsync(p,_,A=>{this._assignExtras(A,_),E(A)})}createMaterial(p,_,E){const A=this._loader.createMaterial(p,_,E);return this._assignExtras(A,_),A}}qs.RegisterExtension(zO,_e=>new nk(_e));class ak extends lN{constructor(p,_,E,A="onesie.glb",$){super(p,_,E),this.url=A,this.outfit=$,this.shadowers=[],this.handsUp=!1,this.aligner=new xF(void 0,$),this.addPlugin(this.aligner)}async load(){if(!(this.loaded||!this.scene))return await this.setupScene(this.scene),super.load()}async setupScene(p){await this.setModel(this.url);const _=new Kl("DirectLightUp",new nt(.5,-1,-.2),p);_.position.set(0,4,-10),_.intensity=5,p.environmentTexture=new Lo("environment.env",p),[_].forEach(E=>{if(!(E instanceof rc))return;const A=new pr(2048,E,!0);A.useBlurCloseExponentialShadowMap=!0,A.blurBoxOffset=1,A.bias=1e-4,A.normalBias=1e-4,E.autoCalcShadowZBounds=!0,this.shadowers.push(A)})}async setModel(p){return this.setOutfit(p,this.outfit)}async setOutfit(p,_){if(this.model){const ne=this.model;this.aligner.setNode(),this.shadowers.forEach(xe=>xe.removeShadowCaster(ne)),this.scene?.removeMesh(ne,!0),ne.dispose(!1,!0)}delete this.model,this.url=p,this.outfit=_;const E=await kn.LoadAssetContainerAsync("",p,this.scene,void 0,".glb"),A=E.meshes.find(ne=>ne.id==="__root__");if(!A)return;E.addAllToScene(),this.aligner.setOutfit(A,_),A.getChildMeshes().forEach(ne=>ne.receiveShadows=!0),this.shadowers.forEach(ne=>ne.addShadowCaster(A)),this.model=A}async update(p,_){const E=p.poses[0];if(!E)return this.handsUp=!1,super.update(p,_);const{points:A}=E,$=new nt(...A.hipL.metric),ne=new nt(...A.hipR.metric),xe=new nt(...A.shoulderL.metric),ce=new nt(...A.shoulderR.metric),Te=new nt(...A.elbowL.metric),Re=new nt(...A.elbowR.metric),ke=new nt(...A.wristL.metric),We=new nt(...A.wristR.metric),Xe=xe.subtract($).normalize(),xt=ce.subtract(ne).normalize(),qe=Te.subtract(xe).normalize(),ht=Re.subtract(ce).normalize(),Nt=ke.subtract(Te).normalize(),wt=We.subtract(Re).normalize(),Qt=nt.Dot(Xe,qe),Ht=nt.Dot(xt,ht),Wt=nt.Dot(Nt,qe),zt=nt.Dot(wt,ht),xi=Math.min(Qt,Ht,Wt,zt);xi>.8&&(this.handsUp=!0),xi<.7&&(this.handsUp=!1);const{textModel:wi}=this;if(wi){const vs=nt.Lerp(ke,We,.5);wi.position=vs,wi.setEnabled(this.handsUp)}await super.update(p,_)}}const $g=new Ma,xk=location.hostname==="localhost"?"1Vb90yJSHSicVmdDpMIarC4D-LaTJOo-":"prod.url_sdk_token",vh={onesie:{file:"onesie.glb",avatar:!1,outfit:{occluders:[/Head$/,/Body/],hidden:[/Eye/,/Teeth/,/Footwear/]}},jacket:{file:"jacket.glb",avatar:!1,outfit:{occluders:[/Head$/,/Body/],hidden:[/Eye/,/Teeth/,/Bottom/,/Footwear/,/Glasses/]}}};let _c="jacket",_u=vh.jacket.avatar;function WO(){const _e=document.createElement("div");_e.className="spinner-container",_e.id="spinner";const p=document.createElement("div");p.className="spinner";for(let _=0;_<6;_++){const E=document.createElement("div");E.className="spinner-dot",p.appendChild(E)}return _e.appendChild(p),_e}let HO=new URLSearchParams(window.location.search).has("rear");async function lk(){const _e=document.getElementById("root");if(!_e)return;const p=new ak(_e,"pad",!HO,vh[_c].file,_u?void 0:vh[_c].outfit),_=document.getElementById("outfit-switch");_.checked=_u,_.onchange=async()=>{xe.forEach(Te=>{Te.disabled=!0}),_.disabled=!0;const ce=WO();document.body.appendChild(ce),_u=_.checked,await p.setOutfit(vh[_c].file,_u?void 0:vh[_c].outfit),document.body.removeChild(ce),xe.forEach(Te=>{Te.disabled=!1}),_.disabled=!1};const A=navigator.userAgent.indexOf("Safari")>-1&&navigator.userAgent.indexOf("Chrome")<=-1?"mp4":"webm",$=new ra(p,"video/"+A),ne=document.getElementById("record");ne&&(ne.onclick=()=>{$?.start(),setTimeout(async()=>{const ce=await $?.stop();if(!ce)return;const Te=URL.createObjectURL(ce),Re=document.createElement("a");Re.hidden=!0,Re.href=Te,Re.download="capture."+A,Re.click(),Re.remove(),URL.revokeObjectURL(Te)},1e4)});const xe=document.getElementsByName("model");xe.forEach(ce=>{ce.onchange=async()=>{if(ce.checked&&vh[ce.value]){xe.forEach(Re=>{Re.disabled=!0}),_.disabled=!0;const Te=WO();document.body.appendChild(Te),_c=ce.value,_u=vh[_c].avatar,await p.setOutfit(vh[_c].file,_u?void 0:vh[_c].outfit),_.checked=_u,document.body.removeChild(Te),xe.forEach(Re=>{Re.disabled=!1}),_.disabled=!1}}}),await Promise.all([$g.addRenderer(p),$g.init({token:xk})]),await $g.setup({size:{width:1920,height:1080},rear:HO}),await $g.start(),document.getElementById("dots")?.remove()}lk()})()})();
